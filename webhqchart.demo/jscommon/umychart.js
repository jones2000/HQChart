/*
   Copyright (c) 2018 jones
 
    http://www.apache.org/licenses/LICENSE-2.0

   开源项目 https://github.com/jones2000/HQChart
 
   jones_2000@163.com

   封装行情类图形控件 (H5版本)
*/


//日志输出类
if (!JSConsole)
{
    var JSConsole=
    { 
        Chart:{ Log:console.log, Warn:console.warn },      //图形日志
        Complier:{ Log:console.log, Warn:console.warn }    //编译器日志
    };
}


function JSChart(divElement, bOffscreen, bCacheCanvas)
{
    this.DivElement=divElement;
    this.DivToolElement=null;           //工具条
    this.JSChartContainer;              //画图控件
    this.ResizeListener;

    //h5 canvas
    this.CanvasElement=document.createElement("canvas");
    this.CanvasElement.className='jschart-drawing';
    this.CanvasElement.id=Guid();
    this.CanvasElement.setAttribute("tabindex",0);
    if (this.CanvasElement.style) 
    {
        this.CanvasElement.style.outline='none';
        //this.CanvasElement.style.position="absolute"; //外部自己设置
    }
    if(divElement.hasChildNodes())
    {
        JSConsole.Chart.Log("[JSChart::JSChart] divElement hasChildNodes", divElement.childNodes);
    }
    divElement.appendChild(this.CanvasElement);

    //离屏
    this.OffscreenCanvasElement;
    if (bOffscreen==true) this.OffscreenCanvasElement=document.createElement("canvas");

    //图形缓存
    this.CacheCanvasElement=null;
    if (bCacheCanvas) this.CacheCanvasElement=document.createElement("canvas");

    //改参数div
    this.ModifyIndexDialog=new ModifyIndexDialog(divElement);
    this.ChangeIndexDialog=new ChangeIndexDialog(divElement);

    //额外的画布
    this.MapExtraCanvasElement=new Map();   //key=画布名字, value={ Element:, Canvas:}

    this.CreateExtraCanvasElement=function(name, option)
    {
        if (this.MapExtraCanvasElement.has(name)) return this.MapExtraCanvasElement.get(name);

        var element=document.createElement("canvas");
        element.className='jschart-drawing-extra';
        element.id=Guid();
        if (name==JSChart.CorssCursorCanvasKey)  
            element.setAttribute("tabindex",5);
        else 
            element.setAttribute("tabindex",1);

        if (element.style) 
        {
            element.style.outline='none';
            element.style.position="absolute";
            element.style.left='0px';
            element.style.top='0px';
            element.style["pointer-events"]="none";
        }

        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.TabIndex))  element.setAttribute("tabindex",option.TabIndex);
            if (IFrameSplitOperator.IsNumber(option.ZIndex))  element.style["z-index"]=option.ZIndex;
        }

        if (this.CanvasElement)
        {
            element.height=this.CanvasElement.height;
            element.width=this.CanvasElement.width;
            if (element.style)
            {
                element.style.width=this.CanvasElement.style.width;
                element.style.height=this.CanvasElement.style.height
            }
        }

        divElement.appendChild(element);

        var item={ Element:element, Canvas:null };
        this.MapExtraCanvasElement.set(name, item);
    }

    this.GetExtraCanvas=function(name)
    {
        if (!this.MapExtraCanvasElement.has(name)) return null;

        var item=this.MapExtraCanvasElement.get(name);
        if (!item.Element) return null;

        if (!item.Canvas) item.Canvas=item.Element.getContext("2d");
        
        return item;
    }

    /*
    { Type: 1=K线柱子宽度不变  2=K线全部显示
      Redraw:是否重绘, XYSplit:是否重新计算分割线 }
    */
    this.OnSize=function(option) 
    {
        //画布大小通过div获取 如果有style里的大小 使用style里的
        var height=this.DivElement.offsetHeight;
        var width=this.DivElement.offsetWidth;
        if (this.DivElement.style.height && this.DivElement.style.width)
        {
            if (this.DivElement.style.height.includes("px"))
                height=parseInt(this.DivElement.style.height.replace("px",""));
            if (this.DivElement.style.width.includes("px"))
                width=parseInt(this.DivElement.style.width.replace("px",""));
        }
        
        if (this.ToolElement)
        {
            //TODO调整工具条大小
            height-=this.ToolElement.style.height.replace("px","");   //减去工具条的高度
        }

        this.CanvasElement.height=height;
        this.CanvasElement.width=width;
        this.CanvasElement.style.width=this.CanvasElement.width+'px';
        this.CanvasElement.style.height=this.CanvasElement.height+'px';

        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        this.CanvasElement.height*=pixelTatio;
        this.CanvasElement.width*=pixelTatio;

        if (this.OffscreenCanvasElement)
        {
            this.OffscreenCanvasElement.height=this.CanvasElement.height;
            this.OffscreenCanvasElement.width=this.CanvasElement.width;
        }

        if (this.CacheCanvasElement)
        {
            this.CacheCanvasElement.height=this.CanvasElement.height;
            this.CacheCanvasElement.width=this.CanvasElement.width;
        }

        for(var mapItem of this.MapExtraCanvasElement)
        {
            var item=mapItem[1];
            var element=item.Element;
            if (!element) continue;

            element.height=this.CanvasElement.height;
            element.width=this.CanvasElement.width;
            element.style.width=this.CanvasElement.style.width;
            element.style.height=this.CanvasElement.style.height;
        }

        JSConsole.Chart.Log(`[JSChart::OnSize] devicePixelRatio=${window.devicePixelRatio}, height=${this.CanvasElement.height}, width=${this.CanvasElement.width}`);

        if (option && option.Redraw==false) return;

        if (this.JSChartContainer)
        {
            if (option && option.XYSplit===true) this.JSChartContainer.ResetFrameXYSplit();

            if (this.JSChartContainer.OnSize && option && option.Type==1)   //K线宽度不变
            {
                this.JSChartContainer.OnSize();
            }
            else if (this.JSChartContainer.ShowAllKLine && option && option.Type==2)
            {
                this.JSChartContainer.ShowAllKLine();
            }
            else
            {
                if (this.JSChartContainer.Frame) this.JSChartContainer.Frame.SetSizeChage(true);
                this.JSChartContainer.Draw();
            }
        } 
    }

    //手机屏需要调整 间距
    this.AdjustChartBorder=function(chart)
    {
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率

        chart.Frame.ChartBorder.Left*=pixelTatio;
        chart.Frame.ChartBorder.Right*=pixelTatio;
        chart.Frame.ChartBorder.Top*=pixelTatio;
        chart.Frame.ChartBorder.Bottom*=pixelTatio;

        if (chart.Frame.AutoLeftBorder)
        {
            var item=chart.Frame.AutoLeftBorder;
            if (IFrameSplitOperator.IsNumber(item.MinWidth)) item.MinWidth*=pixelTatio;
            if (IFrameSplitOperator.IsNumber(item.Blank)) item.Blank*=pixelTatio;
        }

        if (chart.Frame.AutoRightBorder)
        {
            var item=chart.Frame.AutoRightBorder;
            if (IFrameSplitOperator.IsNumber(item.MinWidth)) item.MinWidth*=pixelTatio;
            if (IFrameSplitOperator.IsNumber(item.Blank)) item.Blank*=pixelTatio;
        }
    }

    this.AdjustTitleHeight=function(chart)
    {
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率

        for(var i=0;i<chart.Frame.SubFrame.length;++i)
        {
            chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight*=pixelTatio;
        }

        chart.ChartCorssCursor.TextHeight*=pixelTatio;  //十字光标文本信息高度
    }

    this.SetChartBorder=function(chart, option)
    {
        if (!option.Border) return;
        
        var item=option.Border;
        if (IFrameSplitOperator.IsNumber(option.Border.Left)) chart.Frame.ChartBorder.Left=option.Border.Left;
        else option.Border.Left=chart.Frame.ChartBorder.Left;
        if (IFrameSplitOperator.IsNumber(option.Border.Right)) chart.Frame.ChartBorder.Right=option.Border.Right;
        else option.Border.Right=chart.Frame.ChartBorder.Right;
        if (IFrameSplitOperator.IsNumber(option.Border.Top)) chart.Frame.ChartBorder.Top=option.Border.Top;
        else option.Border.Top=chart.Frame.ChartBorder.Top;
        if (IFrameSplitOperator.IsNumber(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom=option.Border.Bottom;
        else option.Border.Bottom=chart.Frame.ChartBorder.Bottom;

        if (item.AutoLeft) 
        {
            chart.Frame.AutoLeftBorder={ };
            if (IFrameSplitOperator.IsNumber(item.AutoLeft.Blank)) chart.Frame.AutoLeftBorder.Blank=item.AutoLeft.Blank;
            if (IFrameSplitOperator.IsNumber(item.AutoLeft.MinWidth)) chart.Frame.AutoLeftBorder.MinWidth=item.AutoLeft.MinWidth;
        }
        
        if (item.AutoRight) 
        {
            chart.Frame.AutoRightBorder={ };
            if (IFrameSplitOperator.IsNumber(item.AutoRight.Blank)) chart.Frame.AutoRightBorder.Blank=item.AutoRight.Blank;
            if (IFrameSplitOperator.IsNumber(item.AutoRight.MinWidth)) chart.Frame.AutoRightBorder.MinWidth=item.AutoRight.MinWidth;
        }
    }

    this.SetEventCallback=function(chart, aryCallback)
    {
        if (!chart) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(aryCallback)) return;

        for(var i=0;i<aryCallback.length;++i)
        {
            var item=aryCallback[i];
            chart.AddEventCallback(item);
        }
    }

    //历史K线图
    this.CreateKLineChartContainer=function(option)
    {
        var chart=null;
        if (option.Type==="历史K线图横屏") chart=new KLineChartHScreenContainer(this.CanvasElement);
        else chart=new KLineChartContainer(this.CanvasElement,this.OffscreenCanvasElement,this.CacheCanvasElement);

        chart.GetExtraCanvas=(name)=>{ return this.GetExtraCanvas(name); }

        var extraElement=this.GetExtraCanvas(JSChart.CorssCursorCanvasKey);
        if (extraElement) chart.SetCorssCursorElement(extraElement);

        if (option.EventCallback) this.SetEventCallback(chart, option.EventCallback);
        if (option.NetworkFilter) chart.NetworkFilter=option.NetworkFilter;

        //创建改参数div
        chart.ModifyIndexDialog=this.ModifyIndexDialog;
        chart.ChangeIndexDialog=this.ChangeIndexDialog;

        var pixelRatio=GetDevicePixelRatio();
        
        //右键菜单
        if (IFrameSplitOperator.IsBool(option.IsShowRightMenu)) chart.IsShowRightMenu=option.IsShowRightMenu;
        if (option.ScriptError) chart.ScriptErrorCallback=option.ScriptError;
        if (option.EnableScrollUpDown==true) chart.EnableScrollUpDown=option.EnableScrollUpDown;
        if (option.DisableMouse==true) chart.DisableMouse=option.DisableMouse;
        if (option.TouchMoveMinAngle) chart.TouchMoveMinAngle=option.TouchMoveMinAngle;
        if (option.EnableZoomUpDown) chart.EnableZoomUpDown=option.EnableZoomUpDown;
        if (IFrameSplitOperator.IsString(option.SplashTitle)) chart.LoadDataSplashTitle=option.SplashTitle;
        if (IFrameSplitOperator.IsBool(option.EnableZoomIndexWindow)) chart.EnableZoomIndexWindow=option.EnableZoomIndexWindow;
        if (IFrameSplitOperator.IsBool(option.IsDrawPictureXY)) chart.IsDrawPictureXY=option.IsDrawPictureXY;
        if (IFrameSplitOperator.IsNumber(option.CtrlMoveStep)) chart.CtrlMoveStep=option.CtrlMoveStep;
        if (IFrameSplitOperator.IsBool(option.EnableIndexChartDrag)) chart.EnableIndexChartDrag=option.EnableIndexChartDrag;
        if (IFrameSplitOperator.IsBool(option.EnableVerifyRecvData)) chart.EnableVerifyRecvData=option.EnableVerifyRecvData;

        if (option.GlobalOption)
        {
            var item=option.GlobalOption;
            if (IFrameSplitOperator.IsBool(item.IsValueFullRange)) chart.GlobalOption.IsValueFullRange=item.IsValueFullRange;
            if (item.SelectedBorder)
            {
                var subItem=item.SelectedBorder;
                if (IFrameSplitOperator.IsNumber(subItem.Mode)) chart.GlobalOption.SelectedBorder.Mode=subItem.Mode;
            }
        }

        if (option.EnableYDrag)
        {
            var item=option.EnableYDrag;
            if (IFrameSplitOperator.IsBool(item.Left)) chart.EnableYDrag.Left=item.Left;
            if (IFrameSplitOperator.IsBool(item.Right)) chart.EnableYDrag.Right=item.Right;
            if (IFrameSplitOperator.IsBool(item.Wheel)) chart.EnableYDrag.Wheel=item.Wheel;
            if (IFrameSplitOperator.IsNumber(item.WheelYMove)) chart.EnableYDrag.WheelYMove=item.WheelYMove;
        }

        if (option.KLine)   //k线图的属性设置
        {
            var item=option.KLine;
            if (option.KLine.DragMode>=0) chart.DragMode=option.KLine.DragMode;
            if (option.KLine.Right>=0) chart.Right=option.KLine.Right;
            if (option.KLine.Period>=0) chart.Period=option.KLine.Period;
            if (option.KLine.MaxReqeustDataCount>0) chart.MaxRequestDataCount=option.KLine.MaxReqeustDataCount; //兼容老版本
            if (option.KLine.MaxRequestDataCount>0) chart.MaxRequestDataCount=option.KLine.MaxRequestDataCount;
            if (option.KLine.Info && option.KLine.Info.length>0) chart.SetKLineInfo(option.KLine.Info,false);
            if (IFrameSplitOperator.IsBool(item.IsShowTooltip)) chart.IsShowTooltip=item.IsShowTooltip;
            if (IFrameSplitOperator.IsBool(item.IsShowKLineDivTooltip)) chart.IsShowKLineDivTooltip=item.IsShowKLineDivTooltip;
            if (option.KLine.MaxRequestMinuteDayCount>0) chart.MaxRequestMinuteDayCount=option.KLine.MaxRequestMinuteDayCount;
            if (option.KLine.DrawType) chart.KLineDrawType=option.KLine.DrawType;
            if (option.KLine.FirstShowDate>19910101) chart.CustomShow={ Date:option.KLine.FirstShowDate, PageSize:option.KLine.PageSize };  //!!已弃用 新的格式"CustomShow"
            if (option.KLine.RightSpaceCount>0) chart.RightSpaceCount=option.KLine.RightSpaceCount;
            if (option.KLine.ZoomType>0) chart.ZoomType=option.KLine.ZoomType;
            if (option.KLine.DataWidth>=1) chart.KLineSize={ DataWidth:option.KLine.DataWidth };
            if (IFrameSplitOperator.IsNumber(option.KLine.RightFormula)) chart.RightFormula=option.KLine.RightFormula;
        }

        //自定义显示位置
        if (option.CustomShow && IFrameSplitOperator.IsPlusNumber(option.CustomShow.Date))
        {
            var item=option.CustomShow;
            chart.CustomShow={ Date:item.Date };
            if (IFrameSplitOperator.IsNumber(item.Time)) chart.CustomShow.Time=item.Time;
            if (IFrameSplitOperator.IsPlusNumber(item.PageSize)) chart.CustomShow.PageSize=item.PageSize;
        }

        if (option.EnableFlowCapital)
        {
            var item=option.EnableFlowCapital;
            if (item.BIT==true) chart.EnableFlowCapital.BIT=item.BIT;
        }

        if (IFrameSplitOperator.IsBool(option.EnableBorderDrag))
        {
            chart.EnableBorderDrag=option.EnableBorderDrag;
        }

        if (option.Page)
        {
            if (option.Page.Day && option.Page.Day.Enable==true) chart.Page.Day.Enable=true;
            if (option.Page.Minute && option.Page.Minute.Enable==true) chart.Page.Minute.Enable=true;
        }

        if (option.DragDownload)
        {
            if (option.DragDownload.Day && option.DragDownload.Day.Enable==true) chart.DragDownload.Day.Enable=true;
            if (option.DragDownload.Minute && option.DragDownload.Minute.Enable==true) chart.DragDownload.Minute.Enable=true;
        }

        if (option.ZoomDownload)
        {
            if (option.ZoomDownload.Day && IFrameSplitOperator.IsBool(option.ZoomDownload.Day.Enable)) chart.ZoomDownload.Day.Enable=option.ZoomDownload.Day.Enable;
            if (option.ZoomDownload.Minute && IFrameSplitOperator.IsBool(option.ZoomDownload.Minute.Enable)) chart.ZoomDownload.Minute.Enable=option.ZoomDownload.Minute.Enable;
        }

        if (option.Language)
        {
            var value=g_JSChartLocalization.GetLanguageID(option.Language);
            if (IFrameSplitOperator.IsNumber(value)) chart.LanguageID=value;
        }

        if (option.SourceDatatLimit) chart.SetSourceDatatLimit(option.SourceDatatLimit);

        if (option.DrawPicture) //画图工具
        {
            if (option.DrawPicture.StorageKey && chart.ChartDrawStorage) chart.ChartDrawStorage.Load(option.DrawPicture.StorageKey);
        }

        if (option.DrawTool)    //画图工具
        {
            if (option.DrawTool.StorageKey && chart.ChartDrawStorage) chart.ChartDrawStorage.Load(option.DrawTool.StorageKey);
        }

        if (IFrameSplitOperator.IsNumber(option.StepPixel)) chart.StepPixel=option.StepPixel;
        if (option.ZoomStepPixel>0) chart.ZoomStepPixel=option.ZoomStepPixel;
        if (option.IsApiPeriod==true) chart.IsApiPeriod=option.IsApiPeriod;

        //图形选中
        if (option.SelectedChart)
        {
            var item=option.SelectedChart;
            if (IFrameSplitOperator.IsBool(item.EnableSelected)) chart.SelectedChart.EnableSelected=item.EnableSelected;
            if (IFrameSplitOperator.IsBool(item.EnableMoveOn)) chart.SelectedChart.EnableMoveOn=item.EnableMoveOn;
        }

        if (!option.Windows || option.Windows.length<=0) return null;

        //K线扩展计算方法配置
        if (IFrameSplitOperator.IsNonEmptyArray(option.KLineCalcOption))
        {
            for(var i=0;i<option.KLineCalcOption.length;++i)
            {
                var item=option.KLineCalcOption[i];
                if (!item.ClassName || !item.Option) continue;

                chart.SetKLineCalcOption(item.ClassName, item.Option);
            }
        }

        if (chart.ClassName=="KLineChartContainer")
        {
            if (!option.DragSelectRect)
            {
                option.DragSelectRect={ Enable:true };  //默认开启区间选中画布
            }
            
            if (option.DragSelectRect)
            {
                var zindex=10;
                var item=option.DragSelectRect;
                if (IFrameSplitOperator.IsNumber(item.ZIndex)) zindex=item.ZIndex;
                if (item.Enable) this.CreateExtraCanvasElement(JSChart.RectDragCanvasKey, { ZIndex:zindex });   //创建独立的区间选择画布
            }
        }

        //创建子窗口
        chart.Create(option.Windows.length, option);

        this.SetChartBorder(chart, option);

        this.AdjustChartBorder(chart);

        
        if (option.KLine)
        {
            if (option.KLine.PageSize > 0)  //一屏显示的数据个数
            {
                let pageSize = chart.GetMaxMinPageSize();
                if (pageSize.Max>10 && pageSize.Max < option.KLine.PageSize) chart.PageSize = pageSize.Max;
                else if (pageSize.Min>10 && pageSize.Min> option.KLine.PageSize) chart.PageSize=pageSize.Min;
                else chart.PageSize = option.KLine.PageSize;
            }
        }

        //取消显示十字光标刻度信息
        if (option.IsCorssOnlyDrawKLine===true) chart.ChartCorssCursor.IsOnlyDrawKLine=option.IsCorssOnlyDrawKLine;
        if (option.CorssCursorTouchEnd===true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;
        if (option.IsClickShowCorssCursor==true) chart.IsClickShowCorssCursor=option.IsClickShowCorssCursor;
        if (option.CorssCursorInfo)
        {
            var item=option.CorssCursorInfo;
            if (!isNaN(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left=option.CorssCursorInfo.Left;
            if (!isNaN(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right=option.CorssCursorInfo.Right;
            if (!isNaN(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom=option.CorssCursorInfo.Bottom;
            if (option.CorssCursorInfo.IsShowCorss===false) chart.ChartCorssCursor.IsShowCorss=option.CorssCursorInfo.IsShowCorss;
            if (IFrameSplitOperator.IsBool(item.IsShowClose)) chart.ChartCorssCursor.IsShowClose = item.IsShowClose;    //Y轴显示收盘价
            if (IFrameSplitOperator.IsBool(item.IsOnlyDrawKLine)) chart.ChartCorssCursor.IsOnlyDrawKLine = item.IsOnlyDrawKLine;    //Y轴显示收盘价
            if (option.CorssCursorInfo.PressTime) chart.PressTime=option.CorssCursorInfo.PressTime; //长按显示十字光标的时间
            if (IFrameSplitOperator.IsNumber(option.CorssCursorInfo.HPenType)) chart.ChartCorssCursor.HPenType=option.CorssCursorInfo.HPenType;
            if (option.CorssCursorInfo.VPenType>0) chart.ChartCorssCursor.VPenType=option.CorssCursorInfo.VPenType;
            if (IFrameSplitOperator.IsNumber(item.VLineType)) chart.ChartCorssCursor.VLineType=item.VLineType;
            if (option.CorssCursorInfo.DateFormatType>0) chart.ChartCorssCursor.StringFormatX.DateFormatType=option.CorssCursorInfo.DateFormatType;
            if (IFrameSplitOperator.IsBool(item.IsDrawXRangeBG)) chart.ChartCorssCursor.IsDrawXRangeBG=item.IsDrawXRangeBG;
            if (IFrameSplitOperator.IsBool(option.CorssCursorInfo.IsFixXLastTime)) chart.ChartCorssCursor.IsFixXLastTime=option.CorssCursorInfo.IsFixXLastTime;
            if (IFrameSplitOperator.IsNumber(item.TextHeight)) chart.ChartCorssCursor.TextHeight=item.TextHeight;
            
            if (item.RightButton)
            {
                if (IFrameSplitOperator.IsBool(item.RightButton.Enable)) chart.ChartCorssCursor.RightButton.Enable=item.RightButton.Enable;
            }

            if (IFrameSplitOperator.IsNumber(item.PriceFormatType)) chart.ChartCorssCursor.StringFormatY.PriceFormatType=item.PriceFormatType;
            if (IFrameSplitOperator.IsNumber(item.DataFormatType)) chart.ChartCorssCursor.StringFormatY.DataFormatType=item.DataFormatType;
           
        }

        //保存十字光标文字高度
        option.CorssCursor={};
        option.CorssCursor.TitleHeight=chart.ChartCorssCursor.TextHeight;

        if (IFrameSplitOperator.IsNumber(option.SplashTitlePosition))
        {
            if (chart.ChartSplashPaint) chart.ChartSplashPaint.Position=option.SplashTitlePosition;
        }


        if (option.Frame)
        {
            for(var i=0;i<option.Frame.length;++i)
            {
                var item=option.Frame[i];
                if (!chart.Frame.SubFrame[i]) continue;
                var subFrame=chart.Frame.SubFrame[i].Frame;

                if (IFrameSplitOperator.IsNumber(item.SplitCount)) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount=item.SplitCount;
                if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat=item.StringFormat;
                if (IFrameSplitOperator.IsNumber(item.FloatPrecision)) chart.Frame.SubFrame[i].Frame.YSplitOperator.FloatPrecision=item.FloatPrecision;
                if (item.Custom) chart.Frame.SubFrame[i].Frame.YSplitOperator.Custom=item.Custom;
                if (IFrameSplitOperator.IsNumber(item.SplitType)) 
                {
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitType=item.SplitType;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.DefaultSplitType=item.SplitType;
                }
                if (IFrameSplitOperator.IsNumber(item.FilterType)) subFrame.YSplitOperator.FilterType=item.FilterType;
                
                if (!isNaN(item.Height)) chart.Frame.SubFrame[i].Height = item.Height;
                if (item.IsShowLeftText===false || item.IsShowLeftText===true) 
                {
                    chart.Frame.SubFrame[i].Frame.IsShowYText[0]=item.IsShowLeftText;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowLeftText=item.IsShowLeftText;            //显示左边刻度
                }
                if (item.IsShowRightText===false || item.IsShowRightText===true) 
                {
                    chart.Frame.SubFrame[i].Frame.IsShowYText[1]=item.IsShowRightText;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowRightText=item.IsShowRightText;         //显示右边刻度
                }
                if (item.TopSpace>=0) chart.Frame.SubFrame[i].Frame.ChartBorder.TopSpace=item.TopSpace*pixelRatio;
                if (item.BottomSpace>=0) chart.Frame.SubFrame[i].Frame.ChartBorder.BottomSpace=item.BottomSpace*pixelRatio;

                if (item.RightTextPosition>0) chart.Frame.SubFrame[i].Frame.YTextPosition[1]=item.RightTextPosition;
                if (item.LeftTextPosition>0) chart.Frame.SubFrame[i].Frame.YTextPosition[0]=item.LeftTextPosition;

                if (item.IsShowXLine==false) chart.Frame.SubFrame[i].Frame.IsShowXLine=item.IsShowXLine;
                if (item.IsShowYLine==false) chart.Frame.SubFrame[i].Frame.IsShowYLine=item.IsShowYLine;
                if (IFrameSplitOperator.IsNumber(item.YTextBaseline)) chart.Frame.SubFrame[i].Frame.YTextBaseline=item.YTextBaseline;
                
                if (item.YCoordinateType>0) chart.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType=item.YCoordinateType;
                if (item.IsYReverse==true) chart.Frame.SubFrame[0].Frame.CoordinateType=1;  //反转坐标
                if (IFrameSplitOperator.IsNumber(item.PercentageTextFormat)) subFrame.YSplitOperator.PercentageTextFormat=item.PercentageTextFormat;    //百分比坐标格式

                if (item.DefaultYMaxMin) chart.Frame.SubFrame[i].Frame.YSplitOperator.DefaultYMaxMin=item.DefaultYMaxMin;
                if (IFrameSplitOperator.IsBool(item.EnableRemoveZero)) chart.Frame.SubFrame[i].Frame.YSplitOperator.EnableRemoveZero=item.EnableRemoveZero;
                if (IFrameSplitOperator.IsPlusNumber(item.MinYDistance)) chart.Frame.SubFrame[i].Frame.MinYDistance=item.MinYDistance;
                if (IFrameSplitOperator.IsNumber(item.BorderLine)) chart.Frame.SubFrame[i].Frame.BorderLine=item.BorderLine;
                if (IFrameSplitOperator.IsBool(item.IsShowIndexTitle)) chart.Frame.SubFrame[i].Frame.IsShowIndexTitle=item.IsShowIndexTitle;
                if (IFrameSplitOperator.IsBool(item.IsDrawTitleBottomLine)) subFrame.IsDrawTitleBottomLine=item.IsDrawTitleBottomLine;
                if (IFrameSplitOperator.IsBool(item.IsShowNameArrow)) chart.Frame.SubFrame[i].Frame.IsShowNameArrow=item.IsShowNameArrow;

                if (item.ClientBGColor) subFrame.ClientBGColor=item.ClientBGColor;
            }
        }

        if (option.KLine) 
        {
            var item=option.KLine;
            var klineChart=chart.ChartPaint[0];
            if (option.KLine.ShowKLine == false) klineChart.IsShow = false;
            if (option.KLine.InfoPosition>0) klineChart.InfoPosition=option.KLine.InfoPosition;
            if (IFrameSplitOperator.IsBool(item.IsShowMaxMinPrice)) klineChart.IsShowMaxMinPrice=item.IsShowMaxMinPrice;
            if (IFrameSplitOperator.IsNumber(item.OneLimitBarType)) klineChart.OneLimitBarType=item.OneLimitBarType;
            if (item.PriceGap)
            {
                if (IFrameSplitOperator.IsBool(item.PriceGap.Enable)) klineChart.PriceGap.Enable=item.PriceGap.Enable;
                if (IFrameSplitOperator.IsNumber(item.PriceGap.Count)) klineChart.PriceGap.Count=item.PriceGap.Count;
            }
        }

        if(option.KLineTitle)
        {
            var item=option.KLineTitle;
            if(option.KLineTitle.IsShowName==false) chart.TitlePaint[0].IsShowName=false;
            if(option.KLineTitle.IsShowSettingInfo==false) chart.TitlePaint[0].IsShowSettingInfo=false;
            if(option.KLineTitle.IsShow == false) chart.TitlePaint[0].IsShow = false;
            if(IFrameSplitOperator.IsBool(item.IsTitleShowLatestData)) chart.IsTitleShowLatestData=item.IsTitleShowLatestData;
        }

        //叠加股票
        
        if (option.Overlay)
        {
            for(var i=0;i<option.Overlay.length;++i)
            {
                var item=option.Overlay[i];
                chart.OverlaySymbol(item.Symbol,item);
            }
        }

        if (option.ExtendChart)
        {
            for(var i=0;i<option.ExtendChart.length;++i)
            {
                var item=option.ExtendChart[i];
                chart.CreateExtendChart(item.Name, item);
            }
        }

        //创建子窗口的指标
        var scriptData = new JSIndexScript();

        if (option.ColorIndex)    //五彩K线
        {
            var item=option.ColorIndex;
            let indexInfo=scriptData.Get(item.Index);
            if (indexInfo)
            {
                indexInfo.ID=item.Index;
                chart.ColorIndex=new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
            }
        }

        if (option.TradeIndex)  //交易指标
        {
            var item=option.TradeIndex;
            let indexInfo=scriptData.Get(item.Index);
            if (indexInfo)
            {
                indexInfo.ID=item.Index;
                chart.TradeIndex=new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
            }
        }

        for(var i=0;i<option.Windows.length;++i)
        {
            var item=option.Windows[i];
            if (item.Script)
            {
                chart.WindowIndex[i]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
            }
            else if (item.JsonData)
            {
                chart.WindowIndex[i]=new JsonDataIndex(item.Name,item.Script,item.Args,item);    //脚本执行
            }
            else if (item.Local && item.Local.Data)
            {
                chart.WindowIndex[i]=new LocalJsonDataIndex(item.Local.Name,item.Local.Args,{JsonData:item.Local.Data});
            }
            else if (item.API)  //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
            {
                var apiItem=item.API;
                chart.WindowIndex[i]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,item);
            }
            else
            {
                let indexItem=JSIndexMap.Get(item.Index);
                if (indexItem)
                {
                    chart.WindowIndex[i]=indexItem.Create(item.Option);
                    if (chart.WindowIndex[i].SetArgs) chart.WindowIndex[i].SetArgs(item.Args);
                    chart.CreateWindowIndex(i);
                }
                else
                {
                    var scriptData = new JSIndexScript();
                    let indexInfo = scriptData.Get(item.Index);
                    if (!indexInfo) continue;
                    JSIndexScript.ModifyAttribute(indexInfo, item);
                    indexInfo.ID=item.Index;
                   
                    chart.WindowIndex[i] = new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
                    if (item.StringFormat>0) chart.WindowIndex[i].StringFormat=item.StringFormat;
                    if (item.FloatPrecision>=0) chart.WindowIndex[i].FloatPrecision=item.FloatPrecision;
                }

            }

            var frame=chart.Frame.SubFrame[i].Frame;
            if (IFrameSplitOperator.IsBool(item.Modify)) frame.ModifyIndex=item.Modify;
            if (IFrameSplitOperator.IsBool(item.Change)) frame.ChangeIndex=item.Change;
            if (IFrameSplitOperator.IsBool(item.Close)) frame.CloseIndex=item.Close;
            if (IFrameSplitOperator.IsBool(item.Overlay)) frame.OverlayIndex=item.Overlay;
            if (IFrameSplitOperator.IsBool(item.Export)) frame.ExportData=item.Export;
            if (IFrameSplitOperator.IsBool(item.MaxMin)) chart.Frame.SubFrame[i].Frame.MaxMinWindow=item.MaxMin;
            if (IFrameSplitOperator.IsBool(item.TitleWindow)) chart.Frame.SubFrame[i].Frame.TitleWindow=item.TitleWindow;
            if (item.IsDrawTitleBG==true)  chart.Frame.SubFrame[i].Frame.IsDrawTitleBG=item.IsDrawTitleBG;
            if (IFrameSplitOperator.IsBool(item.IsShowNameArrow))  chart.Frame.SubFrame[i].Frame.IsShowNameArrow=item.IsShowNameArrow;

            if (IFrameSplitOperator.IsNumber(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight=item.TitleHeight;
            else item.TitleHeight=chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight;
            if (IFrameSplitOperator.IsBool(item.IsShowTitleArrow)) frame.IsShowTitleArrow=item.IsShowTitleArrow;
            if (IFrameSplitOperator.IsNumber(item.TitleArrowType)) frame.TitleArrowType=item.TitleArrowType;
            if (item.IsShowIndexName==false) chart.Frame.SubFrame[i].Frame.IsShowIndexName=false;
            if (item.IsShowOverlayIndexName==false) chart.Frame.SubFrame[i].Frame.IsShowOverlayIndexName=false;
            if (IFrameSplitOperator.IsNumber(item.IndexParamSpace)) chart.Frame.SubFrame[i].Frame.IndexParamSpace=item.IndexParamSpace;
            if (IFrameSplitOperator.IsNumber(item.IndexTitleSpace)) chart.Frame.SubFrame[i].Frame.IndexTitleSpace=item.IndexTitleSpace;
            if (!IFrameSplitOperator.IsUndefined(item.HorizontalReserved)) frame.HorizontalReserved=item.HorizontalReserved;
            
            if (item.OverlayIndexType)
            {
                if (IFrameSplitOperator.IsNumber(item.OverlayIndexType.Position)) chart.Frame.SubFrame[i].Frame.OverlayIndexType.Position=item.OverlayIndexType.Position;
                if (IFrameSplitOperator.IsNumber(item.OverlayIndexType.LineSpace)) chart.Frame.SubFrame[i].Frame.OverlayIndexType.LineSpace=item.OverlayIndexType.LineSpace;
            }
        }
        
        //叠加指标宽度
        if (option.OverlayIndexFrameWidth>40) chart.Frame.FixedRightWidth.Overlay=option.OverlayIndexFrameWidth;

        //叠加指标
        if (IFrameSplitOperator.IsNonEmptyArray(option.OverlayIndex))
        {
            for(var i=0;i<option.OverlayIndex.length;++i)
            {
                var item=option.OverlayIndex[i];
                if (item.Windows>=chart.Frame.SubFrame.length) continue;
    
                var itemString = JSON.stringify(item);
                var obj = JSON.parse(itemString);
                if (item.Index) obj.IndexName=item.Index;
                if (item.Windows>=0) obj.WindowIndex=item.Windows;
                chart.CreateOverlayWindowsIndex(obj);
            }
    
        }
        
        this.AdjustTitleHeight(chart);

        return chart;
    }

    //自定义指数历史K线图
    this.CreateCustomKLineChartContainer=function(option)
    {
        var chart=new CustomKLineChartContainer(this.CanvasElement);

        //创建改参数div
        chart.ModifyIndexDialog=this.ModifyIndexDialog;
        chart.ChangeIndexDialog=this.ChangeIndexDialog;
        
        //右键菜单
        if (IFrameSplitOperator.IsBool(option.IsShowRightMenu)) chart.IsShowRightMenu=option.IsShowRightMenu;

        if (option.KLine)   //k线图的属性设置
        {
            if (option.KLine.DragMode>=0) chart.DragMode=option.KLine.DragMode;
            if (option.KLine.Right>=0) chart.Right=option.KLine.Right;
            if (option.KLine.Period>=0) chart.Period=option.KLine.Period;
            if (option.KLine.MaxRequestDataCount>0) chart.MaxRequestDataCount=option.KLine.MaxRequestDataCount;
            if (option.KLine.Info && option.KLine.Info.length>0) chart.SetKLineInfo(option.KLine.Info,false);
            if (option.KLine.PageSize>0)  chart.PageSize=option.KLine.PageSize;
            if (option.KLine.IsShowTooltip==false) chart.IsShowTooltip=false;
        }

        if (option.CustomStock) chart.CustomStock=option.CustomStock;
        if (option.QueryDate) chart.QueryDate=option.QueryDate;

        if (!option.Windows || option.Windows.length<=0) return null;

        //创建子窗口
        chart.Create(option.Windows.length);

        if (option.Border)
        {
            if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left=option.Border.Left;
            if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right=option.Border.Right;
            if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top=option.Border.Top;
        }

        if (option.IsShowCorssCursorInfo==false)    //取消显示十字光标刻度信息
        {
            chart.ChartCorssCursor.IsShowText=option.IsShowCorssCursorInfo;
        }

        if (option.Frame)
        {
            for(var i=0;i<option.Frame.length;++i)
            {
                var item=option.Frame[i];
                if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount=item.SplitCount;
                if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat=item.StringFormat;
            }
        }

        if(option.KLineTitle)
        {
            if(option.KLineTitle.IsShowName==false) chart.TitlePaint[0].IsShowName=false;
            if(option.KLineTitle.IsShowSettingInfo==false) chart.TitlePaint[0].IsShowSettingInfo=false;
        }

        //创建子窗口的指标
        let scriptData = new JSIndexScript();
        for(var i=0;i<option.Windows.length;++i)
        {
            var item=option.Windows[i];
            if (item.Script)
            {
                chart.WindowIndex[i]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
            }
            else
            {
                let indexItem=JSIndexMap.Get(item.Index);
                if (indexItem)
                {
                    chart.WindowIndex[i]=indexItem.Create();
                    chart.CreateWindowIndex(i);
                }
                else
                {
                    let indexInfo = scriptData.Get(item.Index);
                    if (!indexInfo) continue;

                    if (item.Lock) indexInfo.Lock=item.Lock;
                    chart.WindowIndex[i] = new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
                }
            }
           
            if (item.Modify!=null)
                chart.Frame.SubFrame[i].Frame.ModifyIndex=item.Modify;
            if (item.Change!=null)
                chart.Frame.SubFrame[i].Frame.ChangeIndex=item.Change;

            if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight=item.TitleHeight;
        }

        return chart;
    }

    //分钟走势图
    this.CreateMinuteChartContainer=function(option)
    {
        var chart=null;
        if (option.Type==="分钟走势图横屏") chart=new MinuteChartHScreenContainer(this.CanvasElement);
        else chart=new MinuteChartContainer(this.CanvasElement, this.OffscreenCanvasElement, this.CacheCanvasElement);

        chart.GetExtraCanvas=(name)=>{ return this.GetExtraCanvas(name); }

        if (option.EventCallback) this.SetEventCallback(chart, option.EventCallback);
        if (option.NetworkFilter) chart.NetworkFilter=option.NetworkFilter;

        chart.ModifyIndexDialog=this.ModifyIndexDialog;
        chart.ChangeIndexDialog=this.ChangeIndexDialog;

        var pixelRatio=GetDevicePixelRatio();

        var windowsCount=2;
        if (option.Windows && option.Windows.length>0) windowsCount+=option.Windows.length; //指标窗口从第3个窗口开始
        if (option.EnableScrollUpDown==true) chart.EnableScrollUpDown=option.EnableScrollUpDown;
        if (option.DisableMouse==true) chart.DisableMouse=option.DisableMouse;
        if (option.ScriptError) chart.ScriptErrorCallback=option.ScriptError;       //指标执行错误回调
        if (IFrameSplitOperator.IsString(option.SplashTitle)) chart.LoadDataSplashTitle=option.SplashTitle;
        if (IFrameSplitOperator.IsBool(option.EnableSelectRect)) chart.EnableSelectRect=option.EnableSelectRect; //是否启用区间选择
        if (IFrameSplitOperator.IsBool(option.EnableZoomIndexWindow)) chart.EnableZoomIndexWindow=option.EnableZoomIndexWindow;
        if (IFrameSplitOperator.IsBool(option.IsDrawPictureXY)) chart.IsDrawPictureXY=option.IsDrawPictureXY;
        if (IFrameSplitOperator.IsBool(option.EnableNewIndex)) chart.EnableNewIndex=option.EnableNewIndex;
        if (IFrameSplitOperator.IsBool(option.EnableIndexChartDrag)) chart.EnableIndexChartDrag=option.EnableIndexChartDrag;
        if (IFrameSplitOperator.IsBool(option.EnableVerifyRecvData)) chart.EnableVerifyRecvData=option.EnableVerifyRecvData;
        if (IFrameSplitOperator.IsBool(option.EnableNightDayBG)) chart.EnableNightDayBG=option.EnableNightDayBG;

        if (option.GlobalOption)
        {
            var item=option.GlobalOption;
            if (IFrameSplitOperator.IsBool(item.IsValueFullRange)) chart.GlobalOption.IsValueFullRange=item.IsValueFullRange;
            if (IFrameSplitOperator.IsNumber(item.XDateFormat)) chart.GlobalOption.XDateFormat=item.XDateFormat;
        }

        if (option.DisplayLatest)
        {
            var item=option.DisplayLatest;
            if (IFrameSplitOperator.IsBool(item.Enable)) chart.DisplayLatestOption.Enable=item.Enable;
            if (IFrameSplitOperator.IsNumber(item.DelayTime)) chart.DisplayLatestOption.DelayTime=item.DelayTime;
        }

        if (option.DrawDynamicInfo)
        {
            var item=option.DrawDynamicInfo;
            if (IFrameSplitOperator.IsBool(item.Enable)) chart.DrawDynamicInfoOption.Enable=item.Enable;
            if (IFrameSplitOperator.IsNumber(item.DelayTime)) chart.DrawDynamicInfoOption.DelayTime=item.DelayTime;
        }
        

        chart.SelectRectDialog=new MinuteSelectRectDialog(this.DivElement);
        

        if (option.Minute)   //分钟走势图属性设置
        {
            if (option.Minute.IsShowTooltip==false) chart.IsShowTooltip=false;
            if (option.Minute.DragMode>=0) chart.DragMode=option.Minute.DragMode;
        }

        if (option.Language)
        {
            var value=g_JSChartLocalization.GetLanguageID(option.Language);
            if (IFrameSplitOperator.IsNumber(value)) chart.LanguageID=value;
        }

        if (option.Info && option.Info.length>0) chart.SetMinuteInfo(option.Info,false);

        if (option.DrawTool)    //画图工具
        {
            if (option.DrawTool.StorageKey && chart.ChartDrawStorage) chart.ChartDrawStorage.Load(option.DrawTool.StorageKey);
        }

        if (option.BeforeOpen)  //集合竞价
        {
            var item=option.BeforeOpen;

            if (IFrameSplitOperator.IsBool(item.IsShow)) chart.IsShowBeforeData=item.IsShow;
            if (IFrameSplitOperator.IsNumber(item.Width)) chart.ExtendWidth.Left=item.Width;
            if (IFrameSplitOperator.IsBool(item.IsShowMultiDay)) chart.IsShowMultiDayBeforeData=item.IsShowMultiDay;
            if (IFrameSplitOperator.IsNumber(item.MulitiDayWidth)) chart.MultiDayExtendWidth.Left=item.MulitiDayWidth;
        }

        if (option.AfterClose)  //收盘集合竞价
        {
            var item=option.AfterClose;
            if (IFrameSplitOperator.IsBool(item.IsShow)) chart.IsShowAfterData=item.IsShow;
            if (IFrameSplitOperator.IsNumber(item.ShareVol)) chart.ShareAfterVol=item.ShareVol;
            if (IFrameSplitOperator.IsNumber(item.Width)) chart.ExtendWidth.Right=item.Width;
            if (IFrameSplitOperator.IsBool(item.IsShowMultiDay)) chart.IsShowMultiDayAfterData=item.IsShowMultiDay;
            if (IFrameSplitOperator.IsNumber(item.MulitiDayWidth)) chart.MultiDayExtendWidth.Right=item.MulitiDayWidth;
        }

        //图形选中
        if (option.SelectedChart)
        {
            var item=option.SelectedChart;
            if (IFrameSplitOperator.IsBool(item.EnableSelected)) chart.SelectedChart.EnableSelected=item.EnableSelected;
            if (IFrameSplitOperator.IsBool(item.EnableMoveOn)) chart.SelectedChart.EnableMoveOn=item.EnableMoveOn;
        }

        if (chart.ClassName=="MinuteChartContainer")
        {
            if (!option.DragSelectRect)
            {
                option.DragSelectRect={ Enable:true };  //默认开启区间选中画布
            }

            if (option.DragSelectRect)
            {
                var item=option.DragSelectRect;
                var zindex=10;
                if (IFrameSplitOperator.IsNumber(item.ZIndex)) zindex=item.ZIndex;
                if (item.Enable) this.CreateExtraCanvasElement(JSChart.RectDragCanvasKey, { ZIndex:zindex });   //创建独立的区间选择画布
            }
        }

        //分页
        if (option.PageInfo) chart.SetPageInfo(option.PageInfo);

        chart.Create(windowsCount,option);                            //创建子窗口

        if (option.CorssCursorInfo)
        {
            var item=option.CorssCursorInfo;
            if (!isNaN(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left=option.CorssCursorInfo.Left;
            if (!isNaN(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right=option.CorssCursorInfo.Right;
            if (!isNaN(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom=option.CorssCursorInfo.Bottom;
            if (option.CorssCursorInfo.IsShowCorss===false) chart.ChartCorssCursor.IsShowCorss=option.CorssCursorInfo.IsShowCorss;
            if (option.CorssCursorInfo.RightTextFormat>0) chart.ChartCorssCursor.TextFormat.Right=option.CorssCursorInfo.RightTextFormat;
            if (option.CorssCursorInfo.IsOnlyDrawMinute == true) chart.ChartCorssCursor.IsOnlyDrawMinute = option.CorssCursorInfo.IsOnlyDrawMinute;    //Y轴显示收盘价
            if (IFrameSplitOperator.IsBool(option.CorssCursorInfo.IsFixXLastTime)) chart.ChartCorssCursor.IsFixXLastTime=option.CorssCursorInfo.IsFixXLastTime;

            if (item.RightButton)
            {
                if (IFrameSplitOperator.IsBool(item.RightButton.Enable)) chart.ChartCorssCursor.RightButton.Enable=item.RightButton.Enable;
            } 

            if (IFrameSplitOperator.IsNumber(item.PriceFormatType)) chart.ChartCorssCursor.StringFormatY.PriceFormatType=item.PriceFormatType;
            if (IFrameSplitOperator.IsNumber(item.DataFormatType)) chart.ChartCorssCursor.StringFormatY.DataFormatType=item.DataFormatType;

            if (IFrameSplitOperator.IsNumber(item.HPenType)) chart.ChartCorssCursor.HPenType=item.HPenType;
            if (IFrameSplitOperator.IsNumber(item.VPenType)) chart.ChartCorssCursor.VPenType=item.VPenType;
        }

        if (option.MinuteInfo) chart.CreateMinuteInfo(option.MinuteInfo);

        if (IFrameSplitOperator.IsBool(option.IsShowRightMenu)) chart.IsShowRightMenu=option.IsShowRightMenu;

        if (IFrameSplitOperator.IsNumber(option.DayCount)) chart.DayCount=option.DayCount;

        this.SetChartBorder(chart, option);

        if (option.SplashTitle) chart.ChartSplashPaint.SplashTitle=option.SplashTitle;

        if (IFrameSplitOperator.IsBool(option.EnableBorderDrag))
        {
            chart.EnableBorderDrag=option.EnableBorderDrag;
        }

        this.AdjustChartBorder(chart);

        if (option.Frame)
        {
            for(var i=0;i<option.Frame.length;++i)
            {
                var item=option.Frame[i];
                if (!chart.Frame.SubFrame[i]) continue;
                var subFrame=chart.Frame.SubFrame[i].Frame;

                if (IFrameSplitOperator.IsNumber(item.SplitCount)) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount=item.SplitCount;
                if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat=item.StringFormat;
                if (IFrameSplitOperator.IsNumber(item.SplitType)) 
                {
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitType=item.SplitType;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.DefaultSplitType=item.SplitType;
                }
                if (IFrameSplitOperator.IsNumber(item.FilterType)) subFrame.YSplitOperator.FilterType=item.FilterType;

                if (item.IsShowLeftText==false) 
                {
                    chart.Frame.SubFrame[i].Frame.IsShowYText[0]=item.IsShowLeftText;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowLeftText=item.IsShowLeftText;            //显示左边刻度
                }
                if (item.IsShowRightText==false) 
                {
                    chart.Frame.SubFrame[i].Frame.IsShowYText[1]=item.IsShowRightText;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowRightText=item.IsShowRightText;         //显示右边刻度 
                }
                if (item.Height>=0) chart.Frame.SubFrame[i].Height = item.Height;
                if (item.Custom) chart.Frame.SubFrame[i].Frame.YSplitOperator.Custom=item.Custom;
                if (item.RightTextFormat>0) chart.Frame.SubFrame[i].Frame.YSplitOperator.RightTextFormat=item.RightTextFormat;
                if (IFrameSplitOperator.IsNumber(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight=item.TitleHeight;
                if (IFrameSplitOperator.IsNumber(item.BorderLine)) chart.Frame.SubFrame[i].Frame.BorderLine=item.BorderLine;
                if (IFrameSplitOperator.IsBool(item.EnableRemoveZero)) chart.Frame.SubFrame[i].Frame.YSplitOperator.EnableRemoveZero=item.EnableRemoveZero;
                if (IFrameSplitOperator.IsNumber(item.FloatPrecision)) chart.Frame.SubFrame[i].Frame.YSplitOperator.FloatPrecision=item.FloatPrecision;
                if (IFrameSplitOperator.IsBool(item.IsShowXLine)) chart.Frame.SubFrame[i].Frame.IsShowXLine=item.IsShowXLine;
                if (IFrameSplitOperator.IsBool(item.IsShowYLine)) chart.Frame.SubFrame[i].Frame.IsShowYLine=item.IsShowYLine;
                if (IFrameSplitOperator.IsNumber(item.YTextBaseline)) chart.Frame.SubFrame[i].Frame.YTextBaseline=item.YTextBaseline;
                if (IFrameSplitOperator.IsBool(item.IsShowIndexTitle)) chart.Frame.SubFrame[i].Frame.IsShowIndexTitle=item.IsShowIndexTitle;

                if (item.TopSpace>=0) chart.Frame.SubFrame[i].Frame.ChartBorder.TopSpace=item.TopSpace*pixelRatio;
                if (item.BottomSpace>=0) chart.Frame.SubFrame[i].Frame.ChartBorder.BottomSpace=item.BottomSpace*pixelRatio;

                //是否显示关闭集合竞价按钮
                if (IFrameSplitOperator.IsNumber(item.CloseBeforeButton)) chart.Frame.SubFrame[i].Frame.IsShowCloseButton=item.CloseBeforeButton;

                if (item.ClientBGColor) subFrame.ClientBGColor=item.ClientBGColor;
                if (!IFrameSplitOperator.IsUndefined(item.HorizontalReserved)) subFrame.HorizontalReserved=item.HorizontalReserved;
            }

            chart.UpdateXShowText();
        }

        if (option.ExtendChart)
        {
            for(var i=0;i<option.ExtendChart.length;++i)
            {
                var item=option.ExtendChart[i];
                chart.CreateExtendChart(item.Name, item);
            }
        }

        //叠加股票
        if (option.Overlay)
        {
            for(var i=0;i<option.Overlay.length;++i)
            {
                var item=option.Overlay[i];
                chart.OverlaySymbol(item.Symbol,item);
            }
        }

        if (option.MinuteLine)
        {
            if (option.MinuteLine.IsDrawAreaPrice==false) chart.ChartPaint[0].IsDrawArea=false;
            if (option.MinuteLine.IsShowLead==false) chart.IsShowLead=false;
            if (option.MinuteLine.IsShowAveragePrice==false) 
            {
                chart.ChartPaint[1].IsShow=false;
                chart.TitlePaint[0].IsShowAveragePrice=false;   //标题栏均线也不显示
                for(var i=0;i<chart.ExtendChartPaint.length;++i)
                {
                    var item=chart.ExtendChartPaint[i];
                    if (item.ClassName=="MinuteTooltipPaint")
                        item.IsShowAveragePrice=false;
                }
            }
            if (option.MinuteLine.SplitType>0) chart.Frame.SubFrame[0].Frame.YSplitOperator.SplitType=option.MinuteLine.SplitType;
        }

        if (option.MinuteVol)
        {
            var item=option.MinuteVol;
            if (IFrameSplitOperator.IsNumber(item.BarColorType)) chart.ChartPaint[2].BarColorType=item.BarColorType;
        }

        if(option.MinuteTitle)
        {
            var item=option.MinuteTitle;
            if(IFrameSplitOperator.IsBool(item.IsShowName)) chart.TitlePaint[0].IsShowName=item.IsShowName;
            if(IFrameSplitOperator.IsBool(item.IsShowDate)) chart.TitlePaint[0].IsShowDate=item.IsShowDate;
            if(IFrameSplitOperator.IsBool(item.IsShowTime)) chart.TitlePaint[0].IsShowTime=item.IsShowTime;
            if(IFrameSplitOperator.IsBool(item.IsTitleShowLatestData)) chart.IsTitleShowLatestData=item.IsTitleShowLatestData;
            if(IFrameSplitOperator.IsBool(item.IsAlwaysShowLastData)) chart.TitlePaint[0].IsAlwaysShowLastData=item.IsAlwaysShowLastData;
            if(IFrameSplitOperator.IsNumber(item.ShowLastDataFormat)) chart.TitlePaint[0].ShowLastDataFormat=item.ShowLastDataFormat;
            if (IFrameSplitOperator.IsNumber(item.TitleBaseLine)) chart.TitlePaint[0].TitleBaseLine=item.TitleBaseLine;
            if (item.TimeFormat) chart.TitlePaint[0].TimeFormat=item.TimeFormat;
        }

        if (IFrameSplitOperator.IsBool(option.CorssCursorTouchEnd)) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;
        if (IFrameSplitOperator.IsBool(option.IsClickShowCorssCursor)) chart.IsClickShowCorssCursor=option.IsClickShowCorssCursor;
        if (option.IsShowBeforeData===true) chart.IsShowBeforeData=option.IsShowBeforeData;

        //分钟数据指标从第3个指标窗口设置
        if (IFrameSplitOperator.IsNonEmptyArray(option.Windows))
        {
            let scriptData = new JSIndexScript();
            for(var i=0;i<option.Windows.length;++i)
            {
                var index=2+i;
                var item=option.Windows[i];
                if (item.Script)
                {
                    chart.WindowIndex[index]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
                }
                else if (item.API)  //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
                {
                    var apiItem=item.API;
                    chart.WindowIndex[index]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,item);
                }
                else
                {
                    var indexItem=JSIndexMap.Get(item.Index);
                    if (indexItem)
                    {
                        chart.WindowIndex[index]=indexItem.Create();       //创建子窗口的指标
                        chart.CreateWindowIndex(index);
                    }
                    else
                    {
                        let indexInfo = scriptData.Get(item.Index);
                        if (!indexInfo) continue;
                        indexInfo.ID=item.Index;
                        var args=indexInfo.Args;
                        if (item.Args) args=item.Args;
                        if (item.IsShortTitle) indexInfo.IsShortTitle=item.IsShortTitle;
                        if (item.TitleFont) indexInfo.TitleFont=item.TitleFont;
                        if (IFrameSplitOperator.IsBool(item.IsSync)) indexInfo.IsSync=item.IsSync;
                        chart.WindowIndex[index] = new ScriptIndex(indexInfo.Name, indexInfo.Script, args,indexInfo);    //脚本执行
                        if (item.StringFormat>0) chart.WindowIndex[index].StringFormat=item.StringFormat;
                        if (item.FloatPrecision>=0) chart.WindowIndex[index].FloatPrecision=item.FloatPrecision;
                    }
                }

                var frame=chart.Frame.SubFrame[index].Frame;
                if (IFrameSplitOperator.IsBool(item.Modify)) frame.ModifyIndex=item.Modify;
                if (IFrameSplitOperator.IsBool(item.Change)) frame.ChangeIndex=item.Change;
                if (IFrameSplitOperator.IsBool(item.Close)) frame.CloseIndex=item.Close;
                if (IFrameSplitOperator.IsBool(item.Overlay)) frame.OverlayIndex=item.Overlay;
                if (IFrameSplitOperator.IsBool(item.Export)) frame.ExportData=item.Export;
                if (IFrameSplitOperator.IsBool(item.MaxMin)) frame.MaxMinWindow=item.MaxMin;
                if (IFrameSplitOperator.IsBool(item.TitleWindow)) frame.TitleWindow=item.TitleWindow;

                if (IFrameSplitOperator.IsNumber(item.YSplitType)) chart.Frame.SubFrame[index].Frame.YSplitOperator.SplitType=item.YSplitType;
                if (IFrameSplitOperator.IsNumber(item.FilterType)) chart.Frame.SubFrame[index].Frame.YSplitOperator.FilterType=item.FilterType;
                if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[index].Frame.ChartBorder.TitleHeight=item.TitleHeight;
                if (IFrameSplitOperator.IsBool(item.IsDrawTitleBG))  chart.Frame.SubFrame[index].Frame.IsDrawTitleBG=item.IsDrawTitleBG;
                if (IFrameSplitOperator.IsBool(item.IsShowNameArrow))  chart.Frame.SubFrame[index].Frame.IsShowNameArrow=item.IsShowNameArrow;

                if (IFrameSplitOperator.IsBool(item.IsShowTitleArrow)) frame.IsShowTitleArrow=item.IsShowTitleArrow;
                if (IFrameSplitOperator.IsNumber(item.TitleArrowType)) frame.TitleArrowType=item.TitleArrowType;
                if (item.IsShowIndexName==false) chart.Frame.SubFrame[index].Frame.IsShowIndexName=false;
                if (item.IsShowOverlayIndexName==false) chart.Frame.SubFrame[index].Frame.IsShowOverlayIndexName=false;
                if (!IFrameSplitOperator.IsUndefined(item.HorizontalReserved)) frame.HorizontalReserved=item.HorizontalReserved;
            }
        }

        this.AdjustTitleHeight(chart);

        //叠加指标
        if (IFrameSplitOperator.IsNonEmptyArray(option.OverlayIndex))
        {
            for(var i=0;i<option.OverlayIndex.length;++i)
            {
                var item=option.OverlayIndex[i];
                if (item.Windows>=chart.Frame.SubFrame.length) continue;
    
                var itemString = JSON.stringify(item);
                var obj = JSON.parse(itemString);
                if (item.Index) obj.IndexName=item.Index;
                if (item.Windows>=0) obj.WindowIndex=item.Windows;
                chart.CreateOverlayWindowsIndex(obj);
            }
        }
        
        return chart;
    }

    this.CreateMinMinuteChartContainer=function(option)
    {
        var chart=null;
        if (option.Type==="迷你分钟走势图横屏") chart=new MinuteChartHScreenContainer(this.CanvasElement);
        else chart=new MinuteChartContainer(this.CanvasElement);

        if (option.NetworkFilter) chart.NetworkFilter=option.NetworkFilter;
        var windowsCount=2;

        if (option.BeforeOpen)  //集合竞价
        {
            var item=option.BeforeOpen;

            if (IFrameSplitOperator.IsBool(item.IsShow)) chart.IsShowBeforeData=item.IsShow;
            if (IFrameSplitOperator.IsNumber(item.Width)) chart.ExtendWidth.Left=item.Width;
            if (IFrameSplitOperator.IsBool(item.IsShowMultiDay)) chart.IsShowMultiDayBeforeData=item.IsShowMultiDay;
            if (IFrameSplitOperator.IsNumber(item.MulitiDayWidth)) chart.MultiDayExtendWidth.Left=item.MulitiDayWidth;
        }

        if (option.AfterClose)  //收盘集合竞价
        {
            var item=option.AfterClose;
            if (IFrameSplitOperator.IsBool(item.IsShow)) chart.IsShowAfterData=item.IsShow;
            if (IFrameSplitOperator.IsNumber(item.ShareVol)) chart.ShareAfterVol=item.ShareVol;
            if (IFrameSplitOperator.IsNumber(item.Width)) chart.ExtendWidth.Right=item.Width;
            if (IFrameSplitOperator.IsBool(item.IsShowMultiDay)) chart.IsShowMultiDayAfterData=item.IsShowMultiDay;
            if (IFrameSplitOperator.IsNumber(item.MulitiDayWidth)) chart.MultiDayExtendWidth.Right=item.MulitiDayWidth;
        }

        if (!option.Listener) option.Listener={ KeyDown:false, Wheel:false };
        chart.Create(windowsCount,option.Listener);    //创建子窗口

        if (option.CorssCursorInfo)
        {
            var item=option.CorssCursorInfo;
            if (IFrameSplitOperator.IsNumber(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left=option.CorssCursorInfo.Left;
            if (IFrameSplitOperator.IsNumber(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right=option.CorssCursorInfo.Right;
            if (IFrameSplitOperator.IsNumber(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom=option.CorssCursorInfo.Bottom;
            if (option.CorssCursorInfo.IsShowCorss===false) chart.ChartCorssCursor.IsShowCorss=option.CorssCursorInfo.IsShowCorss;
            if (option.CorssCursorInfo.RightTextFormat>0) chart.ChartCorssCursor.TextFormat.Right=option.CorssCursorInfo.RightTextFormat;
            if (option.CorssCursorInfo.IsOnlyDrawMinute == true) chart.ChartCorssCursor.IsOnlyDrawMinute = option.CorssCursorInfo.IsOnlyDrawMinute;    //Y轴显示收盘价
            if (IFrameSplitOperator.IsBool(option.CorssCursorInfo.IsFixXLastTime)) chart.ChartCorssCursor.IsFixXLastTime=option.CorssCursorInfo.IsFixXLastTime;

            if (item.RightButton)
            {
                if (IFrameSplitOperator.IsBool(item.RightButton.Enable)) chart.ChartCorssCursor.RightButton.Enable=item.RightButton.Enable;
            } 

            if (IFrameSplitOperator.IsNumber(item.PriceFormatType)) chart.ChartCorssCursor.StringFormatY.PriceFormatType=item.PriceFormatType;
            if (IFrameSplitOperator.IsNumber(item.DataFormatType)) chart.ChartCorssCursor.StringFormatY.DataFormatType=item.DataFormatType;
            if (IFrameSplitOperator.IsNumber(option.CorssCursorInfo.HPenType)) chart.ChartCorssCursor.HPenType=option.CorssCursorInfo.HPenType;
            if (IFrameSplitOperator.IsNumber(option.CorssCursorInfo.VPenType)) chart.ChartCorssCursor.VPenType=option.CorssCursorInfo.VPenType;
        }

        if (IFrameSplitOperator.IsNumber(option.DayCount)) chart.DayCount=option.DayCount;
        this.SetChartBorder(chart, option);

        if (option.SplashTitle) chart.ChartSplashPaint.SplashTitle=option.SplashTitle;
        if (IFrameSplitOperator.IsBool(option.EnableVerifyRecvData)) chart.EnableVerifyRecvData=option.EnableVerifyRecvData;

        chart.TitlePaint[0].IsShow=false;

        //主窗口 隐藏刻度
        var mainFrame=chart.Frame.SubFrame[0];
        mainFrame.Frame.IsShowYText[0]=false;
        mainFrame.Frame.IsShowYText[1]=false;
        mainFrame.Frame.IsShowXLine=false;
        mainFrame.Frame.IsShowYLine=false;
        mainFrame.Frame.BorderLine=0;
        
        chart.Frame.SubFrame[1].Height=0;   //隐藏成交量
        chart.EnableBorderDrag=false;

        if (option.Frame)
        {
            for(var i=0;i<option.Frame.length;++i)
            {
                var item=option.Frame[i];
                if (!chart.Frame.SubFrame[i]) continue;
                if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount=item.SplitCount;
                if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat=item.StringFormat;
                if (IFrameSplitOperator.IsNumber(item.SplitType)) 
                {
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitType=item.SplitType;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.DefaultSplitType=item.SplitType;
                }
                if (IFrameSplitOperator.IsBool(item.IsShowLeftText)) 
                {
                    chart.Frame.SubFrame[i].Frame.IsShowYText[0]=item.IsShowLeftText;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowLeftText=item.IsShowLeftText;            //显示左边刻度
                }
                if (IFrameSplitOperator.IsBool(item.IsShowRightText)) 
                {
                    chart.Frame.SubFrame[i].Frame.IsShowYText[1]=item.IsShowRightText;
                    chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowRightText=item.IsShowRightText;         //显示右边刻度 
                }
                if (item.Height>=0) chart.Frame.SubFrame[i].Height = item.Height;
                if (item.Custom) chart.Frame.SubFrame[i].Frame.YSplitOperator.Custom=item.Custom;
                if (item.RightTextFormat>0) chart.Frame.SubFrame[i].Frame.YSplitOperator.RightTextFormat=item.RightTextFormat;
                if (IFrameSplitOperator.IsNumber(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight=item.TitleHeight;
                if (IFrameSplitOperator.IsNumber(item.BorderLine)) chart.Frame.SubFrame[i].Frame.BorderLine=item.BorderLine;
                if (IFrameSplitOperator.IsBool(item.EnableRemoveZero)) chart.Frame.SubFrame[i].Frame.YSplitOperator.EnableRemoveZero=item.EnableRemoveZero;
                if (IFrameSplitOperator.IsNumber(item.FloatPrecision)) chart.Frame.SubFrame[i].Frame.YSplitOperator.FloatPrecision=item.FloatPrecision;
                if (IFrameSplitOperator.IsBool(item.IsShowXLine)) chart.Frame.SubFrame[i].Frame.IsShowXLine=item.IsShowXLine;
                if (IFrameSplitOperator.IsBool(item.IsShowYLine)) chart.Frame.SubFrame[i].Frame.IsShowYLine=item.IsShowYLine;
                if (IFrameSplitOperator.IsNumber(item.YTextBaseline)) chart.Frame.SubFrame[i].Frame.YTextBaseline=item.YTextBaseline;
            }
        }

        chart.UpdateXShowText();


        if (option.MinuteLine)
        {
            if (option.MinuteLine.IsDrawAreaPrice==false) chart.ChartPaint[0].IsDrawArea=false;
            if (option.MinuteLine.IsShowLead==false) chart.IsShowLead=false;
            if (option.MinuteLine.IsShowAveragePrice==false) 
            {
                chart.ChartPaint[1].IsShow=false;
                chart.TitlePaint[0].IsShowAveragePrice=false;   //标题栏均线也不显示
                for(var i=0;i<chart.ExtendChartPaint.length;++i)
                {
                    var item=chart.ExtendChartPaint[i];
                    if (item.ClassName=="MinuteTooltipPaint")
                        item.IsShowAveragePrice=false;
                }
            }
            if (option.MinuteLine.SplitType>0) chart.Frame.SubFrame[0].Frame.YSplitOperator.SplitType=option.MinuteLine.SplitType;
        }

        this.AdjustTitleHeight(chart);

        if (option.DisableMouseEvent===true)
        {
            //取消鼠标事件
            this.CanvasElement.onmousemove=(e)=>{  }
            this.CanvasElement.oncontextmenu=(e)=> { }
            this.CanvasElement.ondblclick=(e)=>{  }
            this.CanvasElement.onmousedown=(e)=> {  }
            this.CanvasElement.onmouseout=(e)=>{  }
            this.CanvasElement.onmouseleave=(e)=>{  }
        }

        if (option.ExtendChart)
        {
            for(var i=0;i<option.ExtendChart.length;++i)
            {
                var item=option.ExtendChart[i];
                chart.CreateExtendChart(item.Name, item);
            }
        }

        return chart;
        
    }

    /*废弃 
    //统一全部使用 MinuteChartContainer
    //历史分钟走势图
    this.CreateHistoryMinuteChartContainer=function(option)
    {
        var chart=new HistoryMinuteChartContainer(this.CanvasElement);

        var windowsCount=2;
        if (option.Windows && option.Windows.length>0) windowsCount+=option.Windows.length; //指标窗口从第3个窗口开始

        chart.Create(windowsCount);                            //创建子窗口

        if (option.IsShowCorssCursorInfo==false)    //取消显示十字光标刻度信息
        {
            chart.ChartCorssCursor.IsShowText=option.IsShowCorssCursorInfo;
        }

        if (option.Border)
        {
            if (!isNaN(option.Border.Left)) chart.Frame.ChartBorder.Left=option.Border.Left;
            if (!isNaN(option.Border.Right)) chart.Frame.ChartBorder.Right=option.Border.Right;
            if (!isNaN(option.Border.Top)) chart.Frame.ChartBorder.Top=option.Border.Top;
            if (!isNaN(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom=option.Border.Bottom;
        }

        let scriptData = new JSIndexScript();
        if (option.Windows)
        {
            for(var i=0;i<option.Windows.length;++i)
            {
                var item=option.Windows[i];
                if (item.Script)
                {
                    chart.WindowIndex[2+parseInt(i)]=new ScriptIndex(item.Name,item.Script,item.Args);    //脚本执行
                }
                else
                {
                    var indexItem=JSIndexMap.Get(item.Index);
                    if (indexItem)
                    {
                        chart.WindowIndex[2+parseInt(i)]=indexItem.Create();       //创建子窗口的指标
                        chart.CreateWindowIndex(2+parseInt(i));
                    }
                    else
                    {
                        let indexInfo = scriptData.Get(item.Index);
                        if (!indexInfo) continue;

                        chart.WindowIndex[2+parseInt(i)] = new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args);    //脚本执行
                    }
                }

                if (!isNaN(item.TitleHeight)) chart.Frame.SubFrame[2+parseInt(i)].Frame.ChartBorder.TitleHeight=item.TitleHeight;
            }
        }

        chart.TradeDate=20181009;
        if (option.HistoryMinute.TradeDate) chart.TradeDate=option.HistoryMinute.TradeDate;
        if (option.HistoryMinute.IsShowName!=null) chart.TitlePaint[0].IsShowName=option.HistoryMinute.IsShowName;  //动态标题是否显示股票名称
        if (option.HistoryMinute.IsShowDate!=null) chart.TitlePaint[0].IsShowDate=option.HistoryMinute.IsShowDate;  //动态标题是否显示日期

        return chart;
    }
    */

    this.CreateKLineTrainChartContainer=function(option)
    {
        var isSimpleTrain=false;
        if (option.Type=="简单K线训练" || option.Type=="简单K线训练横屏")
        {
            var bHScreen=(option.Type=='简单K线训练横屏'? true:false);
            var chart=new KLineTrainSimpleChartContainer(this.CanvasElement,bHScreen);
            isSimpleTrain=true;
        }
        else
        {
            var bHScreen=(option.Type=='K线训练横屏'? true:false);
            var chart=new KLineTrainChartContainer(this.CanvasElement,bHScreen);
        }
       
        if (option.NetworkFilter) chart.NetworkFilter=option.NetworkFilter;
        if (option.IsApiPeriod==true) chart.IsApiPeriod=option.IsApiPeriod;

        //创建改参数div
        chart.ModifyIndexDialog=this.ModifyIndexDialog;
        chart.ChangeIndexDialog=this.ChangeIndexDialog;

        if (option.ScriptError) chart.ScriptErrorCallback=option.ScriptError;

        if (option.KLine)   //k线图的属性设置
        {
            if (option.KLine.Right>=0) chart.Right=option.KLine.Right;
            if (option.KLine.Period>=0) chart.Period=option.KLine.Period;
            if (option.KLine.MaxRequestDataCount>0) chart.MaxRequestDataCount=option.KLine.MaxRequestDataCount;
            if (option.KLine.Info && option.KLine.Info.length>0) chart.SetKLineInfo(option.KLine.Info,false);
            if (option.KLine.PageSize>0)  chart.PageSize=option.KLine.PageSize;
            if (option.KLine.IsShowTooltip==false) chart.IsShowTooltip=false;
            if (option.KLine.MaxRequestMinuteDayCount>0) chart.MaxRequestMinuteDayCount=option.KLine.MaxRequestMinuteDayCount;
            if (option.KLine.DrawType) chart.KLineDrawType=option.KLine.DrawType;
            if (IFrameSplitOperator.IsNumber(option.KLine.RightSpaceCount) && !isSimpleTrain) chart.RightSpaceCount=option.KLine.RightSpaceCount;
        }

        if (option.Train)
        {
            if (option.Train.DataCount) chart.TrainDataCount=option.Train.DataCount;
            if (option.Train.Callback) chart.TrainCallback=option.Train.Callback;
            if (option.Train.StartDate) chart.TrainStartDate=option.Train.StartDate;
        }

        if (!option.Windows || option.Windows.length<=0) return null;

        //创建子窗口
        chart.Create(option.Windows.length);

        this.SetChartBorder(chart, option);

        this.AdjustChartBorder(chart);

        if (option.IsShowCorssCursorInfo==false) chart.ChartCorssCursor.IsShowText=option.IsShowCorssCursorInfo; //取消显示十字光标刻度信息
        if (option.IsCorssOnlyDrawKLine===true) chart.ChartCorssCursor.IsOnlyDrawKLine=option.IsCorssOnlyDrawKLine;
        if (option.CorssCursorTouchEnd===true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;
        if (option.IsClickShowCorssCursor==true) chart.IsClickShowCorssCursor=option.IsClickShowCorssCursor;
        if (option.CorssCursorInfo)
        {
            if (!isNaN(option.CorssCursorInfo.Left)) chart.ChartCorssCursor.ShowTextMode.Left=option.CorssCursorInfo.Left;
            if (!isNaN(option.CorssCursorInfo.Right)) chart.ChartCorssCursor.ShowTextMode.Right=option.CorssCursorInfo.Right;
            if (!isNaN(option.CorssCursorInfo.Bottom)) chart.ChartCorssCursor.ShowTextMode.Bottom=option.CorssCursorInfo.Bottom;
            if (option.CorssCursorInfo.IsShowCorss===false) chart.ChartCorssCursor.IsShowCorss=option.CorssCursorInfo.IsShowCorss;
            if (option.CorssCursorInfo.IsShowClose == true) chart.ChartCorssCursor.IsShowClose = option.CorssCursorInfo.IsShowClose;    //Y轴显示收盘价
            if (option.CorssCursorInfo.PressTime) chart.PressTime=option.CorssCursorInfo.PressTime; //长按显示十字光标的时间
            if (option.CorssCursorInfo.HPenType>0) chart.ChartCorssCursor.HPenType=option.CorssCursorInfo.HPenType;
            if (option.CorssCursorInfo.VPenType>0) chart.ChartCorssCursor.VPenType=option.CorssCursorInfo.VPenType;
        }

        //保存十字光标文字高度
        option.CorssCursor={};
        option.CorssCursor.TitleHeight=chart.ChartCorssCursor.TextHeight;

        if (option.Frame)
        {
            for(var i=0;i<option.Frame.length;++i)
            {
                var item=option.Frame[i];
                if (!chart.Frame.SubFrame[i]) continue;
                if (item.SplitCount) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitCount=item.SplitCount;
                if (item.StringFormat) chart.Frame.SubFrame[i].Frame.YSplitOperator.StringFormat=item.StringFormat;
                if (IFrameSplitOperator.IsNumber(item.FloatPrecision)) chart.Frame.SubFrame[i].Frame.YSplitOperator.FloatPrecision=item.FloatPrecision;
                if (item.Custom) chart.Frame.SubFrame[i].Frame.YSplitOperator.Custom=item.Custom;
                if (IFrameSplitOperator.IsNumber(item.SplitType)) chart.Frame.SubFrame[i].Frame.YSplitOperator.SplitType=item.SplitType;
                if (item.Height>0) chart.Frame.SubFrame[i].Height = item.Height;

                if (item.IsShowLeftText==false) chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowLeftText=item.IsShowLeftText;            //显示左边刻度
                if (item.IsShowRightText==false) chart.Frame.SubFrame[i].Frame.YSplitOperator.IsShowRightText=item.IsShowRightText;         //显示右边刻度 
            }
        }

        if (option.KLine) 
        {
            if (option.KLine.ShowKLine == false) chart.ChartPaint[0].IsShow = false;
            if (option.KLine.InfoPosition>0) chart.ChartPaint[0].InfoPosition=option.KLine.InfoPosition;
            if (option.KLine.IsShowMaxMinPrice == false) chart.ChartPaint[0].IsShowMaxMinPrice=option.KLine.IsShowMaxMinPrice;
        }

        if(option.KLineTitle)    //股票名称 日期 周期
        {
            if(option.KLineTitle.IsShowName==false) chart.TitlePaint[0].IsShowName=false;
            if(option.KLineTitle.IsShowSettingInfo==false) chart.TitlePaint[0].IsShowSettingInfo=false;
            if(option.KLineTitle.IsShow == false) chart.TitlePaint[0].IsShow = false;
        }

        if (IFrameSplitOperator.IsNonEmptyArray(option.Overlay)) //叠加股票
        {
            for(var i=0;i<option.Overlay.length;++i)
            {
                var item=option.Overlay[i];
                chart.OverlaySymbol(item.Symbol,item);
            }
        }

        if (option.ExtendChart)
        {
            for(var i=0;i<option.ExtendChart.length;++i)
            {
                var item=option.ExtendChart[i];
                chart.CreateExtendChart(item.Name, item);
            }
        }

        if (IFrameSplitOperator.IsNonEmptyArray(option.Windows))
        {
            //创建子窗口的指标
            
            for(var i=0;i<option.Windows.length;++i)
            {
                var item=option.Windows[i];
                if (item.Script)
                {
                    chart.WindowIndex[i]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
                }
                else
                {
                    let indexItem=JSIndexMap.Get(item.Index);
                    if (indexItem)
                    {
                        chart.WindowIndex[i]=indexItem.Create();
                        chart.CreateWindowIndex(i);
                    }
                    else
                    {
                        var scriptData = new JSIndexScript();
                        let indexInfo = scriptData.Get(item.Index);
                        if (!indexInfo) continue;

                        if (item.Lock) indexInfo.Lock=item.Lock;
                        chart.WindowIndex[i] = new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
                    }

                }

                if (item.Modify!=null) chart.Frame.SubFrame[i].Frame.ModifyIndex=item.Modify;
                if (item.Change!=null) chart.Frame.SubFrame[i].Frame.ChangeIndex=item.Change;
                if (item.Close!=null) chart.Frame.SubFrame[i].Frame.CloseIndex=item.Close;
                if (item.Overlay!=null) frame.OverlayIndex=item.Overlay;
                if (IFrameSplitOperator.IsBool(item.Export)) frame.ExportData=item.Export;
                if (IFrameSplitOperator.IsBool(item.MaxMin)) chart.Frame.SubFrame[i].Frame.MaxMinWindow=item.MaxMin;
                if (IFrameSplitOperator.IsBool(item.TitleWindow)) chart.Frame.SubFrame[i].Frame.TitleWindow=item.TitleWindow;
                if (IFrameSplitOperator.IsBool(item.IsDrawTitleBG))  chart.Frame.SubFrame[i].Frame.IsDrawTitleBG=item.IsDrawTitleBG;
                if (IFrameSplitOperator.IsBool(item.IsShowNameArrow))  chart.Frame.SubFrame[i].Frame.IsShowNameArrow=item.IsShowNameArrow;

                if (IFrameSplitOperator.IsNumber(item.TitleHeight)) chart.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight=item.TitleHeight;
                if (IFrameSplitOperator.IsBool(item.IsShowTitleArrow)) chart.Frame.SubFrame[i].Frame.IsShowTitleArrow=item.IsShowTitleArrow;
                if (item.IsShowIndexName==false) chart.Frame.SubFrame[i].Frame.IsShowIndexName=false;
                if (item.IsShowOverlayIndexName==false) chart.Frame.SubFrame[i].Frame.IsShowOverlayIndexName=false;
                if (IFrameSplitOperator.IsNumber(item.IndexParamSpace)) chart.Frame.SubFrame[i].Frame.IndexParamSpace=item.IndexParamSpace;
                if (IFrameSplitOperator.IsNumber(item.IndexTitleSpace)) chart.Frame.SubFrame[i].Frame.IndexTitleSpace=item.IndexTitleSpace;
            }
        }

        this.AdjustTitleHeight(chart);
        
        return chart;
    }

    //深度图
    this.CreateDepthChartContainer=function(option)
    {
        var chart=null;
        chart=new DepthChartContainer(this.CanvasElement);
        if (option.NetworkFilter) chart.NetworkFilter=option.NetworkFilter;

        if (option.EnableScrollUpDown==true) chart.EnableScrollUpDown=option.EnableScrollUpDown;
        if (IFrameSplitOperator.IsPlusNumber(option.MaxVolRate)) chart.MaxVolRate=option.MaxVolRate;
        if (option.ZoomStepPixel>0) chart.ZoomStepPixel=option.ZoomStepPixel;
        if (IFrameSplitOperator.IsString(option.SplashTitle)) chart.LoadDataSplashTitle=option.SplashTitle;
        if (IFrameSplitOperator.IsBool(option.EnableVerifyRecvData)) chart.EnableVerifyRecvData=option.EnableVerifyRecvData;

        if (option.Language)
        {
            var value=g_JSChartLocalization.GetLanguageID(option.Language);
            if (IFrameSplitOperator.IsNumber(value)) chart.LanguageID=value;
        }
        
        chart.Create(option.Listener);  

        if (option.Border)
        {
            if (IFrameSplitOperator.IsNumber(option.Border.Left)) chart.Frame.ChartBorder.Left=option.Border.Left;
            else option.Border.Left=chart.Frame.ChartBorder.Left;
            if (IFrameSplitOperator.IsNumber(option.Border.Right)) chart.Frame.ChartBorder.Right=option.Border.Right;
            else option.Border.Right=chart.Frame.ChartBorder.Right;
            if (IFrameSplitOperator.IsNumber(option.Border.Top)) chart.Frame.ChartBorder.Top=option.Border.Top;
            else option.Border.Top=chart.Frame.ChartBorder.Top;
            if (IFrameSplitOperator.IsNumber(option.Border.Bottom)) chart.Frame.ChartBorder.Bottom=option.Border.Bottom;
            else option.Border.Bottom=chart.Frame.ChartBorder.Bottom;
        }

        this.AdjustChartBorder(chart);

        if (option.CorssCursorTouchEnd===true) chart.CorssCursorTouchEnd = option.CorssCursorTouchEnd;

        if (option.CorssCursorInfo)
        {
            var item=option.CorssCursorInfo;
            if (IFrameSplitOperator.IsNumber(item.HPenType)) chart.ChartCorssCursor.HPenType=item.HPenType;
            if (IFrameSplitOperator.IsNumber(item.VPenType)) chart.ChartCorssCursor.VPenType=item.VPenType;
            if (IFrameSplitOperator.IsBool(item.IsShowTooltip)) chart.ChartCorssCursor.IsShowTooltip=item.IsShowTooltip;
        }
        
        if (option.Frame)
        {
            var item=option.Frame
            if (item.SplitCount) chart.Frame.YSplitOperator.SplitCount=item.SplitCount;
            if (IFrameSplitOperator.IsNumber(item.SplitType)) chart.Frame.YSplitOperator.SplitType=item.SplitType;
            if (IFrameSplitOperator.IsNumber(item.Height)) chart.Frame.Height = item.Height;
            if (IFrameSplitOperator.IsNumber(item.YLineType)) chart.Frame.YSplitOperator.LineType=item.YLineType;
            if (IFrameSplitOperator.IsNumber(item.XLineType)) chart.Frame.XSplitOperator.LineType=item.XLineType;
            if (Array.isArray(item.IgnoreYValue)) chart.Frame.YSplitOperator.IgnoreYValue=item.IgnoreYValue;
            if (item.IsShowLeftText===false || item.IsShowLeftText===true) 
            {
                chart.Frame.IsShowYText[0]=item.IsShowLeftText;
                chart.Frame.YSplitOperator.IsShowLeftText=item.IsShowLeftText;            //显示左边刻度
            }
            if (item.IsShowRightText===false || item.IsShowRightText===true) 
            {
                chart.Frame.IsShowYText[1]=item.IsShowRightText;
                chart.Frame.YSplitOperator.IsShowRightText=item.IsShowRightText;          //显示右边刻度
            }

            if (item.IsShowXLine==false) chart.Frame.IsShowXLine=item.IsShowXLine;
            if (item.IsShowYLine==false) chart.Frame.IsShowYLine=item.IsShowYLine;

            if (IFrameSplitOperator.IsNumber(item.XSplitCount)) chart.Frame.XSplitOperator.SplitCount=item.XSplitCount; //X轴刻度个数 半边的
        }

        return chart;
    }

    //根据option内容绘制图形
    this.SetOption=function(option)
    {
        //toolbar按钮风格
        if (IFrameSplitOperator.IsNumber(option.ToolbarButtonStyle)) g_JSChartResource.ToolbarButtonStyle=option.ToolbarButtonStyle;

        var chart=null;
        switch(option.Type)
        {
            case "历史K线图":
            case '历史K线图横屏':
                chart=this.CreateKLineChartContainer(option);
                break;
            case "自定义指数历史K线图":
                chart=this.CreateCustomKLineChartContainer(option);
                break;
            case "分钟走势图":
            case "分钟走势图横屏":
                chart=this.CreateMinuteChartContainer(option);
                break;
            case "迷你分钟走势图":
                chart=this.CreateMinMinuteChartContainer(option);
                break;
            case 'K线训练':
            case 'K线训练横屏':
            case "简单K线训练":
            case "简单K线训练横屏":
                chart=this.CreateKLineTrainChartContainer(option);
                break;
            case "深度图":
                chart=this.CreateDepthChartContainer(option);
                break;
            default:
                return false;
        }

        if (!chart) return false;

        this.JSChartContainer=chart;
        chart.DivElement=this.DivElement;

        if (option.EnableResize==true) this.CreateResizeListener();

        if (option.DefaultCursor) chart.DefaultCursor=option.DefaultCursor;
        if (option.OnCreatedCallback) option.OnCreatedCallback(chart);

        //是否自动更新
        if (option.IsAutoUpdate!=null) chart.IsAutoUpdate=option.IsAutoUpdate;
        if (option.AutoUpdateFrequency>0) chart.AutoUpdateFrequency=option.AutoUpdateFrequency;

        //内置菜单
        if (option.EnablePopMenuV2===true) chart.InitalPopMenu();

        //画图工具
        if (option.EnableDrawToolDialogV2===true) chart.InitalDrawToolDialog();
        if (option.EnableModifyDrawDialogV2===true) chart.InitalModifyDrawDialog();

        //注册事件
        if (option.EventCallback)
        {
            for(var i=0;i<option.EventCallback.length;++i)
            {
                var item=option.EventCallback[i];
                chart.AddEventCallback(item);
            }
        }
        
        //设置股票代码
        if (!option.Symbol) 
        {
            chart.DrawEmpty();
            this.JSChartContainer=chart;
            this.DivElement.JSChart=this;   //div中保存一份
        }
        else
        {
            chart.Draw();
            chart.ChangeSymbol(option.Symbol);
    
            this.JSChartContainer=chart;
            this.DivElement.JSChart=this;   //div中保存一份
            this.JSChartContainer.Draw();
        }
    }

    this.CreateResizeListener=function()
    {
        this.ResizeListener = new ResizeObserver((entries)=>{ this.OnDivResize(entries); });
        this.ResizeListener.observe(this.DivElement);
    }

    this.OnDivResize=function(entries)
    {
        JSConsole.Chart.Log("[JSChart::OnDivResize] entries=", entries);

        this.OnSize( {Type:1} );
    }

    //创建工具条
    this.CreateToolbar=function(option)
    {

    }

    //创建设置div窗口
    this.CreateSettingDiv=function(option)
    {

    }

    this.Focus=function()
    {
        if (this.CanvasElement) this.CanvasElement.focus();
    }

    //切换股票代码接口
    this.ChangeSymbol=function(symbol, option)
    {
        if (this.JSChartContainer) this.JSChartContainer.ChangeSymbol(symbol,option);
    }

    //K线切换指标
    this.ChangeIndex=function(windowIndex,indexName,option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangeIndex)=='function')
            this.JSChartContainer.ChangeIndex(windowIndex,indexName,option);
    }

    this.AddIndexWindow=function(indexName,option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.AddIndexWindow)=='function')
            this.JSChartContainer.AddIndexWindow(indexName,option);
    }

    this.AddScriptIndexWindow=function(indexInfo, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.AddScriptIndexWindow)=='function')
            this.JSChartContainer.AddScriptIndexWindow(indexInfo,option);
    }

    this.AddAPIIndexWindow=function(indexData, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.AddAPIIndexWindow)=='function')
            this.JSChartContainer.AddAPIIndexWindow(indexData,option);
    }

    this.RemoveIndexWindow=function(id)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.RemoveIndexWindow)=='function')
            this.JSChartContainer.RemoveIndexWindow(id);
    }

    this.ChangeScriptIndex=function(windowIndex,indexData,option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangeScriptIndex)=='function')
            this.JSChartContainer.ChangeScriptIndex(windowIndex,indexData,option);
    }

    this.ChangePyScriptIndex=function(windowIndex, indexData)   //切换py指标
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangePyScriptIndex)=='function')
            this.JSChartContainer.ChangePyScriptIndex(windowIndex,indexData);
    }

    this.GetIndexInfo=function()
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.GetIndexInfo)=='function')
            return this.JSChartContainer.GetIndexInfo();
        else 
            return [];
    }

    this.ChangeInstructionIndex=function(indexName, option) 
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangeInstructionIndex)=='function')
            this.JSChartContainer.ChangeInstructionIndex(indexName, option);
    }

    this.ChangeInstructionScriptIndex=function(indexData)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangeInstructionIndex)=='function')
            this.JSChartContainer.ChangeInstructionScriptIndex(indexData);
    }

    this.CancelInstructionIndex=function()
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.CancelInstructionIndex)=='function')
            this.JSChartContainer.CancelInstructionIndex();
    }

    //K线周期切换
    this.ChangePeriod=function(period, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangePeriod)=='function')
            this.JSChartContainer.ChangePeriod(period, option);
    }

    //K线复权切换
    this.ChangeRight=function(right)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangeRight)=='function')
            this.JSChartContainer.ChangeRight(right);
    }

    //叠加股票
    this.OverlaySymbol=function(symbol,option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.OverlaySymbol)=='function')
            this.JSChartContainer.OverlaySymbol(symbol,option);
    }

    //删除一个叠加股票
    this.DeleteOverlaySymbol=function(symbol)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.DeleteOverlaySymbol)=='function')
        this.JSChartContainer.DeleteOverlaySymbol(symbol);
    }

    //设置当前屏的起始日期 { Date:起始日期(必填), Time:起始时间(分钟K线必填) PageSize:一屏显示的数据个数(可选)}
    this.SetFirstShowDate=function(obj)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.SetFirstShowDate)=='function')
            this.JSChartContainer.SetFirstShowDate(obj);
    }

    //K线切换类型 0=实心K线 1=收盘价线 2=美国线 3=空心K线 4=面积图 5=订单流
    this.ChangeKLineDrawType=function(drawType, isDraw, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.ChangeKLineDrawType)=='function')
            this.JSChartContainer.ChangeKLineDrawType(drawType,isDraw, option);
    }
	
	//指标窗口个数
    this.ChangeIndexWindowCount = function(count, option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ChangeIndexWindowCount) == 'function')
        {
            this.JSChartContainer.ChangeIndexWindowCount(count,option);
        }
    }
	
	//取消叠加
    this.ClearOverlaySymbol = function(){
        if(this.JSChartContainer && typeof(this.JSChartContainer.ClearOverlaySymbol) == 'function'){
            this.JSChartContainer.ClearOverlaySymbol();
        } 
    }

    this.DeleteKLineInfo=function(infoName)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.DeleteKLineInfo) == 'function')
        {
            this.JSChartContainer.DeleteKLineInfo(infoName);
        } 
    }
    
    this.ClearKLineInfo=function()
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ClearKLineInfo) == 'function')
        {
            this.JSChartContainer.ClearKLineInfo();
        } 
    }

    this.AddKLineInfo=function(infoName, bUpdate)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.AddKLineInfo) == 'function')
        {
            this.JSChartContainer.AddKLineInfo(infoName,bUpdate);
        } 
    }

    this.AddOverlayIndex=function(obj) //{WindowIndex:窗口ID, IndexName:指标ID, Identify:叠加指标ID(可选), API}
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.AddOverlayIndex)=='function') 
            this.JSChartContainer.AddOverlayIndex(obj);
    }

    this.MoveOverlayIndex=function(src, dest, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.MoveOverlayIndex)=='function') 
            this.JSChartContainer.MoveOverlayIndex(src, dest, option);
    }

    this.MoveOverlayIndexToNewWindow=function(src, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.MoveOverlayIndexToNewWindow)=='function') 
            this.JSChartContainer.MoveOverlayIndexToNewWindow(src, option);
    }

    this.DeleteOverlayWindowsIndex=function(identify)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.DeleteOverlayWindowsIndex)=='function') 
            this.JSChartContainer.DeleteOverlayWindowsIndex(identify);
    }

    this.StopAutoUpdate=function()
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.StopAutoUpdate)=='function') 
            this.JSChartContainer.StopAutoUpdate();
    }

    this.ChartDestroy=function()
    {
        if (this.JSChartContainer && typeof (this.JSChartContainer.ChartDestroy) == 'function') 
        {
            this.JSChartContainer.ChartDestroy();
        }
    }

    this.ChartDestory=this.ChartDestroy;    //版本写错了,继续使用

    //设置深度图数据 depthData=[ {ID:深度图ID, Data:数据},]   option={ Draw: true/false }
    this.SetDepthMapData=function(depthData, option)
    {
        if (this.JSChartContainer && typeof(this.JSChartContainer.SetDepthMapData)=='function') 
            this.JSChartContainer.SetDepthMapData(depthData, option);
    }

    //设置强制横屏
    this.ForceLandscape=function(bForceLandscape)
    {
        if (this.JSChartContainer) 
        {
            JSConsole.Chart.Log("[JSChart::ForceLandscape] bForceLandscape="+bForceLandscape);
            this.JSChartContainer.IsForceLandscape=bForceLandscape;
        }
    }

    //锁指标
    this.LockIndex=function(lockData)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.LockIndex)=='function')
        {
            JSConsole.Chart.Log('[JSChart:LockIndex] lockData', lockData);
            this.JSChartContainer.LockIndex(lockData);
        }
    }

    //历史分钟数据 更改日期
    this.ChangeTradeDate=function(tradeDate)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ChangeTradeDate)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ChangeTradeDate] date', tradeDate);
            this.JSChartContainer.ChangeTradeDate(tradeDate);
        }
    }

    //多日走势图
    this.ChangeDayCount=function(count, option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ChangeDayCount)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ChangeDayCount] count', count);
            this.JSChartContainer.ChangeDayCount(count,option);
        }
    }

    //集合竞价显示/隐藏
    this.ShowCallAuctionData=function(obj, option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ShowCallAuctionData)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ShowCallAuctionData] obj, option ', obj, option);
            this.JSChartContainer.ShowCallAuctionData(obj, option);
        }
    }

    //返回弹幕数据类
    this.StartAnimation=function(option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.StartAnimation)=='function')
        {
            JSConsole.Chart.Log('[JSChart:StartAnimation] start.');
            return this.JSChartContainer.StartAnimation(option);
        }
    }

    this.StopAnimation=function()
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.StopAnimation)=='function')
        {
            JSConsole.Chart.Log('[JSChart:StopAnimation] start.');
            return this.JSChartContainer.StopAnimation();
        }
    }

    this.SaveToImage = function (format,colorGB)    //format=保存的文件格式,  colorGB=背景色
    {
        if (this.JSChartContainer && typeof (this.JSChartContainer.SaveToImage) == 'function')
            return this.JSChartContainer.SaveToImage(format,colorGB);
    }

    this.SaveToImageUrl=function(obj, callback)
    {
        if (this.JSChartContainer && typeof (this.JSChartContainer.SaveToImageUrl) == 'function')
            return this.JSChartContainer.SaveToImageUrl(obj, callback);
    }

    //事件回调
    this.AddEventCallback=function(obj)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.AddEventCallback)=='function')
        {
            JSConsole.Chart.Log('[JSChart:AddEventCallback] ', obj);
            this.JSChartContainer.AddEventCallback(obj);
        }
    }

    //设置语言 'EN', 'CN'
    this.SetLanguage=function(language)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.SetLanguage)=='function')
        {
            JSConsole.Chart.Log('[JSChart:SetLanguage] ', language);
            this.JSChartContainer.SetLanguage(language);
        }
    }

    //切换指标模板
    this.ChangeIndexTemplate=function(option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ChangeIndexTemplate)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ChangeIndexTemplate] ', option);
            this.JSChartContainer.ChangeIndexTemplate(option);
        }
    }

    //画图工具
    this.SetChartDrawOption=function(option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.SetChartDrawOption)=='function')
        {
            JSConsole.Chart.Log('[JSChart:SetChartDrawOption] ', option);
            this.JSChartContainer.SetChartDrawOption(option);
        }
    }

    this.CreateChartDrawPicture=function(name,option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.CreateChartDrawPicture)=='function')
        {
            JSConsole.Chart.Log('[JSChart:CreateChartDrawPicture] ', name);
            this.JSChartContainer.CreateChartDrawPicture(name,option);
        }
    }

    this.AddChartDrawPicture=function(obj)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.AddChartDrawPicture)=='function')
        {
            JSConsole.Chart.Log('[JSChart:AddChartDrawPicture] ', obj);
            return this.JSChartContainer.AddChartDrawPicture(obj);
        } 
    }

    //删除画图工具
    this.ClearChartDrawPicture=function(drawPicture, option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ClearChartDrawPicture)=='function')
        {
            //JSConsole.Chart.Log('[JSChart:ClearChartDrawPicture] ', drawPicture);
            this.JSChartContainer.ClearChartDrawPicture(drawPicture, option);
        }
    }

    //复制一个画图
    this.PasteChartDrawPicture=function(data, frameID, option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.PasteChartDrawPicture)=='function')
        {
            JSConsole.Chart.Log('[JSChart:PasteChartDrawPicture] ', data, frameID, option);
            return this.JSChartContainer.PasteChartDrawPicture(data, frameID, option);
        } 
    }

    //重新加载配置
    this.ReloadResource=function(option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ReloadResource)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ReloadResource] ');
            this.JSChartContainer.ReloadResource(option);
        }
    }

    this.EnableSplashScreen=function(enable, option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.EnableSplashScreen)=='function')
        {
            JSConsole.Chart.Log('[JSChart:EnableSplashScreen] ');
            this.JSChartContainer.EnableSplashScreen(enable, option);
        }
    }

    this.Draw=function()
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.Draw)=='function')
        {
            JSConsole.Chart.Log('[JSChart:Draw] ');
            this.JSChartContainer.Draw();
        }
    }

    this.SetFocus=function()
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.SetFocus)=='function')
        {
            JSConsole.Chart.Log('[JSChart:SetFocus] ');
            this.JSChartContainer.SetFocus();
        }
    }

    //数据导出, option={ Start:{ Date, Time:可选}, End:{Date: Time:可选} }
    this.ExportData=function(option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ExportData)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ExportData] ');
            return this.JSChartContainer.ExportData(option);
        }
    }

    this.ChangePriceGap=function(option)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.ChangePriceGap)=='function')
        {
            JSConsole.Chart.Log('[JSChart:ChangePriceGap] ');
            return this.JSChartContainer.ChangePriceGap(option);
        }
    }

    this.PopupMenuByTab=function(menuData, rtTab)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.PopupMenuByTab)=='function')
        {
            JSConsole.Chart.Log('[JSChart:PopupMenuByTab] ');
            return this.JSChartContainer.PopupMenuByTab(menuData, rtTab);
        }
    }

    this.PopupMenuByDrapdown=function(menuData, rtButton)
    {
        if(this.JSChartContainer && typeof(this.JSChartContainer.PopupMenuByDrapdown)=='function')
        {
            JSConsole.Chart.Log('[JSChart:PopupMenuByDrapdown] ');
            return this.JSChartContainer.PopupMenuByDrapdown(menuData, rtButton);
        }
    }
}

JSChart.LastVersion=null;   //最新的版本号
JSChart.EnableCanvasWillReadFrequently=false;   //https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
JSChart.CorssCursorCanvasKey="hqchart_corsscursor";
JSChart.TooltipCursorCanvasKey="hqchart_tooltip";
JSChart.RectDragCanvasKey="hqchart_drag_rect";

//初始化
JSChart.Init=function(divElement,bScreen,bCacheCanvas)
{
    var jsChartControl=new JSChart(divElement,bScreen,bCacheCanvas);
    jsChartControl.OnSize();

    return jsChartControl;
}

JSChart.SetDomain=function(domain,cacheDomain)
{
    if (domain) g_JSChartResource.Domain=domain;
    if (cacheDomain) g_JSChartResource.CacheDomain=cacheDomain;
}

JSChart.SetPyIndexDomain=function(domain)   //设置py指标计算api域名
{
    if  (domain) g_JSChartResource.PyIndexDomain=domain;
}

//自定义风格
JSChart.SetStyle=function(option)
{
    if (option) g_JSChartResource.SetStyle(option);
}

//value { EN:'', CH:'' }
JSChart.SetTextResource=function(key,value)
{
    g_JSChartLocalization.SetTextResource(key,value);
}

//获取本地化资源
JSChart.GetLocalization=function()  
{
    return g_JSChartLocalization;
}

//获取设备分辨率比
JSChart.GetDevicePixelRatio=function()
{
    return GetDevicePixelRatio();
}

JSChart.CreateGuid=function()
{
    return Guid();
}

JSChart.GetResource=function()  //获取颜色配置 (设置配必须啊在JSChart.Init()之前)
{
    return g_JSChartResource;
}

JSChart.GetMinuteTimeStringData=function()
{
    return g_MinuteTimeStringData;
}

JSChart.GetMinuteCoordinateData=function()
{
    return g_MinuteCoordinateData;
}

JSChart.GetKLineZoom=function() //K线缩放配置
{
    return ZOOM_SEED;
}

JSChart.SetKLineZoom=function(aryZoom)  //设置K线缩放比例
{
    ZOOM_SEED=aryZoom;
}

JSChart.GetDivTooltipDataFormat=function()  //div tooltip数据格式化
{
    return g_DivTooltipDataForamt;
}

JSChart.GetKLineCustomCalulate=function()   //K线额外计算
{
    return g_KLineCustomCalulate;
}

JSChart.SetUSATimeType=function(type)    //设置 0=标准时间 1=夏令时间 3=美国时间
{
    g_NYMEXTimeData.TimeType=type;
    g_COMEXTimeData.TimeType=type;
    g_NYBOTTimeData.TimeType=type;
    g_CBOTTimeData.TimeType=type;
}

JSChart.GetChinaFuturesTimeData=function()  //获取国内期货交易时间配置
{
    return g_FuturesTimeData;
}

JSChart.AddPeriodCallback=function(obj)     //添加自定义周期方法 { Period:周期ID, Callback:回调 }
{
    g_DataPlus.AddPeriodCallback(obj);
}

JSChart.RemovePeriodCallback=function(obj) //添加自定义周期方法 { Period:周期ID, }
{
    g_DataPlus.RemovePeriodCallback(obj);
}

//注册一个新的画图工具 {Name:中文名字, ClassName:类名, Create:function()}
JSChart.RegisterDrawPicture=function(obj)  
{
    return IChartDrawPicture.RegisterDrawPicture(obj);
}

//注册一个新图标 {Name:, Text: , Color:, Family:}
JSChart.RegisterDrawPictureIonFont=function(obj)
{
    return IChartDrawPicture.RegisterIonFont(obj);
}

JSChart.GetInternalTimeData=function(name)  //内置品种交易时间
{
    switch(name)
    {
        case "NYMEXTimeData":
            return g_NYMEXTimeData;
        case "COMEXTimeData":
            return g_COMEXTimeData;
        case "NYBOTTimeData":
            return g_NYBOTTimeData;
        case "CBOTTimeData":
            return g_CBOTTimeData;
        case "LMETimeData":
            return g_LMETimeData;
        case "FuturesTimeData":
            return g_FuturesTimeData;
        case "TOCOMTimeData":   //东京商品交易所（TOCOM
            return g_TOCOMTimeData;
        case "IPETimeData":
            return g_IPETimeData;   //美国洲际交易所
        default:
            return null;
    }
}

//注册外部扩展图形
//option:{ Create:创建类方法 }
JSChart.RegisterExtendChartClass=function(name, option)
{
    return g_ExtendChartPaintFactory.Add(name,option);
}

JSChart.AddExtendCallbackDraw=function(className)
{
    return g_ExtendChartPaintFactory.AddCallbackDrawClassName(className);
}

//注册外部图形类
//option:{ Create:创建类方法 }
JSChart.RegisterChartPaintClass=function(name, option)
{
    return g_ChartPaintFactory.Add(name, option);
}

//注册外部指标图形
JSChart.RegisterScriptIndexChart=function(name, option)
{
    return g_ScriptIndexChartFactory.Add(name, option);
}

//注册设置对话框类
//option:{ Create:创建类方法 }
JSChart.RegisterDialogClass=function(name, option)
{
    return g_DialogFactory.Add(name, option);
}

//注册框架类
JSChart.RegisterChartFrameClass=function(name, option)
{
    return g_ChartFrameFactory.Add(name, option);
}


//一些公共函数
JSChart.ToFixedPoint=function(value)
{
    return ToFixedPoint(value);
}

JSChart.ToFixedPoint2=function(width, value)
{
    return ToFixedPoint2(width, value);
}

JSChart.ToFixedRect=function(value)
{
    return ToFixedRect(value);
}

JSChart.GetScrollPosition=function()
{
    return GetScrollPosition();
}




var JSCHART_EVENT_ID=
{
    RECV_KLINE_MATCH:1, //接收到形态匹配
    RECV_INDEX_DATA:2,  //接收指标数据
    RECV_HISTROY_DATA:3,//接收到历史数据
    RECV_TRAIN_MOVE_STEP:4, //接收K线训练,移动一次K线
    CHART_STATUS:5,          //每次Draw() 以后会调用
    BARRAGE_PLAY_END:6,      //单个弹幕播放完成
    RECV_OVERLAY_INDEX_DATA:7,//接收叠加指标数据
    DBCLICK_KLINE:8,            //双击K线图
    RECV_START_AUTOUPDATE:9,    //开始自动更新
    RECV_STOP_AUTOUPDATE:10,    //停止自动更新
    ON_CONTEXT_MENU:11,         //右键菜单事件
    ON_TITLE_DRAW:12,           //标题信息绘制事件
    ON_SELECT_RECT:13,          //区间选择事件通知
    RECV_MINUTE_DATA:14,        //分时图数据到达
    ON_CLICK_INDEXTITLE:15,     //点击指标标题事件
    RECV_KLINE_UPDATE_DATA:16,   //K线日,分钟更新数据到达
    ON_CLICK_DRAWPICTURE:17,    //点击画图工具 
    ON_FINISH_DRAWPICTURE:18,    //完成画图工具    
    ON_INDEXTITLE_DRAW:19,       //指标标题重绘事件
    ON_CUSTOM_VERTICAL_DRAW:20,  //自定义X轴绘制事件
    RECV_KLINE_MANUAL_UPDATE_DATA:21,   //手动更新K线事件
    ON_ENABLE_SPLASH_DRAW:22,           //开启/关闭过场动画事件

    ON_CLICK_CHART_PAINT:23,            //点击图形

    ON_DRAW_MINUTE_LAST_POINT:24,        //分时图绘制回调事件, 返回最后一个点的坐标
    ON_DRAW_DEPTH_TOOLTIP:25,            //绘制深度图tooltip事件
    ON_CLICK:26,                         //点击事件
    ON_PHONE_TOUCH:27,                   //手势点击事件 包含 TouchStart 和 TouchEnd

    ON_CLICKUP_CHART_PAINT:28,           //点击图形鼠标抬起

    ON_SPLIT_YCOORDINATE:29,             //分割Y轴及格式化刻度文字
    ON_DBCLICK:30,
    ON_SPLIT_XCOORDINATE:31,             //分割X轴及格式化刻度文字

    ON_KEYDOWN_SELECT_RECT:32,           //键盘空格区间选择完成事件
    ON_DRAG_SELECT_RECT:33,              //区间选择区域变动
    ON_DRAG_SELECT_RECT_MOUSEUP:34,      //区间选择区域变动鼠标松开

    ON_DRAW_KLINE_LAST_POINT:35,          //K线图绘制回调事件,返回最后一个点的坐标
    ON_CLICK_CROSSCURSOR_RIGHT:36,        //十字光标右边按钮

    ON_PLAY_SOUND:37,                     //播放声音 { Name:, Data: }

    ON_CALCULATE_INDEX_OX:38,              //创建OX指标回调

    ON_LOAD_DRAWPICTURE:39,                //加载画图工具
    //ON_SAVE_DRAWPICTURE:40               //画图工具存盘
    ON_DRAW_COUNTDOWN:41,                  //倒计时回调
    ON_BIND_DRAWICON:42,                   //小程序用到,h5无效

    ON_DRAW_DEAL_VOL_COLOR:43,              //成交明细 成交量颜色
    ON_DRAW_DEAL_TEXT:44,                   //成交明细 自定义字段
    ON_FILTER_DEAL_DATA:45,                 //成交明细 数据过滤回调

    ON_FILTER_REPORT_DATA:46,               //报价列表 数据过滤回调
    ON_CLICK_REPORT_ROW:47,                 //点击报价列表
    ON_REPORT_MARKET_STATUS:48,             //报价列表交易状态
    ON_DBCLICK_REPORT_ROW:49,               //双击报价列表
    ON_RCLICK_REPORT_ROW:50,                //右键点击列表
    ON_CLICK_REPORT_HEADER:51,              //单击表头
    ON_RCLICK_REPORT_HEADER:52,             //右键点击表头
    ON_REPORT_LOCAL_SORT:53,                //报价列表本地排序
    ON_DRAW_REPORT_NAME_COLOR:54,           //报价列表股票名称列颜色
    ON_DRAW_CUSTOM_TEXT:55,                 //报价列表自定义列
    ON_CLICK_REPORT_TAB:56,                 //报价列表标签点击
    ON_CLICK_REPORT_TABMENU:57,             //报价列表标签菜单点击
    ON_DRAW_REPORT_FIXEDROW_TEXT:58,        //报价列表固定行绘制
    ON_CLICK_REPORT_FIXEDROW:59,            //点击报价列表点击固定行
    ON_RCLICK_REPORT_FIXEDROW:60,           //点击报价列表右键点击固定行

    ON_KEYDOWN_SELECT_RECT_FIRST:61,         //区间选择第1个位置事件

    ON_CLICK_FRAME_TOOLBAR:62,              //指标标题工具栏

    ON_REPORT_DRAG_ROW:63,                  //自选股行拖拽

    ON_MOUSE_MOVE:64,                        //鼠标移动

    ON_MINUTE_PAGE_CHANGED:65,                //分时图翻页事件

    ON_DRAG_SUB_SELECT_RECT:66,              //拖拽区间选择子区域
    ON_DRAG_SUB_SELECT_RECT_MOUSEUP:67,       //拖拽区间选择子区域鼠标松开

    ON_KEYBOARD_SELECTED:68,        //键盘精灵选中回车
    ON_KEYBOARD_MOUSEUP:69,

    ON_CLICK_DRAWPICTURE_BUTTON:70,  //画图工具按钮
    ON_FINISH_MOVE_DRAWPICTURE:71,   //画图工具移动完成

    ON_CLICK_EXTENDCHART_BUTTON:72,  

    ON_SCROLLBAR_SLIDER_CHANGED:73, //滚动条拖动

    ON_DISPLAY_LATEST:74,            //显示最新数据

    ON_FORMAT_CORSSCURSOR_Y_TEXT:75,    //格式化十字光标Y轴文字
    ON_FORMAT_INDEX_OUT_TEXT:76,           //格式化指标标题文字
    ON_FORMAT_CORSSCURSOR_X_TEXT:77,    //格式化十字光标X轴文字

    ON_REPORT_MOUSE_MOVE:78,          //鼠标移动 { x,y, Cell:单元格}
    ON_REPORT_DRAG_HEADER_TOOLTIP:88,   //表头拖动提示信息

    ON_REPORT_DRAW_CUSTOM_ICON:89,      //表格自定义图标
    ON_REPORT_DRAW_KLINE:90,            //表格绘制K线
    ON_DBCLICK_REPORT_DRAG_COLUMN_WIDTH:91,   //双击表头拖动宽度
    ON_REPORT_FORMAT_DRAW_INFO:92,      //单元格输出信息
    ON_FORMAT_INDEX_Y_LABEL:93,          //格式化指标右侧Y轴刻度输出
    ON_FORMAT_OVERLAY_INDEX_Y_LABEL:94,  //格式化叠加指标右侧Y轴刻度输出

    ON_CUSTOM_UNCHANGE_KLINE_COLOR:95,      //定制平盘K线颜色

    ON_CLICK_TITLE_BUTTON:96,            //指标标题按钮

    ON_CUSTOM_LEFT_TOOLBAR:97,
    ON_CUSTOM_RIGHT_TOOLBAR:98,

    ON_REPORT_DRAG_COLUMN_WIDTH:99,     //拖动列宽

    ON_CUSTOM_UNCHANGE_KLINE_TITLE_COLOR:100,   //定制平盘K线标题颜色

    ON_CHANGE_KLINE_PERIOD:101,                 //切换周期

    ON_MINUTE_TOUCH_ZOOM:102,                   //分时图手势缩放 

    ON_RELOAD_INDEX_CHART_RESOURCE:103,         //加载指标图形额外资源
    ON_RELOAD_OVERLAY_INDEX_CHART_RESOURCE:104, //加载叠加指标图形额外资源

    ON_CREATE_FRAME:105,
    ON_DELETE_FRAME:106,
    ON_SIZE_FRAME:107,

    ON_TOUCH_SCROLL_UP_DOWN:108,        //页面上下滚动 手机端

    ON_RECV_REALTIME_DATA:109,          //实时数据

    ON_CUSTOM_OVERLAY_TOOLBAR:110,          //自定义叠加指标按钮

    //绘图之前的事件
    ON_BEFORE_DRAW:111,                 
    ON_BEFORE_DRAW_DYNAMIC_INFO:112,

    //自定义图形拖拽
    ON_CUSTOM_DRAG_MOUSE_DOWN:113,
    ON_CUSTOM_DRAG_DOC_MOUSE_MOVE:114,
    ON_CUSTOM_DRAG_DOC_MOUSE_UP:115,
    ON_CUSTOM_DRAG_MOUSE_MOVE:116,

    ON_KEYDOWN:117,

    ON_CREATE_OVERLAY_FRAME:118,        //创建叠加框架回调

    ON_CREATE_CUSTOM_Y_COORDINATE:119,  //自定义Y轴刻度

    ON_BEFORE_DRAW_SPLASH_SCREEN:120,


    //T型报价
    ON_TREPORT_MARKET_STATUS:121,             //T型报价列表交易状态
    ON_DBCLICK_TREPORT_ROW:122,               //双击T型报报价列表
    ON_RCLICK_TREPORT_ROW:123,                //右键点击T型报价列表
    ON_CLICK_TREPORT_HEADER:124,              //单击T型报价表头
    ON_RCLICK_TREPORT_HEADER:125,             //右键点击T型报价表头
    ON_TREPORT_LOCAL_SORT:126,                //T型报价列表本地排序
    ON_CLICK_TREPORT_ROW:127,                 //左键点击点击T型报价列表

    ON_DRAW_REPORT_ROW_BG:140,              //报价列表整行背景
    ON_CLICK_REPORT_CHECKBOX:141,           //报价列表checkbox
    ON_CLICK_REPORT_BUTTON:142,             //报价列表按钮
    ON_CLICK_REPORT_LINK:143,               //报价列表 链接
    ON_CREATE_REPORT_HEADER_MENU:144,       //报价列表 表头菜单


    ON_CHANGE_INDEX:150,        //切换指标
    ON_MENU_COMMAND:151,        //菜单事件回调
    ON_CREATE_RIGHT_MENU:152,   //创建右键菜单

    ON_FORMAT_CALL_AUCTION_INDEX_TITLE:153, //集合竞价指标窗口标题内容

    ON_FORMAT_KLINE_HIGH_LOW_TITLE:154,     //K线最高最低价格式化内容
    ON_CUSTOM_CORSSCURSOR_POSITION:155,    //自定义十字光标X轴的输出的位置

    ON_CUSTOM_MINUTE_NIGHT_DAY_X_INDEX:156,   //日盘夜盘的分界线
}

var JSCHART_OPERATOR_ID=
{
    OP_SCROLL_LEFT:1,   //往左移动
    OP_SCROLL_RIGHT:2,  //往右移动
    OP_ZOOM_OUT:3,  //缩小
    OP_ZOOM_IN:4,   //放大
    OP_GOTO_HOME:5, //最新一天数据
    OP_GOTO_END:6,  //第1天的数据

    OP_LEFT_ZOOM_OUT:7,   //左边缩小
    OP_LEFT_ZOOM_IN:8,    //左右放大

    OP_RIGHT_ZOOM_OUT:9,  //右边缩小
    OP_RIGHT_ZOOM_IN:10,  //右边放大

    OP_SCROLL_GOTO:11,   //滚动条移动到某一个位置

    OP_SET_SELECTRECT:12,       //区间选择  
    OP_SET_SUB_SELECTRECT:13,    //区间选择子区域

    OP_CORSSCURSOR_GOTO:14,     //十字光标移动某一个时刻点

    OP_SCROOLBAR_SLIDER_CHANGED:15,    //滑块变动

    OP_GOTO:16,     //移动到某一个天或某一个分钟
    OP_GOTO_BY_DATAINDEX:17,   //的移动到某一个数据起始位置
}

var JSCHART_DRAG_ID=
{
    DISABLE_DRAG_ID:0,
    CLICK_TOUCH_MODE_ID:3   //长按十字光标显示保留/点击十字光标消失 (使用TouchStatus)
}

var JSCHART_BUTTON_ID=
{
    CLOSE_BEFOREOPEN_ID:1,  //关闭集合竞价
    CLOSE_OVERLAY_INDEX:2,  //关闭叠加指标
    

    MODIFY_INDEX_PARAM:3,       //改指标参数
    CHANGE_INDEX:4,             //换指标
    CLOSE_INDEX_WINDOW:5,       //关闭指标窗口
    OVERLAY_INDEX:6,            //叠加指标
    MODIFY_OVERLAY_INDEX_PARAM:7,   //改叠加指标参数

    CHIP_DEFULT:8,
    CHIP_LONG:9,
    CHIP_RECENT:10,

    MAX_MIN_WINDOW:11,      //指标窗口最大最小化
    TITLE_WINDOW:12,         //指标窗口只显示标题

    //画图工具
    DRAW_PICTURE_DELETE:13,
    DRAW_PICTURE_SETTING:14,

    EXTEND_CHART_BUTTON_ID:15,  //扩展画法按钮事件

    EXPORT_DATA:16,

    //画图工具 按钮预留18个
    DRAW_PICTURE_BUTTON_1:17,
    DRAW_PICTURE_BUTTON_2:18,
    DRAW_PICTURE_BUTTON_3:19,
    DRAW_PICTURE_BUTTON_4:20,
    DRAW_PICTURE_BUTTON_5:21,
    DRAW_PICTURE_BUTTON_6:22,
    DRAW_PICTURE_BUTTON_7:23,
    DRAW_PICTURE_BUTTON_8:24,
    DRAW_PICTURE_BUTTON_9:25,
    DRAW_PICTURE_BUTTON_10:26,
    DRAW_PICTURE_BUTTON_11:27,
    DRAW_PICTURE_BUTTON_12:28,
    DRAW_PICTURE_BUTTON_13:29,
    DRAW_PICTURE_BUTTON_14:30,
    DRAW_PICTURE_BUTTON_15:31,
    DRAW_PICTURE_BUTTON_16:32,
    DRAW_PICTURE_BUTTON_17:33,
    DRAW_PICTURE_BUTTON_18:34,

    //弹出菜单
    POP_MENU_1:40,
    POP_MENU_2:41,
    POP_MENU_3:42,

    INDEX_NAME_BUTTON:43
}

var JSCHART_DATA_FIELD_ID=
{
    KLINE_ORDERFLOW:99,
    MINUTE_MULTI_DAY_EXTENDDATA:21, //多日分时图扩展数据序号
    MINUTE_DAY_EXTENDDATA:21,
    MINUTE_BEFOREOPEN_EXTENDDATA:21,
    MINUTE_AFTERCLOSE_EXTENDDATA:21,
    KLINE_COLOR_DATA:66,            //K线自定义颜色数据
    KLINE_DAY_EXTENDDATA:25,
    KLINE_MINUTE_EXTENDDATA:25,

    //OrderBook Heatmap
    KLINE_HEATMAP:67,
}

var JSCHART_WORKER_MESSAGE_ID=
{
    EXECUTE_SCRIPT:1,        //工作线程执行脚本
    FINISH_EXECUTE_SCRIPT:2,    //脚本执行完成
    ERROR_EXECUTE_SCRIPT:3,
}

var JSCHART_MENU_ID=
{
    CMD_CHANGE_PERIOD_ID:1,       //切换周期
    CMD_CHANGE_WINDOW_COUNT_ID:2, //窗口个数
    CMD_CHANGE_RIGHT_ID:3,        //复权
    CMD_CHANGE_INDEX_ID:4,          //切换指标
    CMD_CHANGE_COLOR_INDEX_ID:5,    //五彩K线指标
    CMD_CHANGE_TRADE_INDEX_ID:6,    //专家系统(交易指标)
    CMD_DELETE_COLOR_INDEX_ID:7,    //删除五彩K线指标
    CMD_DELETE_TRADE_INDEX_ID:8,    //删除专家系统(交易指标)
    CMD_CHANGE_KLINE_TYPE_ID:9,     //切换K线类型
    CMD_CHANGE_PRICE_GAP_ID:10,     //缺口提示
    CMD_OVERLAY_SYMBOL_ID:11,       //叠加品种
    CMD_DELETE_ALL_OVERLAY_SYMBOL_ID:12,    //删除所有叠加品种
    CMD_CHANGE_COORDINATETYPE_ID:13,    //切换坐标类型
    CMD_CHANGE_KLINE_INFO_ID:14,        //切换信息地雷
    CMD_DELETE_ALL_KLINE_INFO_ID:15,    //清空信息地雷
    CMD_CHANGE_DRAG_MODE_ID:16,         //切换拖动模式
    CMD_CHANGE_BG_SPLIT_ID:17,          //背景分割

    CMD_SHOW_DRAWTOOL_ID:18,    //画图工具
    CMD_HIDE_DRAWTOOL_ID:19,

    CMD_SHOW_STOCKCHIP_ID:20,   //筹码分布
    CMD_HIDE_STOCKCHIP_ID:21,

    CMD_ENABLE_SELECT_RECT_ID:22,   //启动区间选择
    CMD_CHANGE_DAY_COUNT_ID:23,     //切换天数
    CMD_SHOW_BEFORE_DATA_ID:24,     //显示|隐藏集合竞价

    CMD_SELECTED_ZOOM_ID:25,        //选中放大
    CMD_SELECTED_SUMMARY_ID:26,     //区间统计

    CMD_SHOW_INDEX_ID:27,           //显示隐藏指标
    CMD_SHOW_OVERLAY_INDEX_ID:28,   //显示隐藏叠加指标
    CMD_DELETE_OVERLAY_INDEX_ID:29, //删除叠加指标
    CMD_SHOW_OVERLAY_Y_AXIS_ID:30,   //显示隐藏Y轴叠加指标
    CMD_ENABLE_OVERLAY_SHARE_Y_ID:31,   //和主图指标共享Y轴坐标

    CMD_CHANGE_DEFAULTCURSOR_ID:32,     //修改鼠标形状
    CMD_CHANGE_API_INDEX_ID:33,         //切换后台接口指标
    CMD_CHANGE_SCRIPT_INDEX_ID:34,      //切换成自定义的脚本指标

    CMD_CHANGE_BASELINE_ID:35,          //分时图切换基准线
    CMD_ADD_OVERLAY_INDEX_ID:36,        //添加叠加指标

    CMD_CHANGE_LANGUAGE_ID:37,          //语言切换

    CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID:38,

    CMD_SHOW_CORSS_LINE_ID:39,          //显示十字光标线
    CMD_ENABLE_POP_MINUTE_CHART_ID:40,  //双击弹分时图


    CMD_REPORT_CHANGE_BLOCK_ID:60,      //报价列表 切换板块ID
    CMD_REPORT_COLUMN_SORT_ID:61,       //报价列表 表头排序  Arg[列序号, 排序方向]
    CMD_REPORT_COLUMN_DEL_ID:62,        //报价列表 删除列
    CMD_REPORT_COLUMN_MOVE_ID:63,       //报价列表 列移动
    CMD_REPORT_COLUMN_FILTER_ID:64,     //报价列表 筛选
}


function PhoneDBClick()
{
    this.Start=[];

    this.Clear=function()
    {
        this.Start=[];
    }

    this.AddTouchStart=function(x, y, time)
    {
        if (this.Start.length>0)
        {
            var item=this.Start[this.Start.length-1];
            var spanTime=time-item.Time;
            if (spanTime>0 && spanTime<300)
            {
                this.Start.push({ X:x, Y:y, Time:time });
            }
            else
            {
                this.Start=[];
            }
        }
        else
        {
            this.Start.push({ X:x, Y:y, Time:time });
        }
    }

    this.IsVaildDBClick=function()
    {
        if (this.Start.length==2) return true;

        return false;
    }

    this.AddTouchEnd=function(time)
    {
        if (this.Start.length<=0) return;

        var item=this.Start[this.Start.length-1];
        var spanTime=time-item.Time;
        if (spanTime>=0 && spanTime<150)
        {
            
        }
        else
        {
            this.Start=[];
        }
    }
}

/*
    图形控件
*/
function JSChartContainer(uielement, OffscreenElement, cacheElement)
{
    this.ClassName='JSChartContainer';
    var _self = this;
    this.Frame;                                     //框架画法
    this.ChartPaint=new Array();                    //图形画法
    this.ChartPaintEx=[];                           //图形扩展画法
    this.ChartInfo=new Array();                     //K线|走势图上信息地雷
    this.ChartInfoPaint;                            //信息地理
    this.ExtendChartPaint=new Array();              //扩展画法
    this.TitlePaint=new Array();                    //标题画法
    this.OverlayChartPaint=new Array();             //叠加信息画法
    this.ChartDrawPicture=new Array();              //画图工具
    this.ChartDrawStorage;                          //画图工具保存
    this.ChartDrawOption={ IsLockScreen:false, Zoom:1, Magnet:null };   //画图工具设置 { IsLockScreen://是否锁住屏幕, Zoom: //线段|点放大倍数, Magnet:磁吸 {Enable:, Type, Distance,}  }
    this.CurrentChartDrawPicture=null;              //当前的画图工具
    this.SelectChartDrawPicture=null;               //当前选中的画图
    this.MoveOnChartDrawPicture=null;               //鼠标在画图上
    this.EnableEraseChartDrawPicture=false;         //擦除画图
    this.IsDrawPictureXY=false;                     //选中的画图工具是否显示X,Y轴对应数值
    this.EnableShowCorssCursor={ DrawPicture:true };  //DrawPicture=画图是否显示十字光标
    this.ChartPictureMenu;                          //画图工具 单个图形设置菜单
    this.ChartCorssCursor;                          //十字光标
    this.ChartDragSelectRect;                       //选择区间选中
    this.IsClickShowCorssCursor=false;              //手势点击显示十字光标
    this.ChartSplashPaint=null;                     //等待提示
    this.LoadDataSplashTitle="数据加载中";           //下载数据提示信息
    this.DefaultCursor="default"; //crosshair , default  默认手型

    //绘图缓存
    this.CacheCanvas=null;   
    this.CacheElement=null;
    if (cacheElement)
    {
        this.CacheElement=cacheElement;
        this.CacheCanvas=cacheElement.getContext("2d");
    }                   

    if (OffscreenElement) 
    {
        this.Canvas=OffscreenElement.getContext("2d");
        this.OffscreenCanvasElement=OffscreenElement;

        this.ShowCanvas=uielement.getContext("2d");
    }
    else
    {
        if (JSChart.EnableCanvasWillReadFrequently===true)
        {
            let contextAttr={ willReadFrequently:true };
            this.Canvas=uielement.getContext("2d",contextAttr);         //画布
        }
        else
        {
            this.Canvas=uielement.getContext("2d");         //画布
        }
        
        this.ShowCanvas=null;
    }

    //十字光标层
    this.CorssCursorElement;
    this.CorssCursorCanvas;
    
    this.UIElement=uielement;
    this.MouseDrag;
    this.PhoneTouchInfo;    //手机手势信息
    this.DragMode=1;                                //拖拽模式 0 禁止拖拽 1 数据拖拽 2 区间选择 3(CLICK_TOUCH_MODE_ID)=长按十字光标显示保留/点击十字光标消失 (使用TouchStatus)
    this.EnableBorderDrag=true;                     //是否可以拖拽边框调整指标框高度
    this.BorderDrag;    //{ Index:, }
    this.YDrag;         //{Index: }                 //y轴拖拽放大缩小
    this.TouchStatus={ CorssCursorShow:false },     //十字光标是否显示
    this.DragTimer;
    this.EnableScrollUpDown=false;                  //是否可以上下滚动图形(手机端才有)
    this.ClickChartTimer=null;                      //点击图形定时器,解决双击和单击K线事件

    this.CursorIndex=0;             //十字光标X轴索引
    this.LastPoint=new Point();     //鼠标位置
    this.IsForceLandscape=false;    //是否强制横屏
    this.CorssCursorTouchEnd = false;   //手离开屏幕自动隐藏十字光标
    this.IsTitleShowLatestData=false;     //十字/手势不在K线图上,标题显示最新一个数据
    this.StepPixel=4;                   //移动一个数据需要的像素 0=自动模式(根据K线宽度+间距)
    this.ZoomStepPixel=5;               //放大缩小手势需要的最小像素
    this.TouchMoveMinAngle=70;          //左右移动最小角度
    this.EnableAnimation=false;         //是否开启动画

    //tooltip提示信息
    this.Tooltip=document.createElement("div");
    this.Tooltip.className='jschart-tooltip';
    this.Tooltip.style.background=g_JSChartResource.TooltipBGColor;
    this.Tooltip.style.opacity=g_JSChartResource.TooltipAlpha;
    this.Tooltip.style["pointer-events"]="none";
    this.Tooltip.id=Guid();
    uielement.parentNode.appendChild(this.Tooltip);
    this.IsShowTooltip=true;    //是否显示K线tooltip
    this.TooltipCache={ Type:null, IsShow:false, X:null, Y:null, Data:null, InnerHTML:null };  //缓存tooltip数据

    //坐标轴风格方法 double-更加数值型分割  price-更加股票价格分割
    this.FrameSplitData=new Map();
    this.FrameSplitData.set("double",new SplitData());
    this.FrameSplitData.set("price",new PriceSplitData());

    //事件回调
    this.mapEvent=new Map();   //通知外部调用 key:JSCHART_EVENT_ID value:{Callback:回调,}

    this.PhonePinch=null;       //手机双指操作信息
    this.IsOnTouch = false;     //是否再操作数据
    this.TouchDrawCount = 0;    //手势绘制次数
    this.DisableMouse=false;    //禁止鼠标事件
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.PressTime=500;
    this.IsPress=false;         //是否长按

    this.NetworkFilter;         //网络请求回调 function(data, callback);
    this.LastMouseStatus={ MouseOnToolbar:null }; // MouseOnToolbar={ Rect:{}, Title: }
    this.ClickDownPoint;         //鼠标点击坐标 {X, Y}, 鼠标放开以后清空为null
    this.IsDestroy=false;        //是否已经销毁了

    this.EnableYDrag=
    { 
        Left:false, Right:false,    //是否可以拖拽缩放Y轴最大最小值
        Wheel:false, WheelYMove:5  //是否可以滚轴缩放Y轴最大最小值
    };  

    this.EnableZoomIndexWindow=false;               //是否支持双击缩放附图窗口
    this.EnableVerifyRecvData=false;                //是否检测接收到的数据

    this.PhoneDBClick=new PhoneDBClick();

    this.SelectedChart={ EnableSelected:false, EnableMoveOn:false, Selected:{ Identify:null }, MoveOn:{ Identify:null } };   //选中图形
    this.IndexChartDrag;    //拖拽指标图形
    this.EnableIndexChartDrag=false;

    this.GlobalOption=
    { 
        IsValueFullRange:false , 
        IsDisplayLatest:false, 
        SelectedBorder:{ Mode:0, SelFrame:0 },                      //边框选中模式  Mode:0=禁用 1=右侧标记选中 2=指标窗口标记选中
        SelectedXBorder: { Mode:0, Date:null }          //X边框选中模式 Mode:0=禁用 分时图图有效
         //XDateFormat (多日分时图x轴底部日期格式)
    };  

    this.VerticalDrag;              //通过X轴左右拖动数据(手势才有)
    this.EnableVerticalDrag=false;

    //十字光标长留(手势才有)
    this.ClickModel={ IsShowCorssCursor:false };
    this.EnableClickModel=false;

    //标题栏显示最新数据
    this.DisplayLatestOption={ Timer:null, Enable: false, DelayTime:60*1000*3, LastPoint:null };
    this.DrawDynamicInfoOption={ Timer:null, Enable:false , DelayTime:10 };

    this.CustomChartDrag;       //自定义图形的拖拽操作 { Type:, Data: }

    this.StockCache={ Data:null };        //扩展数据缓存数据

    this.JSPopMenu;     //内置菜单
    this.IsShowRightMenu=true;  //显示右键菜单

    this.DialogDrawTool;    //画图工具
    this.DialogModifyDraw;  //画图修改


    this.ClearStockCache=function()
    {
        this.StockCache.Data=null;
    }

    this.InitalPopMenu=function()   //初始化弹出窗口
    {
        if (this.JSPopMenu) return;

        this.JSPopMenu=new JSPopMenu();     //内置菜单
        this.JSPopMenu.Inital();
    }

    this.InitalDrawToolDialog=function()
    {
        if (this.DialogDrawTool) return;

        this.DialogDrawTool=new JSDialogDrawTool();
        this.DialogDrawTool.Inital(this);
        this.DialogDrawTool.Create();
    }

    this.InitalModifyDrawDialog=function()
    {
        if ( this.DialogModifyDraw) return;

        this.DialogModifyDraw=new JSDialogModifyDraw();
        this.DialogModifyDraw.Inital(this);
        this.DialogModifyDraw.Create();
    }

    this.ShowDrawToolDialog=function(x,y)
    {
        if (!this.DialogDrawTool) return;

        var rtClient=this.UIElement.getBoundingClientRect();
        var rtScroll=GetScrollPosition();
        
        var top=this.UIElement.offsetTop+15;
        var left=this.UIElement.offsetWidth-this.DialogDrawTool.DivDialog.offsetWidth-15;
        left+=rtClient.left+rtScroll.Left;
        top+=rtClient.top+rtScroll.Top;
        
        this.DialogDrawTool.Show(left,top);
    }

    this.IsShowDrawToolDialog=function()
    {
        if (!this.DialogDrawTool) return false;

        return  this.DialogDrawTool.IsShow();
    }

    this.ShowModifyDrawDialog=function(chart, x,y)
    {
        if (!this.DialogModifyDraw) return;

        this.DialogModifyDraw.SetChartPicture(chart);
        if (this.DialogModifyDraw.IsShow()) return;

        var rtClient=this.UIElement.getBoundingClientRect();
        var rtScroll=GetScrollPosition();
        
        var top=this.UIElement.offsetTop+15;
        var left=(this.UIElement.offsetWidth-this.DialogModifyDraw.DivDialog.offsetWidth)/2;
        left+=rtClient.left+rtScroll.Left;
        top+=rtClient.top+rtScroll.Top;

        this.DialogModifyDraw.Show(left, top);
    }

    this.CloseModifyDrawDialog=function()
    {
        if (!this.DialogModifyDraw) return;

        this.DialogModifyDraw.Close();
    }

    //obj={ Element:, Canvas: }
    this.SetCorssCursorElement=function(obj)
    {
        if (!obj || !obj.Element || !obj.Canvas) return;

        this.CorssCursorElement=obj.Element;
        this.CorssCursorCanvas=obj.Canvas;
    }

    this.StopDisplayLatest=function()
    {
        this.GlobalOption.IsDisplayLatest=false;

        if (this.DisplayLatestOption.Timer)
        {
            clearTimeout(this.DisplayLatestOption.Timer);
            this.DisplayLatestOption.Timer=null;
        }
    }

    this.StartStopDisplayLatest=function()
    {
        this.StopDisplayLatest();

        if (!this.DisplayLatestOption.Enable) return;

        this.DisplayLatestOption.Timer=setTimeout(()=>
        {
            if (this.DisplayLatest) 
            {
                JSConsole.Chart.Log('[JSChartContainer:StartStopDisplayLatest] call this.DisplayLatest()');
                this.DisplayLatest();
            }
        },this.DisplayLatestOption.DelayTime);
    }

    this.StopDrawDynamicInfo=function()
    {
        if (this.DrawDynamicInfoOption.Timer)
        {
            clearTimeout(this.DrawDynamicInfoOption.Timer);
            this.DrawDynamicInfoOption.Timer=null;
        }
    }

    this.ChartDestroy=function()    //销毁
    {
        this.IsDestroy=true;
        this.StopAutoUpdate();
    }

    this.ChartDestory=this.ChartDestroy;    //老版本写错了,需要兼容下

    //设置焦点
    this.SetFocus=function()
    {
        if (this.UIElement) this.UIElement.focus();
    }

    //设置事件回调
    //{event:事件id, callback:回调函数}
    this.AddEventCallback=function(object)
    {
        if (!object || !object.event || !object.callback) return;

        var data={Callback:object.callback, Source:object};
        this.mapEvent.set(object.event,data);
    }

    this.RemoveEventCallback=function(eventid)
    {
        if (!this.mapEvent.has(eventid)) return;

        this.mapEvent.delete(eventid);
    }

    this.GetEventCallback=function(id)  //获取事件回调
    {
        if (!this.mapEvent.has(id)) return null;
        var item=this.mapEvent.get(id);
        return item;
    }

    //接收指标数据
    this.GetIndexEvent=function()
    {
        return this.GetEventCallback(JSCHART_EVENT_ID.RECV_INDEX_DATA);
    }

    this.GetOverlayIndexEvent=function()
    {
        return this.GetEventCallback(JSCHART_EVENT_ID.RECV_OVERLAY_INDEX_DATA);
    }

    //鼠标事件绑定
    uielement.onmousemove=(e)=>{ this.UIOnMouseMove(e);}
    uielement.oncontextmenu=(e)=> { return this.UIOnContextMenu(e); }
    uielement.ondblclick=(e)=>{ this.UIOnDblClick(e); }
    uielement.onmousedown=(e)=> { this.UIOnMouseDown(e); }
    uielement.onmouseout=(e)=>{ this.UIOnMounseOut(e); }
    uielement.onmouseleave=(e)=>{ this.UIOnMouseleave(e); }

    this.UIOnMouseMove=function(e)
    {
        //JSConsole.Chart.Log('[JSChartContainer.UIOnMouseMove] e.clientX, e.clientY, left, top ',e.clientX, e.clientY, this.getBoundingClientRect().left,this.getBoundingClientRect().top);
        var pixelTatio = GetDevicePixelRatio(); //鼠标移动坐标是原始坐标 需要乘以放大倍速
        var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
        var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;

        this.StopDisplayLatest();

        //加载数据中,禁用鼠标事件
        this.MoveOnChartDrawPicture=null;
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;
        if (this.DisableMouse==true) return;
        if (this.BorderDrag) return;
        if (this.YDrag) return;
        if (this.IndexChartDrag) return;
        if (this.CustomChartDrag) return;
        //if (this.RectSelectDrag) return;

        /*
        if (this.CurrentChartDrawPicture)
        {
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.PointCount<=2) return;
            JSConsole.Chart.Log("[JSChartContainer::UIOnMouseMove] Status", drawPicture.Status);
        }
        */

        //鼠标离开
        if (e && e.type=="mouseout"  && e.buttons==0)
        {
            x=y=-1;
        }

        //保存最后一次鼠标移动信息
        var MoveStatus={ X:x, Y:y, IsInClient: this.IsMouseOnClient(x,y) };
        this.LastMouseStatus.OnMouseMove=MoveStatus;
        this.LastMouseStatus.MoveOnPoint={X:x, Y:y};    //鼠标移动的位置

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MOUSE_MOVE);
        var titleChart=this.TitlePaint[0];
        if (event && titleChart) titleChart.OnMouseMoveEvent=event;
        
        this.MoveOnPoint={X:x, Y:y};
        this.OnMouseMove(x,y,e);
        
        //this.LastMouseStatus.MoveOnPoint=null;
        if (titleChart) titleChart.OnMouseMoveEvent=null;

        this.StartStopDisplayLatest();
    }

    this.IsMouseOnClient=function(x,y)
    {
        var rect={ Left:this.Frame.ChartBorder.GetLeft(), Top:this.Frame.ChartBorder.GetTop(), Width:this.Frame.ChartBorder.GetWidth(), Height:this.Frame.ChartBorder.GetHeight() };
        rect.Right=rect.Left+rect.Width;
        rect.Bottom=rect.Top+rect.Height;

        if (x>=rect.Left && x<=rect.Right && y>=rect.Top && y<=rect.Bottom) return true;

        return false;
    }

    this.UIOnContextMenu=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;
        if (!this.IsShowRightMenu) return;

        var x = e.clientX-this.UIElement.getBoundingClientRect().left;
        var y = e.clientY-this.UIElement.getBoundingClientRect().top;

        if(typeof(this.OnRightMenu)=='function') this.OnRightMenu(x,y,e);   //右键菜单事件

        return false;
    }

    this.UIOnDblClick=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash) return;

        var pixelTatio = GetDevicePixelRatio();
        var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
        var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;
        this.OnDoubleClick(x,y,e);
    }

    //是否在拖拽Y轴上
    this.TryYDrag=function(x,y)
    {
        if (!this.EnableYDrag) return null;
        if (!this.EnableYDrag.Left && !this.EnableYDrag.Right) return null;
        if (!this.Frame || !this.Frame.PtInFrameY) return null;

        var dragY=this.Frame.PtInFrameY(x,y);
        if (!dragY || dragY.Index<0 ) return null;

        if (dragY.IsOverlay===true)
        {
            if (!dragY.Right || !this.EnableYDrag.Right) return null;

            if (this.Frame.IsEnableOverlayDragY(dragY.Index, dragY.OverlayIndex)) return dragY;

            return null;
        }

        if (dragY.Left && this.EnableYDrag.Left && this.Frame.IsEnableDragY(dragY.Index))
        {
            return dragY;
        }

        if (dragY.Right && this.EnableYDrag.Right && this.Frame.IsEnableDragY(dragY.Index))
        {
            return dragY;
        }

        return null;
    }

    //是否可以上下拖拽
    this.TryUpDownDrag=function(x,y)
    {
        var windowIndex=this.Frame.PtInFrame(x,y);
        if (windowIndex<0) return null;

        var item=this.Frame.SubFrame[windowIndex];
        if (!item || !item.Frame) return null;

        var frame=item.Frame;
        if (!frame.YSplitOperator || !frame.YSplitOperator.FixedYMaxMin) return null;

        return { Index:windowIndex, X:x, Y:y };
    }

    this.TryRectSelectDrag=function(x,y)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return null;
        if (paint.GetPointCount()<=0) return null;

        var item=paint.PtInPaint(x,y);

        return { Item:item, X:x, Y:y };
    }

    this.TryClickCrossCursor=function(x,y,e)
    {
        if (!this.ChartCorssCursor) return;

        var button=this.ChartCorssCursor.PtInButton(x,y);
        if (!button) return false;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_CROSSCURSOR_RIGHT);
        if (event && event.Callback)
        {
            var sendData={ Button:button, e };
            event.Callback(event,sendData,this);
        }

        return true;
    }

    this.TryClickButton=function(x, y, e)
    {
        var button=this.Frame.PtInButtons(x,y);
        if (button && this.ClickFrameButton)
        {
            this.ClickFrameButton(button, e);
            return true;
        }

        button=this.PtInExtendChartButtons(x,y);
        if (button && this.ClickExtendChartButton)
        {
            this.ClickExtendChartButton(button, e);
            return true;
        }

        button=this.PtInDrawPictureButtons(x,y);
        if (button && this.ClickDrawPictureButton)
        {
            this.ClickDrawPictureButton(button, e);
            return true;
        }

        button=this.PtInTitleButtons(x,y);
        if (button && this.ClickTitleButton)
        {
            this.ClickTitleButton(button, e);
            return true;
        }

        return false;
    }

    this.TryMouseMove_CustomChartDrag=function(sendData)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_DRAG_MOUSE_MOVE);
        if (!event || !event.Callback) return false;

        return event.Callback(event, sendData, this);
    }

    this.TryClick_CustomChartDrag=function(sendData)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_DRAG_MOUSE_DOWN);
        if (!event || !event.Callback) return false;

        sendData.ChartDrag=null;
        sendData.Cusrsor=null;

        event.Callback(event, sendData, this);
        this.CustomChartDrag=sendData.ChartDrag;

        this.SetCursor(sendData);
    }

    this.TryDragMove_CustomChartDrag=function(sendData)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_DRAG_DOC_MOUSE_MOVE);
        if (!event || !event.Callback) return;

        var e=sendData.e;
        var drag=sendData.Drag;
        if(Math.abs(drag.LastMove.Y-e.clientY)<2 &&  Math.abs(drag.LastMove.X-e.clientX)<2) return;

        if (event.Callback(event, sendData, this))
        {
            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;
        }
    }

    this.TryMouseUp_CustomChartDrag=function(sendData)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_DRAG_DOC_MOUSE_UP);
        if (!event || !event.Callback) return;

        event.Callback(event, sendData, this);
    }

    this.UIOnMouseDown=function(e)
    {
        this.MoveOnChartDrawPicture=null;

        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        this.ClickDownPoint={ X:e.clientX, Y:e.clientY };
        this.IsOnTouch=true;
        this.BorderDrag=null;
        this.YDrag=null;
        this.UpDownDrag=null;
        this.RectSelectDrag=null;
        this.IndexChartDrag=null;
        this.CustomChartDrag=null;  

        var pixelTatio = GetDevicePixelRatio();
        var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
        var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;

        if (this.TryClickButton(x,y,e))
        {
            this.IsOnTouch=false;
            return;
        }

        var bDrawDynamicInfo=false;
        if (this.GlobalOption.SelectedBorder && this.GlobalOption.SelectedBorder.Mode>=1)
        {
            var item=this.GlobalOption.SelectedBorder;
            var frameId=this.Frame.PtInFrame(x,y);
            if (frameId>=0 && frameId!=item.SelFrame) 
            {
                item.SelFrame=frameId;
                bDrawDynamicInfo=true;
            }
        }

        var bRedraw=false;
        if (this.GlobalOption.SelectedXBorder && this.GlobalOption.SelectedXBorder.Mode>=1)
        {
            if (this.PtInMulitDayMinute)
            {
                var item=this.GlobalOption.SelectedXBorder;
                var selectedDate=this.PtInMulitDayMinute(x,y);
                if (item.Date!=selectedDate)
                {
                    item.Date=selectedDate
                    bRedraw=true;
                }
            }
        }

        if (this.TryClickCrossCursor(x,y, e))
        {
            this.IsOnTouch=false;
            return;
        }

        if (this.TryClickChartTooltipData && this.TryClickChartTooltipData(x,y,e))  //预留给外部点击图标什么用的
        {
            this.IsOnTouch=false;
            return;
        }

        if (this.TryClickLock)
        {
            //JSConsole.Chart.Log('[uielement.onmousedown] left, top ',e.clientX, e.clientY, this.getBoundingClientRect().left,this.getBoundingClientRect().top);
            if (this.TryClickLock(x,y)) return;
        }

        this.HideSelectRect();
        this.ClearDragSelectRect();
        if (this.ChartPictureMenu) this.ChartPictureMenu.Hide();

        var paint=this.GetRectSelectPaint();
        if (paint && paint.GetPointCount()>0)
        {
            var item=paint.PtInPaint(x,y);
            if (item)
            {
                if (item.Type==4) 
                {
                    //this.UIElement.style.cursor="pointer";
                    this.SetCursor({Cursor:"pointer"});
                    var obj={ X:e.clientX };
                    if (this.GetXDataIndex(obj))
                    {
                        this.RectSelectDrag={ DataIndex:obj.DataIndex, Type:item.Type, X:e.clientX };
                        JSConsole.Chart.Log("[JSChartContainer::UIOnMouseDown] drag sub rect select ", obj);
                    }
                }
                else 
                {
                    //this.UIElement.style.cursor="ew-resize";
                    this.SetCursor({Cursor:"ew-resize"});
                    this.RectSelectDrag={ Index:item.PointIndex, Type:item.Type };
                    JSConsole.Chart.Log("[JSChartContainer::UIOnMouseDown] drag rect select ",item);
                }
            }
        }
        
        if (!this.RectSelectDrag && this.ClearRectSelect(false)) this.Draw();

        if (this.EnableBorderDrag && this.Frame)
        {
            var dragBorder=this.Frame.PtInFrameBorder(x,y);
            if (dragBorder && dragBorder.Index>=0)
            {
                //this.UIElement.style.cursor="n-resize";
                this.SetCursor({Cursor:"n-resize"});
                this.BorderDrag={ Index:dragBorder.Index };
                JSConsole.Chart.Log("[JSChartContainer::UIOnMouseDown] DragBorder ",dragBorder);
            }
        }

        //拖拽Y轴缩放
        if (!this.BorderDrag)
        {
            var dragY=this.TryYDrag(x,y);
            if (dragY)
            {
                //this.UIElement.style.cursor=dragY.Position==0 ? "n-resize":"row-resize";
                var cursor=dragY.Position==0 ? "n-resize":"row-resize";
                this.SetCursor({Cursor:cursor});
                this.YDrag=dragY;
                JSConsole.Chart.Log("[JSChartContainer::UIOnMouseDown] dragY ",dragY);
            }
            else
            {
                var dragUpDown=this.TryUpDownDrag(x,y);
                if (dragUpDown)
                {
                    //this.UIElement.style.cursor="pointer";
                    this.SetCursor({Cursor:"pointer"});
                    this.UpDownDrag=dragUpDown;
                    JSConsole.Chart.Log("[JSChartContainer::UIOnMouseDown] dragUpDown ",dragUpDown);
                }
            }
        }

        var sendData={ X:x, Y:y, e:e };
        if (this.TryClick_CustomChartDrag(sendData))
        {

        }

        if(this.DragMode==0) return;

        var drag=
        {
            "Click":{},
            "LastMove":{},  //最后移动的位置
            CurrentMove:{},     //当前的移动
        };

        drag.Click.X=e.clientX;
        drag.Click.Y=e.clientY;
        drag.Click.IsInFrameBottom=this.Frame.PtInFrameBottom(x,y);   //是否点击在X轴上
        drag.LastMove.X=e.clientX;
        drag.LastMove.Y=e.clientY;

        this.MouseDrag=drag;
        var drawPictureActive=this.GetActiveDrawPicture();  //上一次选中的
        var selectedChart={ Chart:this.SelectedChart.Selected.Chart, Identify:this.SelectedChart.Selected.Identify };   //上一次选中的图形
        this.SelectChartDrawPicture=null;

        if (this.BorderDrag)
        {

        }
        else if (this.YDrag  || this.RectSelectDrag || this.CustomChartDrag)
        {

        }
        else if (this.CurrentChartDrawPicture)  //画图工具模式
        {
            this.UpDownDrag=null;   //画图优先
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.Status==2)
                this.SetChartDrawPictureThirdPoint(drag.Click.X,drag.Click.Y);
            else
            {
                this.SetChartDrawPictureFirstPoint(drag.Click.X,drag.Click.Y);
                //只有1个点 直接完成
                if (this.FinishChartDrawPicturePoint()) 
                {
                    if (drawPicture.IsDrawMain) this.Draw();
                    else this.DrawDynamicInfo();
                }
            }

            if (drawPictureActive.Select.Guid && ( !this.CurrentChartDrawPicture ||drawPictureActive.Select.Guid!=this.CurrentChartDrawPicture.Guid))
            {
                if (drawPictureActive.Select.Chart.IsDrawMain) this.Draw();
            }
        }
        else    //是否在画图工具上
        {
            var drawPictrueData={};
            drawPictrueData.X=(e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
            drawPictrueData.Y=(e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;
            if (this.GetChartDrawPictureByPoint(drawPictrueData))
            {
                if (this.EnableEraseChartDrawPicture)   //擦掉画线
                {
                    this.CurrentChartDrawPicture=null;
                    this.SelectChartDrawPicture=null;
                    this.ClearChartDrawPicture(drawPictrueData.ChartDrawPicture);
                }
                else if (drawPictrueData.ChartDrawPicture.EnableMove==true)
                {
                    this.UpDownDrag=null;   //画图优先
                    this.CurrentChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    this.SelectChartDrawPicture=drawPictrueData.ChartDrawPicture;
                   
                    //当前已有选中的，需要刷下
                    var bDraw=false;
                    if (drawPictureActive.Select.Guid && drawPictureActive.Select.Chart && drawPictureActive.Select.Chart.IsDrawMain) bDraw=true;   
                    else if (drawPictrueData.ChartDrawPicture.IsDrawMain) bDraw=true;

                    if (bDraw) this.Draw();

                    drawPictrueData.ChartDrawPicture.Status=20;
                    drawPictrueData.ChartDrawPicture.ValueToPoint();
                    drawPictrueData.ChartDrawPicture.MovePointIndex=drawPictrueData.PointIndex;
                    //this.CurrentChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    //this.SelectChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    this.SelectChartDrawPicture.DragInfo={Click:{X:e.clientX,Y:e.clientY}};
                }
                else
                {
                    this.CurrentChartDrawPicture=null;
                    this.SelectChartDrawPicture=null;
                }
               
                var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_DRAWPICTURE); //选中画图工具事件
                if (event && event.Callback)
                {
                    var sendData={ DrawPicture: drawPictrueData.ChartDrawPicture };
                    event.Callback(event,sendData,this);
                }
                else
                {
                    this.OnSelectChartPicture(drawPictrueData.ChartDrawPicture);    //选中画图工具事件
                }
            }
            else
            {
                if (this.ClickChartTimer!=null)
                {
                    clearTimeout(this.ClickChartTimer);
                    this.ClickChartTimer=null;
                }
                
                var self=this;
                var ptClick={ X:this.ClickDownPoint.X, Y:this.ClickDownPoint.Y };
                this.ClickChartTimer = setTimeout(function() 
                {
                    self.TryClickPaintEvent(JSCHART_EVENT_ID.ON_CLICK_CHART_PAINT,ptClick,e);
                }, 250);

                var bSelectedChartChanged=false;
                if (this.SelectedChart.EnableSelected)
                {
                    var selectChart=this.PtInChart(x,y);
                    if (selectChart)
                    {
                        if (this.SelectedChart.Selected.Identify!=selectChart.Identify) 
                        {
                            this.SelectedChart.Selected.Identify=selectChart.Identify;
                            this.SelectedChart.Selected.Chart=selectChart.Chart;
                            bSelectedChartChanged=true;
                        }

                        if (this.EnableIndexChartDrag)
                        {
                            this.IndexChartDrag={ SelectedChart:selectChart, LastMove:{X:x, Y:y}, Click:{X:x, Y:y } };
                            this.IndexChartDrag.Info=this.GetSelectedChartInfo(selectChart);
                            if (this.IndexChartDrag.Info) this.IndexChartDrag.Info.FrameID=this.Frame.PtInFrame(x,y);
                        }
                    }
                    else
                    {
                        if (this.SelectedChart.Selected.Identify)
                        {
                            this.SelectedChart.Selected.Identify=null;
                            this.SelectedChart.Selected.Chart=null;
                            bSelectedChartChanged=true;
                        }
                    }
                }
                else
                {
                    if (this.SelectedChart.Selected.Identify)
                    {
                        this.SelectedChart.Selected.Identify=null;
                        bSelectedChartChanged=true;
                    }
                }
                
                if ((drawPictureActive.Select.Guid!=null && this.SelectChartDrawPicture==null) || bSelectedChartChanged)
                {
                    var drawType=0;
                    if (drawPictureActive.Select.Guid && drawPictureActive.Select.Chart && drawPictureActive.Select.Chart.IsDrawMain)
                        drawType=1;
                        
                    if (bSelectedChartChanged)
                    {
                        var chart=selectedChart.Chart;
                        if (chart && chart.SetSelectedStatus)
                        {
                            chart.SetSelectedStatus(0);
                            drawType=1;
                        }

                        chart=this.SelectedChart.Selected.Chart;
                        if (chart &&chart.SetSelectedStatus)
                        {
                            chart.SetSelectedStatus(1);
                            drawType=1;
                        }
                    }
                    
                    
                    if (drawType==1) 
                        this.Draw();
                    else  
                        this.DrawDynamicInfo();
                }
                else if (bRedraw)
                {
                    this.Draw();
                }
                else if (bDrawDynamicInfo)
                {
                    this.DrawDynamicInfo();
                }
                    
            }
        }


        if (!this.SelectChartDrawPicture) this.CloseModifyDrawDialog(); //当前没有选中画图 隐藏画图修改框

        document.onmousemove=(e)=>{ this.DocOnMouseMove(e); }
        document.onmouseup=(e)=> { this.DocOnMouseUp(e); }


    }

    this.DocOnMouseMove=function(e)
    {
        //加载数据中,禁用鼠标事件
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash) return;
        
        var drag=this.MouseDrag;
        if (!drag) return;

        var moveSetp=Math.abs(drag.LastMove.X-e.clientX);
        var moveSetpY=Math.abs(drag.LastMove.Y-e.clientY);
        var isDragSelectRect=(this.RectSelectDrag && this.RectSelectDrag.Index>=0);
        var isDragSubSelectRect=(this.RectSelectDrag && this.RectSelectDrag.Type==4);
        if (drag.CurrentMove) 
        {
            drag.CurrentMove.X=e.clientX;
            drag.CurrentMove.Y=e.clientY;
        }

        if (this.BorderDrag && this.BorderDrag.Index>=0)    //边框拖动
        {
            if(Math.abs(drag.LastMove.Y-e.clientY)<5) return;

            var yMove=e.clientY-drag.LastMove.Y;

            this.OnMoveFromeBorder(this.BorderDrag.Index, yMove);

            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;
        }
        else if (this.YDrag && this.YDrag.Index>=0) //Y轴缩放
        {
            if(moveSetpY<5) return;

            var yMove=e.clientY-drag.LastMove.Y;

            //this.UIElement.style.cursor="n-resize";

            JSConsole.Chart.Log("[JSChartContainer::DocOnMouseMove] YDrag ",this.YDrag,yMove);
            this.OnZoomUpDownFrameY(this.YDrag, yMove);

            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;
        }
        else if (this.IndexChartDrag && this.IndexChartDrag.SelectedChart)
        {
            if(Math.abs(drag.LastMove.Y-e.clientY)<2 &&  Math.abs(drag.LastMove.X-e.clientX)<2) return;

            var chartMove=this.GetExtendChartByClassName("DragMovePaint");
            if (chartMove && chartMove.Chart)
            {
                var pixelTatio = GetDevicePixelRatio();
                var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
                var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;
                chartMove.Chart.Point={X:x, Y:y};
                chartMove.Chart.IsShow=true;
                chartMove.Chart.Info=this.IndexChartDrag.Info;
                this.DrawDynamicInfo();
            }
            
            this.IndexChartDrag.LastMove.X=x;
            this.IndexChartDrag.LastMove.Y=y;

            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;
        }
        else if (this.CustomChartDrag)
        {
            var pixelTatio = GetDevicePixelRatio();
            var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
            var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;
            var sendData={X:x, Y:y, e:e, ChartDrag:this.CustomChartDrag, Drag:drag };
            this.TryDragMove_CustomChartDrag(sendData);
        }
        else if (this.CurrentChartDrawPicture)
        {
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.Status==1 || drawPicture.Status==2)
            {
                if(Math.abs(drag.LastMove.X-e.clientX)<5 && Math.abs(drag.LastMove.Y-e.clientY)<5) return;
                if(this.SetChartDrawPictureSecondPoint(e.clientX,e.clientY))
                {
                    this.DrawDynamicInfo();
                }
            }
            else if (drawPicture.Status==3)
            {
                if(this.SetChartDrawPictureThirdPoint(e.clientX,e.clientY))
                {
                    this.DrawDynamicInfo();
                }
            }
            else if (drawPicture.Status==20)    //画图工具移动
            {
                if(Math.abs(drag.LastMove.X-e.clientX)<5 && Math.abs(drag.LastMove.Y-e.clientY)<1) return;

                if (this.SelectChartDrawPicture)
                {
                    if (this.SelectChartDrawPicture.EnableCtrlMove)
                    {
                        if (!e.ctrlKey) return;
                    }
                }

                if (this.SelectChartDrawPicture && this.SelectChartDrawPicture.DragInfo)
                    this.SelectChartDrawPicture.DragInfo.Move={X:e.clientX, Y:e.client};

                if(this.MoveChartDrawPicture(e.clientX-drag.LastMove.X,e.clientY-drag.LastMove.Y,false,drag))
                {
                    this.DrawDynamicInfo();
                }
            }

            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;
        }
        else if (this.DragMode==1 || isDragSelectRect || isDragSubSelectRect)  //数据上下左右拖拽
        {
            this.OnDragMode_One({X:moveSetp, Y:moveSetpY}, e);
        }
        else if (this.DragMode==2) //区间选择
        {
            var yMoveSetp=Math.abs(drag.LastMove.Y-e.clientY);

            if (moveSetp<5 && yMoveSetp<5) return;

            this.SetCursor({Cursor:"default"});
            var ptStart=this.PointAbsoluteToRelative(drag.Click.X, drag.Click.Y);
            var ptEnd=this.PointAbsoluteToRelative(e.clientX, e.clientY);

            this.ShowDragSelectRect(ptStart, ptEnd);

            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;

        }
    }

    this.OnDragMode_One=function(moveData, e)
    {
        var moveSetp=moveData.X;
        var moveSetpY=moveData.Y;
        var drag=this.MouseDrag;

        if (moveSetp<5 && moveSetpY<5) return;

        var bNeedDraw=false;
        var bUpDownY=false;
        if (moveSetpY>=5)
        {
            if (this.UpDownDrag && this.UpDownDrag.Index>=0)
            {
                var yMove=e.clientY-drag.LastMove.Y;
                JSConsole.Chart.Log("[JSChartContainer::OnDragMode_One] UpDownDrag ",this.UpDownDrag,yMove);
                //this.UIElement.style.cursor="pointer";
                this.SetCursor({Cursor:"pointer"});
                if (this.OnUpDonwFrameY(this.UpDownDrag, yMove)) 
                {
                    bNeedDraw=true;
                    bUpDownY=true;
                }
                drag.LastMove.Y=e.clientY;
            }
        }

        if (moveSetp>=5)
        {
            if (this.RectSelectDrag)
            {
                if (this.RectSelectDrag.Index>=0)
                {
                    var obj={ X:e.clientX, Y:e.clientY, PointIndex:this.RectSelectDrag.Index, Name:"MoveRectSelectLine" };
                    if (this.MoveRectSelectPoint(obj)) bNeedDraw=true;
                }
                else if (this.RectSelectDrag.Type===4)
                {
                    var obj={ X:e.clientX };
                    if (!this.GetXDataIndex(obj)) return;
                    if (obj.DataIndex==this.RectSelectDrag.DataIndex) return;

                    var step=obj.DataIndex-this.RectSelectDrag.DataIndex;
                    var isLeft=true;
                    if (step>0) isLeft=false;

                    if (!this.MoveSubRectSelect({ Step:Math.abs(step), IsLeft:isLeft, X:e.clientX, Y:e.clientY })) return;

                    this.RectSelectDrag.DataIndex=obj.DataIndex;
                    this.RectSelectDrag.X=e.clientX;

                    bNeedDraw=true;
                }
            }
            else
            {
                var isLeft=true;
                if (drag.LastMove.X<e.clientX) isLeft=false;//右移数据

                var cursorStatus="pointer";
                if (drag.Click.IsInFrameBottom)  cursorStatus="ew-resize";
                var oneStepWidth=this.GetMoveOneStepWidth();
                if (moveSetp<oneStepWidth)
                {
                    //this.UIElement.style.cursor=cursorStatus;
                    this.SetCursor({Cursor:cursorStatus});
                    if (bNeedDraw) this.Draw();
                    return;
                }
                else
                {
                    if (drag.Click && drag.Click.IsInFrameBottom)
                    {
                       
                        if (this.XCoordinateZoom(moveSetp,isLeft))
                        {
                            this.UpdataDataoffset();
                            this.UpdateFrameMaxMin();
                            this.ResetFrameXYSplit();
                            bNeedDraw=true;
                        }
                    }
                    else if(this.DataMove(moveSetp,isLeft))
                    {
                        this.UpdataDataoffset();
                        //this.UpdatePointByCursorIndex(); //推拽数据的时候不需要把鼠标位置更新到K线上
                        this.UpdateFrameMaxMin();
                        this.ResetFrameXYSplit();
                        bNeedDraw=true;
                    }
                    else if (!bUpDownY)
                    {
                        if (this.DragDownloadData) 
                        {
                            this.DragDownloadData();
                            if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash) return;
                        }
                    }
                }
                //this.UIElement.style.cursor=cursorStatus;
                this.SetCursor({Cursor:cursorStatus});
            }
            drag.LastMove.X=e.clientX;
        }

        if (bNeedDraw) 
        {
            this.Draw();
            this.OnKLinePageChange("datamove");
        }
    }

    this.GetXDataIndex=function(obj)
    {
        if (!this.ChartPaint[0] || !this.ChartPaint[0].Data) return false;
        var kData=this.ChartPaint[0].Data;

        if (!this.Frame.SubFrame[0]) return false;
        var subFrame=this.Frame.SubFrame[0].Frame;
        if (!subFrame) false;

        var pixelTatio = GetDevicePixelRatio();
        var x=(obj.X-uielement.getBoundingClientRect().left)*pixelTatio;
        var index=subFrame.GetXData(x);
        index=parseInt(index.toFixed(0));
        var dataIndex=index+kData.DataOffset;
        if (dataIndex>=kData.Data.length) dataIndex=kData.Data.length-1;

        var item = kData.Data[dataIndex];
        obj.DataIndex=dataIndex;
        obj.Item=item;

        //JSConsole.Chart.Log("[JSChartContainer::GetXDataIndex] point, item", obj.PointIndex, item);

        return true;
    }

    this.DocOnMouseUp=function(e)
    {
        //清空事件
        document.onmousemove=null;
        document.onmouseup=null;
        var IsMinuteChart=(this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer") ? true:false;
        var isDragSelectRect=(this.RectSelectDrag && this.RectSelectDrag.Index>=0);
        var isDragSubSelectRect=(this.RectSelectDrag && this.RectSelectDrag.Type==4);
        var bClearDrawPicture=true;
        if (this.CurrentChartDrawPicture)
        {
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.Status==2 || drawPicture.Status==1 || drawPicture.Status==3)
            {
                drawPicture.PointStatus=drawPicture.Status;
                if (this.FinishChartDrawPicturePoint())
                    this.DrawDynamicInfo();
                else
                    bClearDrawPicture=false;
            }
            else if (drawPicture.Status==20)
            {
                if (this.FinishMoveChartDrawPicture())
                    this.DrawDynamicInfo();
            }
        }
        else if (this.IndexChartDrag && this.IndexChartDrag.SelectedChart)
        {
            var chartMove=this.GetExtendChartByClassName("DragMovePaint");
            if (chartMove && chartMove.Chart) chartMove.Chart.Clear();
            if (!this.OnDragChart(this.IndexChartDrag)) this.DrawDynamicInfo();
            //this.UIElement.style.cursor="default";
            this.SetCursor({Cursor:"default"});
        }
        else if (this.CustomChartDrag)
        {
            var sendData={ e:e, ChartDrag:this.CustomChartDrag, Drag:this.MouseDrag };
            this.TryMouseUp_CustomChartDrag(sendData);
        }
        else if (isDragSelectRect)  //区间选择拖动范围
        {
            if (this.OnDragSelectRectMouseUp) this.OnDragSelectRectMouseUp(e);
        }
        else if (isDragSubSelectRect)
        {
            if (this.OnDragSubSelectRectMouseUp) this.OnDragSubSelectRectMouseUp(e);
        }
        else if (IsMinuteChart)
        {
            if (this.OnMinuteSelectRectMouseUp) this.OnMinuteSelectRectMouseUp(e);
        }
        else if (this.DragMode==2)  //区间选择
        {
            var drag=this.MouseDrag;
            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;

            var selectData=new SelectRectData();
            var pixelTatio = GetDevicePixelRatio();
            //区间起始位置 结束位子
            selectData.XStart=(drag.Click.X-uielement.getBoundingClientRect().left)*pixelTatio;
            selectData.YStart=(drag.Click.Y-uielement.getBoundingClientRect().top)*pixelTatio;
            selectData.XEnd=(drag.LastMove.X-uielement.getBoundingClientRect().left)*pixelTatio;
            selectData.YEnd=(drag.LastMove.Y-uielement.getBoundingClientRect().top)*pixelTatio;
            selectData.JSChartContainer=this;
            selectData.Stock={Symbol:this.Symbol, Name:this.Name};

            if (this.ChartDragSelectRect.Enable && !this.BorderDrag && this.GetSelectRectData(selectData))
            {
                var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SELECT_RECT);
                var paint=this.GetRectSelectPaint();
                var isShowMenu=true;
                if (event && event.Callback)
                {
                    var data=
                    { 
                        X:drag.LastMove.X-uielement.getBoundingClientRect().left,
                        Y:drag.LastMove.Y-uielement.getBoundingClientRect().top,
                        SelectData:selectData,    //区间选择的数据
                        RectSelectPaint:paint,    //区间选择背景
                        IsShowMenu:true,
                        e,e
                    };
                    event.Callback(event,data,this);
                    isShowMenu=data.IsShowMenu;
                }

                if (IsMinuteChart)  //分时图直接显示显示区间选择
                {
                    this.HideSelectRect();
                    this.UpdateSelectRect(selectData.Start,selectData.End);
                }
                else
                {
                    if (isShowMenu)
                    {
                        var data=
                        { 
                            Chart:this,
                            X:drag.LastMove.X-uielement.getBoundingClientRect().left,
                            Y:drag.LastMove.Y-uielement.getBoundingClientRect().top,
                            SelectData:selectData,          //区间选择的数据
                            RectSelectPaint:paint           //区间选择背景
                        };

                        e.data=data;
                        this.PopupSelectRectMenuV2(data, e);
                    }
                }
            }
            else
            {
                this.TryClickPaintEvent(JSCHART_EVENT_ID.ON_CLICKUP_CHART_PAINT,this.ClickDownPoint,e);
            }
        }
        else
        {
            this.TryClickPaintEvent(JSCHART_EVENT_ID.ON_CLICKUP_CHART_PAINT,this.ClickDownPoint,e);
            this.ClickEvent(e);
        }

        //清空数据
        JSConsole.Chart.Log('[KLineChartContainer::document.onmouseup]',e);
        if (this.SelectChartDrawPicture) this.SelectChartDrawPicture.DragInfo=null;
        //this.UIElement.style.cursor="default";
        this.SetCursor({Cursor:"default"});
        this.MouseDrag=null;
        this.ClickDownPoint=null;
        this.IsOnTouch=false;
        if (this.EnableEraseChartDrawPicture==true) 
        {
            this.EnableEraseChartDrawPicture=false;
            //更改画图工具对话框橡皮状态
            if (this.DialogDrawTool && this.DialogDrawTool.SetEraseChartButtonStatus) this.DialogDrawTool.SetEraseChartButtonStatus(false);
        }
        
        if (this.BorderDrag && this.BorderDrag.Index>=0) this.Frame.SaveSubFrameHeightRate();   //拖拽指标窗口高度以后保存
        this.BorderDrag=null;
        this.YDrag=null;
        this.UpDownDrag=null;
        this.RectSelectDrag=null;
        this.IndexChartDrag=null;
        this.CustomChartDrag=null;
        if (bClearDrawPicture===true) this.CurrentChartDrawPicture=null;
    }

    this.UIOnMounseOut=function(e)
    {
        JSConsole.Chart.Log('[KLineChartContainer::UIOnMounseOut]',e);
        this.UIOnMouseMove(e);
    }

    this.UIOnMouseleave=function(e)
    {
        JSConsole.Chart.Log('[KLineChartContainer::UIOnMouseleave]',e);
        //this.UIOnMouseMove(e);
    }


    this.OnDragChart=function(drag)
    {
        if (!drag) return false;
        var info=drag.Info;
        var lastMove=drag.LastMove;
        var startFrameID=info.FrameID;
        var endFrameID=this.Frame.PtInFrame(lastMove.X,lastMove.Y);
        if (endFrameID<0) 
        {
            if (endFrameID==-3) //底部 移动到新的窗口
                return this.MoveIndexToNewWindow({ WindowIndex:startFrameID, IndexID:info.IndexID }, { Operator:0 }); 

            return false;
        }

        if (startFrameID==endFrameID) return false;
        //移动指标
        return this.MoveIndex({ WindowIndex:startFrameID, IndexID:info.IndexID }, { WindowIndex:endFrameID, }, { Operator:0 });
    }

    //获取选中图形信息
    this.GetSelectedChartInfo=function(selectedChart)
    {
        if (!selectedChart) return null;
        var result={ Type:0 };
        var id=selectedChart.Identify;
        if (id=="Main-KLine") 
        {
            result.Name=this.Name;
            result.Symbol=this.Symbol;
            result.Type=JSCHART_DRAGCHART_TYPE_ID.MAIN_KLINE;
        }
        else if (id.indexOf("Overlay-KLine-")==0)
        {
            result.Name=selectedChart.Chart.Title;
            result.Symbol=selectedChart.Chart.Symbol;
            result.Type=JSCHART_DRAGCHART_TYPE_ID.OVERLAY_KLINE;
        }
        else if (id.indexOf("Overlay-Minute-")==0)
        {
            result.Name=selectedChart.Chart.Title;
            result.Symbol=selectedChart.Chart.Symbol;
            result.Type=JSCHART_DRAGCHART_TYPE_ID.OVERLAY_MINUTE;
        }
        else if (id=="Minute-Line")
        {
            result.Name=this.Name;
            result.Symbol=this.Symbol;
            result.Type=JSCHART_DRAGCHART_TYPE_ID.MAIN_MINUTE;
        }
        else if (id=="Minute-Average-Line")
        {
            result.Name=this.Name;
            result.Symbol=this.Symbol;
            result.Type=JSCHART_DRAGCHART_TYPE_ID.MAIN_AVERAGE_MINUTE;
        }
        else if (id=="Minute-Vol-Bar")
        {
            result.Name=this.Name;
            result.Symbol=this.Symbol;
            result.Type=JSCHART_DRAGCHART_TYPE_ID.MAIN_MINUTE_VOL;
        }
        else if (id.indexOf("guid")==0)
        {
            for(var i=0;i<this.TitlePaint.length;++i)
            {
                var titleItem=this.TitlePaint[i];
                if (titleItem.ClassName!="DynamicChartTitlePainting") continue;
                if (titleItem.Identify==id)
                {
                    result.IndexName=titleItem.Title;
                    result.IndexID=id;
                    result.Type=JSCHART_DRAGCHART_TYPE_ID.MAIN_INDEX;
                    break;
                }

                for(var item of titleItem.OverlayIndex)
                {
                    if (item[0]==id)
                    {
                        result.IndexName=item[1].Title;
                        result.IndexID=id;
                        result.Type=JSCHART_DRAGCHART_TYPE_ID.OVERLAY_INDEX;
                        break;
                    }
                }

                if (result.Type>0) break;
            }
        }

        return result;
    }

    //点击事件
    this.ClickEvent=function(e) 
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK);
        if (!event || !event.Callback) return false;
        if (this.ClickDownPoint.X!=e.clientX || this.ClickDownPoint.Y!=e.clientY) return false;
        var pixelTatio = GetDevicePixelRatio();
        var x=(e.clientX-uielement.getBoundingClientRect().left)*pixelTatio;
        var y=(e.clientY-uielement.getBoundingClientRect().top)*pixelTatio;
        var data= { X:e.clientX, Y:e.clientY, FrameID:-1 };
    
        var isInClient=false;
        this.Canvas.beginPath();
        this.Canvas.rect(this.Frame.ChartBorder.GetLeft(),this.Frame.ChartBorder.GetTop(),this.Frame.ChartBorder.GetWidth(),this.Frame.ChartBorder.GetHeight());
        isInClient=this.Canvas.isPointInPath(x,y);
        if (isInClient)
        {
            var yValueExtend={};
            var yValue=this.Frame.GetYData(y,yValueExtend);

            if (IFrameSplitOperator.IsNumber(yValueExtend.FrameID) && yValueExtend.FrameID>=0)
            {
                var xValue=this.Frame.GetXData(x);
                data.FrameID=yValueExtend.FrameID;
                data.Data={ X:xValue, Y:yValue } ;
            }
        }
        
        event.Callback(event, data, this);
        return true;
    }

    //双击事件
    this.DBClickEvent=function(dbClickInfo, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DBCLICK);
        if (!event || !event.Callback) return false;

        var pixelTatio = GetDevicePixelRatio();
        var x=(e.clientX-uielement.getBoundingClientRect().left)*pixelTatio;
        var y=(e.clientY-uielement.getBoundingClientRect().top)*pixelTatio;
        var data= { X:e.clientX, Y:e.clientY, FrameID:-1 , ClientPos:-1 };

        var clientPos=this.PtInClient(x,y);
        data.ClientPos=clientPos;

        if (clientPos>0)
        {
            var yValueExtend={};
            var yValue=this.Frame.GetYData(y,yValueExtend);

            if (IFrameSplitOperator.IsNumber(yValueExtend.FrameID) && yValueExtend.FrameID>=0)
            {
                var xValue=this.Frame.GetXData(x);
                data.FrameID=yValueExtend.FrameID;
                data.Data={ X:xValue, Y:yValue } ;

                if (this.GetDataItem) data.Data.Item=this.GetDataItem({ClientPos:clientPos, Index:xValue, Point:{ X:x, Y:y } });
            }
        }

        //选中图形
        if (dbClickInfo && dbClickInfo.SelectedChart)
        {
            data.SelectedChart=this.GetSelectedChartInfo(dbClickInfo.SelectedChart);
        }

        event.Callback(event, data, this);
        return true;
    }

    this.PtInChartPaintTooltip=function(x,y, toolTip)
    {
        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            if (item.GetTooltipData(x,y,toolTip))
                return item;
        }

        return null;
    }

    this.PtInOverlayChartPaintTooltip=function(x,y,toolTip)
    {
        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            if (item.GetTooltipData(x,y,toolTip))
                return item;
        }

        return null;
    }

    //扩展图形支持tooltip外部接口
    this.PtInExtendChartPaintTooltip=function(x,y,tooltip)
    {
        return null;
    }

    this.TryClickPaintEvent=function(eventID, ptClick, e)
    {
        var event=this.GetEventCallback(eventID);
        if (event && event.Callback)
        {
            if (ptClick.X==e.clientX && ptClick.Y==e.clientY)
            {
                var pixelTatio = GetDevicePixelRatio();
                var x = (e.clientX-uielement.getBoundingClientRect().left)*pixelTatio;
                var y = (e.clientY-uielement.getBoundingClientRect().top)*pixelTatio;

                var toolTip=new TooltipData();
                var stock=null;
            
                //主数据
                var paint=this.PtInChartPaintTooltip(x,y, toolTip);
                if (paint) stock={ Symbol:this.Symbol, Name:this.Name };

                if (!paint)    //叠加数据
                {
                    paint=this.PtInOverlayChartPaintTooltip(x,y, toolTip);
                    if (paint) stock={ Symbol:toolTip.ChartPaint.Symbol, Name:toolTip.ChartPaint.Title };
                }

                if (toolTip.Data)
                {
                    var data= { X:e.clientX, Y:e.clientY, Stock: stock, Tooltip:toolTip };
                    event.Callback(event, data, this);
                    return true;
                }
            }
        }

        return false;
    }


    //判断是单个手指
    this.IsPhoneDragging=function(e)
    {
        // JSConsole.Chart.Log(e);
        var changed=e.changedTouches.length;
        var touching=e.touches.length;

        return changed==1 && touching==1;
    }

    //是否是2个手指操所
    this.IsPhonePinching=function(e)
    {
        var changed=e.changedTouches.length;
        var touching=e.touches.length;

        return (changed==1 || changed==2) && touching==2;
    }

    this.PreventTouchEvent=function(e)
    {
        if (e.cancelable) e.preventDefault();
        e.stopPropagation();
    }

    this.GetToucheData=function(e, isForceLandscape)
    {
        var touches=new Array();
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        for(var i=0; i<e.touches.length; ++i)
        {
            var item=e.touches[i];
            if (isForceLandscape)
            {
                touches.push(
                    {
                        clientX:item.clientY*pixelTatio, clientY:item.clientX*pixelTatio, 
                        pageX:item.pageY*pixelTatio, pageY:item.pageX*pixelTatio
                    });
            }
            else
            {
                touches.push(
                    {
                        clientX:item.clientX*pixelTatio, clientY:item.clientY*pixelTatio, 
                        pageX:item.pageX*pixelTatio, pageY:item.pageY*pixelTatio
                    });
            }
        }

        return touches;
    }

    this.IsSingleTouch=function(e)  //是否是单点触屏
    {
        var touchCount=e.touches.length;

        return touchCount==1;
    }

    this.StopDragTimer=function()
    {
        if (IFrameSplitOperator.IsNumber(this.DragTimer))
        {
            clearTimeout(this.DragTimer);
            this.DragTimer=null;
            this.IsPress=false;
        }
    }


    this.GetMoveAngle=function(pt,pt2)  //计算角度
    {
        var xMove=Math.abs(pt.X-pt2.X);
        var yMove=Math.abs(pt.Y-pt2.Y);
        var angle=Math.atan(xMove/yMove)*180/Math.PI;
        return angle;
    }

    //手机拖拽
    uielement.ontouchstart=(e)=> { this.OnTouchStart(e); } 
    uielement.ontouchmove=(e)=> {this.OnTouchMove(e); }
    uielement.ontouchend=(e)=> {this.OnTouchEnd(e); }    

    this.AddPhoneDBClickInfo=function(x,y,time)
    {
        var item={ X:x, Y:y, Time:time };
        this.PhoneDBClickInfo.Start.push(item);
    }

    this.ClearPhoneDBClickInfo=function()
    {
        this.PhoneDBClickInfo.Start=[];
    }

    this.IsShortPhoneClick=function(x,y,time)
    {

    }

    this.OnTouchStart=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        this.IsPress=false;
        this.IsOnTouch=true;
        this.TouchDrawCount=0;
        this.PhonePinch=null;
        this.StopDragTimer();

        var isSingleTouch=this.IsSingleTouch(e);
        if (this.EnableScrollUpDown==false ||  !isSingleTouch || //多点触屏
            (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID && this.TouchStatus.CorssCursorShow==true)) //十字光标显示,不能滚动页面   
        {
            if (e.cancelable) e.preventDefault();
        }

        if (this.IsPhoneDragging(e))
        {
            var touches = this.GetToucheData(e, this.IsForceLandscape);
            var pt=this.PointAbsoluteToRelative(touches[0].clientX, touches[0].clientY, true);

            if (this.TryClickLock || this.TryClickIndexTitle) //指标枷锁区域 , 指标标题点击
            {
                var x = pt.X;
                var y = pt.Y;
                if (this.TryClickLock && this.TryClickLock(x, y)) return;
                if (this.TryClickIndexTitle && this.TryClickIndexTitle(x,y)) return;
            }

            if (this.ClickFrameButton)
            {
                var button=this.Frame.PtInButtons(pt.X,pt.Y);
                if (button)
                {
                    this.ClickFrameButton(button, e);
                    return;
                }
            }

            if (this.EnableVerticalDrag )
            {
                this.VerticalDrag={ IsDrag:false };
                if (this.Frame.PtInFrameVertical(pt.X, pt.Y))
                    this.VerticalDrag.IsDrag=true;
            }
            
            var bStartTimer=true;
            if (this.ChartDrawOption.IsLockScreen)
            {
                bStartTimer=false;
            }
            else if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
            {
                if (this.TouchStatus.CorssCursorShow==true) bStartTimer=false;
            }
            else if (this.DragMode==JSCHART_DRAG_ID.DISABLE_DRAG_ID)
            {
                bStartTimer=false;
            }
            else
            {
                if (!isSingleTouch) bStartTimer=false;
            }

            if (this.VerticalDrag) bStartTimer=false;

            if (this.EnableClickModel && this.ClickModel.IsShowCorssCursor==true) bStartTimer=false;

            var drag=
            {
                "Click":{},
                "LastMove":{}  //最后移动的位置
            };

            //var touches=this.GetToucheData(e,this.IsForceLandscape);

            drag.Click.X=touches[0].clientX;
            drag.Click.Y=touches[0].clientY;
            drag.LastMove.X=touches[0].clientX;
            drag.LastMove.Y=touches[0].clientY;

            this.MouseDrag=drag;
            var drawPictureActive=this.GetActiveDrawPicture();  //上一次选中的
            var selectedChart={ Chart:this.SelectedChart.Selected.Chart, Identify:this.SelectedChart.Selected.Identify };   //上一次选中的图形
            this.PhoneTouchInfo={ Start:{X:touches[0].clientX, Y:touches[0].clientY }, End:{ X:touches[0].clientX, Y:touches[0].clientY } };
            if (this.SelectChartDrawPicture) this.SelectChartDrawPicture.IsSelected=false;
            this.SelectChartDrawPicture=null;
            var isDrawPictrue=false;
            if (this.CurrentChartDrawPicture)  //画图工具模式
            {
                var drawPicture=this.CurrentChartDrawPicture;
                if (drawPicture.Status==2)
                    this.SetChartDrawPictureThirdPoint(drag.Click.X,drag.Click.Y,true);
                else
                {
                    this.SetChartDrawPictureFirstPoint(drag.Click.X,drag.Click.Y,true);
                    //只有1个点 直接完成
                    if (this.FinishChartDrawPicturePoint()) 
                    {
                        if (drawPicture.IsDrawMain) this.Draw();
                        else this.DrawDynamicInfo( {Corss:false, Tooltip:false} );
                    }
                }

                if (e.cancelable) e.preventDefault();
                return;
            }
            else
            {
                var pt=this.PointAbsoluteToRelative(touches[0].clientX,touches[0].clientY, true);
                var drawPictrueData={ X:pt.X, Y:pt.Y };
                var pixelTatio = GetDevicePixelRatio(); //鼠标移动坐标是原始坐标 需要乘以放大倍速
                if (this.GetChartDrawPictureByPoint(drawPictrueData))
                {
                    drawPictrueData.ChartDrawPicture.Status=20;
                    drawPictrueData.ChartDrawPicture.ValueToPoint();
                    drawPictrueData.ChartDrawPicture.MovePointIndex=drawPictrueData.PointIndex;
                    drawPictrueData.ChartDrawPicture.IsSelected=true;
                    this.CurrentChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    this.SelectChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    let event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_DRAWPICTURE); //选中画图工具事件
                    if (event && event.Callback)
                    {
                        let sendData={ DrawPicture: drawPictrueData.ChartDrawPicture };
                        event.Callback(event,sendData,this);
                    }

                    var drawType=0;
                    if (drawPictrueData.ChartDrawPicture.IsDrawMain) drawType=1;
                    else if (drawPictureActive.Select.Guid && drawPictureActive.Select.Chart && drawPictureActive.Select.Chart.IsDrawMain)  drawType=1;

                    if (drawType==1) this.Draw();

                    if (e.cancelable) e.preventDefault();
                    return;
                }
            }

            if (bStartTimer)
            {
                //长按2秒,十字光标
                var self=this;
                this.DragTimer=setTimeout(function()
                {
                    self.IsPress=true;
                    if (drag.Click.X==drag.LastMove.X && drag.Click.Y==drag.LastMove.Y) //手指没有移动，出现十字光标
                    {
                        var mouseDrag=self.MouseDrag;
                        self.MouseDrag=null;
                        if (self.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID) self.TouchStatus.CorssCursorShow=true;    //十字显示
                        if (self.EnableClickModel===true) self.ClickModel.IsShowCorssCursor=true;
                        self.MoveCorssCursor(drag.Click,e);//移动十字光标
                    }

                }, self.PressTime);
            }

            if (this.EnableZoomIndexWindow)
            {
                this.PhoneDBClick.AddTouchStart(touches[0].clientX, touches[0].clientY, Date.now());
                JSConsole.Chart.Log("[JSChartContainer::OnTouchStart] PhoneDBClick ", this.PhoneDBClick);
            }
            
            if (this.ChartDrawOption.IsLockScreen)
            {
                this.MouseDrag=null;
            }
            else if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
            {

            }
            else if (this.DragMode==JSCHART_DRAG_ID.DISABLE_DRAG_ID)
            {
                this.MouseDrag=null;
                this.MoveCorssCursor(drag.Click,e);
            }
            else if (this.EnableClickModel)
            {
                //if (this.ClickModel.IsShowCorssCursor===true) this.MoveCorssCursor(drag.Click,e)
            }
            else if (this.VerticalDrag)
            {
                if (!this.VerticalDrag.IsDrag) this.MoveCorssCursor(drag.Click,e);  //没有点击X轴, 就显示十字光标
            }
            else if (this.IsClickShowCorssCursor)
            {
                this.MoveCorssCursor(drag.Click,e);
            }
            
            this.TouchEvent({ EventID:JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName:"OnTouchStart"}, e);

            var drawType=0;
            if (drawPictureActive.Select.Guid!=null)
            {
                if (drawPictureActive.Select.Guid && drawPictureActive.Select.Chart)  drawType=1;
            }

            if (drawType==1) this.Draw();
        }
        else if (this.IsPhonePinching(e))
        {
            var phonePinch=
            {
                "Start":{},
                "Last":{}
            };

            var touches=this.GetToucheData(e,this.IsForceLandscape);

            phonePinch.Start={X:touches[0].pageX, Y:touches[0].pageY, X2:touches[1].pageX, Y2:touches[1].pageY};
            phonePinch.Last={X:touches[0].pageX, Y:touches[0].pageY, X2:touches[1].pageX, Y2:touches[1].pageY};

            this.PhonePinch=phonePinch;
            this.SelectChartDrawPicture=null;
        }
    }

    this.OnTouchMove=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        var touches=this.GetToucheData(e,this.IsForceLandscape);

        if (this.IsPhoneDragging(e))
        {
            var drag=this.MouseDrag;
            if (drag==null)
            {
                if (this.IsForceLandscape) y=uielement.getBoundingClientRect().width-touches[0].clientY;    //强制横屏Y计算
                if (!this.ChartDrawOption.IsLockScreen) this.MoveCorssCursor({X:touches[0].clientX, Y:touches[0].clientY},e);
            }
            else
            {
                var moveAngle=this.GetMoveAngle(drag.LastMove,{X:touches[0].clientX, Y:touches[0].clientY});
                var moveSetp=Math.abs(drag.LastMove.X-touches[0].clientX);
                var moveUpDown=Math.abs(drag.LastMove.Y-touches[0].clientY);
                moveSetp=parseInt(moveSetp);
                var isMoveCorssCursor=(this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID && this.TouchStatus.CorssCursorShow==true); //是否移动十字光标

                if (this.VerticalDrag) 
                {
                    if (this.VerticalDrag.IsDrag===true) isMoveCorssCursor=false;
                    else isMoveCorssCursor=true;
                }

                if (this.EnableClickModel)
                {
                    if (this.ClickModel.IsShowCorssCursor===true) isMoveCorssCursor=true;
                    else isMoveCorssCursor=false;
                }

                //JSConsole.Chart.Log(`[JSChartContainer::OnTouchMove]  moveAngle=${moveAngle} , moveUpDown=${moveUpDown}, moveSetp=${moveSetp}`);

                if (this.CurrentChartDrawPicture)
                {
                    var drawPicture=this.CurrentChartDrawPicture;
                    if (drawPicture.Status==1 || drawPicture.Status==2)
                    {
                        if(moveSetp<5 && moveUpDown<5) return;
                        if(this.SetChartDrawPictureSecondPoint(touches[0].clientX,touches[0].clientY,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }
                    else if (drawPicture.Status==3)
                    {
                        if(this.SetChartDrawPictureThirdPoint(touches[0].clientX,touches[0].clientY,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }
                    else if (drawPicture.Status==20)    //画图工具移动
                    {
                        if(moveSetp<5 && moveUpDown<5) return;

                        if(this.MoveChartDrawPicture(touches[0].clientX-drag.LastMove.X,touches[0].clientY-drag.LastMove.Y,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }

                    drag.LastMove.X=touches[0].clientX;
                    drag.LastMove.Y=touches[0].clientY;
                }
                else if (isMoveCorssCursor)  //点击模式下 十字光标显示 左右移动十字光标
                {
                    var mouseDrag=this.MouseDrag;
                    this.MouseDrag=null;
                    this.MoveCorssCursor(drag.Click,e); //移动十字光标
                }
                else if (this.DragMode==1 || isMoveCorssCursor==false)  //数据左右拖拽
                {
                    if ( ((moveUpDown>0 && moveSetp<=3) || moveAngle<=this.TouchMoveMinAngle) && this.EnableScrollUpDown==true ) 
                    {
                        this.StopDragTimer();
                        return;
                    }

                    if (moveSetp<5 || moveAngle<=this.TouchMoveMinAngle) 
                    {
                        this.PreventTouchEvent(e);
                        return;
                    }

                    if (this.EnableVerticalDrag)
                    {
                        if (!this.VerticalDrag) return;
                        if (!this.VerticalDrag.IsDrag) return;
                    }

                    var isLeft=true;
                    if (drag.LastMove.X<touches[0].clientX) isLeft=false;//右移数据

                    var oneStepWidth=this.GetMoveOneStepWidth();
                    if (moveSetp<oneStepWidth) return;

                    if(this.DataMove(moveSetp,isLeft))
                    {
                        this.UpdataDataoffset();
                        this.UpdatePointByCursorIndex();
                        this.UpdateFrameMaxMin();
                        this.ResetFrameXYSplit();
                        this.Draw();
                        this.OnKLinePageChange("OnTouchMove");
                    }
                    else
                    {
                        if (this.DragDownloadData) this.DragDownloadData();
                    }

                    drag.LastMove.X=touches[0].clientX;
                    drag.LastMove.Y=touches[0].clientY;
                }
            }

            if (this.PhoneTouchInfo)
            {
                this.PhoneTouchInfo.End.X=touches[0].clientX;
                this.PhoneTouchInfo.End.Y=touches[0].clientY;
            }
        }
        else if (this.IsPhonePinching(e))
        {
            if (this.DragMode==JSCHART_DRAG_ID.DISABLE_DRAG_ID) return;

            this.PreventTouchEvent(e);
            var phonePinch=this.PhonePinch;
            if (!phonePinch) return;

            phonePinch.Operator=null;
            if (this.EnableZoomUpDown && this.EnableZoomUpDown.Touch===false) return;

            var yHeight=Math.abs(touches[0].pageY-touches[1].pageY);
            var yLastHeight=Math.abs(phonePinch.Last.Y-phonePinch.Last.Y2);
            var yStep=yHeight-yLastHeight;

            var xHeight=Math.abs(touches[0].pageX-touches[1].pageX);
            var xLastHeight=Math.abs(phonePinch.Last.X-phonePinch.Last.X2);
            var xStep=xHeight-xLastHeight;
            var minStep=this.ZoomStepPixel;
            if (Math.abs(yStep)<minStep && Math.abs(xStep)<minStep) return;
            var step=yStep;
            if (Math.abs(yStep)<minStep) step=xStep;

            if (step>0)    //放大
            {
                var cursorIndex={ IsLockRight:this.IsZoomLockRight };
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (!this.Frame.ZoomUp(cursorIndex)) return;
                phonePinch.Operator="ZoomUp";
                this.CursorIndex=cursorIndex.Index;
                this.UpdatePointByCursorIndex();
                this.UpdataDataoffset();
                this.UpdateFrameMaxMin();
                //this.ResetFrameXSplit();
                this.Draw();
                this.ShowTooltipByKeyDown();
                this.StopDragTimer();
            }
            else        //缩小
            {
                var cursorIndex={ IsLockRight:this.IsZoomLockRight };
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (!this.Frame.ZoomDown(cursorIndex)) return;
                phonePinch.Operator="ZoomDown";
                this.CursorIndex=cursorIndex.Index;
                this.UpdataDataoffset();
                this.UpdatePointByCursorIndex();
                this.UpdateFrameMaxMin();
                //this.ResetFrameXSplit();
                this.Draw();
                this.ShowTooltipByKeyDown();
                this.StopDragTimer();
            }

            phonePinch.Last={ X:touches[0].pageX, Y:touches[0].pageY, X2:touches[1].pageX, Y2:touches[1].pageY };
        }

        this.PreventTouchEvent(e);
    }

    this.OnTouchEnd=function(e)
    {
        JSConsole.Chart.Log('[KLineChartContainer:OnTouchEnd]',e);
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        var bClearDrawPicture=true;
        if (this.CurrentChartDrawPicture)
        {
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.Status==2 || drawPicture.Status==1 || drawPicture.Status==3)
            {
                drawPicture.PointStatus=drawPicture.Status;
                if (this.FinishChartDrawPicturePoint())
                    this.DrawDynamicInfo();
                else
                    bClearDrawPicture=false;
            }
            else if (drawPicture.Status==20)
            {
                if (this.FinishMoveChartDrawPicture())
                    this.DrawDynamicInfo();
            }
        }

        if (this.EnableZoomIndexWindow)
        {
            var time=Date.now();
            this.PhoneDBClick.AddTouchEnd(time);
            if (this.PhoneDBClick.IsVaildDBClick())
            {
                this.OnTouchDBClick(this.PhoneDBClick.Start);
                this.PhoneDBClick.Clear();
            }
        }
        
        this.IsOnTouch = false;
        this.VerticalDrag=null;
        if (bClearDrawPicture===true) this.CurrentChartDrawPicture=null;
        this.StopDragTimer();
        this.TouchEvent({ EventID:JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName:"OnTouchEnd"}, e);
        this.OnTouchFinished();
        this.TouchDrawCount=0;
        this.PhonePinch=null;
    }

    this.OnTouchDBClick=function(points)
    {
        var pt=this.PointAbsoluteToRelative(points[0].X, points[0].Y, true);
        var x=pt.X, y=pt.Y;
        JSConsole.Chart.Log(`[KLineChartContainer:OnTouchDBClick] Phone dbclick absolute [${x},${y}], soruce [${points[0].X},${points[0].Y}]`);

        var frameId=this.Frame.PtInFrame(x,y);
        JSConsole.Chart.Log("[KLineChartContainer::OnTouchDBClick] frameId",frameId);
        if (frameId>=this.Frame.ZoomStartWindowIndex)
        {
            if (this.ZoomIndexWindow(frameId, {X:x, Y:y}))
            {
                this.Frame.SetSizeChage(true);
                this.Draw();
                return true;
            }
        }
    }

    //手势事件
    this.TouchEvent=function(obj,e)
    {
        var eventID=obj.EventID;
        var event=this.GetEventCallback(eventID);
        if (!event || !event.Callback) return false;
        var drag=this.PhoneTouchInfo
        if (!drag || !drag.Start || !drag.End ) return false;
        var pixelTatio = GetDevicePixelRatio();
        var clientX=drag.End.X/pixelTatio;
        var clientY=drag.End.Y/pixelTatio;
        var x=drag.End.X-this.UIElement.getBoundingClientRect().left*pixelTatio;
        var y=drag.End.Y-this.UIElement.getBoundingClientRect().top*pixelTatio;
        var data= 
        { 
            X:clientX, Y:clientY, FrameID:-1, FunctionName:obj.FunctionName,
            Drag:
            { 
                Start:{ X:drag.Start.X/pixelTatio, Y:drag.Start.Y/pixelTatio }, 
                End:{ X:drag.End.X/pixelTatio, Y:drag.End.Y/pixelTatio } 
            } 
        };

        var isInClient=false;
        this.Canvas.beginPath();
        this.Canvas.rect(this.Frame.ChartBorder.GetLeft(),this.Frame.ChartBorder.GetTop(),this.Frame.ChartBorder.GetWidth(),this.Frame.ChartBorder.GetHeight());
        isInClient=this.Canvas.isPointInPath(x,y);

        if (isInClient)
        {
            if (this.Frame && this.Frame.IsHScreen)
            {
                var yValueExtend={};
                var yValue=this.Frame.GetYData(x,yValueExtend);
    
                if (IFrameSplitOperator.IsNumber(yValueExtend.FrameID) && yValueExtend.FrameID>=0)
                {
                    var xValue=this.Frame.GetXData(y);
                    data.FrameID=yValueExtend.FrameID;
                    data.Data={ X:xValue, Y:yValue } ;
                }
            }
            else
            {
                var yValueExtend={};
                var yValue=this.Frame.GetYData(y,yValueExtend);
    
                if (IFrameSplitOperator.IsNumber(yValueExtend.FrameID) && yValueExtend.FrameID>=0)
                {
                    var xValue=this.Frame.GetXData(x);
                    data.FrameID=yValueExtend.FrameID;
                    data.Data={ X:xValue, Y:yValue } ;
                }
            }
        }

        event.Callback(event, data, this);
        return true;
    }

    this.MoveCorssCursor=function(point,e)
    {
        var pixelTatio = GetDevicePixelRatio();
        var x = point.X-this.UIElement.getBoundingClientRect().left*pixelTatio;
        var y = point.Y-this.UIElement.getBoundingClientRect().top*pixelTatio;
        if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID) this.TouchStatus.CorssCursorShow=true;    //十字显示
        this.OnMouseMove(x,y,e,true);
    }

    this.DrawEmpty=function()
    {
        if (this.UIElement.width<=0 || this.UIElement.height<=0) return; 
        this.Canvas.clearRect(0,0,this.UIElement.width,this.UIElement.height);
        if (this.Frame)
        {
            this.Frame.ScreenImageData=null;
            this.Frame.Draw();
        }
    }

    this.PtInChart=function(x,y)
    {
        var result=null;
        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            if (!item.PtInChart) continue;
            if (item.IsHideScriptIndex()) continue;
            
            result=item.PtInChart(x,y);
            if (result) return result;
        }

        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.PtInChart) continue;

            result=item.PtInChart(x,y);
            if (result) return result;
        }

        if (this.Frame.PtInOveralyChart) 
        {
            result=this.Frame.PtInOveralyChart(x,y);
            if (result) return result;
        }

        return null;
    }

    //绘制选中图形的状态
    this.DrawSelectedStatus=function()
    {
        if (!this.SelectedChart.MoveOn.Identify && !this.SelectedChart.Selected.Identify) return;

        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            if (!item.Identify) continue;
            if (item.Identify!=this.SelectedChart.MoveOn.Identify && item.Identify!=this.SelectedChart.Selected.Identify) continue;
            if (item.DrawSelectedStatus) item.DrawSelectedStatus();
        }

        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Identify) continue;
            if (item.Identify!=this.SelectedChart.MoveOn.Identify && item.Identify!=this.SelectedChart.Selected.Identify) continue;
            if (item.DrawSelectedStatus) item.DrawSelectedStatus();
        }

        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Identify) continue;
            if (item.Identify!=this.SelectedChart.MoveOn.Identify && item.Identify!=this.SelectedChart.Selected.Identify) continue;
            if (item.DrawSelectedStatus) item.DrawSelectedStatus();
        }

        if (this.Frame.DrawOveralySelectedStatus) this.Frame.DrawOveralySelectedStatus(this.SelectedChart);
    }

    this.SetCanvas=function(canvas)
    {
        if (this.Frame)
        {
            var subFrame=this.Frame.SubFrame;
            for(var i=0; i<subFrame.length; ++i)
            {
                var item=subFrame[i];
                item.Frame.Canvas=canvas; //框架

                for(var j=0; j<item.OverlayIndex.length; ++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    overlayItem.Frame.Canvas=canvas;    //子框架

                    for(var k=0;k<overlayItem.ChartPaint.length;++k)
                    {
                        var chartItem=overlayItem.ChartPaint[k];
                        chartItem.Canvas=canvas;    //叠加图形
                    }
                }
            }
        }

        //画图工具
        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            item.Canvas=canvas;
        }

        //图形
        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            item.Canvas=canvas;
        }

        //扩展图形
        for(var i=0;i<this.ChartPaintEx.length;++i)
        {
            var item=this.ChartPaintEx[i];
            item.Canvas=canvas;
        }

        //叠加股票
        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            item.Canvas=canvas;
        }

        //扩展画法
        for(var i=0;i<this.ExtendChartPaint.length;++i)
        {
            var item=this.ExtendChartPaint[i];
            item.Canvas=canvas;
        }
    }

    //清空画布
    this.ClearCanvas=function(canvas)
    {
        if (!canvas) return;
        if (!this.UIElement) return;

        canvas.clearRect(0,0,this.UIElement.width,this.UIElement.height);
    }

    this.Draw=function()
    {
        if (this.ChartCorssCursor) this.ChartCorssCursor.Status=0;
        if (this.UIElement.width<=0 || this.UIElement.height<=0) return; 

        this.StopDrawDynamicInfo();

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_BEFORE_DRAW);
        if (event && event.Callback)
        {
            var sendData={ };
            event.Callback(event,sendData,this);
        }

        this.Canvas.clearRect(0,0,this.UIElement.width,this.UIElement.height);
        if (this.CacheCanvas) this.CacheCanvas.clearRect(0,0,this.UIElement.width,this.UIElement.height);

        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        this.Canvas.lineWidth=pixelTatio;       //手机端需要根据分辨率比调整线段宽度

        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash)
        {
            var data=this.InvokeBeforeDrawSplashScreenCallback();
            if (data && data.PreventDefault===true) return;

            this.Frame.ClearCoordinateText();
            this.Frame.Draw( { IsEnableSplash:this.ChartSplashPaint.IsEnableSplash} );
            this.ChartSplashPaint.Draw();
            return;
        }

        if (this.CacheCanvas) this.SetCanvas(this.CacheCanvas);

        //框架
        if (this.Frame.SetBeforeDrawXYCallback)
        {
            this.Frame.SetBeforeDrawXYCallback((frame)=>
            {
                this.BeforeDrawXYCoordinate(frame);
            });
        }

        this.Frame.Draw();
        if (this.Frame.DrawCustomVertical) 
        {
            var eventCVericalDraw=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_VERTICAL_DRAW);
            this.Frame.DrawCustomVertical(eventCVericalDraw);
        }
        this.Frame.CalculateLock();

        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (!item.IsDrawMain) continue;
            if (item.IsDrawMain()) item.MainDraw();
        }

        //框架内图形
        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            if (item.IsDrawFirst)
                item.Draw();
        }

        if (this.Frame.DrawOveraly)
            this.Frame.DrawOveraly(true);   //画叠加指标

        for(var i=0; i<this.ChartPaint.length; ++i)
        {
            var item=this.ChartPaint[i];
            if (!item.IsDrawFirst)
                item.Draw();
        }

        for(var i=0;i<this.ChartPaintEx.length;++i)
        {
            var item=this.ChartPaintEx[i];
            item.Draw();
        }

        //叠加股票
        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            item.Draw();
        }

        if (this.Frame.DrawOveraly)
            this.Frame.DrawOveraly(false);   //画叠加指标

        //固定扩展图形
        for(var i=0;i<this.ExtendChartPaint.length;++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsCallbackDraw) continue;
            if (item.DrawAfterPicture) continue;
            if (!item.IsDynamic && item.IsAnimation==false) item.Draw();
        }

        if (this.Frame.DrawInsideHorizontal) this.Frame.DrawInsideHorizontal();
        this.KLineIncreaseCustomHorizontal();
        if (this.Frame.DrawCustomHorizontal) this.Frame.DrawCustomHorizontal(); //Y轴自定义坐标
        if (this.Frame.DrawEx) this.Frame.DrawEx( {Symbol:this.Symbol} );
        if (this.ChartInfoPaint) this.ChartInfoPaint.Draw();
        this.Frame.DrawLock();
        this.Frame.DrawLogo();

        //图形缓存
        if (this.CacheCanvas) 
        {
            this.Canvas.drawImage(this.CacheElement,0,0);
            this.SetCanvas(this.Canvas);
        }
        else
        {
            this.Frame.Snapshot();
        }

        if (this.Frame.DrawToolbar) this.Frame.DrawToolbar(this.LastMouseStatus);
        this.DrawSelectedStatus();

        this.DrawSelectedBorder();
        if (this.DrawSelectedXBorder) this.DrawSelectedXBorder();

        var moveonPoint=null;
        if (this.LastMouseStatus && this.LastMouseStatus.MoveOnPoint) moveonPoint=this.LastMouseStatus.MoveOnPoint;
        for(var i=0;i<this.ExtendChartPaint.length;++i) //动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsCallbackDraw) continue;
            if (item.DrawAfterPicture) continue;
            if (item.IsDynamic && item.DrawAfterTitle===false) 
            {
                item.Draw();
                if (item.DrawToolbar) item.DrawToolbar(moveonPoint);
            }
        }

        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (item.IsDrawFirst) item.Draw();
        }

        this.DrawDrawPictureXYCoordinate(); //绘制画图工具 X,Y轴刻度信息
        
        var ptPosition=null;    //鼠标位置 null 无效 -1 在外面 >=0 对应的指标窗口中ID
        if (this.LastPoint.X!=null || this.LastPoint.Y!=null)
        {
            if (this.ChartCorssCursor)
            {
                this.ChartCorssCursor.LastPoint=this.LastPoint;
                this.ChartCorssCursor.CursorIndex=this.CursorIndex;
                if (this.EnableNewIndex)
                {
                    this.ChartCorssCursor.CorssCursorIndex=this.CorssCursorIndex;
                    this.ChartCorssCursor.EnableNewIndex=this.EnableNewIndex;
                }

                var bRestoreCanvas=false;
                if (this.CorssCursorCanvas) //独立的十字光标层
                {
                    this.ChartCorssCursor.Canvas=this.CorssCursorCanvas;
                    this.ChartCorssCursor.Canvas.clearRect(0,0,this.CorssCursorElement.width,this.CorssCursorElement.height)
                    bRestoreCanvas=true;
                }

                var button=this.PtInButton(this.LastPoint.X,this.LastPoint.Y);
                if (button) //鼠标在按钮上 不显示十字光标
                {

                }
                else if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
                {   //点击手势模式下
                    if (this.TouchStatus.CorssCursorShow==true) this.ChartCorssCursor.Draw();
                }
                else if (this.EnableClickModel)
                {
                    if (this.ClickModel.IsShowCorssCursor===true) this.ChartCorssCursor.Draw();
                }
                else if (!(this.CorssCursorTouchEnd===true && this.MouseDrag) && !(this.CorssCursorTouchEnd==true && this.IsOnTouch==false)) 
                {   //移动端 拖拽数据的时候 不显示十字光标, 没有按屏的时候也不显示十字光标
                    this.ChartCorssCursor.Draw();
                }

                if (bRestoreCanvas)
                {
                    this.ChartCorssCursor.Canvas=this.Canvas;
                }
            }

            ptPosition=this.Frame.PtInFrame(this.LastPoint.X, this.LastPoint.Y);
        }

        var drawStatus=this.GetDrawStatus();
        drawStatus.DrawName="Draw";
        var eventTitleDraw=this.GetEventCallback(JSCHART_EVENT_ID.ON_TITLE_DRAW);
        var eventIndexTitleDraw=this.GetEventCallback(JSCHART_EVENT_ID.ON_INDEXTITLE_DRAW);
        for(var i=0;i<this.TitlePaint.length;++i)
        {
            var item=this.TitlePaint[i];
            if (!item.IsDynamic) continue;

            item.CursorIndex=this.CursorIndex;
            item.LastPoint=this.LastPoint;
            if (item.ClassName=='DynamicChartTitlePainting')  item.OnDrawEvent=eventIndexTitleDraw
            else item.OnDrawEvent=eventTitleDraw;

            if (item.OnDrawEvent) 
            {
                item.OnDrawEvent.FunctionName='Draw';
                item.OnDrawEvent.PointPosition=ptPosition;
            }

            item.DrawStatus=drawStatus;
            item.Draw(moveonPoint, this.LastMouseStatus);
        }

        for(var i=0;i<this.ExtendChartPaint.length;++i) //动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsCallbackDraw) continue;
            if (item.DrawAfterPicture) continue;
            if (item.IsDynamic && item.DrawAfterTitle===true && item.IsAnimation==false) item.Draw();
        }

        if (this.EnableAnimation)
        {
            for(var i=0;i<this.ExtendChartPaint.length;++i) //动画
            {
                var item=this.ExtendChartPaint[i];
                if (item.IsAnimation===true) item.Draw();
            }
        }

        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (item.IsDrawFirst) continue;
            if (item.IsDrawMain && item.IsDrawMain()) continue;
            if (this.SelectChartDrawPicture && this.SelectChartDrawPicture.Guid==item.Guid) continue;   //当前选中在最后画

            item.Draw();
        }

        if (this.SelectChartDrawPicture) this.SelectChartDrawPicture.Draw();

        if (this.CurrentChartDrawPicture && this.CurrentChartDrawPicture.Status!=10)
        {
            this.CurrentChartDrawPicture.Draw();
        }

        for(var i=0;i<this.ExtendChartPaint.length;++i) //画图工具绘制完成以后 动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.DrawAfterPicture)
                item.Draw();
        }

        this.OffscreenToShowCanvas();

        //更新滚动条
        if (typeof(this.UpdateScrollBar)=='function') this.UpdateScrollBar();

        if (this.LastMouseStatus.MouseOnToolbar)    //工具栏按钮提示信息
        {
            var frame=this.LastMouseStatus.MouseOnToolbar.Frame;
            if (frame && frame.DrawToolbarTooltip) frame.DrawToolbarTooltip(this.LastMouseStatus.MouseOnToolbar);
        }
       
        //发送图形状态给外部
        if (this.mapEvent.has(JSCHART_EVENT_ID.CHART_STATUS))
        {
            var event=this.mapEvent.get(JSCHART_EVENT_ID.CHART_STATUS);
            
            var data={  };
            if (typeof(this.GetChartStatus)=='function') data=this.GetChartStatus();
            event.Callback(event,data,this);
        }

        ++this.TouchDrawCount;
    }

    this.PtInButton=function(x, y)
    {
        var button=this.Frame.PtInButtons(x,y);
        if (button) 
            return { Name:"FrameButton", Button:button };

        button=this.PtInExtendChartButtons(x,y);
        if (button)
            return { Name:"ExtendChartButton", Button:button };

        button=this.PtInDrawPictureButtons(x,y);
        if (button)
            return { Name:"DrawPictureButton", Button:button };

        button=this.PtInTitleButtons(x,y);
        if (button)
            return { Name:"TitleButton", Button:button };

        return null;
    }

    this.DrawDrawPictureXYCoordinate=function()
    {
        var actionDrawPicture=null; //当前激活的画图
        if (this.CurrentChartDrawPicture)  actionDrawPicture=this.CurrentChartDrawPicture;
        else if (this.SelectChartDrawPicture) actionDrawPicture=this.SelectChartDrawPicture;

        //画图工具显示点在Y轴的刻度
        var option= { Symbol:this.Symbol, Period:this.Period }
        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (!item) continue;

            if (this.IsDrawPictureXY && actionDrawPicture&& (actionDrawPicture==item || actionDrawPicture.Guid==item.Guid) )
            {
                if (this.Frame.DrawPictureCoordinate(actionDrawPicture,option)) continue;
            }

            if (item.IsShowYCoordinate)
            {
                if (item.Frame) item.Frame.DrawPicturePointYCoordinate(item, option);
            }
        }
    }

    this.BeforeDrawXYCoordinate=function(frame)
    {
        for(var i=0;i<this.ExtendChartPaint.length;++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsCallbackDraw) 
            {
                if (["KLineYAxisBGPaint","DepthMapPaint","BackgroundPaint","MinuteBackgroundPaint", "SessionBreaksPaint"].includes(item.ClassName))
                {
                    if (item.FrameID==frame.Identify) item.Draw();
                }
                else if (g_ExtendChartPaintFactory.IsCallbackDraw(item.ClassName))
                {
                    if (item.FrameID==frame.Identify) item.Draw();
                }
            }
        }
    }

    this.DrawSelectedBorder=function()
    {
        if (!this.GlobalOption.SelectedBorder) return;
        var item=this.GlobalOption.SelectedBorder;
        if (!IFrameSplitOperator.IsPlusNumber(item.Mode)) return;
        if (!IFrameSplitOperator.IsNumber(item.SelFrame) && item.SelFrame<0) return;

        var subFrame=this.Frame.SubFrame[item.SelFrame];
        if (!subFrame) return;

        if (subFrame.Frame.DrawSelectedBorder) subFrame.Frame.DrawSelectedBorder(item);
    }

    //当前屏K线涨幅Y轴刻度
    this.KLineIncreaseCustomHorizontal=function()
    {
        if (!this.Frame || !this.Frame.SubFrame) return;

        var frame=this.Frame.SubFrame[0].Frame;
        if (!frame) return;
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        var isPercentage=false; //是否是百分比坐标
        if (frame.YSplitOperator && frame.YSplitOperator.CoordinateType==1) isPercentage=true;
        var isOverlayCoordinate=false;  //是否包含叠加股票刻度

        for(var i=0;i<frame.CustomHorizontalInfo.length;++i)
        {
            var info=frame.CustomHorizontalInfo[i];
            if (info.Type==4) isOverlayCoordinate=true;

            if ((isPercentage && info.Type==3) || info.Type==2)
            {
                var item=this.ChartPaint[0];
                if (!item) continue;

                var data=item.Data;
                if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) continue;
                if (!IFrameSplitOperator.IsNumber(item.DrawKRange.Start) || !IFrameSplitOperator.IsNumber(item.DrawKRange.End)) continue;
                var startKLine=data.Data[item.DrawKRange.Start];
                var endKLine=data.Data[item.DrawKRange.End];
                var value=(endKLine.Close-startKLine.Close)/startKLine.Close*100;
                info.Value=endKLine.Close;
                if (info.Type==2) 
                {
                    info.Message[1]=endKLine.Close.toFixed(defaultfloatPrecision);
                    if (endKLine.Close>endKLine.Open) info.LineColor=g_JSChartResource.FrameLatestPrice.UpBarColor;
                    else if (endKLine.Close<endKLine.Open) info.LineColor=g_JSChartResource.FrameLatestPrice.DownBarColor;
                    else info.LineColor=g_JSChartResource.FrameLatestPrice.UnchagneBarColor;
                }
                else 
                {
                    info.Message[1]=value.toFixed(2)+"%";
                }
                if (this.Name) info.Title=this.Name;
            }
        }

        if (isOverlayCoordinate)
        {
            //叠加股票自定义刻度需要移除重新添加
            var newCustomHorizontalInfo= frame.CustomHorizontalInfo.filter(function(value, index, ary)
            {
                return value.Type!=4
            });
            frame.CustomHorizontalInfo=newCustomHorizontalInfo;
        }
        
        
        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item) continue;
            if (item.YInfoType!=4) continue;
            var data=item.Data;
            if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) continue;
            if (!IFrameSplitOperator.IsNumber(item.DrawKRange.Start) || !IFrameSplitOperator.IsNumber(item.DrawKRange.End)) continue;
            var startKLine=data.Data[item.DrawKRange.Start];
            var endKLine=data.Data[item.DrawKRange.End];
            var value=(endKLine.Close-startKLine.Close)/startKLine.Close*100;

            var info=new CoordinateInfo();
            info.Value=endKLine.Close/item.ShowRange.FirstOverlayOpen*item.ShowRange.FirstOpen;
            info.Message[1]=value.toFixed(2)+"%";
            info.LineType=-1;
            info.Type=item.YInfoType;    //叠加股票
            info.LineColor=item.Color;
            info.TextColor=g_JSChartResource.FrameLatestPrice.OverlayTextColor;
            if (item.Title) info.Title=item.Title;
            frame.CustomHorizontalInfo.push(info);
        }
    }

    this.OffscreenToShowCanvas=function()
    {
        if (!this.ShowCanvas) return;

        this.ShowCanvas.clearRect(0,0,this.UIElement.width,this.UIElement.height);
        this.ShowCanvas.drawImage(this.OffscreenCanvasElement,0,0);
    }

    this.GetDrawStatus=function()
    {
        var status=
        {
            Point:{ X:this.LastPoint.X, Y:this.LastPoint.Y }, 
            IsOnTouch:this.IsOnTouch,
            CorssCursorTouchEnd:this.CorssCursorTouchEnd,
            IsTitleShowLatestData:this.IsTitleShowLatestData,
            IsMinuteChart:(this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer") ? true:false
        };

        status.FrameID=this.Frame.PtInFrame(this.LastPoint.X, this.LastPoint.Y);

        return status;
    }

    this.InvokeBeforeDrawSplashScreenCallback=function()
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_BEFORE_DRAW_SPLASH_SCREEN);
        if (!event || !event.Callback) return null;

        var data={ PreventDefault:false };
        event.Callback(event,data,this);

        return data;
    }

    this.DrawSplashScreen=function(option)
    {
        var data=this.InvokeBeforeDrawSplashScreenCallback();
        if (data && data.PreventDefault===true) return;

        if (this.Frame.ScreenImageData==null && !this.CacheCanvas) return;

        if (this.Frame.ScreenImageData)
        {
            this.Canvas.putImageData(this.Frame.ScreenImageData,0,0);
        }
        else if (this.CacheCanvas)
        {
            this.Canvas.clearRect(0,0,this.UIElement.width,this.UIElement.height)
            this.Canvas.drawImage(this.CacheElement,0,0);
        }

        var bgColor=g_JSChartResource.SplashScreen.BGColor;
        this.Canvas.fillStyle=bgColor;
        this.Canvas.fillRect(0,0,this.UIElement.width,this.UIElement.height)

        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash)
        {
            var title=g_JSChartResource.SplashScreen.Title;
            if (option && option.Title) title=option.Title;
            this.ChartSplashPaint.SetTitle(title);
            this.ChartSplashPaint.Draw();
        }
    }

    //画动态信息
    this.DrawDynamicInfo=function(option)
    {
        this.LastMouseStatus.MouseOnToolbar=null;   //鼠标在工具栏按钮上

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_BEFORE_DRAW_DYNAMIC_INFO);
        if (event && event.Callback)
        {
            var sendData={ };
            event.Callback(event,sendData,this);
        }

        if (this.Frame.ScreenImageData==null && !this.CacheCanvas) return;

        var isErase=false;
        if (this.ChartCorssCursor)
        {
            if (this.ChartCorssCursor.PointX!=null || this.ChartCorssCursor.PointY!=null)
                isErase=true;
        }

        isErase=true;   //每次都擦除背景
        if (isErase==false)
        {
            for(var i=0;i<this.ExtendChartPaint.length;++i)
            {
                var item=this.ExtendChartPaint[i];
                if (item.IsCallbackDraw) continue;
                if (item.IsDynamic && item.IsEraseBG) 
                {
                    isErase=true;
                    break;
                }
            }
        }

        if (isErase) 
        {
            if (this.Frame.ScreenImageData)
            {
                this.Canvas.putImageData(this.Frame.ScreenImageData,0,0);
            }
            else if (this.CacheCanvas)
            {
                this.Canvas.clearRect(0,0,this.UIElement.width,this.UIElement.height)
                this.Canvas.drawImage(this.CacheElement,0,0);
            }
        }

        if (this.Frame.DrawToolbar) this.Frame.DrawToolbar(this.LastMouseStatus);

        this.DrawSelectedStatus();
        this.DrawSelectedBorder();
        if (this.DrawSelectedXBorder) this.DrawSelectedXBorder();

        var moveonPoint=null;
        if (this.LastMouseStatus && this.LastMouseStatus.MoveOnPoint) moveonPoint=this.LastMouseStatus.MoveOnPoint;
        for(var i=0;i<this.ExtendChartPaint.length;++i) //动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsCallbackDraw) continue;
            if (item.DrawAfterPicture) continue;
            if (item.IsDynamic && item.DrawAfterTitle===false && item.IsAnimation==false) 
            {
                item.Draw();
                if (item.DrawToolbar) item.DrawToolbar(moveonPoint, this.LastMouseStatus);
            }
        }

        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (item.IsDrawFirst) item.Draw();
        }

        this.DrawDrawPictureXYCoordinate();

        if (this.ChartCorssCursor)
        {
            this.ChartCorssCursor.LastPoint=this.LastPoint;
            this.ChartCorssCursor.CursorIndex=this.CursorIndex;
            if (this.EnableNewIndex)
            {
                this.ChartCorssCursor.CorssCursorIndex=this.CorssCursorIndex;
                this.ChartCorssCursor.EnableNewIndex=this.EnableNewIndex;
            }

            var bRestoreCanvas=false;
            if (this.CorssCursorCanvas) //独立的十字光标层
            {
                this.ChartCorssCursor.Canvas=this.CorssCursorCanvas;
                this.ChartCorssCursor.Canvas.clearRect(0,0,this.CorssCursorElement.width,this.CorssCursorElement.height)
                bRestoreCanvas=true;
            }

            if (option && option.Corss==false)
            {

            }
            else if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
            {
                if (this.TouchStatus.CorssCursorShow==true) this.ChartCorssCursor.Draw();
            }
            else if (this.IsOnTouch===false && this.CurrentChartDrawPicture && this.CurrentChartDrawPicture.IsShowCorssCursor===true)    //开始绘图
            {
                this.ChartCorssCursor.Draw();
            }
            else if ( !(this.IsOnTouch===false && this.CorssCursorTouchEnd===true) && !this.CurrentChartDrawPicture)
            {
                this.ChartCorssCursor.Draw();
            }
            else if (this.IsOnTouch===true && (this.CurrentChartDrawPicture && this.EnableShowCorssCursor && this.EnableShowCorssCursor.DrawPicture==true))
            {
                this.ChartCorssCursor.Draw();
            }

            if (bRestoreCanvas)
            {
                this.ChartCorssCursor.Canvas=this.Canvas;
            }
        }

        var ptPosition=null;    //鼠标位置 null 无效 -1 在外面 >=0 对应的指标窗口中ID
        if (option && option.Point && (option.ParentFunction=='OnMouseMove' || option.ParentFunction=='MoveCorssCursorIndex'))
        {
            ptPosition=this.Frame.PtInFrame(option.Point.X, option.Point.Y);
        }

        var drawStatus=this.GetDrawStatus();
        drawStatus.DrawName="DrawDynamicInfo";
        for(var i=0;i<this.TitlePaint.length;++i)
        {
            var item=this.TitlePaint[i];
            if (!item.IsDynamic) continue;

            item.CursorIndex=this.CursorIndex;
            item.LastPoint=this.LastPoint;
            if (item.OnDrawEvent) 
            {
                item.OnDrawEvent.FunctionName='DrawDynamicInfo';
                item.OnDrawEvent.PointPosition=ptPosition;
            }
            item.DrawStatus=drawStatus;

            var pointInfo=null;
            if (option && IFrameSplitOperator.IsNumber(option.ClientPos) && option.Point)   //当前鼠标所在位置的详细信息 包含盘前盘后
                pointInfo={ ClientPos:option.ClientPos, Point:{ X:option.Point.X, Y:option.Point.Y }};
            item.PointInfo=pointInfo;

            item.Draw(moveonPoint, this.LastMouseStatus);
        }

        for(var i=0;i<this.ExtendChartPaint.length;++i) //动态扩展图形   在动态标题以后画
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsCallbackDraw) continue;
            if (item.DrawAfterPicture) continue;
            if (item.ClassName=='KLineTooltipPaint' && option)
            {
                if (option.Tooltip==false) continue;
                if (option.Point) item.LatestPoint=option.Point;
            }
            else if (item.ClassName=="MinuteTooltipPaint" && option)
            {
                if (option.Point) item.LatestPoint=option.Point;
            }

            if (item.IsDynamic && item.DrawAfterTitle===true) item.Draw(moveonPoint, this.LastMouseStatus);
        }

        if (this.EnableAnimation)
        {
            for(var i=0;i<this.ExtendChartPaint.length;++i) //动画
            {
                var item=this.ExtendChartPaint[i];
                if (item.IsAnimation===true) item.Draw();
            }
        }

        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (item.IsDrawFirst) continue;
            if (item.IsDrawMain && item.IsDrawMain()) continue;
            if (this.SelectChartDrawPicture &&item.Guid==this.SelectChartDrawPicture.Guid) continue;    //选中画图最后画 确保显示在最外面

            item.Draw(moveonPoint, this.LastMouseStatus);
        }

        if (this.SelectChartDrawPicture) 
        {
            this.SelectChartDrawPicture.Draw(moveonPoint, this.LastMouseStatus);
        }

        if (this.CurrentChartDrawPicture && this.CurrentChartDrawPicture.Status!=10)
        {
            this.CurrentChartDrawPicture.Draw();
        }

        for(var i=0;i<this.ExtendChartPaint.length;++i) //动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.DrawAfterPicture) 
                item.Draw();
        }

        if (this.LastMouseStatus.MouseOnToolbar)    //工具栏按钮提示信息
        {
            var frame=this.LastMouseStatus.MouseOnToolbar.Frame;
            if (frame && frame.DrawToolbarTooltip) frame.DrawToolbarTooltip(this.LastMouseStatus.MouseOnToolbar);
        }

        this.OffscreenToShowCanvas();

        ++this.TouchDrawCount;
    }

    this.DrawAnimation=function()   //绘制动画 如弹幕
    {
        if (!this.EnableAnimation) return;

        if (this.Frame.ScreenImageData && !this.IsOnTouch)
        {
            for(var i=0;i<this.ExtendChartPaint.length;++i)
            {
                var item=this.ExtendChartPaint[i];
                if (item.IsAnimation===true) item.IsMoveStep=true;  //移动弹幕
            }

            this.DrawDynamicInfo();
        }
        
        var self=this;
        window.requestAnimationFrame(function() { self.DrawAnimation(); });
    }

    this.StartAnimation=function(option)
    {
        var bCreated=false; //是否已经创建了弹幕画法
        var barrageData=null;
        for(var i=0;i<this.ExtendChartPaint.length;++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName==='BarragePaint')
            {
                bCreated=true;
                barrageData=item.BarrageList;
                break;
            }
        }

        if (!bCreated)
        {
            var chart=new BarragePaint();
            chart.Canvas=this.Canvas;
            chart.ChartBorder=this.Frame.ChartBorder;
            chart.ChartFrame=this.Frame;
            chart.HQChart=this;
            chart.SetOption(option);
            this.ExtendChartPaint.push(chart);
            barrageData=chart.BarrageList;
        }

        this.EnableAnimation=true;
        var self=this;
        window.requestAnimationFrame(function() { self.DrawAnimation(); });

        return barrageData;
    }

    this.StopAnimation=function()
    {
        this.EnableAnimation=false;
        this.DrawDynamicInfo();
    }

    this.GetChartTooltipData=function(x,y,option)
    {
        var toolTip=new TooltipData();

        if (this.ChartInfoPaint)
        {
            if (this.ChartInfoPaint.GetTooltipData(x,y,toolTip)) 
                return toolTip;
        }

        if (this.PtInChartPaintTooltip(x,y, toolTip))
            return toolTip;

        if (IFrameSplitOperator.IsNonEmptyArray(this.Frame.SubFrame))
        {
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                var subFrame=this.Frame.SubFrame[i];
                for(var j=0;j<subFrame.OverlayIndex.length;++j)
                {
                    var overlayItem=subFrame.OverlayIndex[j];
                    for(var k=0;k<overlayItem.ChartPaint.length;++k)
                    {
                        var item=overlayItem.ChartPaint[k];
                        if (item.GetTooltipData(x,y,toolTip))
                            return toolTip;
                    }
                }
            }
        }

        if (this.PtInOverlayChartPaintTooltip(x,y,toolTip))
            return toolTip;

        if (this.PtInExtendChartPaintTooltip(x,y,toolTip))
            return toolTip;
        
        return null;
    }

    this.PtInExtendChartButtons=function(x,y)
    {
        for(var i=0;i<this.ExtendChartPaint.length; ++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.PtInButtons)
            {
                var button=item.PtInButtons(x,y);
                if (button)
                {
                    button.Chart=item;
                    return button;
                }
            }
        }

        return null;
    }

    this.ClickExtendChartButton=function(button, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_EXTENDCHART_BUTTON);
        if (event && event.Callback)
        {
            var data={ Info:button, PreventDefault:false  };    //PreventDefault 是否阻止内置的点击处理
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }
    }

    this.PtInDrawPictureButtons=function(x,y)
    {
        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (!item.PtInButtons) continue;

            var button=item.PtInButtons(x,y);
            if (button)
            {
                button.Chart=item;
                return button;
            }
        }
        return null;
    }

    this.ClickDrawPictureButton=function(button, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_DRAWPICTURE_BUTTON);
        if (event && event.Callback)
        {
            var data={ Info:button, PreventDefault:false  };    //PreventDefault 是否阻止内置的点击处理
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }

        if (button.ID==JSCHART_BUTTON_ID.DRAW_PICTURE_DELETE)
        {
            JSConsole.Chart.Log(button,"ClickDrawPictureButton");
            this.ClearChartDrawPicture(button.Chart);    //删除画图工具
        }
        else if (button.ID==JSCHART_BUTTON_ID.DRAW_PICTURE_SETTING)
        {

        }
    }

    this.PtInTitleButtons=function(x,y)
    {
        for(var i=0;i<this.TitlePaint.length;++i)
        {
            var item=this.TitlePaint[i];
            if (!item.PtInButtons) continue;

            var button=item.PtInButtons(x,y);
            if (button)
            {
                button.Chart=item;
                return button;
            }
        }

        return null;
    }

    this.OnMouseMove=function(x,y,e, isPhone)
    {
        this.StopDrawDynamicInfo();

        this.LastPoint.X=x;
        this.LastPoint.Y=y;
        var mouseStatus=null;   //鼠标状态
        var button=null;        //当前鼠标所在按钮
        var frameID=this.Frame.PtInFrame(x,y);
        if (IFrameSplitOperator.IsNumber(frameID) && frameID>=0)    //在K线内部移动,调整K线索引
            this.CursorIndex=this.Frame.GetXData(x);
        

        if (this.EnableBorderDrag && this.Frame && !this.CurrentChartDrawPicture)
        {
            var dragBorder=this.Frame.PtInFrameBorder(x,y);
            if (dragBorder && dragBorder.Index>=0)
            {
                mouseStatus={ Cursor:"n-resize", Name:"DragBorder"};
                JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] drag border ",dragBorder);
            }
        }

        if (this.EnableYDrag && this.Frame && !this.CurrentChartDrawPicture)
        {
            var dragY=this.TryYDrag(x,y);
            if (dragY)
            {
                mouseStatus={ Cursor:dragY.Position==0 ? "n-resize":"row-resize", Name:"DragY"};
                JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] drag y ",dragY);
            }
        }

        if (!this.CurrentChartDrawPicture)
        {
            button=this.PtInButton(x,y);
            if (button)
            {
                mouseStatus={ Cursor:"pointer", Name:button.Name};
                JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] frame button ", button);
            }
        }

        if (this.ChartCorssCursor)
        {
            var crossButton=this.ChartCorssCursor.PtInButton(x,y);
            if (crossButton)
            {
                mouseStatus={ Cursor:"pointer", Name:"CorssCursorButton"};
                JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] cross cursor button ", crossButton);
            }
        }

        if (this.ClassName=="KLineChartContainer"  && this.Frame.PtInFrameBottom(x,y))
        {
            mouseStatus={ Cursor:"ew-resize", Name:"FrameButtom"};
            JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] frame bottom ");
        }

        if (this.SelectedChart.EnableMoveOn && this.PtInChart && !this.CurrentChartDrawPicture)
        {
            var chartInfo=this.PtInChart(x,y);
            if (chartInfo && chartInfo.Identify)
            {
                mouseStatus={ Cursor:"pointer", Name:"PtInChart"};
                this.SelectedChart.MoveOn.Identify=chartInfo.Identify;
                this.SelectedChart.MoveOn.Identify=null;
                JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] Point in chart ", chartInfo);
            }
            else
            {
                this.SelectedChart.MoveOn.Identify=null;
            }
        }
        else
        {
            this.SelectedChart.MoveOn.Identify=null;
        }


        //区间选择
        var paint=this.GetRectSelectPaint();
        if (paint && paint.GetPointCount()>0)
        {
            var item=paint.PtInPaint(x,y);
            if (item)
            {
                if (item.Type==4) mouseStatus={ Cursor:"pointer", Name:"DragRectSelect"};   //子区域选中
                else mouseStatus={ Cursor:"ew-resize", Name:"DragRectSelect" };
                JSConsole.Chart.Log("[JSChartContainer::OnMouseMove] drag rect select ",item);
            }
        }

        
        var sendData={ MouseStatus:null, X:x, Y:y, FrameID:frameID, e:e };
        if (this.TryMouseMove_CustomChartDrag(sendData))
        {
            if (sendData.MouseStatus) 
                mouseStatus=sendData.MouseStatus;
        }
        
        var bDrawPicture=false; //是否正在画图
        if (this.CurrentChartDrawPicture)
        {
            var index=this.Frame.PtInChartFrame(x,y);
            if (this.CurrentChartDrawPicture.Status!=20)
            {
                var bDrawValid=false;   //是否在有效绘图区域里面
                if (IFrameSplitOperator.IsNumber(this.CurrentChartDrawPicture.LimitFrameID))
                {
                    if (index>=0 && index==this.CurrentChartDrawPicture.LimitFrameID) bDrawValid=true;
                }
                else
                {
                    if (index>=0) bDrawValid=true;
                }

                mouseStatus={ Cursor:bDrawValid ? "crosshair":"not-allowed", Name:"CurrentChartDrawPicture"};
            }

            if (this.CurrentChartDrawPicture.SetLastPoint) this.CurrentChartDrawPicture.SetLastPoint({X:x,Y:y});
            bDrawPicture=true;
        }
        else
        {
            var drawPictrueData={};
            drawPictrueData.X=x;
            drawPictrueData.Y=y;
            if (this.GetChartDrawPictureByPoint(drawPictrueData) && drawPictrueData.ChartDrawPicture) 
            {
                if (this.EnableEraseChartDrawPicture)
                {
                    this.SetCursor({Cursor:"grabbing"});
                }
                else
                {
                    if (drawPictrueData.ChartDrawPicture.EnableMove==true)
                    {
                        if (drawPictrueData.PointIndex===100) 
                        {
                            if (drawPictrueData.Cursor) this.SetCursor(drawPictrueData); //this.UIElement.style.cursor=drawPictrueData.Cursor;
                            else this.SetCursor({Cursor:"move"}); //this.UIElement.style.cursor="move";
                        }
                        else 
                        {
                            if (drawPictrueData.Cursor) this.SetCursor(drawPictrueData); //this.UIElement.style.cursor=drawPictrueData.Cursor
                            else this.SetCursor({Cursor:"pointer"}); //this.UIElement.style.cursor="pointer";
                        }

                        bDrawPicture=true;
                    }
                }
               
                this.MoveOnChartDrawPicture=drawPictrueData.ChartDrawPicture;
            }
            else 
            {
                if (!this.MouseDrag) 
                    this.SetCursor({Cursor:"default"}); //this.UIElement.style.cursor="default";
            }
        }

        var clientPos=this.PtInClient(x,y);
        var option={ ParentFunction:'OnMouseMove', Point:{X:x, Y:y}, IsPhone:isPhone===true, ClientPos:clientPos };
        if ((e && (e.type=="mouseout" || e.type=="mouseleave")) || button) option.Corss=false; //鼠标移开,在按钮上,不显示十字光标

        if (this.SetCorssCursorIndex) this.SetCorssCursorIndex(option);

        if (this.DrawDynamicInfoOption.Enable)
        {
            this.DrawDynamicInfoOption.Timer=setTimeout(()=>
            {
                this.DrawDynamicInfo(option);
    
            },this.DrawDynamicInfoOption.DelayTime);
        }
        else
        {
            this.DrawDynamicInfo(option);
        }
       
        this.SetCursor(mouseStatus);

        if (this.IsShowTooltip && bDrawPicture==false)
        {
            var toolTip=this.GetChartTooltipData(x,y);

            if (toolTip && toolTip.Data)
            {
                if (isPhone===true)
                {
                    var touche=e.touches[0];
                    var xTooltip = touche.clientX-this.UIElement.getBoundingClientRect().left;
                    var yTooltip = touche.clientY-this.UIElement.getBoundingClientRect().top;
                }
                else
                {
                    var xTooltip = e.clientX-this.UIElement.getBoundingClientRect().left;
                    var yTooltip = e.clientY-this.UIElement.getBoundingClientRect().top;
                }
                this.ShowTooltip(xTooltip,yTooltip,toolTip);
            }
            else
            {
                this.HideTooltip();
            }
        }
    }

    //设置鼠标形状 {Cursor:鼠标形状 }
    this.SetCursor=function(obj)
    {
        if (!obj || !obj.Cursor) return;

        if (obj.Cursor=="default") 
            this.UIElement.style.cursor=this.DefaultCursor;
        else
            this.UIElement.style.cursor=obj.Cursor;
    }

    this.OnKeyDown=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        //回调事件
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_KEYDOWN);
        if (event && event.Callback)
        {
            var sendData={ e:e, PreventDefault:false };
            event.Callback(event, sendData, this);
            if (sendData.PreventDefault) return;
        }
        
        var keyID = e.keyCode ? e.keyCode :e.which;
        switch(keyID)
        {
            case 37: //left
                if (e.ctrlKey && this.OnCustomKeyDown)
                {
                    if (this.OnCustomKeyDown(keyID, e))
                        break;
                }

                if (this.CursorIndex<=0.99999)
                {
                    if (!this.DataMoveLeft()) 
                    {   //左移数据到头了 触发下载新数据
                        if (this.DragDownloadData) this.DragDownloadData();
                        break;
                    }
                    this.UpdataDataoffset();
                    this.UpdatePointByCursorIndex();
                    this.UpdateFrameMaxMin();
                    this.ResetFrameXSplit();
                    this.Draw();
                    this.ShowTooltipByKeyDown();
                    this.OnKLinePageChange("keydown");
                }
                else
                {
                    --this.CursorIndex;
                    this.UpdatePointByCursorIndex();
                    this.DrawDynamicInfo();
                    this.ShowTooltipByKeyDown();
                }
                break;
            case 39: //right
                if (e.ctrlKey && this.OnCustomKeyDown)
                {
                    if (this.OnCustomKeyDown(keyID, e))
                        break;
                }

                var xPointcount=0;
                if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
                else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
                if (this.CursorIndex+1>=xPointcount)
                {
                    if (!this.DataMoveRight()) break;
                    this.UpdataDataoffset();
                    this.UpdatePointByCursorIndex();
                    this.UpdateFrameMaxMin();
                    this.ResetFrameXSplit();
                    this.Draw();
                    this.ShowTooltipByKeyDown();
                    this.OnKLinePageChange("keydown");
                }
                else
                {
                    //判断是否在最后一个数据上
                    var data=null;
                    if (this.Frame.Data) data=this.Frame.Data;
                    else data=this.Frame.SubFrame[0].Frame.Data;
                    if (!data) break;
                    if (this.CursorIndex+data.DataOffset+1>=data.Data.length) break;

                    ++this.CursorIndex;
                    this.UpdatePointByCursorIndex();
                    this.DrawDynamicInfo();
                    this.ShowTooltipByKeyDown();
                }
                break;
            case 38:    //up
                if (this.EnableZoomUpDown && this.EnableZoomUpDown.Keyboard===false) break;
                var cursorIndex={ ZoomType:this.ZoomType, IsLockRight:this.IsZoomLockRight };
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (!this.Frame.ZoomUp(cursorIndex)) break;
                this.CursorIndex=cursorIndex.Index;
                this.UpdatePointByCursorIndex();
                this.UpdataDataoffset();
                this.UpdateFrameMaxMin();
                this.ResetFrameXSplit();
                this.Draw();
                this.ShowTooltipByKeyDown();
                this.OnKLinePageChange("keydown");
                break;
            case 40:    //down
                if (this.EnableZoomUpDown && this.EnableZoomUpDown.Keyboard===false) break;
                var cursorIndex={ ZoomType:this.ZoomType ,IsLockRight:this.IsZoomLockRight };
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (!this.Frame.ZoomDown(cursorIndex, { ZoomDownloadDataCallback:(requestData)=>{ this.ZoomDownloadData(requestData) } })) break;
                
                this.CursorIndex=cursorIndex.Index;
                this.UpdataDataoffset();
                this.UpdatePointByCursorIndex();
                this.UpdateFrameMaxMin();
                this.ResetFrameXSplit();
                if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true)
                {
                    
                }
                else
                {
                    this.Draw();
                }
                this.ShowTooltipByKeyDown();
                this.OnKLinePageChange("keydown");
                
                break;
            case 46:    //del
                if (this.SelectChartDrawPicture)
                {
                    var drawPicture=this.SelectChartDrawPicture;
                    JSConsole.Chart.Log("[JSChartContainer::OnKeyDown] delete draw picture.");
                    this.SelectChartDrawPicture=null;
                    if (this.ChartPictureMenu) this.ChartPictureMenu.Hide();
                    this.ClearChartDrawPicture(drawPicture);        //删除选中的画图工具
                    this.CloseModifyDrawDialog();
                }
                else if (this.SelectedChart && this.SelectedChart.Selected.Identify)
                {
                    var selectedInfo=this.GetSelectedChartInfo(this.SelectedChart.Selected);
                    if (selectedInfo)
                    {
                        if (selectedInfo.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_INDEX)
                            this.DeleteOverlayWindowsIndex(selectedInfo.IndexID);
                        else if (selectedInfo.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_KLINE)
                            this.DeleteOverlaySymbol(selectedInfo.Symbol);
                    }
                }
                break;
            case 32:    //space
                this.OnMarkRectSelect(e);
                break;
            case 27:      //ESCAPE  取消画布工具
                if (this.CurrentChartDrawPicture)
                {
                    var drawPicture=this.CurrentChartDrawPicture;
                    if (drawPicture.Status!=20) //画布移动的时候不能取消
                        this.CurrentChartDrawPicture=null;
                }
                break;
            default:
                return;
        }

        //不让滚动条滚动
        if(e.preventDefault) e.preventDefault();
        else e.returnValue = false;
    }

    this.OnDoubleClick=function(x,y,e)
    {
        //JSConsole.Chart.Log(e);
    }

    this.ZoomIndexWindow=function(frameID, option)   //最大化/最小化指标窗口 
    {
        if (frameID<0 || frameID>=this.Frame.SubFrame.length) return false;

        return this.Frame.ZoomIndexWindow(frameID, option);
    }

    this.ShowIndexTitleOnly=function(frameID, option)      //只显示指标的标题
    {
        if (frameID<0 || frameID>=this.Frame.SubFrame.length) return false;
        return this.Frame.ShowIndexTitleOnly(frameID, option);
    }

    this.RemoveMinSizeWindows=function()    //清空最小化窗口
    {
        if (!this.Frame.ZoomWindowsInfo) return;

        var aryDeleteIndex=[], aryIndex=[]; //删除的索引， 保留的索引
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            item.Frame.ClearToolbar();
            if (item.Frame.IsMinSize) 
                aryDeleteIndex.push(i);
            else 
                aryIndex.push(i);
        }
        this.Frame.ZoomWindowsInfo=null;
        if (aryDeleteIndex.length<=0) return;

        for(var i=0;i<aryDeleteIndex.length;++i)
        {
            this.DeleteIndexPaint(aryDeleteIndex[i]);
        }

        var newSubFrame=[];
        var newWindowIndex=[];
        var newTitlePaint=[this.TitlePaint[0]];
        for(var i=0;i<aryIndex.length;++i)
        {
            var id=aryIndex[i];
            newSubFrame[i]=this.Frame.SubFrame[id];
            newWindowIndex[i]=this.WindowIndex[id];
            newTitlePaint[i+1]=this.TitlePaint[id+1];
        }
        this.Frame.SubFrame=newSubFrame;
        this.WindowIndex=newWindowIndex;
        this.TitlePaint=newTitlePaint;

        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;

            item.Identify=i;
        }

        if (IFrameSplitOperator.IsNonEmptyArray(this.ChartDrawPicture))
        {
            var aryDrawPicture=[];
            for(var i=0; i<this.ChartDrawPicture.length; ++i)
            {
                var item=this.ChartDrawPicture[i];
                for(var j=0; j<this.Frame.SubFrame.length; ++j)
                {
                    if (item.Frame==this.Frame.SubFrame[j].Frame)
                    {
                        aryDrawPicture.push(item);
                        break;
                    }
                }
            }
            this.ChartDrawPicture=aryDrawPicture;
        }

    }

    this.PtInClient=function(x,y)
    {
        this.Canvas.beginPath();
        if (this.Frame.IsHScreen===true)
        {
            var border=this.Frame.ChartBorder.GetHScreenBorder();
            if (border.DayBorder)   //多日分时+多日集合竞价
            {
                var width=border.Right-border.Left;
                for(var i=0;i<border.DayBorder.length;++i)
                {
                    var client=border.DayBorder[i];
                    this.Canvas.beginPath();
                    this.Canvas.rect(border.Left,client.TopEx,width,client.BottomEx-client.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 1;

                    //盘前
                    this.Canvas.beginPath();
                    this.Canvas.rect(border.Left,client.Top,width,client.TopEx-client.Top);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 200+parseInt(i);

                    //盘后
                    this.Canvas.beginPath();
                    this.Canvas.rect(border.Left,client.BottomEx,width,client.Bottom-client.BottomEx);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 300+parseInt(i);
                }

                return -1;
            }

            this.Canvas.rect(border.Left,border.TopEx,border.Right-border.Left,border.BottomEx-border.TopEx);
        }
        else
        {
            var border=this.Frame.ChartBorder.GetBorder();
            if (border.DayBorder)   //多日分时+多日集合竞价
            {
                for(var i=0;i<border.DayBorder.length;++i)
                {
                    var client=border.DayBorder[i];

                    //盘前
                    this.Canvas.beginPath();
                    this.Canvas.rect(client.Left,border.TopEx,client.LeftEx-client.Left,border.BottomEx-border.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 200+parseInt(i);

                    //盘中
                    this.Canvas.beginPath();
                    this.Canvas.rect(client.LeftEx,border.TopEx,client.RightEx-client.LeftEx,border.BottomEx-border.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) return 1;
                    
                    //盘后
                    this.Canvas.beginPath();
                    this.Canvas.rect(client.RightEx,border.TopEx,client.Right-client.RightEx,border.BottomEx-border.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 300+parseInt(i);
                }

                return -1;
            }

            this.Canvas.rect(border.LeftEx,border.Top,border.RightEx-border.LeftEx,border.Bottom-border.Top);
        }

        if (this.Canvas.isPointInPath(x,y)) return 1;

        if (this.Frame.ChartBorder.LeftExtendWidth>10)
        {
            this.Canvas.beginPath();
            if (this.Frame.IsHScreen===true)
            {
                this.Canvas.rect(border.Left,border.Top,border.Right-border.Left,border.TopEx-border.Top);
            }
            else
            {
                this.Canvas.rect(border.Left,border.Top,border.LeftEx-border.Left,border.Bottom-border.Top);
            }
    
            if (this.Canvas.isPointInPath(x,y)) return 2;
        }

        if (this.Frame.ChartBorder.RightExtendWidth>10)
        {
            this.Canvas.beginPath();
            if (this.Frame.IsHScreen===true)
            {
                this.Canvas.rect(border.Left,border.BottomEx,border.Right-border.Left,border.Bottom-border.BottomEx);
            }
            else
            {
                this.Canvas.rect(border.RightEx,border.Top,border.Right-border.RightEx,border.Bottom-border.Top);
            }
    
            if (this.Canvas.isPointInPath(x,y)) return 3;
        }

        return -1;
    }

    this.OnMoveFromeBorder=function(index, yMove)
    {
        if (!this.Frame) return;

        if (!this.Frame.OnMoveFromeBorder(index,yMove)) return ;

        //this.Frame.SetSizeChage(true);
        this.Frame.SetFrameBorderSizeChange();
        this.Frame.ReDrawToolbar();
        this.Draw();
    }

    this.OnZoomUpDownFrameY=function(obj, yMove)
    {
        if (!this.Frame) return;

        if (!this.Frame.OnZoomUpDownFrameY(obj,yMove)) return ;

        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    this.OnUpDonwFrameY=function(obj, yMove)
    {
        if (!this.Frame) return false;

        if (!this.Frame.OnUpDonwFrameY(obj,yMove)) return false;

        this.Frame.SetSizeChage(true);

        return true;
    }

    this.CancelZoomUpDownFrameY=function(obj)
    {
        if (!this.Frame) return;

        if (!this.Frame.CancelZoomUpDownFrameY(obj)) return ;

        this.UpdateFrameMaxMin();
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    this.IsKLineContainer=function()
    {
        if (this.ClassName=='KLineChartContainer' || this.ClassName=='KLineChartHScreenContainer' ||
            this.ClassName=="KLineTrainChartContainer" || this.ClassName=="CustomKLineChartContainer" ) return true;

        return false;
    }

    this.IsMinuteContainer=function()
    {
        if (this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer") return true;

        return false;
    }

    this.UpdatePointByCursorIndex=function(type)    //type 1=根据十字光标更新 2=强制取消十字光标
    {
        var pt={X:null, Y:null};
        pt.X=this.Frame.GetXFromIndex(this.CursorIndex);
        var index=Math.abs(this.CursorIndex-0.5);
        if (this.IsKLineContainer()) index=this.CursorIndex;

        var data=this.Frame.Data;
        if (data.DataOffset+index<data.Data.length)
        {
            var close=data.Data[data.DataOffset+index].Close;
            pt.Y=this.Frame.GetYFromData(close);
        }
       
        if (type==1 && this.ChartCorssCursor)
        {
            if (this.ChartCorssCursor.Status==1)    //十字光标显示中, 不调整位置
            {

            }
            else
            {
                this.LastPoint.X=this.Frame.GetXFromIndex(this.CursorIndex);
                var index=Math.abs(this.CursorIndex-0.5);
                index=parseInt(index.toFixed(0));
                if (this.IsKLineContainer()) index=this.CursorIndex;
                this.LastPoint.Y=null;
            }
        }
        else if (type==2 && this.ChartCorssCursor)  //取消鼠标位置，十字光标就不显示了
        {
            this.LastPoint.Y=null;
            this.LastPoint.X=null;
        }
        else
        {
            this.LastPoint.X=pt.X;
            this.LastPoint.Y=pt.Y;
        }
    }

    this.ShowTooltipByKeyDown=function()
    {
        var index=Math.abs(this.CursorIndex-0.5);
        index=parseInt(index.toFixed(0));
        if (this.ClassName=='KLineChartContainer' || this.ClassName=='KLineTrainChartContainer') index=this.CursorIndex;

        var data=this.Frame.Data;
        var toolTip=new TooltipData();
        toolTip.Data=data.Data[data.DataOffset+index];
        toolTip.ChartPaint=this.ChartPaint[0];

        var pixelTatio = GetDevicePixelRatio();
        if (pixelTatio===0) pixelTatio=1;   //div 缩放还是使用原始坐标
        this.ShowTooltip(this.LastPoint.X/pixelTatio,this.LastPoint.Y/pixelTatio,toolTip);
    }

    this.ShowTooltip=function(x,y,toolTip)
    {
        if (!this.IsShowTooltip) return;

        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        var xMove=15/pixelTatio;    //顶部坐标偏移位置

        this.TooltipCache.Type=toolTip.Type;
        this.TooltipCache.Data=null;
        this.TooltipCache.X=x;
        this.TooltipCache.Y=y;

        if (toolTip.Type===0) //K线信息
        {
            if (!this.IsShowKLineDivTooltip) return;

            var scrollPos=GetScrollPosition();
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('HistoryDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.LanguageID=this.LanguageID;
            format.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            if (!format.Operator()) return;
            var textHeight=format.LineCount*25; //每行的行高25
            if (format.Height>0) textHeight=format.Height;  //新版本高度有格式化类计算完成
            var width=format.Width;

            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =textHeight+"px";
            //JSConsole.Chart.Log(`[JSChartContainer::ShowTooltip] left=${left} top=${top} xMove=${xMove}` );
            //if (toolTip.ChartPaint.Name=="Overlay-KLine")  this.Tooltip.style.height =220+"px";
            this.Tooltip.style.position = "absolute";
            //JSConsole.Chart.Log('[JSChartContainer::ShowTooltip] getBoundingClientRect() ',this.UIElement.getBoundingClientRect())
            if (left+width>this.UIElement.getBoundingClientRect().width)
                this.Tooltip.style.left = (left-width) + "px";
            else
                this.Tooltip.style.left = left + "px";
            
            if (top+xMove+textHeight>this.UIElement.getBoundingClientRect().height-5)
                this.Tooltip.style.top = (top-textHeight)+ "px";
            else this.Tooltip.style.top = (top + xMove)+ "px";
            
            this.Tooltip.className='jschart-tooltip';
            this.Tooltip.innerHTML=format.Text;
            this.Tooltip.style.display = "block";

            this.TooltipCache.IsShow=true;
            this.TooltipCache.Data={ Date:toolTip.Data.Date, Time:toolTip.Data.Time };
            this.TooltipCache.InnerHTML=format.Text;
        }
        else if (toolTip.Type===1)   //信息地雷提示信息
        {
            var scrollPos=GetScrollPosition();
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('KLineInfoDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-klineinfo-tooltip';
            this.Tooltip.style.position = "absolute";
            if(left+width>this.UIElement.getBoundingClientRect().width){
                this.Tooltip.style.left = (left-width) + "px";
            }else{
                this.Tooltip.style.left = left + "px";
            }
            
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;
            this.Tooltip.style.display = "block";
        }
        else if (toolTip.Type==2)   //指标信息
        {
            var left = x;
            var top = y;
            
            var format=g_DivTooltipDataForamt.Create('KLineTradeDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-klinetrade-tooltip';
            this.Tooltip.style.position = "absolute";
            this.Tooltip.style.left = left + "px";
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;;
            this.Tooltip.style.display = "block";
        }
        else if (toolTip.Type==3)   //分时图异动信息
        {
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('MinuteInfoDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-minuteinfo-tooltip'; //分时图异动
            this.Tooltip.style.position = "absolute";
            this.Tooltip.style.left = left + "px";
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;;
            this.Tooltip.style.display = "block";
        }
        else if (toolTip.Type==4)   //icon图标信息
        {
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('IconDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-iconinfo-tooltip'; //图标信息
            this.Tooltip.style.position = "absolute";
            this.Tooltip.style.left = left + "px";
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;;
            this.Tooltip.style.display = "block";
        }
        else if (toolTip.Type==5)
        {
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('ChartOXDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.Period=this.Period;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-chartox-tooltip'; //OX指标数据
            this.Tooltip.style.position = "absolute";
            this.Tooltip.style.left = left + "px";
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;;
            this.Tooltip.style.display = "block";
        }
        else if (toolTip.Type==6)   //散点图
        {
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('ScatterPlotDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.Period=this.Period;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-charscatterplot-tooltip'; //OX指标数据
            this.Tooltip.style.position = "absolute";
            this.Tooltip.style.left = left + "px";
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;;
            this.Tooltip.style.display = "block";
        }
        else if (toolTip.Type==7)   //ChartDrawSVG
        {
            var left = x;
            var top = y;

            var format=g_DivTooltipDataForamt.Create('ChartDrawSVGDataStringFormat');
            format.Value=toolTip;
            format.Symbol=this.Symbol;
            format.Period=this.Period;
            format.LanguageID=this.LanguageID;
            if (!format.Operator()) return;
            var width=format.Width;

            this.Tooltip.className='jchart-chartdrawsvg-tooltip'; //ChartDrawSVG指标数据
            this.Tooltip.style.position = "absolute";
            this.Tooltip.style.left = left + "px";
            this.Tooltip.style.top = (top +xMove)+ "px";
            this.Tooltip.style.width = width+"px";
            this.Tooltip.style.height =null;
            this.Tooltip.innerHTML=format.Text;
            this.Tooltip.style.display = "block";
        }
    }

    this.UpdateDOMTooltip=function(toolTipType, data)
    {
        if (!this.TooltipCache.IsShow) return ;
        if (this.TooltipCache.Type!=toolTipType) return;
        if (!this.TooltipCache.Data) return;

        if (this.TooltipCache.Type===0)
        {
            if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) return;
            var lastItem=data.Data[data.Data.length-1];
            if (lastItem.Date!=this.TooltipCache.Data.Date) return;
            if (IFrameSplitOperator.IsNumber(lastItem.Time) && lastItem.Time!=this.TooltipCache.Data.Time) return;
            var klinePaint=this.ChartPaint[0];

            var format=g_DivTooltipDataForamt.Create('HistoryDataStringFormat');
            format.Value={ Data:lastItem, ChartPaint:klinePaint, Type:this.TooltipCache.Type };
            format.Symbol=this.Symbol;
            format.LanguageID=this.LanguageID;
            format.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            if (!format.Operator()) return;
            if (format.Text==this.TooltipCache.InnerHTML) return;
            this.Tooltip.innerHTML=format.Text;
            this.TooltipCache.InnerHTML=format.Text;
        }
    }

    this.HideTooltip=function()
    {
        this.TooltipCache.IsShow=false;
        this.TooltipCache.Type=null;
        this.TooltipCache.InnerHTML=null;
        this.TooltipCache.Data=null;

        if (this.Tooltip.style.display!="none") this.Tooltip.style.display = "none";
    }

    this.UpdateSelectRect=function(start,end)
    {
        if (!this.ChartPaint[0].Data) return;
        var paint=this.GetRectSelectPaint();
        if (!paint) return;

        var data=this.ChartPaint[0].Data;
        var startItem=data.Data[start];
        var endItem=data.Data[end];

        JSConsole.Chart.Log('[JSChartContainer::UpdateSelectRect]',startItem,endItem);
        paint.SetPoint(startItem, { Index:0, DataIndex:start });
        paint.SetPoint(endItem, { Index:1, DataIndex:end });

        this.Draw();
    }

    this.HideSelectRect=function()
    {
        this.ClearDragSelectRect();
    }

    this.ResetFrameXYSplit=function()
    {
        if (typeof(this.Frame.ResetXYSplit)=='function')
            this.Frame.ResetXYSplit();
    }

    this.ResetFrameXSplit=function()
    {
        if (typeof(this.Frame.ResetXSplit)=='function')
            this.Frame.ResetXSplit();
    }

    this.UpdateFrameMaxMinV2=function()
    {
        var mapFrame=new Map(); //key=frameid, value:{ ChartPaint:[] }
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var subItem=this.Frame.SubFrame[i];
            if (!subItem || !subItem.Frame) continue;

            var frame=subItem.Frame;

            //自定义刻度每次都调用
            frame.YCustomSplit=true;

            var key=frame.Identify;
            var item=
            { 
                ID:key, Frame:frame, ChartPaint:[] , Max:null, Min:null, 
                OverlayFrame:[],        //共享坐标
                SingleOverlay:[],       //独立坐标
                MainOverlayFrame:[null, null],  //叠加坐标在主坐标显示[0]=left [1]=right
            };

            for(var j=0;j<subItem.OverlayIndex.length;++j)
            {
                var overlayItem=subItem.OverlayIndex[j];
                var overlayFrame=overlayItem.Frame;

                if (overlayFrame.IsShowMainFrame===1) item.MainOverlayFrame[0]= overlayFrame;
                else if (overlayFrame.IsShowMainFrame===2) item.MainOverlayFrame[1]= overlayFrame;

                if (overlayFrame.IsShareY)
                {
                    if (!overlayFrame.MainFrame) continue;
                    if (overlayFrame.IsCalculateYMaxMin===false) continue;  //叠加坐标Y轴不调整
                    item.OverlayFrame.push(overlayFrame);
                    for(var k=0; k<overlayItem.ChartPaint.length; ++k)
                    {
                        var chart=overlayItem.ChartPaint[k];
                        item.ChartPaint.push(chart);
                    }
                }
                else
                {
                    item.SingleOverlay.push(overlayItem);
                }
            }

            mapFrame.set(key, item);
        }

        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var chart=this.ChartPaint[i];
            var key=chart.ChartFrame.Identify;
            if (!mapFrame.has(key)) continue;

            var finder=mapFrame.get(key);
            finder.ChartPaint.push(chart);
        }

        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var chart=this.OverlayChartPaint[i];
            if (!chart.ChartFrame) continue;
            var key=chart.ChartFrame.Identify;
            if (!mapFrame.has(key)) continue;

            var finder=mapFrame.get(key);
            finder.ChartPaint.push(chart);
        }

        for(var mapItem of mapFrame)
        {
            var item=mapItem[1];
            var frame=item.Frame;
            //计算主框架最大最小
            for(var i=0;i<item.ChartPaint.length;++i)   
            {
                var chart=item.ChartPaint[i];
                if (chart.IsShow==false) continue;      //隐藏的图形不计算
                if (chart.NotSupportMessage)  continue;
                if (!chart.ChartFrame) continue;
                if (chart.IsExcludeYValue===true) continue;

                var range=chart.GetMaxMin();
                if (range==null || range.Max==null || range.Min==null) continue;

                if (item.Max==null || item.Max<range.Max) item.Max=range.Max;
                if (item.Min==null || item.Min>range.Min) item.Min=range.Min;
            }

            if (item.Frame.YSpecificMaxMin) //固定坐标
            {
                item.Min=item.Frame.YSpecificMaxMin.Max;
                item.Max=item.Frame.YSpecificMaxMin.Min;
            }

            if (!IFrameSplitOperator.IsNumber(frame.YMaxMin.Max) || frame.YMaxMin.Max!=item.Max)
            {
                frame.YMaxMin.Max=item.Max;
                frame.XYSplit=true;
            }

            if (!IFrameSplitOperator.IsNumber(frame.YMaxMin.Min) || frame.YMaxMin.Min!=item.Min)
            {
                frame.YMaxMin.Min=item.Min
                frame.XYSplit=true;
            }

            if (frame.XYSplit)
            {
                var max=10, min=0;
                if (item.Max!=null) max=item.Max;
                if (item.Min!=null) min=item.Min;
    
                frame.HorizontalMax=max;
                frame.HorizontalMin=min;  
            }
            else
            {
                frame.XSplit=true;
            }

            //共享Y轴叠加指标同步下坐标
            for(var j=0;j<item.OverlayFrame.length;++j)
            {
                item.OverlayFrame[j].XYSplit=true;
            }

            //叠加坐标显示在主图坐标 需要同步
            for(var i=0;i<item.MainOverlayFrame.length;++i)
            {
                var subItem=item.MainOverlayFrame[i];
                if (subItem) subItem.XYSplit=true;
            }

            //独立坐标叠加指标
            for(var i=0;i<item.SingleOverlay.length;++i)
            {
                var overlayItem=item.SingleOverlay[i];
                overlayItem.UpdateFrameMaxMin();
            }
        }
    }

    this.UpdateFrameMaxMin=function()
    {
        this.UpdateFrameMaxMinV2();

        return;

        var frameMaxMinData=new Array();

        var chartPaint=new Array();

        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            if (item.IsShow==false) continue;   //隐藏的图形不计算
            chartPaint.push(this.ChartPaint[i]);
        }

        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            chartPaint.push(this.OverlayChartPaint[i]);
        }


        var aryNotSupport=[];
        for(var i=0;i<chartPaint.length;++i)
        {
            var paint=chartPaint[i];
            if (paint.NotSupportMessage) 
            {
                aryNotSupport.push(paint);
                continue;
            }

            var range=paint.GetMaxMin();
            if (range==null || range.Max==null || range.Min==null) continue;

            var frameItem=null;
            for(var j=0; j<frameMaxMinData.length; ++j)
            {
                if (frameMaxMinData[j].Frame==paint.ChartFrame)
                {
                    frameItem=frameMaxMinData[j];
                    break;
                }
            }

            if (frameItem)
            {
                if (frameItem.Range.Max<range.Max) frameItem.Range.Max=range.Max;
                if (frameItem.Range.Min>range.Min) frameItem.Range.Min=range.Min;
            }
            else
            {
                frameItem={ OverlayFrame:[] };
                frameItem.Frame=paint.ChartFrame;
                frameItem.Range=range;
                frameMaxMinData.push(frameItem);
            }
        }

        //当前计算
        for(var i=0;i<aryNotSupport.length;++i)
        {
            var paint=aryNotSupport[i];
            var range={Max:10, Min:1 };

            var frameItem=null;
            for(var j=0; j<frameMaxMinData.length; ++j)
            {
                if (frameMaxMinData[j].Frame==paint.ChartFrame)
                {
                    frameItem=frameMaxMinData[j];
                    break;
                }
            }

            if (frameItem) continue;

            frameItem={ OverlayFrame:[] };
            frameItem.Frame=paint.ChartFrame;
            frameItem.Range=range;
            frameMaxMinData.push(frameItem);
        }

        var mapFrame=new Map();
        for(var i=0;i<frameMaxMinData.length;++i)
        {
            var item=frameMaxMinData[i];
            mapFrame.set(item.Frame.Identify,item);
        }

        //叠加坐标Y轴使用主图指标， 最大最小值
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var subFrame=this.Frame.SubFrame[i];
            for(var j=0;j<subFrame.OverlayIndex.length;++j)
            {
                var overlayItem=subFrame.OverlayIndex[j];
                var overlayFrame=overlayItem.Frame;
                if (overlayFrame.IsShareY!=true) continue;
                if (!overlayFrame.MainFrame) continue;
                if (!mapFrame.has(overlayFrame.MainFrame.Identify)) continue;

                var frameItem=mapFrame.get(overlayFrame.MainFrame.Identify);
                if (!frameItem) continue;
                frameItem.OverlayFrame.push(overlayFrame);
                if (overlayFrame.IsCalculateYMaxMin===false) continue;  //叠加坐标Y轴不调整

                for(var k=0; k<overlayItem.ChartPaint.length; ++k)
                {
                    var paint=overlayItem.ChartPaint[k];
                    if (paint.IsShow==false) 
                        continue;   //隐藏的图形不计算
                    var range=paint.GetMaxMin();
                    if (range==null || range.Max==null || range.Min==null) continue;

                    if (frameItem.Range.Max<range.Max) frameItem.Range.Max=range.Max;
                    if (frameItem.Range.Min>range.Min) frameItem.Range.Min=range.Min;
                }
            }
        }

        for(var i=0;i<frameMaxMinData.length;++i)
        {
            var item=frameMaxMinData[i];
            if (!item.Frame || !item.Range) continue;
            if (item.Range.Max==null || item.Range.Min==null) continue;
            if (item.Frame.YSpecificMaxMin)
            {
                item.Frame.HorizontalMax=item.Frame.YSpecificMaxMin.Max;
                item.Frame.HorizontalMin=item.Frame.YSpecificMaxMin.Min;
            }
            else
            {
                item.Frame.HorizontalMax=item.Range.Max;
                item.Frame.HorizontalMin=item.Range.Min;
            }
            item.Frame.XYSplit=true;

            for(var j in item.OverlayFrame)
            {
                item.OverlayFrame[j].XYSplit=true;
            }
        }

        

        //更新独立子坐标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var subFrame=this.Frame.SubFrame[i];
            for(var j=0;j<subFrame.OverlayIndex.length;++j)
            {
                var overlayItem=subFrame.OverlayIndex[j];
                if (overlayItem.Frame.IsShareY===true) continue;
                overlayItem.UpdateFrameMaxMin();
            }
        }
    }

    this.DataMoveLeft=function()
    {
        var data=null;
        if (!this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return false;
        if (data.DataOffset<=0) return false;
        --data.DataOffset;
        return true;
    }

    this.DataMoveRight=function()
    {
        var data=null;
        if (!this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return false;

        var xPointcount=0;
        if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
        else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
        if (!xPointcount) return false;

        if (xPointcount+data.DataOffset>=data.Data.length) return false;

        ++data.DataOffset;
        return true;
    }

    this.UpdataDataoffset=function()
    {
        var data=null;
        if (this.Frame.Data)
            data=this.Frame.Data;
        else
            data=this.Frame.SubFrame[0].Frame.Data;

        if (!data) return;

        for(var i in this.ChartPaint)
        {
            var item =this.ChartPaint[i];
            if (!item.Data) continue;
            item.Data.DataOffset=data.DataOffset;
        }

        for(var i in this.OverlayChartPaint)
        {
            var item =this.OverlayChartPaint[i];
            if (!item.Data) continue;
            item.Data.DataOffset=data.DataOffset;
        }

        //叠加指标当前显示的数据偏移
        for (var i in this.Frame.SubFrame)
        {
            var subFrame=this.Frame.SubFrame[i];
            for(var j in subFrame.OverlayIndex)
            {
                var overlayItem=subFrame.OverlayIndex[j];
                for(var k in overlayItem.ChartPaint)
                {
                    var item=overlayItem.ChartPaint[k];
                    if (!item.Data) continue;
                    item.Data.DataOffset=data.DataOffset;
                }
            }
        }

    }

    this.GetMoveOneStepWidth=function()
    {
        if (IFrameSplitOperator.IsPlusNumber(this.StepPixel)) return this.StepPixel;
        
        var pixelRatio=GetDevicePixelRatio();
        var mainFrame=this.Frame.SubFrame[0].Frame;
        var dataWidth=mainFrame.DataWidth;
        var distanceWidth=mainFrame.DistanceWidth;
        var oneStepWidth=this.StepPixel;
        var oneStepWidth=(dataWidth+distanceWidth)/pixelRatio;
        if (oneStepWidth<1) oneStepWidth=1;

        return oneStepWidth;
    }

    this.DataMove=function(step,isLeft)
    {
        var oneStepWidth=this.GetMoveOneStepWidth();
        var moveStep=step;
        step=parseInt(step/oneStepWidth);  //除以4个像素
        if (step<=0) return false;

        var data=null;
        if (!this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return false;

        var xPointcount=0;
        if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
        else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
        if (!xPointcount) return false;

        if (this.Frame.SubFrame && this.Frame.SubFrame.length>0 && this.Frame.SubFrame[0].Frame)
        {
            var fristFrame=this.Frame.SubFrame[0].Frame;
            if (fristFrame.DataWidth<=1 || fristFrame.DistanceWidth<=1) //K线在缩放很小的时候 移动加速
            {
                if (IFrameSplitOperator.IsPlusNumber(this.StepPixel))
                    step=parseInt(moveStep)*this.StepPixel;
            }
               
        }

        if (isLeft) //-->
        {
            if (this.RightSpaceCount>0)
            {
                if (xPointcount+data.DataOffset>=data.Data.length+this.RightSpaceCount) return false;
                data.DataOffset+=step;

                if (data.DataOffset+xPointcount>=data.Data.length+this.RightSpaceCount)
                    data.DataOffset=data.Data.length-(xPointcount-this.RightSpaceCount);
            }
            else
            {
                if (xPointcount+data.DataOffset>=data.Data.length) return false;
                data.DataOffset+=step;

                if (data.DataOffset+xPointcount>=data.Data.length)
                    data.DataOffset=data.Data.length-xPointcount;
            }
            return true;
        }
        else        //<--
        {
            if (data.DataOffset<=0) return false;

            data.DataOffset-=step;
            if (data.DataOffset<0) data.DataOffset=0;

            return true;
        }
    }

    this.XCoordinateZoom=function(step, isMoveLeft)
    {
        var oneStepWidth=this.GetMoveOneStepWidth();
        var moveStep=step;
        step=parseInt(step/oneStepWidth);  //除以4个像素
        if (step<=0) return false;

        return this.Frame.XCoordinateZoom(isMoveLeft);
    }

    //获取鼠标在当前子窗口id
    this.GetSubFrameIndex=function(x,y)
    {
        if (!this.Frame.SubFrame || this.Frame.SubFrame.length<=0) return -1;

        for(var i in this.Frame.SubFrame)
        {
            var frame=this.Frame.SubFrame[i].Frame;
            var left=frame.ChartBorder.GetLeft();
            var top=frame.ChartBorder.GetTop();
            var height=frame.ChartBorder.GetHeight();
            var width=frame.ChartBorder.GetWidth();

            this.Canvas.beginPath();
            this.Canvas.rect(left,top,width,height);
            if (this.Canvas.isPointInPath(x,y)) return parseInt(i);

        }
        return 0;
    }

    //根据X坐标获取数据索引
    this.GetDataIndexByPoint=function(x)
    {
        var frame=this.Frame;
        if (this.Frame.SubFrame && this.Frame.SubFrame.length>0) frame=this.Frame.SubFrame[0].Frame;

        var data=null;
        if (this.Frame.Data)
            data=this.Frame.Data;
        else
            data=this.Frame.SubFrame[0].Frame.Data;

        if (!data || !frame) return;

        var index=parseInt(frame.GetXData(x));

        //JSConsole.Chart.Log('x='+ x +' date='+data.Data[data.DataOffset+index].Date);
        return data.DataOffset+index;
    }

    //获取主数据
    this.GetSelectRectData=function(selectData)
    {
        if (Math.abs(selectData.XStart-selectData.XEnd)<5) return false;

        var startClientPos=this.PtInClient(selectData.XStart, selectData.YStart);
        var endClientPos=this.PtInClient(selectData.XEnd, selectData.YEnd);
        
        var data=null;
        if (this.Frame.Data)
            data=this.Frame.Data;
        else
            data=this.Frame.SubFrame[0].Frame.Data;

        if (!data) return false;

        var start=this.GetDataIndexByPoint(selectData.XStart);
        var end=this.GetDataIndexByPoint(selectData.XEnd);

        if (Math.abs(start-end)<2) return false;

        selectData.Data=data;
        if (start>end)
        {
            selectData.Start=end;
            selectData.End=start;
        }
        else
        {
            selectData.Start=start;
            selectData.End=end;
        }

        return true;
    }

    //获取当前的点对应的 画图工具的图形
    //data.X data.Y 鼠标位置  返回 data.ChartDrawPicture 数据在画图工具 data.PointIndex 在画图工具对应点索引
    this.GetChartDrawPictureByPoint=function(data)
    {
        for(var i=0;i<this.ChartDrawPicture.length; ++i)
        {
            var item =this.ChartDrawPicture[i];
            var pointIndex=item.IsPointIn(data.X, data.Y, this.ChartDrawOption);
            if (pointIndex===false) continue;

            if (pointIndex>=0)
            {
                data.ChartDrawPicture=item;
                data.PointIndex=pointIndex;
                if (item.GetCursorType) data.Cursor=item.GetCursorType(pointIndex); //鼠标形状
                return true;
            }
        }

        return false;
    }

    // 保存图片
    this.SaveToImage = function (format,colorGB) 
    {
        if (this.UIElement.width<=0 || this.UIElement.height<=0) return null;
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash) return null; // 数据加载中不能保存

        JSConsole.Chart.Log('[JSChartContainer::SaveToImage]', this.UIElement);
        var clrBG='rgb(255,255,255)';
        if (colorGB) clrBG=colorGB;
        this.Canvas.clearRect(0,0,this.UIElement.width,this.UIElement.height);
        this.Canvas.fillStyle=clrBG;
        this.Canvas.fillRect(0,0,this.UIElement.width,this.UIElement.height);   //画一个背景色, 不然是一个黑的背景
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        this.Canvas.lineWidth=pixelTatio;       //手机端需要根据分辨率比调整线段宽度

        this.Frame.Draw();  //框架

        for (var i in this.ChartPaint)  //框架内图形
        {
            var item=this.ChartPaint[i];
            if (item.IsDrawFirst)
                item.Draw();
        }

        for(var i in this.ChartPaint)
        {
            var item=this.ChartPaint[i];
            if (!item.IsDrawFirst)
                item.Draw();
        }

        for(var i in this.ChartPaintEx)
        {
            var item=this.ChartPaintEx[i];
            item.Draw();
        }

        for(var i in this.OverlayChartPaint)    //叠加股票
        {
            var item=this.OverlayChartPaint[i];
            item.Draw();
        }

        
        for(var i in this.ExtendChartPaint)     //固定扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (!item.IsDynamic && item.IsAnimation==false) item.Draw();
        }

        if (this.Frame.DrawInsideHorizontal) this.Frame.DrawInsideHorizontal();
        this.Frame.DrawLock();

        for(var i in this.ExtendChartPaint) //动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsDynamic && item.DrawAfterTitle===false) item.Draw();
        }

        if (this.LastPoint.X!=null || this.LastPoint.Y!=null)
        {
            if (this.ChartCorssCursor)  //十字光标不画 
            {
                this.ChartCorssCursor.LastPoint=this.LastPoint;
                this.ChartCorssCursor.CursorIndex=this.CursorIndex;
            }
        }

        for(var i in this.TitlePaint)
        {
            var item=this.TitlePaint[i];
            if (!item.IsDynamic) continue;

            item.CursorIndex=this.CursorIndex;
            item.Draw();
        }

        for(var i in this.ExtendChartPaint) //动态扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item.IsDynamic && item.DrawAfterTitle===true && item.IsAnimation==false) item.Draw();
        }

        if (this.EnableAnimation)
        {
            for(var i in this.ExtendChartPaint)    //动画
            {
                var item=this.ExtendChartPaint[i];
                if (item.IsAnimation===true) item.Draw();
            }
        }

        for(var i in this.ChartDrawPicture)
        {
            var item=this.ChartDrawPicture[i];
            item.Draw();
        }

        if (this.CurrentChartDrawPicture && this.CurrentChartDrawPicture.Status!=10)
        {
            this.CurrentChartDrawPicture.Draw();
        }

        var dataURL=this.UIElement.toDataURL(format ? format:'image/png', 1.0);
        JSConsole.Chart.Log('[JSChartContainer::SaveToImage] data= ', dataURL);
        return dataURL;
    }


    this.SaveToImageUrl=function(obj,callback) //obj:{Format: 图片格式, ColorGB: 背景色}, callback:function(bSuccess,obj)
    {
        if (!obj) obj={Format:'image/png', ColorGB:'rgb(255,255,255)'};
        var imageData=this.SaveToImage(obj.Format, obj.ColorGB);
        var postData={"Base64":imageData, "BucketName":"downloadcache", "Path":"hqchart/hq_snapshot"};
        var url=g_JSChartResource.Domain+'/API/FileUploadForBase64';

        JSNetwork.HttpRequest({
            url: url,
            method: "POST",
            dataType: "json",
            data: postData,
            success: function (data) 
            {
                JSConsole.Chart.Log('[JSChartContainer::SaveToImageUrl] recv data', data);
                var result={Path:data.relativeurl, Domain:'http://127.0.0.1:8087'};
                result.Url=`${result.Domain}/${result.Path}`;
                if (callback) callback(true,result,'');
            },
            error: function (request) 
            {
                JSConsole.Chart.Log('[JSChartContainer::SaveToImageUrl] error ', request);
                if (callback) callback(false,null,'upload failed');
            }
        });

    }

    this.ExportDataToCSV=function(data)
    {
        var strCSV="";
        var strRow="";
        var rowCount=0;
        //标题
        for(var i=0;i<data.length;++i)
        {
            var item=data[i];
            strRow+=`"${item.Name}"`;
            if (i==data.length-1) strRow+="\r\n";
            else strRow+=",";

            if (IFrameSplitOperator.IsNonEmptyArray(item.Data))
                rowCount=Math.max(rowCount,item.Data.length);
        }
        strCSV+=strRow;

        for(var i=0, j=0;i<rowCount;++i)
        {
            strRow="";
            for(j=0;j<data.length;++j)
            {
                var item=data[j];
                var value=null;
                if (item.Data && i<item.Data.length) 
                    value=item.Data[i];

                strRow+=`"${value}"`;

                if (j==data.length-1) strRow+="\r\n";
                else strRow+=",";

            }

            strCSV+=strRow;
        }

        strCSV = "\uFEFF" + strCSV;

        return strCSV;
    }

    this.SetLanguage=function(language)
    {
        var languageID=g_JSChartLocalization.GetLanguageID(language);
        if (!IFrameSplitOperator.IsNumber(languageID))
        {
            console.warn(`[JSChartContainer::SetLanguage] language=${language} error`);
            return;
        }

        if (this.LanguageID==languageID) return;
        
        this.LanguageID=languageID;
        if (this.ChartCorssCursor && this.ChartCorssCursor.StringFormatY) this.ChartCorssCursor.StringFormatY.LanguageID=this.LanguageID;

        for(var i=0; i<this.TitlePaint.length; ++i) //标题
        {
            var item=this.TitlePaint[i];
            if (item) item.LanguageID=this.LanguageID;
        }

        for(var i=0;i<this.ExtendChartPaint.length;++i) //tooltip 等扩展图形
        {
            var item=this.ExtendChartPaint[i];
            if (item) item.LanguageID=this.LanguageID;
        }

        if (this.Frame && this.Frame.SetLanguage) this.Frame.SetLanguage(this.LanguageID);

        //this.Frame.ClearYCoordinateMaxMin();
        this.ResetFrameXYSplit();
        this.Frame.SetSizeChage(true);
        this.Draw();

        if (this.PopMinuteChart) this.PopMinuteChart.SetLanguage(language);
    }

    this.ReloadTiltePaintResource=function(resource)  //重新加载配置
    {
        for(var i in this.TitlePaint)
        {
            var item=this.TitlePaint[i];
            if (item.ReloadResource) item.ReloadResource(resource);
        }
    }

    this.ReloadExtendChartPaintResource=function(resource)  //扩展画法重新加载配置
    {
        for(var i=0;i<this.ExtendChartPaint.length; ++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ReloadResource) item.ReloadResource(resource);
        }

        if (this.ChartDragSelectRect && this.ChartDragSelectRect.ReloadResource) this.ChartDragSelectRect.ReloadResource(resource);
    }

    this.ReloadChartDrawPictureResource=function(resource)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.ChartDrawPicture)) return;

        for(var i=0;i<this.ChartDrawPicture.length;++i)
        {
            var item=this.ChartDrawPicture[i];
            if (item.ReloadResource) item.ReloadResource(resource);
        }
    }

    this.ReloadResource=function(option)
    {
        this.ReloadBorder(option);
        this.ReloadTiltePaintResource(option.Resource);
        this.ReloadChartPaint(option.Resource);
        this.ReloadFrame(option.Resource);
        this.ReloadExtendChartPaintResource(option.Resource);
        this.ReloadChartCorssCursor(option,option.Resource);
        this.ReloadChartDrawPictureResource(option.Resource);

        if (option.Update && this.Update) this.Update( {UpdateCursorIndexType:2} );       //是否立即更新并重绘
        else if (option.Draw==true) this.Draw(); //是否立即重绘

        if (this.PopMinuteChart) this.PopMinuteChart.ReloadResource(option);
    }

    this.ReloadBorder=function(option)  //根据页面缩放调整对应边框的尺长
    {
        if (!option) return;

        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        if (option.Border)
        {
            var item=option.Border;
            if (IFrameSplitOperator.IsNumber(item.Left)) this.Frame.ChartBorder.Left=item.Left*pixelTatio;
            if (IFrameSplitOperator.IsNumber(item.Right)) this.Frame.ChartBorder.Right=item.Right*pixelTatio;
            if (IFrameSplitOperator.IsNumber(item.Top)) this.Frame.ChartBorder.Top=item.Top*pixelTatio;
            if (IFrameSplitOperator.IsNumber(item.Bottom)) this.Frame.ChartBorder.Bottom=item.Bottom*pixelTatio;
        }

        for(var i in option.Windows)
        {
            var item=option.Windows[i];
            if (i>=this.Frame.SubFrame.length) continue;
            var subFrame=this.Frame.SubFrame[i];
            var border=subFrame.Frame.ChartBorder;
            if (IFrameSplitOperator.IsNumber(item.TitleHeight)) border.TitleHeight=item.TitleHeight*pixelTatio;
        }

        for(var i in option.Frame)
        {
            var item=option.Frame[i];
            if (i>=this.Frame.SubFrame.length) continue;

            var subFrame=this.Frame.SubFrame[i];
            var border=subFrame.Frame.ChartBorder;
            if (item.TopSpace>=0) border.TopSpace=item.TopSpace*pixelTatio;
            if (item.BottomSpace>=0) border.BottomSpace=item.BottomSpace*pixelTatio;
        }
    }

    this.ReloadFrame=function(resource)
    {
        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            var subFrame=item.Frame;
            if (subFrame && subFrame.ReloadResource) subFrame.ReloadResource(resource);

            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Frame && overlayItem.Frame.ReloadResource) overlayItem.Frame.ReloadResource(resource);
            }
        }
    }

    this.ReloadChartPaint=function(resource)
    {
        for(var i=0; i<this.ChartPaint.length; ++i)
        {
            var item=this.ChartPaint[i];
            if (item && item.ReloadResource) item.ReloadResource(resource);
        }
    }

    this.ReloadChartCorssCursor=function(option, resource)
    {
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        if (option && option.CorssCursor)
        {
            var item=option.CorssCursor;
            if (IFrameSplitOperator.IsNumber(item.TitleHeight)) this.ChartCorssCursor.TextHeight=item.TitleHeight*pixelTatio;  //十字光标文本信息高度
        }

        if (this.ChartCorssCursor.ReloadResource) this.ChartCorssCursor.ReloadResource(resource);
    }

    this.SetDepthMapData=function(depthData, option)
    {
        for(var i=0;i<depthData.length; ++i)
        {
            var item=depthData[i];
            for(var j=0;j<this.ExtendChartPaint.length; ++j)
            {
                var chart=this.ExtendChartPaint[j];
                if (chart.ID==item.ID)
                {
                    chart.Data=item.Data;
                    break;
                }
            }
        }

        if (option)
        {
            if (option.Draw==true) this.Draw();
        }
    }

    //画图工具
    //把X, Y绝对位置转成的相对位置的点
    this.PointAbsoluteToRelative=function(x, y, isPhone)
    {
        var pt={ X:x, Y:y };
        var pixelTatio = GetDevicePixelRatio();             //x,y是原始坐标 需要乘以放大倍速
        var uiRect=this.UIElement.getBoundingClientRect();  //dom返回的是没有放大倍数的值

        if (isPhone)
        {
            pt.X=x-uiRect.left*pixelTatio;      //手机端 dom返回的是没有放大倍数的值
            pt.Y=y-uiRect.top*pixelTatio;
        }
        else
        {
            pt.X=(x-uiRect.left)*pixelTatio;
            pt.Y=(y-uiRect.top)*pixelTatio;
        }

        return pt;
    }

    this.SetChartDrawPictureFirstPoint=function(x,y, isPhone)
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;
        if (!this.Frame.SubFrame || this.Frame.SubFrame.length<=0) return false;

        //相对坐标
        var pt=this.PointAbsoluteToRelative(x, y, isPhone);
        var xFixed=pt.X;
        var yFixed=pt.Y;

        for(var i=0;i<this.Frame.SubFrame.length; ++i)
        {
            var frame=this.Frame.SubFrame[i].Frame;
            var left=frame.ChartBorder.GetLeft();
            var top=frame.ChartBorder.GetTopEx();
            var bottom=frame.ChartBorder.GetBottomEx();
            var height=bottom-top;
            var width=frame.ChartBorder.GetWidth();

            this.Canvas.beginPath();
            this.Canvas.rect(left,top,width,height);
            //this.Canvas.fillStyle='rgb(255,0,0)';
            //this.Canvas.fill();     
            if (this.Canvas.isPointInPath(xFixed,yFixed))
            {
                if (IFrameSplitOperator.IsNumber(drawPicture.LimitFrameID))
                {
                    if (i!=drawPicture.LimitFrameID) return false;
                }
                    
                drawPicture.Frame=frame;
                break;
            }
        }

        if (!drawPicture.Frame) return false;

        drawPicture.Point[0]=new Point();
        drawPicture.Point[0].X=xFixed;
        drawPicture.Point[0].Y=yFixed;
        drawPicture.Status=1;   //第1个点完成
        drawPicture.PointMagnetKLine();
        return true;
    }

    this.SetChartDrawPictureSecondPoint=function(x,y,isPhone)
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;

        //相对坐标
        var pt=this.PointAbsoluteToRelative(x, y, isPhone);

        drawPicture.Point[1]=new Point();
        drawPicture.Point[1].X=pt.X;
        drawPicture.Point[1].Y=pt.Y;

        drawPicture.Status=2;   //设置第2个点
        return true;
    }

    //设置第3个点
    this.SetChartDrawPictureThirdPoint=function(x,y,isPhone)
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;

        //相对坐标
        var pt=this.PointAbsoluteToRelative(x, y, isPhone);

        drawPicture.Point[2]=new Point();
        drawPicture.Point[2].X=pt.X;
        drawPicture.Point[2].Y=pt.Y;

        drawPicture.Status=3;   //设置第3个点
        return true;
    }

    //xStep,yStep 移动的偏移量
    this.MoveChartDrawPicture=function(x,y,isPhone,drag)
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;

        var pixelTatio = GetDevicePixelRatio(); //x,y 需要乘以放大倍速
        if (isPhone) pixelTatio=1;
        var xStep=x*pixelTatio;
        var yStep=y*pixelTatio;
        //JSConsole.Chart.Log("xStep="+xStep+" yStep="+yStep);
        drawPicture.Move(xStep,yStep,drag);

        return true;
    }

    this.FinishChartDrawPicturePoint=function()
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;
        if (drawPicture.PointCount!=drawPicture.Point.length) return false;
        if (drawPicture.ClassName=="ChartDrawRuler")    //尺子不用保存的
        {
            if (drawPicture.FinishedCallback) drawPicture.FinishedCallback(drawPicture);
            this.CurrentChartDrawPicture=null;
            return true;
        }

        drawPicture.PointMagnetKLine();
        drawPicture.Status=10;  //完成
        drawPicture.PointToValue();

        this.ChartDrawPicture.push(drawPicture);
        this.CurrentChartDrawPicture=null;

        //通知上层画好了
        let event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FINISH_DRAWPICTURE); //完成画图工具事件
        if (event && event.Callback)
        {
            let sendData={ DrawPicture: drawPicture };
            event.Callback(event,sendData,this);
        }
        
        //单个回调
        if (drawPicture.FinishedCallback) drawPicture.FinishedCallback(drawPicture);

        if (drawPicture.OnFinish) drawPicture.OnFinish();

        if (this.ChartDrawStorage) this.ChartDrawStorage.SaveDrawData(drawPicture);
        
        return true;
    }

    //选中画图工具 出现单个图形设置菜单
    this.OnSelectChartPicture=function(chart)
    {   
        JSConsole.Chart.Log('[JSChartContainer::OnSelectChartPicture]',chart);

        if (!this.DialogModifyDraw) return;

        if (chart.ClassName=="ChartDrawPictureText" || chart.ClassName=='ChartDrawVolProfile')
        {
            this.CloseModifyDrawDialog();

            if (!this.ChartPictureMenu) this.ChartPictureMenu=g_DialogFactory.Create('ChartPictureSettingMenu', this.UIElement.parentNode);
            if (!this.ChartPictureMenu) return;

            var event={ data: { ChartPicture:chart, HQChart:this}};
            this.ChartPictureMenu.DoModal(event);
        }
        else
        {
            this.ShowModifyDrawDialog(chart);
        } 
    }

    this.FinishMoveChartDrawPicture=function()
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;
        if (drawPicture.PointCount!=drawPicture.Point.length) return false;

        drawPicture.PointMagnetKLine();
        drawPicture.Status=10;  //完成
        drawPicture.PointToValue();

        if (this.ChartDrawStorage) this.ChartDrawStorage.SaveDrawData(drawPicture);

        this.CurrentChartDrawPicture=null;

        if (this.SelectChartDrawPicture && this.SelectChartDrawPicture.DragInfo)    //图形移动了回调调用移动完成函数
        {
            var dargInfo=this.SelectChartDrawPicture.DragInfo;
            if (dargInfo.Click && dargInfo.Move)
            {
                if (dargInfo.Click.X!=dargInfo.Move.X || dargInfo.Click.Y!=dargInfo.Move.Y)
                {
                    //通知上层画好了
                    var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FINISH_MOVE_DRAWPICTURE); //完成画图工具事件
                    if (event && event.Callback)
                    {
                        let sendData={ DrawPicture: drawPicture };
                        event.Callback(event,sendData,this);
                    }

                    if (drawPicture.OnMoveFinish) drawPicture.OnMoveFinish();
                }
            }
        }

        return true;
    }

    //清空所有的画线工具 option={ Draw:false/true }
    this.ClearChartDrawPicture=function(drawPicture, option)
    {
        var bDraw=true;
        if (!drawPicture)
        {
            this.ChartDrawPicture=[];
            if (this.ChartDrawStorage) this.ChartDrawStorage.Clear();
            this.SelectChartDrawPicture=null;

            if (option && option.Draw==false) bDraw=false;
            if (bDraw) this.Draw();
        }
        else
        {
            for(var i=0; i<this.ChartDrawPicture.length; ++i)
            {
                var item=this.ChartDrawPicture[i];
                if (item.Guid==drawPicture.Guid || item==drawPicture)
                {
                    if (this.ChartDrawStorage) this.ChartDrawStorage.DeleteDrawData(drawPicture);
                    this.ChartDrawPicture.splice(i,1);

                    if (this.SelectChartDrawPicture)    //去掉选中
                    {
                        if (this.SelectChartDrawPicture.Guid==drawPicture.Guid || this.SelectChartDrawPicture==drawPicture) 
                            this.SelectChartDrawPicture=null;
                    }

                    if (option && option.Draw==false) bDraw=false;
                    if (bDraw) this.Draw();
                }
            }
        }
    }

    //获取画图工具当前选中图形的Guid
    this.GetActiveDrawPicture=function()
    {
        var result={ Move: { Guid:null }, Select:{ Guid:null }, MoveOn: {Guid:null} };
        if (this.CurrentChartDrawPicture) 
            result.Move={ Guid: this.CurrentChartDrawPicture.Guid };
        if (this.SelectChartDrawPicture) 
            result.Select={ Guid:this.SelectChartDrawPicture.Guid, Chart:this.SelectChartDrawPicture };
        if (this.MoveOnChartDrawPicture)
            result.MoveOn={ Guid:this.MoveOnChartDrawPicture.Guid };

        return result;
    }

    this.SetChartDrawOption=function(option)
    {
        if (IFrameSplitOperator.IsBool(option.IsLockScreen)) this.ChartDrawOption.IsLockScreen=option.IsLockScreen;
        if (IFrameSplitOperator.IsNumber(option.Zoom) && option.Zoom>=0)  this.ChartDrawOption.Zoom=option.Zoom;

        if (option.Magnet)
        {
            var item=option.Magnet;
            if (!this.ChartDrawOption.Magnet) this.ChartDrawOption.Magnet={ Type:0, Distance:20*GetDevicePixelRatio(), Enable:false };
            if (IFrameSplitOperator.IsBool(item.Enable)) this.ChartDrawOption.Magnet.Enable=item.Enable;
            if (IFrameSplitOperator.IsNumber(item.Type)) this.ChartDrawOption.Magnet.Type=item.Type;
            if (IFrameSplitOperator.IsNumber(item.Distance)) this.ChartDrawOption.Magnet.Distance=item.Distance;
        }
    }

    //是否显示十字光标的十字线
    this.EnableShowCorssCursorLine=function(bShow)
    {
        if (!this.ChartCorssCursor) return;

        this.ChartCorssCursor.IsShowCorss=bShow;
    }

    //获取扩展画法
    this.GetExtendChartByClassName=function(name)
    {
        for(var i=0; i<this.ExtendChartPaint.length; ++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName==name) return { Index:i, Chart:item };
        }

        return null
    }

    //获取多个扩展画法
    this.GetExtendChartByClassNameV2=function(name)
    {
        var aryChart=[];
        for(var i=0; i<this.ExtendChartPaint.length; ++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName==name) 
            {
                aryChart.push({ Index:i, Chart:item });
            } 
        }

        if (aryChart.length<=0) return null;

        return aryChart;
    }

    this.GetExtendChartRightWidth=function()  //扩展画法右边宽度
    {
        var width=0;
        for(var i=0; i<this.ExtendChartPaint.length; ++i)
        {
            var item=this.ExtendChartPaint[i];
            if (!item) continue;
            if (item.ClassName=="StockChip")
            {
                if (IFrameSplitOperator.IsNumber(item.Width)) 
                    width+=item.Width;
            }
        }

        return width;
    }

    //删除扩展画法
    this.DeleteExtendChart=function(data)
    {
        if (data.Index>=this.ExtendChartPaint.length) return;
        if (this.ExtendChartPaint[data.Index]!=data.Chart) return;

        if (typeof(data.Chart.Clear)=='function') data.Chart.Clear();
        this.ExtendChartPaint.splice(data.Index,1);
    }

    //删除扩展画法
    this.DeleteExtendChartByID=function(id)
    {
        for(var i=0;i<this.ExtendChartPaint.length;++i)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ID==id)
            {
                this.ExtendChartPaint.splice(i, 1);
                return true;
            }
        }

        return false;
    }

    //全屏提示信息 { Title:提示信息, Draw:false/true 是否立即重绘, }
    this.EnableSplashScreen=function(enable, option)
    {
        if (!this.ChartSplashPaint) return;

        this.ChartSplashPaint.EnableSplash(enable);

        if (option && option.Draw===false) return;

        if (enable) this.DrawSplashScreen(option);
        else this.Draw();
    }

    //设置指标窗口属性 windowItem=SetOption.Windows[i], frameItem=SetOption.Frames[i];
    this.SetSubFrameAttribute=function(subFrame, windowItem, frameItem)
    {
        if (!subFrame || !subFrame.Frame) return;

        var frame=subFrame.Frame;

        if (windowItem)
        {
            if (IFrameSplitOperator.IsBool(windowItem.Modify)) frame.ModifyIndex=windowItem.Modify;
            if (IFrameSplitOperator.IsBool(windowItem.Change)) frame.ChangeIndex=windowItem.Change;
            if (IFrameSplitOperator.IsBool(windowItem.Close)) frame.CloseIndex=windowItem.Close;
            if (IFrameSplitOperator.IsBool(windowItem.Overlay)) frame.OverlayIndex=windowItem.Overlay;
            if (IFrameSplitOperator.IsBool(windowItem.IsDrawTitleBG))  frame.IsDrawTitleBG=windowItem.IsDrawTitleBG;

            if (IFrameSplitOperator.IsNumber(windowItem.TitleHeight)) frame.ChartBorder.TitleHeight=windowItem.TitleHeight;
            else windowItem.TitleHeight=frame.ChartBorder.TitleHeight;

            if (IFrameSplitOperator.IsBool(windowItem.IsShowTitleArrow)) frame.IsShowTitleArrow=windowItem.IsShowTitleArrow;
            if (IFrameSplitOperator.IsNumber(windowItem.TitleArrowType)) frame.TitleArrowType=windowItem.TitleArrowType;
            if (IFrameSplitOperator.IsBool(windowItem.IsShowIndexName)) frame.IsShowIndexName=windowItem.IsShowIndexName;
            if (IFrameSplitOperator.IsNumber(windowItem.IndexParamSpace)) frame.IndexParamSpace=windowItem.IndexParamSpace;
            if (IFrameSplitOperator.IsNumber(windowItem.IndexTitleSpace)) frame.IndexTitleSpace=windowItem.IndexTitleSpace;
            if (!IFrameSplitOperator.IsUndefined(windowItem.HorizontalReserved)) frame.HorizontalReserved=windowItem.HorizontalReserved;    //Y轴上下预留
        }

        if (frameItem)
        {
            if (frameItem.SplitCount) frame.YSplitOperator.SplitCount=frameItem.SplitCount;
            if (IFrameSplitOperator.IsNumber(frameItem.SplitType)) 
            {
                frame.YSplitOperator.SplitType=frameItem.SplitType;
                frame.YSplitOperator.DefaultSplitType=frameItem.SplitType;
            }

            if (IFrameSplitOperator.IsBool(frameItem.IsShowXLine)) frame.IsShowXLine=frameItem.IsShowXLine;
            if (IFrameSplitOperator.IsBool(frameItem.IsShowYLine)) frame.IsShowYLine=frameItem.IsShowYLine;

            if (IFrameSplitOperator.IsBool(frameItem.IsShowLeftText)) 
            {
                frame.IsShowYText[0]=frameItem.IsShowLeftText;
                frame.YSplitOperator.IsShowLeftText=frameItem.IsShowLeftText;            //显示左边刻度
            }
            if (IFrameSplitOperator.IsBool(frameItem.IsShowRightText)) 
            {
                frame.IsShowYText[1]=frameItem.IsShowRightText;
                frame.YSplitOperator.IsShowRightText=frameItem.IsShowRightText;         //显示右边刻度
            }

            if (IFrameSplitOperator.IsNumber(frameItem.Height) && frameItem.Height>=0) subFrame.Height = frameItem.Height;
        }

    }

    this.SetSubFrameOption=function(subFrame, option)
    {
        if (!option) return;

        var frame=subFrame.Frame;

        if (option.Window)
        {
            var item=option.Window;
            if (IFrameSplitOperator.IsBool(item.Modify)) frame.ModifyIndex=item.Modify;
            if (IFrameSplitOperator.IsBool(item.Change)) frame.ChangeIndex=item.Change;
            if (IFrameSplitOperator.IsBool(item.Close)) frame.CloseIndex=item.Close;
            if (IFrameSplitOperator.IsBool(item.Overlay)) frame.OverlayIndex=item.Overlay;
            if (IFrameSplitOperator.IsBool(item.Export)) frame.ExportData=item.Export;
            if (IFrameSplitOperator.IsBool(item.MaxMin)) frame.MaxMinWindow=item.MaxMin;
            if (IFrameSplitOperator.IsBool(item.TitleWindow)) frame.TitleWindow=item.TitleWindow;

            if (IFrameSplitOperator.IsBool(item.IsDrawTitleBG))  frame.IsDrawTitleBG=item.IsDrawTitleBG;
            if (IFrameSplitOperator.IsBool(item.IsShowNameArrow)) frame.IsShowNameArrow=item.IsShowNameArrow;

            if (item.OverlayIndexType)
            {
                if (IFrameSplitOperator.IsNumber(item.OverlayIndexType.Position)) frame.OverlayIndexType.Position=item.OverlayIndexType.Position;
                if (IFrameSplitOperator.IsNumber(item.OverlayIndexType.LineSpace)) frame.OverlayIndexType.LineSpace=item.OverlayIndexType.LineSpace;
            }

            if (IFrameSplitOperator.IsNonEmptyArray(item.CustomToolbar))    //自定义工具按钮
            {
                frame.CustomToolbar=item.CustomToolbar.slice();
            }
        }

        if (IFrameSplitOperator.IsNumber(option.SplitCount)) subFrame.Frame.YSplitOperator.SplitCount=option.SplitCount;
        if (IFrameSplitOperator.IsNumber(option.TitleHeight)) subFrame.Frame.ChartBorder.TitleHeight=option.TitleHeight;
        if (IFrameSplitOperator.IsBool(option.IsShowTitleArrow)) subFrame.Frame.IsShowTitleArrow=option.IsShowTitleArrow;
        if (IFrameSplitOperator.IsNumber(option.TitleArrowType)) subFrame.Frame.TitleArrowType=option.TitleArrowType;
        if (IFrameSplitOperator.IsBool(option.IsShowIndexName)) subFrame.Frame.IsShowIndexName=option.IsShowIndexName;
        if (IFrameSplitOperator.IsBool(option.IsShowOverlayIndexName)) subFrame.Frame.IsShowOverlayIndexName=option.IsShowOverlayIndexName;
        if (IFrameSplitOperator.IsNumber(option.IndexParamSpace)) subFrame.Frame.IndexParamSpace=option.IndexParamSpace;
        if (IFrameSplitOperator.IsBool(option.IsShowXLine)) subFrame.Frame.IsShowXLine=option.IsShowXLine;
        if (IFrameSplitOperator.IsBool(option.IsShowYLine)) subFrame.Frame.IsShowYLine=option.IsShowYLine;
        if (IFrameSplitOperator.IsBool(option.IsShowIndexTitle)) subFrame.Frame.IsShowIndexTitle=option.IsShowIndexTitle;
        

        if (IFrameSplitOperator.IsBool(option.IsShowLeftText)) 
        {
            subFrame.Frame.IsShowYText[0]=option.IsShowLeftText;
            subFrame.Frame.YSplitOperator.IsShowLeftText=option.IsShowLeftText;            //显示左边刻度
        }
        if (IFrameSplitOperator.IsBool(option.IsShowRightText)) 
        {
            subFrame.Frame.IsShowYText[1]=option.IsShowRightText;
            subFrame.Frame.YSplitOperator.IsShowRightText=option.IsShowRightText;         //显示右边刻度
        }
    }

    this.AddNewSubFrame=function(option)
    {
        var index=this.Frame.SubFrame.length;
        var subFrame=this.CreateSubFrameItem(index);
        var pixelRatio=GetDevicePixelRatio();
        subFrame.Frame.ChartBorder.TitleHeight*=pixelRatio;
        this.Frame.SubFrame[index]=subFrame;
        var titlePaint=new DynamicChartTitlePainting();
        titlePaint.Frame=this.Frame.SubFrame[index].Frame;
        titlePaint.Canvas=this.Canvas;
        titlePaint.LanguageID=this.LanguageID;
        titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.TitlePaint[index+1]=titlePaint;

        this.SetSubFrameOption(subFrame,option);

        //最后一个显示X轴坐标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;
        }

        this.UpdataDataoffset();        //更新数据偏移  
        this.Frame.SetSizeChage(true);
        if (this.UpdateXShowText) this.UpdateXShowText();
        this.ResetFrameXYSplit();
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();

        return index;
    }

    //增加一个指标窗口
    this.AddIndexWindow=function(indexName,option)
    {
        //查找系统指标
        let scriptData = new JSIndexScript();
        let indexInfo = scriptData.Get(indexName);
        if (!indexInfo) return;

        this.RemoveMinSizeWindows();    //清空隐藏的指标
        var index=this.AddNewSubFrame(option);

        JSIndexScript.ModifyAttribute(indexInfo, option);

        this.WindowIndex[index] = new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
        if (this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer")
            var bindData=this.SourceData;
        else 
            var bindData=this.ChartPaint[0].Data;

        this.BindIndexData(index,bindData);     //执行脚本
    }

    this.AddAPIIndexWindow=function(indexData, option)
    {
        if (!indexData.API) return;

        this.RemoveMinSizeWindows();    //清空隐藏的指标
        var index=this.AddNewSubFrame(option);

        //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
        var apiItem=indexData.API;
        this.WindowIndex[index]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,indexData);
        if (this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer")
            var bindData=this.SourceData;
        else 
            var bindData=this.ChartPaint[0].Data;

        this.BindIndexData(index,bindData);     //执行脚本
    }

    //增加一个自定义指标窗口
    this.AddScriptIndexWindow=function(indexInfo, option)
    {
        if (!indexInfo || !indexInfo.Script || !indexInfo.Name) return;

        this.RemoveMinSizeWindows();    //清空隐藏的指标
        var index=this.AddNewSubFrame(option);

        var indexData = 
        { 
            Name:indexInfo.Name, Script:indexInfo.Script, Args: indexInfo.Args, ID:indexInfo.Name ,
            //扩展属性 可以是空
            KLineType:indexInfo.KLineType,  YSpecificMaxMin:indexInfo.YSpecificMaxMin,  YSplitScale:indexInfo.YSplitScale,
            FloatPrecision:indexInfo.FloatPrecision, Condition:indexInfo.Condition,StringFormat:indexInfo.StringFormat,
            OutName:indexInfo.OutName
        };

        if (indexInfo.ID) indexData.ID=indexInfo.ID;

        this.WindowIndex[index] = new ScriptIndex(indexData.Name, indexData.Script, indexData.Args,indexData);    //脚本执行
        if (this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer")
            var bindData=this.SourceData;
        else 
            var bindData=this.ChartPaint[0].Data;

        this.BindIndexData(index,bindData);     //执行脚本
    }

    //区间选择
    this.GetRectSelectPaint=function()
    {
        var finder=this.GetExtendChartByClassName("RectSelectPaint");
        if (!finder) return null;

        return finder.Chart;
    }

    //鼠标拖动区域
    this.GetRectDragPaint=function()
    {
        var finder=this.GetExtendChartByClassName("RectDragPaint");
        if (!finder) return null;

        return finder.Chart;
    }

    this.SetRectSelectData=function(kItem, index)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return false;

        if (paint.GetPointCount()==2) 
        {
            if (!paint.SpaceReselected)
                return false;

            var oldPreventClose=paint.PreventClose; //备份下
            paint.PreventClose=false;
            paint.ClearPoint();
            paint.PreventClose=oldPreventClose; //还原
        }

        return paint.SetPoint(kItem, { DataIndex:index} );
    }

    this.MoveRectSelectPoint=function(obj)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return false;

        if (!this.ChartPaint[0] || !this.ChartPaint[0].Data) return false;
        var kData=this.ChartPaint[0].Data;

        if (!this.Frame.SubFrame[0]) return false;
        var subFrame=this.Frame.SubFrame[0].Frame;
        if (!subFrame) false;

        var pixelTatio = GetDevicePixelRatio();
        var x=(obj.X-uielement.getBoundingClientRect().left)*pixelTatio;
        var index=subFrame.GetXData(x);
        index=parseInt(index.toFixed(0));
        var dataIndex=index+kData.DataOffset;
        if (dataIndex>=kData.Data.length) dataIndex=kData.Data.length-1;

        var item = kData.Data[dataIndex];
        JSConsole.Chart.Log("[KLineChartContainer::MoveRectSelectPoint] point, item", obj.PointIndex, item);

        if (!paint.SetPoint(item,{ Index: obj.PointIndex, DataIndex:dataIndex })) return false;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAG_SELECT_RECT);
        if (event)
        {
            var selectData=paint.GetSelectRectData();
            var data={ X:obj.X, Y:obj.Y, SelectData:selectData, RectSelectPaint:paint };
            event.Callback(event,data,this);
        }

        return true;
    }

    this.MoveSubRectSelect=function(obj)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return false;
        
        if (!paint.MoveSubRect(obj.Step, obj.IsLeft)) return false;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAG_SUB_SELECT_RECT);
        if (event)
        {
            var subRectData={Start:paint.SubClient.FirstPoint, End: paint.SubClient.SecondPoint }
            var data={ X:obj.X, Y:obj.Y, SubRectSelectData: subRectData, RectSelectPaint:paint };
            event.Callback(event,data,this);
        }

        return true;
    }

    this.ClearRectSelect=function(bEnforce)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return false;
        if (bEnforce) paint.PreventClose=false;
        return paint.ClearPoint();
    }

    //删除指定窗口的所有叠加指标
    this.DeleteWindowsOverlayIndex=function(windowIndex)
    {
        if (!IFrameSplitOperator.IsNumber(windowIndex)) return;
        if (windowIndex<0 || windowIndex>=this.Frame.SubFrame.length) return;
            
        var subFrame=this.Frame.SubFrame[windowIndex];
        if (!IFrameSplitOperator.IsNonEmptyArray(subFrame.OverlayIndex)) return;

        var aryIndexID=[];
        for(var i=0; i<subFrame.OverlayIndex.length; ++i)
        {
            var overlayItem=subFrame.OverlayIndex[i];
            aryIndexID.push(overlayItem.Identify);

            for(var j=0;j<overlayItem.ChartPaint.length;++j)    //图形销毁事件
            {
                var overlayChart=overlayItem.ChartPaint[j];
                if (overlayChart && overlayChart.OnDestroy) overlayChart.OnDestroy();
            }

            overlayItem.ChartPaint=[];
        }

        subFrame.OverlayIndex=[];

        var titlePaint=this.TitlePaint[windowIndex+1];
        for(var i=0;i<aryIndexID.length;++i)
        {
            var identify=aryIndexID[i];

            if (titlePaint.OverlayIndex.has(identify))
                titlePaint.OverlayIndex.delete(identify);
    
            if (titlePaint.OverlayDynamicTitle.has(identify))
                titlePaint.OverlayDynamicTitle.delete(identify);
        }
    }

    //删除叠加指标, 没有重绘
    this.DeleteOverlayIndex=function(identify, windowIndex)
    {
        var findIndex=null;
        if (IFrameSplitOperator.IsNumber(windowIndex))
        {
            if (windowIndex>=0 && windowIndex<this.Frame.SubFrame.length)
            {
                var item=this.Frame.SubFrame[windowIndex];
                for(var j=0; j<item.OverlayIndex.length; ++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    if (overlayItem.Identify===identify)
                    {
                        for(var k=0;k<overlayItem.ChartPaint.length;++k)    //图形销毁事件
                        {
                           var overlayChart=overlayItem.ChartPaint[k];
                           if (overlayChart && overlayChart.OnDestroy) overlayChart.OnDestroy();
                        }

                        item.OverlayIndex.splice(j, 1);
                        findIndex=windowIndex
                        break;
                    }
                }
            }
        }
        else
        {
            for(var i=0; i<this.Frame.SubFrame.length; ++i)
            {
                var item=this.Frame.SubFrame[i];
                for(var j=0; j<item.OverlayIndex.length; ++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    if (overlayItem.Identify===identify)
                    {
                        for(var k=0;k<overlayItem.ChartPaint.length;++k)    //图形销毁事件
                        {
                           var overlayChart=overlayItem.ChartPaint[k];
                           if (overlayChart && overlayChart.OnDestroy) overlayChart.OnDestroy();
                        }

                        item.OverlayIndex.splice(j, 1);
                        findIndex=i;
                        break;
                    }
                }
            }
        }

        if (findIndex==null) 
        {
            console.warn(`[JSChartContainer::DeleteOverlayIndex] can't find overlay index. [identify=${identify}]`);
            return false;
        }

        var windowsIndex=findIndex+1;
        var titlePaint=this.TitlePaint[windowsIndex];
        if (titlePaint.OverlayIndex.has(identify))
            titlePaint.OverlayIndex.delete(identify);

        if (titlePaint.OverlayDynamicTitle.has(identify))
            titlePaint.OverlayDynamicTitle.delete(identify);

        return true;
    }

    this.FindScriptIndex=function(guid, windowsIndex)
    {
        if (IFrameSplitOperator.IsNumber(windowsIndex) && windowsIndex>=0)
        {
            if (windowsIndex>=this.Frame.SubFrame.length) return null;
            var item=this.WindowIndex[windowsIndex];
            if (item && item.Guid==guid) 
                return { Type:0, Data:item, WindowIndex:windowsIndex };

            var item=this.Frame.SubFrame[windowsIndex];
            for(var i=0; i<item.OverlayIndex.length; ++i)
            {
                var overlayItem=item.OverlayIndex[i];
                if (overlayItem.Identify===guid)
                    return { Type:1, Data:overlayItem, WindowIndex:windowsIndex, OverlayIndex:i };
            }
        }
        else
        {
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                var item=this.WindowIndex[i];
                if (item && item.Guid==guid) 
                    return { Type:0, Data:item, WindowIndex:i };

                var item=this.Frame.SubFrame[i];
                for(var j=0; j<item.OverlayIndex.length; ++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    if (overlayItem.Identify===guid)
                        return { Type:1, Data:overlayItem, WindowIndex:i, OverlayIndex:j };
                }
            }
        }

        return null;
    }

    //移动指标  src={ WindowIndex:指标窗口索引，IndexID:指标ID } dest={ WindowIndex:指标窗口索引 } , option={ Operator: 0=移动, 1=复制 }
    this.MoveIndex=function(src, dest, option)
    {
        if (!src || !dest || !option) return false;
        if ( !IFrameSplitOperator.IsNumber(src.WindowIndex) || src.WindowIndex<0 || src.WindowIndex>=this.Frame.SubFrame.length ) return false;
        if ( !IFrameSplitOperator.IsNumber(dest.WindowIndex) || dest.WindowIndex<0 || dest.WindowIndex>=this.Frame.SubFrame.length ) return false;

        var find=this.FindScriptIndex(src.IndexID,src.WindowIndex);
        if (!find) return false;

        var findItem=null,findOverlayItem=null;
        if (find.Type==0) findItem=find.Data;
        else if (find.Type==1) findOverlayItem=find.Data;

        if (!findOverlayItem && !findItem) return false;

        //固定窗口
        var fixedWindowCount=0;
        var isMinuteChart=(this.ClassName=="MinuteChartContainer" || this.ClassName=="MinuteChartHScreenContainer") ? true:false;
        if (isMinuteChart) fixedWindowCount=2;  //走势图固定2个窗口
        if (dest.WindowIndex>=fixedWindowCount && this.WindowIndex[dest.WindowIndex]==null)  //主指标是空的，移动到主指标上
        {
            if (findItem) this.WindowIndex[dest.WindowIndex] = this.CreateMainScript(findItem);    
            else if (findOverlayItem) this.WindowIndex[dest.WindowIndex] = this.CreateMainScript(findOverlayItem.Script);    

            if (option.Operator==0) //移动模式, 删除原来的
            {
                if (findOverlayItem)
                    this.DeleteOverlayIndex(findOverlayItem.Identify, src.WindowIndex);
                else if (findItem)
                    this.DeleteMainIndex(findItem.Guid,src.WindowIndex);
            }
            
            var bindData=this.GetMainData();
            this.BindIndexData(dest.WindowIndex,bindData);     //执行脚本
            this.UpdataDataoffset();           //更新数据偏移
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Draw();
        }
        else
        {
            var subFrame=this.Frame.SubFrame[dest.WindowIndex];
            var overlayFrame=new OverlayIndexItem();
            var frame=this.CreateOverlayFrame();
            frame.Canvas=this.Canvas;
            frame.MainFrame=subFrame.Frame;
            frame.ChartBorder=subFrame.Frame.ChartBorder;
            if (findOverlayItem) frame.IsShow=findOverlayItem.Frame.IsShow;
            //if (obj.IsShareY===true) frame.IsShareY=true;   
            frame.YSplitOperator=new FrameSplitY();
            frame.YSplitOperator.LanguageID=this.LanguageID;
            frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
            frame.YSplitOperator.Frame=frame;
            frame.YSplitOperator.ChartBorder=frame.ChartBorder;
            frame.YSplitOperator.SplitCount=subFrame.Frame.YSplitOperator.SplitCount;
            frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
    
            overlayFrame.Frame=frame;

            var scriptIndex;
            if (findItem) 
            {
                scriptIndex=this.CreateOverlayScript(findItem);
                scriptIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:dest.WindowIndex, Frame:overlayFrame };    //叠加指标信息
            }
            else if (findOverlayItem) 
            {
                scriptIndex=this.CreateOverlayScript(findOverlayItem.Script);
                scriptIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:dest.WindowIndex, Frame:overlayFrame };    //叠加指标信息
            }
            
            overlayFrame.Script=scriptIndex;

            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_OVERLAY_FRAME);
            if (event && event.Callback)
            {
                var sendData={ OverlayFrame:overlayFrame, WindowIndex:dest.WindowIndex, SubFrame:subFrame };
                event.Callback(event, sendData, this);
            }

            subFrame.OverlayIndex.push(overlayFrame);
    
            var updateWindowIndex=dest.WindowIndex;
            if (option.Operator==0) //移动模式, 删除原来的
            {
                if (findOverlayItem)
                    this.DeleteOverlayIndex(findOverlayItem.Identify, src.WindowIndex);
                else if (findItem)
                {
                    this.DeleteMainIndex(findItem.Guid,src.WindowIndex);
                    var find=this.FindScriptIndex(overlayFrame.Identify);
                    if (find) updateWindowIndex=find.WindowIndex;
                }
            }
    
            var bindData=this.GetMainData();
            this.BindOverlayIndexData(overlayFrame,updateWindowIndex,bindData);
            this.UpdataDataoffset();           //更新数据偏移
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Draw();
        }
    }

    //移动指标到新的指标窗口 src={ WindowIndex:指标窗口索引，IndexID:指标ID } , option={ Operator: 0=移动, 1=复制 }
    this.MoveIndexToNewWindow=function(src, option)
    {
        if (!src || !option) return false;
        if (!IFrameSplitOperator.IsNumber(src.WindowIndex) || src.WindowIndex<0 || src.WindowIndex>=this.Frame.SubFrame.length) return false;
    
        var find=this.FindScriptIndex(src.IndexID,src.WindowIndex);
        if (!find) return false;

        var findItem=null,findOverlayItem=null;
        if (find.Type==0) findItem=find.Data;
        else if (find.Type==1) findOverlayItem=find.Data;
        
        if (!findOverlayItem && !findItem) return false;
        if (src.WindowIndex==this.Frame.SubFrame.length-1 && this.Frame.SubFrame[src.WindowIndex].OverlayIndex<=0) return false;    //指标在最后一个窗口不需要移动

        this.RemoveMinSizeWindows();    //清空隐藏的指标

        var index=this.Frame.SubFrame.length;
        var subFrame=this.CreateSubFrameItem(index);
        var pixelRatio=GetDevicePixelRatio();
        subFrame.Frame.ChartBorder.TitleHeight*=pixelRatio;
        this.Frame.SubFrame[index]=subFrame;
        var titlePaint=new DynamicChartTitlePainting();
        titlePaint.Frame=this.Frame.SubFrame[index].Frame;
        titlePaint.Canvas=this.Canvas;
        titlePaint.LanguageID=this.LanguageID;
        titlePaint.SelectedChart=this.SelectedChart;
        titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.TitlePaint[index+1]=titlePaint;

        this.SetSubFrameOption(subFrame, option);

        //最后一个显示X轴坐标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;
        }

        if (option.Operator==0) //移动模式, 删除原来的
        {
            if (findOverlayItem)
                this.DeleteOverlayIndex(findOverlayItem.Identify, src.WindowIndex);
            else if (findItem)
                this.DeleteMainIndex(findItem.Guid,src.WindowIndex);
        }

        this.UpdataDataoffset();        //更新数据偏移  
        this.Frame.SetSizeChage(true);
        if (this.UpdateXShowText) this.UpdateXShowText();
        this.ResetFrameXYSplit();
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();

        var index=this.Frame.SubFrame.length-1;
        if (findItem) this.WindowIndex[index] = this.CreateMainScript(findItem);    
        else if (findOverlayItem) this.WindowIndex[index] = this.CreateMainScript(findOverlayItem.Script);    
        var bindData=this.GetMainData();

        this.BindIndexData(index,bindData);     //执行脚本
    }

    //创建一个叠加指标
    this.CreateOverlayScript=function(src)
    {
        var scriptIndex=null;
        switch(src.ClassName)
        {
            case "ScriptIndex":
                scriptIndex=new OverlayScriptIndex();
                break;
            case "APIScriptIndex":
                scriptIndex=new APIScriptIndex(null, null, null,null, true);
                break;
            case "OverlayScriptIndex":
                scriptIndex=new OverlayScriptIndex();
                break;
        }

        src.CopyTo(scriptIndex);

        return scriptIndex;
    }

    //创建主指标
    this.CreateMainScript=function(src)
    {
        var scriptIndex=null;
        switch(src.ClassName)
        {
            case "ScriptIndex":
            case "OverlayScriptIndex":
                scriptIndex=new ScriptIndex();
                break;
            case "APIScriptIndex":
                scriptIndex=new APIScriptIndex();
                break;
        }

        src.CopyTo(scriptIndex);

        return scriptIndex;
    }

    //删除主指标, 如果有叠加指标，移动第1个叠加指标为主指标, 没有叠加指标，删除指标窗口
    this.DeleteMainIndex=function(identify, windowIndex)
    {
        var mainIndex=this.WindowIndex[windowIndex];
        if (!mainIndex) return false;

        var subFrame=this.Frame.SubFrame[windowIndex];
        if (!subFrame) return false;
        if (!IFrameSplitOperator.IsNonEmptyArray(subFrame.OverlayIndex))
        {
            this.RemoveIndexWindow(windowIndex, { DeleteMainIndex:true });
        }
        else
        {
            var overlayItem=subFrame.OverlayIndex[0];
            this.DeleteOverlayIndex(overlayItem.Identify, windowIndex);

            this.WindowIndex[windowIndex] = this.CreateMainScript(overlayItem.Script);    
            var bindData=this.GetMainData();

            this.BindIndexData(windowIndex,bindData);     //执行脚本
        }
    }

    this.GetMainData=function()
    {
        switch(this.ClassName)
        {
            case "MinuteChartContainer":
            case "MinuteChartHScreenContainer":
                return this.SourceData;
            case "KLineChartContainer":
            case "KLineChartHScreenContainer":
                return this.ChartPaint[0].Data;
        }
    }

    this.CreateOverlayFrame=function()
    {
        switch(this.ClassName)
        {
            case "KLineChartContainer":
                return new OverlayKLineFrame();
            case "KLineChartHScreenContainer":
                return new OverlayKLineHScreenFrame();
            case "MinuteChartContainer":
                return new OverlayMinuteFrame();
            case "MinuteChartHScreenContainer":
                return new OverlayMinuteHScreenFrame();
        }
    }

    //数据导出
    this.ExportData=function(option)
    {
        if (!this.ExportMainData) return null;
        if (!this.ChartPaint[0]) return null;
        var mainData=this.GetMainData();
        if (!mainData || !IFrameSplitOperator.IsNonEmptyArray(mainData.Data)) return null;

        var range=null;
        var aryKData=mainData.Data;   //K线/分时数据
        if (option.Start && option.End) range=mainData.GetDataRange(option.Start, option.End);
        var aryData=this.ExportMainData(mainData, range);   //导出K线/分时
        if (!aryData) return null;

        //主图+附图指标
        for(var i=1;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            if (!item || !item.ExportData) continue;

            var data=item.ExportData(aryKData, range);

            if (data && IFrameSplitOperator.IsNonEmptyArray(data))
            {
                for(var j=0;j<data.length;++j)
                {
                    var subItem=data[j];
                    if (item.IndexName) aryData.push({Name:`${subItem.Name}(${item.IndexName})`, Data:subItem.Data});
                    else aryData.push(subItem);
                }
            }
        }
        
        //叠加股票
        for(var i=0;i<this.OverlayChartPaint.length;++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Data || !IFrameSplitOperator.IsNonEmptyArray(chart.Data.Data)) continue;
            var data=this.ExportMainData(item.Data, { IsOverlay:true });   

            if (data && IFrameSplitOperator.IsNonEmptyArray(data))
            {
                for(var j=0;j<data.length;++j)
                {
                    var subItem=data[j];
                    aryData.push({ Name:`${subItem.Name}(${item.Symbol})`, Data:subItem.Data} );
                }
            }
        }

        //叠加指标
        for(var i=0, j=0, k=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            for(j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (IFrameSplitOperator.IsNonEmptyArray(overlayItem.ChartPaint))
                {
                    for(k=0;k<overlayItem.ChartPaint.length;++k)
                    {
                        var chart=overlayItem.ChartPaint[k];
                        if (!chart || !chart.ExportData) continue;
                        var data=chart.ExportData(aryKData, range);

                        if (data && IFrameSplitOperator.IsNonEmptyArray(data))
                        {
                            for(var index=0;index<data.length;++index)
                            {
                                var subItem=data[index];
                                if (chart.IndexName) aryData.push({Name:`${subItem.Name}(${chart.IndexName})`, Data:subItem.Data});
                                else aryData.push(subItem);
                            }
                        }
                    }
                }
                
            }
        }

        if (option && option.Type=="CSV") 
        {
            return this.ExportDataToCSV(aryData);
        }
        
        return aryData;
    }

    //重置指标计数器
    this.ClearIndexRunCount=function()
    {
        //主图指标
        for(var i=0;i<this.WindowIndex.length;++i)
        {
            var item=this.WindowIndex[i];
            if (!item) continue;

            item.RunCount=0;
        }

        //叠加指标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Script) overlayItem.Script.RunCount=0;
            }
        }
    }

    //获取当前的显示的指标 包含叠加指标
    this.GetIndexInfo=function()
    {
        var aryIndex=[];
        for(var i=0, j=0; i<this.WindowIndex.length; ++i)
        {
            var item=this.WindowIndex[i];
            if (!item) continue;
            
            var info={ Name:item.Name, WindowIndex:i, IsOverlay:false };
            if (item.ID) info.ID=item.ID;
            if (IFrameSplitOperator.IsNonEmptyArray(item.Arguments)) //参数
            {
                info.Args=[];
                for(j=0;j<item.Arguments.length;++j)
                {
                    var argItem=item.Arguments[j];
                    info.Args.push( { Name:argItem.Name, Value:argItem.Value} );
                }
            }

            aryIndex.push(info);
        }

        this.GetOverlayIndexInfo(aryIndex); //叠加指标

        return aryIndex;
    }

    //叠加指标
    this.GetOverlayIndexInfo=function(aryIndex)
    {
        for(var i=0, j=0, k=0; i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            if (!IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex)) continue;

            for(j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (!overlayItem.Script) continue;
                var indexData=overlayItem.Script;
                var info={ Name:indexData.Name, ID:indexData.ID, WindowIndex:i, IsOverlay:true, Identify:overlayItem.Identify };

                if (IFrameSplitOperator.IsNonEmptyArray(indexData.Arguments)) //参数
                {
                    info.Args=[];
                    for(k=0;k<indexData.Arguments.length;++k)
                    {
                        var argItem=indexData.Arguments[k];
                        info.Args.push( { Name:argItem.Name, Value:argItem.Value} );
                    }
                }

                aryIndex.push(info);
            }
        }
    }

    //点tab弹菜单
    this.PopupMenuByTab=function(menuData, rtTab)
    {
        if (!this.JSPopMenu) return;

        var pixelRatio=GetDevicePixelRatio();
        var rtCell={ Left:rtTab.Left/pixelRatio, Right:rtTab.Right/pixelRatio, Bottom:rtTab.Bottom/pixelRatio, Top:rtTab.Top/pixelRatio };
        rtCell.Width=rtCell.Right-rtCell.Left;
        rtCell.Height=rtCell.Bottom-rtCell.Top;

        var rtClient=this.UIElement.getBoundingClientRect();
        var rtScroll=GetScrollPosition();

        var offsetLeft=rtClient.left+rtScroll.Left;
        var offsetTop=rtClient.top+rtScroll.Top;
        rtCell.Left+=offsetLeft;
        rtCell.Right+=offsetLeft;
        rtCell.Top+=offsetTop;
        rtCell.Bottom+=offsetTop;

        this.JSPopMenu.CreatePopMenu(menuData);
        this.JSPopMenu.PopupMenuByTab(rtCell);
    }

    //下拉菜单
    this.PopupMenuByDrapdown=function(menuData, rtButton)
    {
        if (!this.JSPopMenu) return;

        var pixelRatio=GetDevicePixelRatio();
        var rtCell={ Left:rtButton.Left/pixelRatio, Right:rtButton.Right/pixelRatio, Bottom:rtButton.Bottom/pixelRatio, Top:rtButton.Top/pixelRatio };
        rtCell.Width=rtCell.Right-rtCell.Left;
        rtCell.Height=rtCell.Bottom-rtCell.Top;

        var rtClient=this.UIElement.getBoundingClientRect();
        var rtScroll=GetScrollPosition();

        var offsetLeft=rtClient.left+rtScroll.Left;
        var offsetTop=rtClient.top+rtScroll.Top;
        rtCell.Left+=offsetLeft;
        rtCell.Right+=offsetLeft;
        rtCell.Top+=offsetTop;
        rtCell.Bottom+=offsetTop;

        this.JSPopMenu.CreatePopMenu(menuData);
        this.JSPopMenu.PopupMenuByDrapdown(rtCell);
    }

    //右键菜单
    this.PopupMenuByRClick=function(menuData, x, y)
    {
        if (!this.JSPopMenu) return;

        var rtClient=this.UIElement.getBoundingClientRect();
        var rtScroll=GetScrollPosition();

        x+=rtClient.left+rtScroll.Left;
        y+=rtClient.top+rtScroll.Top;

        this.JSPopMenu.CreatePopMenu(menuData);
        this.JSPopMenu.PopupMenuByRight(x,y);
    }

    //菜单命令
    this.ExecuteMenuCommand=function(cmdID, aryArgs)
    {
        JSConsole.Chart.Log('[JSChartContainer::ExecuteMenuCommand] cmdID=, aryArgs=', cmdID,aryArgs);

        var param=null, srcParam=null;  //原始值
        if (IFrameSplitOperator.IsNonEmptyArray(aryArgs))
        {
            srcParam=aryArgs[0];
            if (IFrameSplitOperator.IsNumber(aryArgs[0])) param=aryArgs[0];
        }

        switch(cmdID)
        {
            case JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID:
                if (this.ChangePeriod && param!=null)
                    this.ChangePeriod(param);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID:
                if (this.ChangeIndexWindowCount && param!=null)
                    this.ChangeIndexWindowCount(param);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_RIGHT_ID:
                if (this.ChangeRight && param!=null)
                    this.ChangeRight(param);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID:
                if (this.ChangeIndex && param!=null && aryArgs[1]) 
                    this.ChangeIndex(param,aryArgs[1]);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_API_INDEX_ID:
                if (this.ChangeAPIIndex && param!=null && aryArgs[1]) 
                    this.ChangeAPIIndex(param, aryArgs[1]);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_SCRIPT_INDEX_ID:
                if (this.ChangeScriptIndex && param!=null && aryArgs[1]) 
                    this.ChangeScriptIndex(param,aryArgs[1],aryArgs[2]);
                break;

            case JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID:
            case JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID:
                if (this.ChangeInstructionIndex && aryArgs[0])
                    this.ChangeInstructionIndex(aryArgs[0]);
                break;
            case JSCHART_MENU_ID.CMD_DELETE_COLOR_INDEX_ID:    //删除五彩K线指标
            case JSCHART_MENU_ID.CMD_DELETE_TRADE_INDEX_ID:    //删除专家系统(交易指标)
                if (this.CancelInstructionIndex) this.CancelInstructionIndex();
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID:      //切换K线类型
                if (this.ChangeKLineDrawType && param!=null)
                    this.ChangeKLineDrawType(param,aryArgs[1],aryArgs[2]);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_PRICE_GAP_ID:       //缺口提示
                if (this.ChangePriceGap && IFrameSplitOperator.IsBool(aryArgs[0]))
                {
                    if (aryArgs[0]==false)
                    {
                        this.ChangePriceGap({ Enable:aryArgs[0] });
                    }
                    else 
                    {
                        if (IFrameSplitOperator.IsNumber(aryArgs[1]))
                            this.ChangePriceGap({ Enable:aryArgs[0], Count:aryArgs[1] });
                    }
                }
                break;
            case JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID:
                if (aryArgs[1]===true)
                {
                    if (this.OverlaySymbol && aryArgs[0]) this.OverlaySymbol(aryArgs[0]);
                }
                else if (aryArgs[1]===false)
                {
                    if (this.DeleteOverlaySymbol && aryArgs[0]) this.DeleteOverlaySymbol(aryArgs[0]);
                }
                break;
            case JSCHART_MENU_ID.CMD_DELETE_ALL_OVERLAY_SYMBOL_ID:
                if (this.ClearOverlaySymbol) this.ClearOverlaySymbol();
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID:
                if (this.ChangeCoordinateType && aryArgs[0]) this.ChangeCoordinateType(aryArgs[0]);
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID:
                if (aryArgs[0] && IFrameSplitOperator.IsBool(aryArgs[1]))
                {
                    if (aryArgs[1]==true && this.AddKLineInfo) this.AddKLineInfo(aryArgs[0],true);
                    else if (aryArgs[1]==false && this.DeleteKLineInfo) this.DeleteKLineInfo(aryArgs[0]);
                }
                break;
            case JSCHART_MENU_ID.CMD_DELETE_ALL_KLINE_INFO_ID:
                if (this.ClearKLineInfo) this.ClearKLineInfo();
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_DRAG_MODE_ID:
                if (param!=null) this.DragMode=param;
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_BG_SPLIT_ID:
                if (IFrameSplitOperator.IsBool(srcParam))
                {
                    if (srcParam) 
                    {
                        this.CreateExtendChart("SessionBreaksPaint", { }); 
                        this.Draw();
                    }
                    else 
                    {
                        var finder=this.GetExtendChartByClassName("SessionBreaksPaint");
                        if (finder) 
                        {
                            this.DeleteExtendChartByID(finder.Chart.ID);
                            this.Draw();
                        }
                    }
                }
                break;
            case JSCHART_MENU_ID.CMD_SHOW_DRAWTOOL_ID:
                if (!this.IsShowDrawToolDialog()) 
                    this.ShowDrawToolDialog();
                break;
            case JSCHART_MENU_ID.CMD_SHOW_STOCKCHIP_ID:
                var option={Name:'筹码分布', ShowType:1, Width:230 };
                var extendChart=this.CreateExtendChart(option.Name, option);   //创建扩展图形
                this.SetSizeChange(true);
                this.Draw();
                break;
            case JSCHART_MENU_ID.CMD_HIDE_STOCKCHIP_ID:
                var StockChip=this.GetExtendChartByClassName('StockChip');
                if (StockChip)
                {
                    var chipWidth=StockChip.Chart.Width;
                    this.DeleteExtendChart(StockChip); 
                    this.Frame.ChartBorder.Right-=chipWidth;
                    this.SetSizeChange(true);
                    this.Draw();
                }
                break;
            case JSCHART_MENU_ID.CMD_ENABLE_SELECT_RECT_ID:
                if (IFrameSplitOperator.IsBool(srcParam))
                    this.EnableSelectRect=srcParam;
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_DAY_COUNT_ID:
                if (this.ChangeDayCount && param!=null)
                    this.ChangeDayCount(param);
                break;
            case JSCHART_MENU_ID.CMD_SHOW_BEFORE_DATA_ID:
                if (this.ShowCallAuctionData && IFrameSplitOperator.IsBool(srcParam))
                    this.ShowCallAuctionData({ Left:srcParam, MultiDay:{ Left:srcParam }});
                break;
            case JSCHART_MENU_ID.CMD_CHANGE_BASELINE_ID:
                if (this.ChangeBaselineType && IFrameSplitOperator.IsNumber(param))
                    this.ChangeBaselineType(param);
                break;

            case JSCHART_MENU_ID.CMD_SELECTED_ZOOM_ID:
                if (this.ShowSelectData && srcParam) this.ShowSelectData(srcParam);
                break;
            case JSCHART_MENU_ID.CMD_SELECTED_SUMMARY_ID:
                var dlg=new KLineSelectRectDialog(this.DivElement);
                dlg.DoModal(srcParam);
                break;

            case JSCHART_MENU_ID.CMD_SHOW_INDEX_ID:        //显示隐藏指标   [0]=windowIndex [1]=0=自动 1=隐藏 2=显示
                if (param==null || !IFrameSplitOperator.IsNumber(aryArgs[1])) return false;
                var windowIndex=param, showType=aryArgs[1];
                var script=this.WindowIndex[windowIndex];
                if (!script) return false;
            
                if (showType==1) script.IsShow=false;
                else if (showType==2) script.IsShow=true;
                else script.IsShow=!script.IsShow;

                this.UpdateWindowIndex(windowIndex);
                break;

            case JSCHART_MENU_ID.CMD_SHOW_OVERLAY_INDEX_ID:   //显示隐藏叠加指标 [0]=indexGuid [1]=0=自动 1=隐藏 2=显示
                if (!srcParam || !IFrameSplitOperator.IsNumber(aryArgs[1])) return false;
                var indexGuid=srcParam,showType=aryArgs[1];

                var overlay=this.GetOverlayIndexByIdentify(indexGuid);
                if (!overlay || !overlay.OverlayItem || !overlay.OverlayItem.Script) return false;

                var script=overlay.OverlayItem.Script;

                if (showType==1) script.IsShow=false;
                else if (showType==2) script.IsShow==true;
                else script.IsShow=!script.IsShow;

                this.UpdateOverlayIndex(indexGuid);
                break;
            case JSCHART_MENU_ID.CMD_DELETE_OVERLAY_INDEX_ID:
                if (srcParam && this.DeleteOverlayWindowsIndex)
                    this.DeleteOverlayWindowsIndex(srcParam);
                break;
            case JSCHART_MENU_ID.CMD_SHOW_OVERLAY_Y_AXIS_ID:
                if (!srcParam || !IFrameSplitOperator.IsNumber(aryArgs[1])) return false;
                if (!this.GetOverlayIndexByIdentify) return false;

                var indexGuid=srcParam,showType=aryArgs[1];
                var finder=this.GetOverlayIndexByIdentify(indexGuid);
                if (!finder || !finder.OverlayItem) return false;
                
                var frame=finder.OverlayItem.Frame;
                if (showType==1) frame.IsShow=false;
                else if (showType==2) frame.IsShow==true;
                else frame.IsShow=!frame.IsShow; 

                this.UpdataDataoffset();           //更新数据偏移
                this.UpdateFrameMaxMin();          //调整坐标最大 最小值
                this.Draw();

                break;

            case JSCHART_MENU_ID.CMD_ENABLE_OVERLAY_SHARE_Y_ID:
                if (!srcParam || !IFrameSplitOperator.IsNumber(aryArgs[1])) return false;
                if (!this.GetOverlayIndexByIdentify) return false;

                var indexGuid=srcParam,showType=aryArgs[1];
                var finder=this.GetOverlayIndexByIdentify(indexGuid);
                if (!finder || !finder.OverlayItem) return false;

                var frame=finder.OverlayItem.Frame;
                if (showType==1) frame.IsShareY=false;
                else if (showType==2) frame.IsShareY==true;
                else frame.IsShareY=!frame.IsShareY; 

                this.UpdataDataoffset();           //更新数据偏移
                this.UpdateFrameMaxMin();          //调整坐标最大 最小值
                this.Draw();

                break;
            case JSCHART_MENU_ID.CMD_CHANGE_DEFAULTCURSOR_ID:
                if (!IFrameSplitOperator.IsString(srcParam)) return;
                this.DefaultCursor=srcParam;
                this.UIElement.style.cursor=this.DefaultCursor;
                break;

            case JSCHART_MENU_ID.CMD_ADD_OVERLAY_INDEX_ID:  //叠加指标 0=windowIndex, 1=indexinfo
                if (param==null || !aryArgs[1]) return false;
                var obj=aryArgs[1];
                obj.WindowIndex=param;
                this.AddOverlayIndex(obj);
                break;

            case JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID:
                if (srcParam) this.SetLanguage(srcParam);
                break;

            case JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID:
                if (param!=null)
                {
                    if (this.ChartDragSelectRect) this.ChartDragSelectRect.ShowMode=param;
                }
                break;

            case JSCHART_MENU_ID.CMD_SHOW_CORSS_LINE_ID:
                if (IFrameSplitOperator.IsBool(srcParam))
                {
                    if (this.ChartCorssCursor) this.ChartCorssCursor.IsShowCorss=srcParam;
                }
                break;
         
            case JSCHART_MENU_ID.CMD_ENABLE_POP_MINUTE_CHART_ID://双击弹分时图
                if (IFrameSplitOperator.IsBool(srcParam))
                {
                    if (srcParam) 
                    {
                        this.DestroyPopMinuteChart();
                        this.InitalPopMinuteChart( {KLine:{KLineDoubleClick:true}} );
                    }
                    else 
                    {
                        this.DestroyPopMinuteChart();
                    }
                }
                break;
        }
    }

    this.GetShowIndexMenuData=function(windowIndex, showType)
    {
        var script=this.WindowIndex[windowIndex];
        if (!script) return null;

        var data= { Name:script.IsShow?"隐藏指标":"显示指标",  Data:{ ID: JSCHART_MENU_ID.CMD_SHOW_INDEX_ID, Args:[windowIndex, 0] } };  

        return data;
    }

    this.GetShowOverlayIndexMenuData=function(indexGuid, showType)
    {
        var overlay=this.GetOverlayIndexByIdentify(indexGuid);
        if (!overlay || !overlay.OverlayItem || !overlay.OverlayItem.Script) return null;

        var script=overlay.OverlayItem.Script;
        var data= { Name:script.IsShow?"隐藏指标":"显示指标",  Data:{ ID: JSCHART_MENU_ID.CMD_SHOW_OVERLAY_INDEX_ID, Args:[indexGuid, 0] } };  

        return data;
    }

    this.GetShowOverlayIndexYAxisMenuData=function(indexGuid, showType)
    {
        var overlay=this.GetOverlayIndexByIdentify(indexGuid);
        if (!overlay || !overlay.OverlayItem || !overlay.OverlayItem.Script) return null;

        var frame=overlay.OverlayItem.Frame;
        var data= { Name:frame.IsShow?"隐藏Y轴":"显示Y轴",  Data:{ ID: JSCHART_MENU_ID.CMD_SHOW_OVERLAY_Y_AXIS_ID, Args:[indexGuid, 0] } };  

        return data;
    }

    this.GetOverlayIndexShareYMenuData=function(indexGuid, showType)
    {
        var overlay=this.GetOverlayIndexByIdentify(indexGuid);
        if (!overlay || !overlay.OverlayItem || !overlay.OverlayItem.Script) return null;

        var frame=overlay.OverlayItem.Frame;
        var data= { Name:"公用窗口Y轴", Data:{ ID: JSCHART_MENU_ID.CMD_ENABLE_OVERLAY_SHARE_Y_ID, Args:[indexGuid, 0] } , Checked:frame.IsShareY };  

        return data;
    }

    //点击右键菜单
    this.OnClickRightMenu=function(data)
    {
        JSConsole.Chart.Log('[JSChartContainer::OnClickRightMenu] ',data);
        if (!data || !data.Data) return;

        var cmdID=data.Data.ID;     //命令ID
        var aryArgs=data.Data.Args; //参数

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MENU_COMMAND);  //回调通知外部
        if (event && event.Callback)
        {
            var data={ PreventDefault:false, CommandID:cmdID, Args:aryArgs, SrcData:data };
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }

        this.ExecuteMenuCommand(cmdID, aryArgs);
    }

    this.PopupRightMenuV2=function(data,e)
    {
        if (!this.JSPopMenu) return;
        var x=data.X, y=data.Y;
        var frameID=data.FrameID;
        var menuData={ Menu:this.GetRightMenuData(frameID), Position:JSPopMenu.POSITION_ID.RIGHT_MENU_ID };
        menuData.ClickCallback=(data)=>{ this.OnClickRightMenu(data); }

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_RIGHT_MENU);
        if (event && event.Callback)
        {
            var sendData={ MenuData:menuData, FrameID:frameID };
            event.Callback(event, sendData, this);
        }

        this.PopupMenuByRClick(menuData, x, y);
    }

    //指标窗口扩展图形
    this.CreateChartPaintExtend=function(chart, windowIndex)
    {
        if (windowIndex<0) return false;
        var subFrame=this.Frame.SubFrame[windowIndex];
        if (!subFrame || !subFrame.Frame) return false;

        var frame=subFrame.Frame;
        chart.Canvas=this.Canvas;
        chart.ChartBorder=frame.ChartBorder;
        chart.ChartFrame=frame;
       
        this.ChartPaintEx.push(chart);

        return true;
    }

    //删除指标窗口扩展图形 option={ ChartID:图形ID, WindowIndex:窗口 }
    this.DeleteChartPaintExtend=function(option, bCallDestroy)
    {
        if (!option) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.ChartPaintEx)) return;
       
        if (IFrameSplitOperator.IsNumber(option.WindowIndex))
        {
            var windowIndex=option.WindowIndex;
            if (!this.Frame.SubFrame[windowIndex]) return;
            var subFrame=this.Frame.SubFrame[windowIndex].Frame;
            if (!subFrame) return;

            var paint=[];  //踢出当前窗口的指标画法
            var deleteCount=0;
            for(var i=0;i<this.ChartPaintEx.length; ++i)
            {
                var item=this.ChartPaintEx[i];
                var bFind=(item.ChartFrame.Guid==subFrame.Guid || item.ChartFrame==subFrame);

                if (!bFind)
                {
                    paint.push(item);
                }
                else
                {
                    ++deleteCount;
                    if (bCallDestroy===true)
                    {
                        if (item && item.OnDestroy) item.OnDestroy();   //图形销毁
                    }
                }
            }

            if (deleteCount>0) this.ChartPaintEx=paint;
        }
    }

    this.ClearCurrnetDrawPicture=function()
    {
        this.CurrentChartDrawPicture=null;
    }


    this.CreateDragSelectRect=function(option)
    {
        var chart=g_ExtendChartPaintFactory.Create("RectDragPaint",option);
        if (!chart) return null;

        if (option && option.Enable===true) chart.Enable=true;
        chart.ChartBorder=this.Frame.ChartBorder;
        chart.ChartFrame=this.Frame;
        chart.HQChart=this;
        chart.SetOption(option);

        this.ChartDragSelectRect=chart;
    }

    this.ClearDragSelectRect=function()
    {
        if (!this.ChartDragSelectRect) return;

        this.ChartDragSelectRect.ClearPoint();
    }

    this.ShowDragSelectRect=function(ptStart, ptEnd)
    {
        if (!this.ChartDragSelectRect) return;

        this.ChartDragSelectRect.SetFirstPoint(ptStart.X, ptStart.Y);
        this.ChartDragSelectRect.SetSecondPoint(ptEnd.X, ptEnd.Y);
        this.ChartDragSelectRect.Draw();
    }
}

function GetDevicePixelRatio()
{
    if (typeof(window) =='undefined') return 1;
    return window.devicePixelRatio || 1;
}

function GetFontHeight(context, font, word)
{
    if (!context) return null;

    if (font) context.font=font;

    var text='擎';
    if (IFrameSplitOperator.IsString(word)) text=word;

    var fontInfo=context.measureText(text);
    var textHeight=fontInfo.fontBoundingBoxAscent + fontInfo.fontBoundingBoxDescent;
    if (!IFrameSplitOperator.IsNumber(textHeight)) textHeight=fontInfo.width+2*GetDevicePixelRatio();

    return textHeight;
}

function IsPhoneWeb()
{
    var userAgentInfo=navigator.userAgent;   
    const Agents =new Array("Android","iPhone","SymbianOS","Windows Phone","iPad","iPod");   
    for(var v=0;v<Agents.length;v++) 
    {      
        if(userAgentInfo.indexOf(Agents[v])>0) return true;
    }    
    return false; 
}

function OnKeyDown(e)   //键盘事件
{
    if(this.JSChartContainer && this.JSChartContainer.OnKeyDown)
        this.JSChartContainer.OnKeyDown(e);
}

function OnWheel(e)    //上下滚动事件
{
    if(this.JSChartContainer && this.JSChartContainer.OnWheel)
        this.JSChartContainer.OnWheel(e);
}

function ToFixed(number, precision)
{
    var b = 1;
    if (isNaN(number)) return number;
    if (number < 0) b = -1;
    var multiplier = Math.pow(10, precision);
    var value=Math.round(Math.abs(number) * multiplier) / multiplier * b;

    if (/^(\d+(?:\.\d+)?)(e)([\-]?\d+)$/.test(value))
        var s=value.toFixed2(precision);
    else 
        var s = value.toString();
    
    var rs = s.indexOf('.');
    if (rs < 0 && precision>0)
    {
        rs = s.length;
        s += '.';
    }

    while (s.length <= rs + precision)
    {
        s += '0';
    }

    

    return s;
}

Number.prototype.toFixed2=Number.prototype.toFixed; //备份下老的
Number.prototype.toFixed = function( precision )
{
    return ToFixed(this,precision);
}

function Guid()
{
    function S4()
    {
       return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
    }
    return "guid" + (S4()+S4()+"-"+S4()+"-"+S4()+"-"+S4()+"-"+S4()+S4()+S4());
}

function GetScrollPosition()
{
    var scrollPos={};
    var scrollTop=0;
    var scrollLeft=0;
    if (document.documentElement && (document.documentElement.scrollTop || document.documentElement.scrollLeft))
    {
        scrollTop=document.documentElement.scrollTop;
        scrollLeft=document.documentElement.scrollLeft;
    }
    else if(document.body)
    {
        scrollTop=document.body.scrollTop;
        scrollLeft=document.body.scrollLeft;
    }

    scrollPos.Top=scrollTop;
    scrollPos.Left=scrollLeft;
    return scrollPos;
}

//修正线段有毛刺
function ToFixedPoint(value)
{
    return parseInt(value)+0.5;
}

//修正粗线段毛刺
function ToFixedPoint2(width, value)
{
    var fixValue=(width % 2)===0 ? Math.floor(value):Math.floor(value) + 0.5;    //毛边修正
    return fixValue;
}

function ToFixedRect(value)
{
    // With a bitwise or.
    //rounded = (0.5 + somenum) | 0;
    // A double bitwise not.
    //rounded = ~~ (0.5 + somenum);
    // Finally, a left bitwise shift.
    //value*=GetDevicePixelRatio();
    var rounded;
    return rounded = (0.5 + value) << 0;
}

//深拷贝
function CloneData(data)
{
    if (!data) return null;

    var strData=JSON.stringify(data);
    var item= JSON.parse(strData);
    
    return item;
}

function IsRecvOverlap(rect1, rect2)
{
    return Math.max(rect1.Left,rect2.Left) < Math.min(rect1.Right,rect2.Right) && Math.max(rect1.Top,rect2.Top) < Math.min(rect1.Bottom,rect2.Bottom); 
}

function CopyMarginConfig(dest,src)
{
    if (!src || !dest) return;

    if (IFrameSplitOperator.IsNumber(src.Left)) dest.Left=src.Left;
    if (IFrameSplitOperator.IsNumber(src.Top)) dest.Top=src.Top;
    if (IFrameSplitOperator.IsNumber(src.Right)) dest.Right=src.Right;
    if (IFrameSplitOperator.IsNumber(src.Bottom)) dest.Bottom=src.Bottom;
}

//兼容老版本
function CopyMerginConfig(dest,src) { CopyMarginConfig(dest,src); }


//数值比较
function NumberCompare() { }

//<
NumberCompare.LT=function(left, right)
{
    if (IFrameSplitOperator.IsNumberV2(left, right))
    {
        //==
        if (Math.abs(left - right)< 0.0000001) return false;
    }

    return left<right;
}

//>
NumberCompare.GT=function(left, right)
{
    if (IFrameSplitOperator.IsNumberV2(left, right))
    {
        //==
        if (Math.abs(left - right)< 0.0000001) return false;
    }

    return left>right;
}




function Point()
{
    this.X;
    this.Y;
}

function SelectRectData()
{
    this.Data;                  //主数据
    this.JSChartContainer;      //行情控件

    this.Start; //数据起始位子
    this.End;   //数据结束位置

    this.XStart;//X坐标起始位置
    this.YStart;
    this.XEnd;  //X位置结束为止
    this.YEnd;
}

//坐标信息
function CoordinateInfo()
{
    this.Value;                                                 //坐标数据
    this.Message=[];                                            //坐标输出文字信息 0=左 1=右 2=内左 3=内右
    this.TextColor=g_JSChartResource.FrameSplitTextColor        //文字颜色
    this.TextBGColor;                                           //文字背景色
    this.TextColor2;                                            //右侧文字颜色,空使用TextColor
    this.Font=g_JSChartResource.FrameSplitTextFont;             //字体
    this.LineColor=g_JSChartResource.FrameSplitPen;             //线段颜色
    this.LineDash=null;                                         //当线段类型==2时 可以设置虚线样式
    this.LineType=1;                                            //线段类型 -1=不画线段 2=虚线, 8,9=集合竞价坐标
    this.LineWidth;                                             //线段宽度
    this.ExtendLine;                                            //延长线长度[ ] { Width:长度 } [0]=左 [1]=右  实例: [null, { Width: 50}];  
    this.ExtendData;                                            //扩展属性
                                                                //百分比 { PriceColor:, PercentageColor:, SplitColor:, Font: }
                                                                //自定义刻度 { Custom:{ Position: 1=强制内部 }}
    this.AreaData;  //区域: { Start:, End:, BGColor:, Position:[0=左, 1=右] }
}


//边框信息
function ChartBorder()
{
    this.UIElement;

    //四周间距
    this.Left=50;
    this.Right=80;
    this.Top=50;
    this.Bottom=50;
    this.TitleHeight=24;    //标题高度
    this.TopSpace=0;
    this.BottomSpace=0;

    this.LeftExtendWidth=0;      //左边扩展图形宽度
    this.RightExtendWidth=0;

    this.MultiDayMinute={ Count:1, Left:0, Right:0 }  // { Count:天数, Left:, Right: }

    this.IsShowTitleOnly=false;                       // 是否只显示标题

    this.GetBorder=function()
    {
        var data=
        { 
            Left:this.Left, 
            LeftEx:this.Left+this.LeftExtendWidth,
            Right:this.UIElement.width-this.Right,
            RightEx:this.UIElement.width-this.Right-this.RightExtendWidth,

            Top:this.Top,
            TopEx:this.Top+this.TitleHeight+this.TopSpace,
            TopTitle:this.Top+this.TitleHeight,
            Bottom:this.UIElement.height-this.Bottom,
            BottomEx:this.UIElement.height-this.Bottom-this.BottomSpace,

            ChartWidth:this.UIElement.width,
            ChartHeight:this.UIElement.height
        };

        if (this.MultiDayMinute && this.MultiDayMinute.Count>1 && ( this.MultiDayMinute.Left>0 || this.MultiDayMinute.Right>0 ))
        {
            var frameWidth=this.UIElement.width-this.Left-this.Right;   //坐标框子宽度
            var dayWidth=frameWidth/this.MultiDayMinute.Count;   // 每天的框子的宽度

            var dayBorder=[];
            for(var i=0;i<this.MultiDayMinute.Count;++i)
            {
                var item={ Left:this.Left+dayWidth*i, Right:this.Left+dayWidth*(i+1) };
                item.LeftEx=item.Left+this.MultiDayMinute.Left;
                item.RightEx=item.Right-this.MultiDayMinute.Right;
                if (i>0) item.Left+=1;  //第2天的盘前 移到一个像素,跟上一天分开

                dayBorder.push(item);
            }

            data.DayBorder=dayBorder;
        }

        return data;
    }

    this.GetHScreenBorder=function()
    {
        var data=
        {
            Left:this.Left,
            LeftEx:this.Left+this.BottomSpace,

            Right:this.UIElement.width-this.Right,
            RightEx:this.UIElement.width-this.Right-this.TitleHeight- this.TopSpace,
            RightTitle:this.UIElement.width-this.Right-this.TitleHeight,

            Top:this.Top,
            TopEx:this.Top+this.LeftExtendWidth,
            Bottom:this.UIElement.height-this.Bottom,
            BottomEx:this.UIElement.height-this.Bottom-this.RightExtendWidth,

            ChartWidth:this.UIElement.width,
            ChartHeight:this.UIElement.height
        };

        if (this.MultiDayMinute && this.MultiDayMinute.Count>1 && ( this.MultiDayMinute.Left>0 || this.MultiDayMinute.Right>0 ))
        {
            var frameWidth=this.UIElement.height-this.Top-this.Bottom;   //坐标框子宽度
            var dayWidth=frameWidth/this.MultiDayMinute.Count;          //每天的框子的宽度

            var dayBorder=[];
            for(var i=0;i<this.MultiDayMinute.Count;++i)
            {
                var item={ Top:this.Top+dayWidth*i, Bottom:this.Top+dayWidth*(i+1) };
                item.TopEx=item.Top+this.MultiDayMinute.Left;
                item.BottomEx=item.Bottom-this.MultiDayMinute.Right;
                dayBorder.push(item);
            }

            data.DayBorder=dayBorder;
        }

        return data;
    }

    //1=在K线上 -1不在图上 [200-299]=集合竞价 [300-399]=集合竞价 2=左边集合竞价 3=右边集合竞价
    this.PtInClient=function(x, y, canvas, isHScreen)
    {
        if (isHScreen)
        {
            var border=this.GetHScreenBorder();
            canvas.rect(border.Left,border.TopEx,border.Right-border.Left,border.BottomEx-border.TopEx);
        }
        else
        {
            var border=this.GetBorder();
            if (border.DayBorder)   //多日分时+多日集合竞价
            {
                for(var i=0;i<border.DayBorder.length;++i)
                {
                    var client=border.DayBorder[i];
                    canvas.beginPath();
                    canvas.rect(client.LeftEx,border.TopEx,client.RightEx-client.LeftEx,border.BottomEx-border.TopEx);
                    if (canvas.isPointInPath(x,y)) return 1;

                    //盘前
                    canvas.beginPath();
                    canvas.rect(client.Left,border.TopEx,client.LeftEx-client.Left,border.BottomEx-border.TopEx);
                    if (canvas.isPointInPath(x,y)) 
                        return 200+parseInt(i);

                    //盘后
                    canvas.beginPath();
                    canvas.rect(client.RightEx,border.TopEx,client.Right-client.RightEx,border.BottomEx-border.TopEx);
                    if (canvas.isPointInPath(x,y)) 
                        return 300+parseInt(i);
                }

                return -1;
            }

            canvas.rect(border.LeftEx,border.Top,border.RightEx-border.LeftEx,border.Bottom-border.Top);
        }

        if (canvas.isPointInPath(x,y)) return 1;

        if (this.LeftExtendWidth>10)
        {
            canvas.beginPath();
            if (isHScreen===true)
            {
                canvas.rect(border.Left,border.Top,border.Right-border.Left,border.TopEx-border.Top);
            }
            else
            {
                canvas.rect(border.Left,border.Top,border.LeftEx-border.Left,border.Bottom-border.Top);
            }
    
            if (canvas.isPointInPath(x,y)) return 2;
        }

        if (this.RightExtendWidth>10)
        {
            canvas.beginPath();
            if (isHScreen===true)
            {
                canvas.rect(border.Left,border.BottomEx,border.Right-border.Left,border.Bottom-border.BottomEx);
            }
            else
            {
                canvas.rect(border.RightEx,border.Top,border.Right-border.RightEx,border.Bottom-border.Top);
            }
    
            if (canvas.isPointInPath(x,y)) return 3;
        }

        return -1;
    }

    this.GetChartWidth=function()
    {
        return this.UIElement.width;
    }

    this.GetChartHeight=function()
    {
        return this.UIElement.height;
    }

    this.GetLeft=function()
    {
        return this.Left+this.LeftExtendWidth;
    }

    this.GetRight=function()
    {
        return this.UIElement.width-this.Right-this.RightExtendWidth;
    }

    this.GetTop=function()
    {
        return this.Top;
    }

    this.GetTopEx=function()    //去掉标题，上面间距
    {
        return this.Top+this.TitleHeight+this.TopSpace;
    }

    this.GetTopTitle=function() //去掉标题
    {
        return this.Top+this.TitleHeight;
    }

    this.GetBottom=function()
    {
        return this.UIElement.height-this.Bottom;
    }

    this.GetBottomEx=function()
    {
        return this.UIElement.height-this.Bottom-this.BottomSpace;
    }

    this.GetWidth=function()
    {
        return this.UIElement.width-this.Left-this.Right-this.LeftExtendWidth-this.RightExtendWidth;
    }

    this.GetHeight=function()
    {
        return this.UIElement.height-this.Top-this.Bottom;
    }

    this.GetHeightEx=function() //去掉标题的高度, 上下间距
    {
        return this.UIElement.height-this.Top-this.Bottom-this.TitleHeight-this.TopSpace-this.BottomSpace;
    }

    this.GetRightEx=function()  //横屏去掉标题高度的 上面间距
    {
        return this.UIElement.width-this.Right-this.TitleHeight- this.TopSpace;
    }

    this.GetWidthEx=function()  //横屏去掉标题宽度 上下间距
    {
        return this.UIElement.width-this.Left-this.Right-this.TitleHeight- this.TopSpace - this.BottomSpace;
    }

    this.GetLeftEx = function () //横屏
    {
        return this.Left+this.BottomSpace;
    }

    this.GetRightTitle = function ()//横屏
    {
        return this.UIElement.width - this.Right - this.TitleHeight;
    }

    this.GetTitleHeight=function()
    {
        return this.TitleHeight;
    }
}

//框架外部挂接
function ChartFrameFactory()
{
    //[key:name, { Create:function(option) { return new class(); }} ]
    this.DataMap=new Map(
    [
        ["KLineFrame", { Create:function(option) { return new KLineFrame(); } }],   //K线图
        ["KLineHScreenFrame", { Create:function(option) { return new KLineHScreenFrame(); } }], 
    ]); 

    this.Create=function(name, option)
    {
        if (!this.DataMap.has(name)) 
        {
            JSConsole.Warn(`[ChartFrameFactory::Create] can't find class=${name}.`);
            return null;
        }

        var item=this.DataMap.get(name);
        return item.Create(option);
    }

    this.Add=function(name, option)
    {
        var oldData=null;
        if (this.DataMap.has(name)) oldData=this.DataMap.get(name);

        this.DataMap.set(name, { Create:option.Create } );

        return oldData;
    }
}

var g_ChartFrameFactory=new ChartFrameFactory();


function IChartFramePainting()
{
    this.HorizontalInfo=new Array();    //Y轴
    this.VerticalInfo=new Array();      //X轴
    this.ClassName='IChartFramePainting';

    this.Canvas;                        //画布

    this.Identify;                      //窗口标识
    this.Guid=Guid();                   //内部窗口唯一标识

    this.ChartBorder;
    this.PenBorder=g_JSChartResource.FrameBorderPen;        //边框颜色
    this.TitleBGColor=g_JSChartResource.FrameTitleBGColor;  //标题背景色
    this.IsShow=true;                   //是否显示
    this.SizeChange=true;               //大小是否改变
    this.XYSplit=true;                  //XY轴坐标信息改变
    this.XSplit=true;                   //X轴变化
    this.YCustomSplit=true;            //自定义Y轴分割线

    this.HorizontalMax;                 //Y轴最大值
    this.HorizontalMin;                 //Y轴最小值
    this.HorizontalReserved=null;       //Y轴预留高度 { Top:上, Bottom:下 }
    this.XPointCount=10;                //X轴数据个数

    this.ClientBGColor;                 //客户区背景色

    //Y轴原始的最大值 最小值
    this.YMaxMin={ Max:null, Min:null };

    this.YSplitOperator;               //Y轴分割
    this.XSplitOperator;               //X轴分割
    this.Data;                         //主数据

    this.IsLocked=false;               //是否上锁
    this.LockPaint = null;

    this.YSpecificMaxMin=null;         //指定Y轴最大最小值
    this.IsShowBorder = true;          //是否显示边框
    this.IsShowTitleArrow=g_JSChartResource.IndexTitle.EnableIndexArrow;        //是否显示指标信息上涨下跌箭头
    this.TitleArrowType=g_JSChartResource.IndexTitle.ArrowType;             //指标信息上涨下跌箭头类型 0=独立颜色 1=跟指标名字颜色一致
    this.IsShowIndexName=true;         //是否显示指标名字
    this.IsShowOverlayIndexName=true;  //是否显示叠加指标名字
    //this.OverlayIndexType= { Position:0, LineSpace:5 };
    this.OverlayIndexType= { Position:1, LineSpace:3 };
    this.IndexParamSpace=2;            //指标参数数值显示间距
    this.IndexTitleSpace=0;            //指标标题和参数值之间的间距
    this.IsShowIndexTitle=true;        //显示整个指标标题信息
    this.IsDrawTitleBottomLine=false;

    this.BorderLine=null;               //1=上 2=下 4=左 8=右
    this.Buttons=[];                    //按钮事件 
    this.LeftButtonWidth=0;             //左侧按钮的宽度

    this.IsMinSize=false;               //窗口是否最小化

    this.LogoTextColor=g_JSChartResource.FrameLogo.TextColor;
    this.LogoTextFont=g_JSChartResource.FrameLogo.Font;
    this.LogoBGColor=g_JSChartResource.FrameLogo.BGColor;
    this.GlobalOption;

    //this.IsDrawLeftBorder;
    this.IsDrawRightBorder=false;   //是否绘制右侧刻度空白的边框
    this.IsDrawLeftBorder=false;    //是否绘制右侧刻度空白的边框

    this.PtInButtons=function(x,y) //坐标是否在按钮上
    {
        for(var i=0;i<this.Buttons.length;++i)
        {
            var item=this.Buttons[i];
            if (!item.Rect) continue;

            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.Left,rect.Top,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                return { ID:item.ID, Rect:rect };
            }

        }

        return null;
    }

    this.GetBorder=function()
    {
        if (this.IsHScreen) return this.ChartBorder.GetHScreenBorder();
        else return this.ChartBorder.GetBorder();
    }

    this.Draw=function()
    {
        this.Buttons=[];
        this.DrawClientBG();
        this.DrawFrame();
        this.DrawBorder();

        this.SizeChange=false;
        this.XYSplit=false;
        this.XSplit=false;
        this.YCustomSplit=false;            //自定义Y轴分割线
    }

    this.DrawFrame=function() { }

    this.DrawClientBG=function()
    {
        if (!this.ClientBGColor) return;

        var border=this.IsHScreen==true?this.ChartBorder.GetHScreenBorder():this.ChartBorder.GetBorder();

        var left=ToFixedPoint(border.Left);
        var top=ToFixedPoint(border.Top);
        //var top=ToFixedPoint(border.TopEx);
        var right=ToFixedPoint(border.Right);
        var bottom=ToFixedPoint(border.Bottom);
        var width=right-left;
        var height=bottom-top;

        this.Canvas.fillStyle=this.ClientBGColor;
        this.Canvas.fillRect(left,top,width,height);

    }

    this.ClearCoordinateText=function(option)
    {
        if (IFrameSplitOperator.IsNonEmptyArray(this.HorizontalInfo))
        {
            for(var i=0;i<this.HorizontalInfo.length;++i)
            {
                var item=this.HorizontalInfo[i];
                if (item && item.Message && Array.isArray(item.Message)) item.Message[0]=item.Message[1]=null;
            }
        }

        if (IFrameSplitOperator.IsNonEmptyArray(this.VerticalInfo))
        {
            for(var i=0;i<this.VerticalInfo.length;++i)
            {
                var item=this.VerticalInfo[i];
                if (item && item.Message && Array.isArray(item.Message)) item.Message[0]=item.Message[1]=null;
            }
        }
    }

    //画边框
    this.DrawBorder=function()
    {
        if (!this.IsShowBorder) return;
        if (this.IsMinSize) return;

        var border=this.IsHScreen==true?this.ChartBorder.GetHScreenBorder():this.ChartBorder.GetBorder();

        var left=ToFixedPoint(border.Left);
        var top=ToFixedPoint(border.Top);
        //var top=ToFixedPoint(border.TopEx);
        var right=ToFixedPoint(border.Right);
        var bottom=ToFixedPoint(border.Bottom);
        var width=right-left;
        var height=bottom-top;

        //JSConsole.Chart.Log(`[IChartFramePainting.DrawBorder] left=${left} `);
        if (this.BorderLine==null)
        {
            if (this.IsDrawRightBorder || this.IsDrawLeftBorder)
            {
                this.Canvas.strokeStyle=this.PenBorder;

                if (this.IsDrawRightBorder && this.IsDrawLeftBorder)
                {
                    var xRight=ToFixedPoint(border.ChartWidth);
                    var xLeft=ToFixedPoint(0);
                    this.Canvas.strokeRect(xLeft,top,xRight-xLeft-1,height);  //少一个像素让边框显示出来
                }
                else if (this.IsDrawRightBorder)
                {
                    var xRight=ToFixedPoint(border.ChartWidth);
                    this.Canvas.strokeRect(left,top,xRight-left-1,height);  //少一个像素让边框显示出来
                }
                else if (this.IsDrawLeftBorder)
                {
                    var xLeft=ToFixedPoint(0);
                    this.Canvas.strokeRect(xLeft,top,right-xLeft,height);  //少一个像素让边框显示出来
                }

                if (this.IsDrawRightBorder)
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(right,top);
                    this.Canvas.lineTo(right,bottom);
                    this.Canvas.stroke();
                }

                if (this.IsDrawLeftBorder)
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(left,top);
                    this.Canvas.lineTo(left,bottom);
                    this.Canvas.stroke();
                }
            }
            else
            {
                this.Canvas.strokeStyle=this.PenBorder;
                this.Canvas.strokeRect(left,top,width,height);
            }
        }
        else if (IFrameSplitOperator.IsPlusNumber(this.BorderLine)) //单独绘制每个边框
        {
            this.Canvas.strokeStyle=this.PenBorder;
            this.Canvas.beginPath();

            if ((this.BorderLine&1)>0) //上
            {
                this.Canvas.moveTo(left,top);
                this.Canvas.lineTo(right,top);
            }

            if ((this.BorderLine&2)>0)  //下
            {
                this.Canvas.moveTo(left,bottom);
                this.Canvas.lineTo(right,bottom);
            }

            if ((this.BorderLine&4)>0)  //左
            {
                this.Canvas.moveTo(left,top);
                this.Canvas.lineTo(left,bottom);
            }

            if ((this.BorderLine&8)>0)    //右
            {
                this.Canvas.moveTo(right,top);
                this.Canvas.lineTo(right,bottom);
            }
              
            this.Canvas.stroke();
        }

        /*
        if (this.IsDrawRightBorder)
        {
            var xRight=ToFixedPoint(border.ChartWidth);
            var xLeft=right;
            this.Canvas.beginPath();
            this.Canvas.moveTo(xLeft,top);
            this.Canvas.lineTo(xRight,top);
            this.Canvas.lineTo(xRight,bottom);
            this.Canvas.lineTo(xLeft,bottom);

            this.Canvas.stroke();
        }
        */
    }

    //画标题背景色
    this.DrawTitleBG=function()
    {
        if (this.ChartBorder.TitleHeight<=0) return;

        var border=this.GetBorder();

        var left=ToFixedPoint(border.Left);
        var top=ToFixedPoint(border.Top);
        var right=ToFixedPoint(border.Right);
        var bottom=ToFixedPoint(this.ChartBorder.GetTopTitle());
        var width=right-left;
        var height=bottom-top;

        this.Canvas.fillStyle=this.TitleBGColor;
        this.Canvas.fillRect(left,top,width,height);

        if (this.IsDrawTitleBottomLine)
        {
            this.Canvas.strokeStyle=this.PenBorder;
            this.Canvas.beginPath();
            this.Canvas.moveTo(left,ToFixedPoint(border.TopTitle));
            this.Canvas.lineTo(right,ToFixedPoint(border.TopTitle));
            this.Canvas.stroke();
        }
    }

    this.DrawLock=function()
    {
        if (this.IsLocked)
        {
            if (this.LockPaint == null)
                this.LockPaint = new ChartLock();
            this.LockPaint.Canvas=this.Canvas;
            this.LockPaint.ChartBorder=this.ChartBorder;
            this.LockPaint.ChartFrame=this;
            this.LockPaint.Draw(true);
        }
    }

    this.DrawLogo=function()
    {
        var border=this.GetBorder();
        var text=g_JSChartResource.FrameLogo.Text;
        if (!IFrameSplitOperator.IsString(text)) return;

        
        this.Canvas.font=this.LogoTextFont;
        this.Canvas.textAlign = 'left';
        this.Canvas.textBaseline = 'bottom';
        var height=this.Canvas.measureText("擎").width;
        var width=this.Canvas.measureText(text).width;
        if (this.IsHScreen)
        {
            var x=border.Left+5;
            var y=border.Top+5;
            this.Canvas.save();
            this.Canvas.translate(x,y);
            this.Canvas.rotate(90 * Math.PI / 180);

            var rtBG={ Left:0, Bottom:0, Width:width+4, Height:height+4 };
            rtBG.Top=rtBG.Bottom-rtBG.Height;
            rtBG.Right=rtBG.Left+rtBG.Width;

            if (this.LogoBGColor)
            {
                this.Canvas.fillStyle=this.LogoBGColor;
                this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
            }

            this.Canvas.fillStyle=this.LogoTextColor;
            this.Canvas.fillText(text,1,0);
            this.Canvas.restore();
        }
        else
        {
            var rtBG={ Left:border.Left+5, Bottom:border.Bottom-5, Width:width+4, Height:height+4 };
            rtBG.Top=rtBG.Bottom-rtBG.Height;
            rtBG.Right=rtBG.Left+rtBG.Width;

            if (this.LogoBGColor)
            {
                this.Canvas.fillStyle=this.LogoBGColor;
                this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
            }

            var x=rtBG.Left+1;
            var y=rtBG.Bottom-1;
            this.Canvas.fillStyle=this.LogoTextColor;
            this.Canvas.fillText(text,x,y);
        }   
    }

    this.CalculateLock=function()
    {
        if (this.IsLocked)
        {
            if (this.LockPaint == null)
                this.LockPaint = new ChartLock();
            this.LockPaint.Canvas=this.Canvas;
            this.LockPaint.ChartBorder=this.ChartBorder;
            this.LockPaint.ChartFrame=this;
            this.LockPaint.Draw(false);
        }
    }

    //设施上锁
    this.SetLock=function(lockData)
    {
        if (!lockData)  //空数据不上锁
        {
            this.IsLocked=false;
            return;
        }

        this.IsLocked=true;
        if (!this.LockPaint) this.LockPaint=new ChartLock();    //创建锁

        if (lockData.Callback) this.LockPaint.Callback=lockData.Callback;       //回调
        if (lockData.IndexName) this.LockPaint.IndexName=lockData.IndexName;    //指标名字
        if (lockData.ID) this.LockPaint.LockID=lockData.ID;                     //锁ID
        if (lockData.BG) this.LockPaint.BGColor=lockData.BG;                    //背景色 
        if (lockData.Text) this.LockPaint.Title= lockData.Text;   
        if (lockData.TextColor) this.LockPaint.TextColor=lockData.TextColor;  
        if (lockData.Font) this.LockPaint.Font=lockData.Font;
        if (lockData.Count) this.LockPaint.LockCount=lockData.Count;
        if (lockData.MinWidth>0) this.LockPaint.MinWidth=lockData.MinWidth;
    }

    this.GetLockRect=function()
    {
        if (!this.IsLocked) return null;
        if (!this.LockPaint) return null; 
        return this.LockPaint.LockRect;
    }

    this.ReloadResource=function(resource)
    {
        if (!resource)
        {
            this.PenBorder=g_JSChartResource.FrameBorderPen;        //边框颜色
            this.TitleBGColor=g_JSChartResource.FrameTitleBGColor;  //标题背景色
        }

        for(var i in this.HorizontalInfo)
        {
            var item=this.HorizontalInfo[i];
            if (item.Font) item.Font=g_JSChartResource.FrameSplitTextFont;             //字体
            if (item.TextColor) item.TextColor=g_JSChartResource.FrameSplitTextColor        //文字颜色
            if (item.LineColor) item.LineColor=g_JSChartResource.FrameSplitPen;             //线段颜色
        }

        for(var i in this.VerticalInfo)
        {
            var item=this.VerticalInfo[i];
            if (item.Font) item.Font=g_JSChartResource.FrameSplitTextFont;             //字体
            if (item.TextColor) item.TextColor=g_JSChartResource.FrameSplitTextColor        //文字颜色
            if (item.LineColor) item.LineColor=g_JSChartResource.FrameSplitPen;             //线段颜色
        }
    }

    this.GetFontHeight=function(font)
    {
        return GetFontHeight(this.Canvas, font, "擎");
    }

    //左右刻度文字宽度
    this.GetScaleTextWidth=function()
    {

    }

    //bIncludeOverlay =false不包含叠加框架  true=主框架+叠加框架 默认true
    this.IsMinuteFrame=function(bIncludeOverlay)
    {
        var aryName=["MinuteFrame", "MinuteHScreenFrame", "OverlayMinuteFrame", "OverlayMinuteHScreenFrame"];
        if (bIncludeOverlay===false) aryName=["MinuteFrame", "MinuteHScreenFrame"];

        var isMinute=aryName.includes(this.ClassName);
        return isMinute;
    }

    //bIncludeOverlay =false不包含叠加框架  true=主框架+叠加框架 默认true
    this.IsKLineFrame=function(bIncludeOverlay)
    {
        var aryName=["KLineFrame", "KLineHScreenFrame", "KLineHScreenFrame", "OverlayKLineHScreenFrame"];
        if (bIncludeOverlay===false) aryName=["KLineFrame", "KLineHScreenFrame"];

        var isKline=aryName.includes(this.ClassName);
        return isKline;
    }
}

//空框架只画边框
function NoneFrame()
{
    this.newMethod=IChartFramePainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="NoneFrame";

    this.Snapshot=function()
    {

    }

    this.SetSizeChage=function(sizeChange)
    {
        this.SizeChange=sizeChange;

        //画布的位置
        this.Position={
            X:this.ChartBorder.UIElement.offsetLeft,
            Y:this.ChartBorder.UIElement.offsetTop,
            W:this.ChartBorder.UIElement.clientWidth,
            H:this.ChartBorder.UIElement.clientHeight
        };
    }
}

function AverageWidthFrame()
{
    this.newMethod=IChartFramePainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="AverageWidthFrame";
    this.DataWidth=50*GetDevicePixelRatio();
    this.DistanceWidth=10*GetDevicePixelRatio();
    this.MinXDistance = 30*GetDevicePixelRatio();       //X轴刻度最小间距
    this.MinYDistance=12*GetDevicePixelRatio();         //Y轴刻度最小间距
    this.CoordinateType=0;  //坐标类型 0=普通坐标 1=反转坐标
    this.IsShowYText=[true,true];       //是否显示Y轴坐标坐标 [0=左侧] [1=右侧]
    this.XBottomOffset=g_JSChartResource.Frame.XBottomOffset;   //X轴文字显示向下偏移
    this.YTextTopOffset=g_JSChartResource.Frame.YTopOffset;         //Y轴顶部文字向下偏移
    this.YTextPosition=[0,0],       //是坐标否强制画在内部 [0=左侧] [1=右侧] 1=OUT" , 2=INSIDE
    this.YTextPadding=[g_JSChartResource.Frame.YTextPadding[0], g_JSChartResource.Frame.YTextPadding[1]],        //Y轴文字和边框间距 [0=左侧] [1=右侧]
    this.IsShowXLine=true;              //是否显示X轴刻度线
    this.IsShowYLine=true;
    this.YInsideOffset=0;
    this.YTextBaseline=0;       //0=居中 1=上部 (目前就支持内部刻度)
    this.MultiTextFormat=0;    //多行刻度信息显示模式 0=显示第1行 1=价格/百分比 2=显示2行
    this.RightTextMaxWidth=0;

    this.ShortYLineLength=5;
    this.ShortXLineLength=5;
    this.BeforeDrawXYCallback;      //坐标绘制前回调,绘制深度图
    this.GetEventCallback;          //事件回调

    //工具栏的按钮样式
    this.ToolbarButtonStyle=g_JSChartResource.ToolbarButtonStyle;
    this.CloseWindowButton=CloneData(g_JSChartResource.Buttons.CloseWindow);
    this.OverlayIndexButton=CloneData(g_JSChartResource.Buttons.OverlayIndex);
    this.ChangeIndexButton=CloneData(g_JSChartResource.Buttons.ChangeIndex);
    this.ModifyIndexParamButton=CloneData(g_JSChartResource.Buttons.ModifyIndexParam);
    this.MaxMinWindowButton=CloneData(g_JSChartResource.Buttons.MaxMinWindow);
    this.TitleWindowButton=CloneData(g_JSChartResource.Buttons.TitleWindow);
    this.ExportDataButton=CloneData(g_JSChartResource.Buttons.ExportData);

    this.ButtonTooltip=CloneData(g_JSChartResource.Buttons.Tooltip);

    //Y轴刻度长线
    this.YLineExtend;    //[0]=左 [1]=右     { Width:5, Color:颜色,  }
    this.YTextExtend;    //[0]=左 [1]=右     { Align:0=默认  1=左对齐 2=右对齐 }
    this.YRightTextInfo; 

    //X轴延长线
    this.XTextExtend;   //[0]=底部  { Align:0=默认(居中), 1=左对齐 }
    this.XLineExtend;   //[0]=底部  { Mode:1, Color: }  Mode=1 分割线  Mode=2短线

    this.FrameData={ SubFrameItem:null };    //窗口框架信息

    //画图工具刻度
    
    this.DrawPicture={ 
        BGColor:g_JSChartResource.DrawPicture.XYCoordinate.BGColor, 
        TextBGColor:g_JSChartResource.DrawPicture.XYCoordinate.TextBGColor, 
        TextColor:g_JSChartResource.DrawPicture.XYCoordinate.TextColor, Font:g_JSChartResource.DrawPicture.XYCoordinate.Font };


    this.IChartFramePainting_ReloadResource=this.ReloadResource;
    this.ReloadResource=function(resource)
    {
        this.IChartFramePainting_ReloadResource(resource);

        if (!resource)
        {
            this.ToolbarButtonStyle=g_JSChartResource.ToolbarButtonStyle;
            this.CloseWindowButton=CloneData(g_JSChartResource.Buttons.CloseWindow);
            this.OverlayIndexButton=CloneData(g_JSChartResource.Buttons.OverlayIndex);
            this.ChangeIndexButton=CloneData(g_JSChartResource.Buttons.ChangeIndex);
            this.ModifyIndexParamButton=CloneData(g_JSChartResource.Buttons.ModifyIndexParam);
            this.MaxMinWindowButton=CloneData(g_JSChartResource.Buttons.MaxMinWindow);
            this.TitleWindowButton=CloneData(g_JSChartResource.Buttons.TitleWindow);
            this.ButtonTooltip=CloneData(g_JSChartResource.Buttons.Tooltip);
        }
    }

    this.DrawFrame=function()
    {
        if (this.XPointCount>0)
        {
            let dInterval=this.ChartBorder.GetWidth()/(6*this.XPointCount); //分6份, 数据4 间距2
            this.DistanceWidth=2*dInterval;
			this.DataWidth=4*dInterval;
        }

        this.DrawHorizontal();
        this.DrawVertical();
    }

    this.DrawTitleButton=function(aryButton, moveonPoint, mouseStatus)
    {
        var border=this.GetBorder();
        if (this.IsHScreen)
        {
            var y=border.Bottom-3;
            var x=border.RightTitle+this.ChartBorder.TitleHeight/2;

            this.Canvas.save(); 
            this.Canvas.translate(x, y);
            this.Canvas.rotate(90 * Math.PI / 180);

            //底部开始画
            var yButton=0, xButton=0, bottom=0;
            for(var i=0;i<aryButton.length;++i)
            {
                var item=aryButton[i];
                var size=item.Style.Size;
                var xButton=bottom-size-item.Style.MerginLeft;
                var font=`${size}px ${item.Style.Family}`;

                var color=item.Style.Color;
                this.Canvas.fillStyle=color;
                this.Canvas.font=font;
                this.Canvas.textAlign="left";
                this.Canvas.textBaseline="middle";
                this.Canvas.fillText(item.Style.Text, xButton, 0);

                var rtButton={ Left:x-size/2, Right:x+size/2, Bottom:y, Width:size, Height:size+item.Style.MerginLeft };
                rtButton.Top=rtButton.Bottom-size-item.Style.MerginLeft;
                this.Buttons.push({ ID:item.ID, Rect:rtButton });

                bottom=xButton;
                y=rtButton.Top;
            }

            this.Canvas.restore();
        }
        else
        {
            var right=border.Right-3;
            var left=border.Left;
            var yButton=border.Top+this.ChartBorder.TitleHeight/2;
        
            //右往左绘制
            for(var i=0;i<aryButton.length;++i)
            {
                var item=aryButton[i];
                var size=item.Style.Size;
                var xBotton=right-size-item.Style.MerginLeft;
                var font=`${size}px ${item.Style.Family}`;
                var rtButton={ Left:xBotton, Top:yButton-size/2, Right:xBotton+size+item.Style.MerginLeft, Bottom:yButton+size/2, Width:size+item.Style.MerginLeft, Height:size };
                var color=item.Style.Color;
                if (moveonPoint && (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
                {
                    color=item.Style.MoveOnColor;
                    if (mouseStatus)
                        mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:item, Frame:this, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
                }
                    

                this.Canvas.fillStyle=color;
                this.Canvas.font=font;
                this.Canvas.textAlign="left";
                this.Canvas.textBaseline="middle";
                this.Canvas.fillText(item.Style.Text, xBotton, yButton);

                this.Buttons.push({ ID:item.ID, Rect:rtButton });

                right=xBotton;
            }
        }
    }

    this.DrawToolbarTooltip=function(mouseOnToolbar)
    {
        if (!mouseOnToolbar) return;

        var border=this.GetBorder();
        
        var text=null;
        if (mouseOnToolbar.Item.TooltipText) 
        {
            text=mouseOnToolbar.Item.TooltipText;
        }
        else
        {
            var key='Toolbar-'+mouseOnToolbar.Item.ID;
            text=g_JSChartLocalization.GetText(key,0);
        }

        if (!text) return;
        
        var pixelRatio=GetDevicePixelRatio();
        var canvas=this.Canvas;
        if (this.GetExtraCanvas)
        {
            var finder=this.GetExtraCanvas(JSChart.TooltipCursorCanvasKey);
            if (finder) canvas=finder.Canvas;
        }
        
        var xCenter=mouseOnToolbar.Rect.Left+mouseOnToolbar.Rect.Width/2;

        canvas.font=this.ButtonTooltip.Font;
        canvas.textAlign="left";
        canvas.textBaseline="bottom";

        var mergin= this.ButtonTooltip.Mergin;
        var textWidth=canvas.measureText(text).width+mergin.Left+mergin.Right;
        var textHeight=this.GetFontHeight();
        var bgHeight=textHeight+mergin.Top+mergin.Bottom;
        if (mouseOnToolbar.ID=="TitleButton")
        {
            var x=mouseOnToolbar.Point.X;
            var y=mouseOnToolbar.Point.Y+20;
        }
        else if (JSCHART_BUTTON_ID.CLOSE_BEFOREOPEN_ID==mouseOnToolbar.Item.ID)
        {
            var x=mouseOnToolbar.Rect.Right+5;
            var y=mouseOnToolbar.Rect.Top;
        }
        else if (JSCHART_BUTTON_ID.DRAW_PICTURE_DELETE==mouseOnToolbar.Item.ID || JSCHART_BUTTON_ID.DRAW_PICTURE_SETTING==mouseOnToolbar.Item.ID ||
            (mouseOnToolbar.Item.ID>=JSCHART_BUTTON_ID.DRAW_PICTURE_BUTTON_1 && mouseOnToolbar.Item.ID<=JSCHART_BUTTON_ID.DRAW_PICTURE_BUTTON_18 ))
        {
            var x=mouseOnToolbar.Point.X;
            var y=mouseOnToolbar.Point.Y+20;

            if ((x+textWidth)>=border.ChartWidth) x=border.ChartWidth-textWidth-2;
        }
        else
        {
            var x=xCenter-textWidth/2;
            var y=border.Top-bgHeight;
            if (y<0) y=border.TopEx+1;
            if (x+textWidth>border.ChartWidth) x=border.ChartWidth-textWidth-2;
        }

        if (IFrameSplitOperator.IsNumber(this.ButtonTooltip.BorderRadius))  //圆角
        {
            var roundRadius=this.ButtonTooltip.BorderRadius;
            canvas.beginPath();
            canvas.roundRect(ToFixedPoint(x), ToFixedPoint(y), ToFixedRect(textWidth), ToFixedRect(bgHeight), [roundRadius]);
            canvas.closePath();

            canvas.fillStyle=this.ButtonTooltip.ColorBG;
            canvas.fill();

            canvas.strokeStyle=this.ButtonTooltip.ColorBorder;
            canvas.stroke();

            canvas.fillStyle=this.ButtonTooltip.Color;
            canvas.fillText(text, x+mergin.Left, y+bgHeight-mergin.Bottom);
        }
        else
        {
            canvas.fillStyle=this.ButtonTooltip.ColorBG; 
            canvas.fillRect(x,y,textWidth,bgHeight);   //画一个背景色, 不然是一个黑的背景
            canvas.fillStyle=this.ButtonTooltip.Color;
            canvas.fillText(text, x+mergin.Left,y+bgHeight-mergin.Bottom);
        }
        

        
    }

    //isLimit 是否限制在当前坐标下
    this.GetYFromData=function(value, isLimit)
    {
        if (this.Logarithmic && this.GetYLogarithmicFromData)
        {
            return this.GetYLogarithmicFromData(value, isLimit);
        }

        if (isLimit===false)
        {
            if (this.CoordinateType==1)
            {
                var height=this.ChartBorder.GetHeightEx()*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
                return this.ChartBorder.GetTopEx()+height;
            }
            else
            {
                var height=this.ChartBorder.GetHeightEx()*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
                return this.ChartBorder.GetBottomEx()-height;
            }
        }
        else
        {
            if (this.CoordinateType==1)
            {
                if(value<=this.HorizontalMin) return this.ChartBorder.GetTopEx();
                if(value>=this.HorizontalMax) return this.ChartBorder.GetBottomEx();

                var height=this.ChartBorder.GetHeightEx()*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
                return this.ChartBorder.GetTopEx()+height;
            }
            else
            {
                if(value<=this.HorizontalMin) return this.ChartBorder.GetBottomEx();
                if(value>=this.HorizontalMax) return this.ChartBorder.GetTopEx();

                var height=this.ChartBorder.GetHeightEx()*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
                return this.ChartBorder.GetBottomEx()-height;
            }
        }
    }

    //画Y轴
    this.DrawHorizontal=function()
    {
        this.RightTextMaxWidth=0;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.HorizontalInfo)) return;
        if (this.ChartBorder.IsShowTitleOnly) return;

        var border=this.ChartBorder.GetBorder();
        var left=border.Left;
        var right=border.Right
        var bottom = border.Bottom
        var top = this.ChartBorder.GetTop();
        var borderRight=this.ChartBorder.Right;
        var borderLeft=this.ChartBorder.Left;

        var isDrawLeft=borderLeft>10 && this.IsShowYText[0]===true && this.YTextPosition[0]!=2;
        var isDrawRight=borderRight>10 && this.IsShowYText[1]===true && this.YTextPosition[1]!=2;

        var rightExtendLine=null;   //右侧延长线
        var leftExtendLine=null;    //左侧延长线
        if (IFrameSplitOperator.IsNonEmptyArray(this.YLineExtend)) 
        {
            rightExtendLine=this.YLineExtend[1];
            leftExtendLine=this.YLineExtend[0];
        }

        var rightExtendText=null;   //右侧文字设置
        var leftExtendText=null;    //左侧文字设置
        if (IFrameSplitOperator.IsNonEmptyArray(this.YTextExtend))
        {
            leftExtendText=this.YTextExtend[0];
            rightExtendText=this.YTextExtend[1];
        }

        var yPrev=null; //上一个坐标y的值
        var pixelRatio=GetDevicePixelRatio();
        var itemHeight=(border.BottomEx-border.TopEx)/this.HorizontalInfo.length;
        var aryMultiText=[];
        var rtPreRight, rtRight, rtLeft, rtPreLeft;
        var textBaseline=0; //0=上 1=中 2=下
        for(var i=this.HorizontalInfo.length-1; i>=0; --i)  //从上往下画分割线
        {
            var item=this.HorizontalInfo[i];
            if (!IFrameSplitOperator.IsNumber(item.Value)) continue;
            if (NumberCompare.GT(item.Value,this.HorizontalMax) || NumberCompare.LT(item.Value,this.HorizontalMin)) 
                continue;

            var y=this.GetYFromData(item.Value);
            if (y!=null && yPrev!=null && Math.abs(y-yPrev)<this.MinYDistance) continue;  //两个坐标在近了 就不画了
            
            var yFixed=ToFixedPoint(y);
            //绘制刻度线
            if (y!=bottom && this.IsShowYLine)
            {
                var bChangeLineWidth=false;
                if (IFrameSplitOperator.IsPlusNumber(item.LineWidth))   //刻度线宽度
                {
                    this.Canvas.lineWidth=item.LineWidth*pixelRatio;
                    bChangeLineWidth=true;
                }

                this.Canvas.strokeStyle=item.LineColor;
                if (item.LineType==2)
                {
                    this.Canvas.save();
                    if (item.LineDash) this.Canvas.setLineDash(item.LineDash);
                    else this.Canvas.setLineDash([5*pixelRatio,5*pixelRatio]);   //虚线
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(left,yFixed);
                    this.Canvas.lineTo(right,yFixed);
                    this.Canvas.stroke();
                    this.Canvas.setLineDash([]);
                    this.Canvas.restore();
                }
                else if (item.LineType==3)  //只在刻度边上画一个短横线
                {

                }
                else if (item.LineType==8 || item.LineType==9)  //集合竞价不画线
                {

                }
                else if (item.LineType>0)
                {
                    if (g_JSChartResource.FrameYLineDash)
                    {
                        this.Canvas.save();
                        this.Canvas.setLineDash(g_JSChartResource.FrameYLineDash);   //虚线
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(left,yFixed);
                        this.Canvas.lineTo(right,yFixed);
                        this.Canvas.stroke();
                        this.Canvas.setLineDash([]);
                        this.Canvas.restore();
                    }
                    else
                    {
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(left,yFixed);
                        this.Canvas.lineTo(right,yFixed);
                        this.Canvas.stroke();
                    }
                }

                if (bChangeLineWidth)
                {
                    this.Canvas.lineWidth=pixelRatio;
                }
            }
            
            var yText=y;
            if (y >= bottom - 2) 
            {
                this.Canvas.textBaseline = 'bottom';
                textBaseline=2;
            }
            else if (y <= top + 2) 
            {
                this.Canvas.textBaseline = 'top';
                yText+=this.YTextTopOffset;
                textBaseline=0;
            }
            else 
            {
                this.Canvas.textBaseline = "middle";
                textBaseline=1;
            }

            //左边 坐标信息  间距小于10 不画坐标
            this.Canvas.strokeStyle=item.TextColor;
            this.Canvas.fillStyle=item.TextColor;

            if (item.Message[0]!=null && isDrawLeft)
            {
                if (Array.isArray(item.Message[0]))
                {
                    if (this.MultiTextFormat==3)
                    {
                        var obj={ Data:item.Message[0], X:left, Y:yText, TextBaseLine:textBaseline, IsLeft:true, Item:item, TextPadding:this.YTextPadding[0] };
                        this.DrawMultiLineText(obj);
                    }
                }
                else
                {
                    if (item.Font!=null) this.Canvas.font=item.Font;

                    var xText=left;
                    if (leftExtendLine && leftExtendLine.Width>1)
                    {
                        var lineLength=leftExtendLine.Width;
                        if (leftExtendLine.Color) this.Canvas.strokeStyle=leftExtendLine.Color;
                        else this.Canvas.strokeStyle=item.LineColor;
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xText,yFixed);
                        this.Canvas.lineTo(xText-lineLength,yFixed);
                        this.Canvas.stroke();

                        xText-=lineLength;
                    }

                    rtLeft=this.GetTextTopBottom(textBaseline,yText);
                    if (!rtPreLeft || (rtLeft && !this.IsTextTopBottomOverlap(rtLeft, rtPreLeft)))
                    {
                        if (leftExtendText && leftExtendText.Align===1)
                        {
                            this.Canvas.textAlign="left";
                            this.Canvas.fillText(item.Message[0],this.YTextPadding[0],yText);
                        }
                        else
                        {
                            this.Canvas.textAlign="right";
                            this.Canvas.fillText(item.Message[0],xText-this.YTextPadding[0],yText);
                            rtPreLeft=rtLeft;
                        }
                    }
                }
            }

            //右边 坐标信息  间距小于10 不画坐标
            if (item.Message[1]!=null && isDrawRight)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                var xText=right;
                if (item.LineType==3)
                {
                    var lineLength=this.ShortYLineLength*GetDevicePixelRatio();
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(xText,yFixed);
                    this.Canvas.lineTo(xText+lineLength,yFixed);
                    this.Canvas.stroke();

                    xText+=lineLength;
                }

                //右侧延长线
                if (rightExtendLine && rightExtendLine.Width>1)
                {
                    var lineLength=rightExtendLine.Width;
                    if (rightExtendLine.Color) this.Canvas.strokeStyle=rightExtendLine.Color;
                    else this.Canvas.strokeStyle=item.LineColor;
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(xText,yFixed);
                    this.Canvas.lineTo(xText+lineLength,yFixed);
                    this.Canvas.stroke();

                    xText+=lineLength+2;
                }
                

                this.Canvas.textAlign="left";
                if (Array.isArray(item.Message[1]))
                {
                    if (this.MultiTextFormat==1)    //显示1行 格式:价格/百分比
                    {
                        if (item.ExtendData)
                        {
                            if (item.ExtendData.Font) this.Canvas.font=item.ExtendData.Font;
                        }
                            
                        var textData=
                        { 
                            Text:
                            [ 
                                {Text:item.Message[1][0], Width:this.Canvas.measureText(item.Message[1][0]).width },
                                {Text:item.Message[1][1], Width:this.Canvas.measureText(item.Message[1][1]).width } 
                            ],
                            X:xText+2,
                            Y:yText,
                            TextBaseline:this.Canvas.textBaseline,
                            Item:item
                        }
                        aryMultiText.push(textData);
                    }
                    else if (this.MultiTextFormat==2)   //显示2行
                    {
                        this.Canvas.fillText(item.Message[1][0],xText+this.YTextPadding[1],yText);
                        var lineHeight=this.Canvas.measureText('M').width;
                        if (itemHeight>lineHeight*2) this.Canvas.fillText(item.Message[1][1],xText+this.YTextPadding[1],yText+lineHeight);
                    }
                    else if (this.MultiTextFormat==3)
                    {
                        var obj={ Data:item.Message[1], X:xText, Y:yText, TextBaseLine:textBaseline, IsLeft:false, Item:item, TextPadding:this.YTextPadding[1] };
                        this.DrawMultiLineText(obj);
                    }
                    else    //显示第1行
                    {
                        var text=item.Message[1][0];

                        if (item.TextColor2) this.Canvas.fillStyle=item.TextColor2;
                        if (rightExtendText && rightExtendText.Align===2 && this.YRightTextInfo)    //右对齐
                        {
                            this.Canvas.textAlign="right";
                            var xRight=this.YRightTextInfo.MainTextWidth+right-this.YTextPadding[1];
                            this.Canvas.fillText(text,xRight,yText);
                        }
                        else
                        {
                            this.Canvas.fillText(text,xText+this.YTextPadding[1],yText);
                        }
                    }
                }
                else
                {
                    //计算显示的区域
                    rtRight=this.GetTextTopBottom(textBaseline,yText);
                    if (!rtPreRight || (rtRight && !this.IsTextTopBottomOverlap(rtRight,rtPreRight)))
                    {
                        if (item.TextColor2) this.Canvas.fillStyle=item.TextColor2;
                        if (rightExtendText && rightExtendText.Align===2 && this.YRightTextInfo)    //右对齐
                        {
                            this.Canvas.textAlign="right";
                            var xRight=this.YRightTextInfo.MainTextWidth+right-this.YTextPadding[1];
                            this.Canvas.fillText(item.Message[1],xRight,yText);
                        }
                        else
                        {
                            this.Canvas.fillText(item.Message[1],xText+this.YTextPadding[1],yText);
                        }
                        
                        rtPreRight=rtRight;
                    }
                }
            }

            yPrev=y;
        }

        if (IFrameSplitOperator.IsNonEmptyArray(aryMultiText) && this.MultiTextFormat==1) this.DrawHorizontalMuText(aryMultiText);

        if (isDrawRight && this.IsDrawRightBorder && this.YRightTextInfo)
        {  
            var xRight=this.YRightTextInfo.MainTextWidth+right; 
            xLine=ToFixedPoint(xRight);
            this.Canvas.strokeStyle=this.PenBorder;
            this.Canvas.beginPath();
            this.Canvas.moveTo(xLine,top);
            this.Canvas.lineTo(xLine,bottom);
            this.Canvas.stroke();

            if (IFrameSplitOperator.IsNonEmptyArray(this.YRightTextInfo.AryOverlayWidth))
            {
                this.Canvas.beginPath();
                for(var i=0;i<this.YRightTextInfo.AryOverlayWidth.length;++i)
                {
                    var width=this.YRightTextInfo.AryOverlayWidth[i];
                    xRight+=width;
                    xLine=ToFixedPoint(xRight);
                    this.Canvas.moveTo(xLine,top);
                    this.Canvas.lineTo(xLine,bottom);
                }
                this.Canvas.stroke();

            }
        }
    }

    //多行文字刻度输出 obj={ Data:, X:, Y:, TextBaseLine:, IsLeft:, Item:刻度数据 }
    this.DrawMultiLineText=function(obj)
    {
        var lineSpacing=2;
        var lineHeight=this.Canvas.measureText('擎').width;
        var lineCount=obj.Data.length;
        var textHeight=lineHeight*lineCount+(lineSpacing*(lineCount-1));
        var yText=obj.Y;

        if (obj.Item.Font!=null) this.Canvas.font=obj.Item.Font;

        if (obj.IsLeft)
        {
            this.Canvas.textAlign="right";
            var xText=obj.X-obj.TextPadding;
        }
        else
        {
            this.Canvas.textAlign="left";
            var xText=obj.X+obj.TextPadding;
        }

        var textBaseline=this.Canvas.textBaseline;  //备份下原来的对齐方式
        this.Canvas.textBaseline='top';
        if (obj.TextBaseLine==1)    //middle
        {
            yText-=textHeight/2;
        }
        else if (obj.TextBaseLine==0)   //top
        {

        }
        else if (obj.TextBaseLine==2)   //bottom
        {
            yText-=textHeight;
        }
       
        
        for(var i=0;i<obj.Data.length;++i)
        {
            var item=obj.Data[i];
            var text=item.Text;

            var backupTextColor=null;
            if (item.Color) 
            {
                backupTextColor=this.Canvas.fillStyle;
                this.Canvas.fillStyle=item.Color;
            }

            this.Canvas.fillText(text,xText,yText);
            yText+=lineHeight+lineSpacing;

            if (backupTextColor) this.Canvas.fillStyle=backupTextColor;
        }

        this.Canvas.textBaseline=textBaseline;  //还原对齐方式
    }

    //上下区域是否重叠
    this.IsTextTopBottomOverlap=function(rt, rt2)
    {
        if (rt2.Top>=rt.Top && rt2.Top<=rt.Bottom) return true;
        if (rt2.Bottom>=rt.Top && rt2.Bottom<=rt.Bottom) return true;

        return false;
    }

    this.GetTextTopBottom=function(textBaseline, yText)
    {
        var rtRight=null;
        var textHeight=this.Canvas.measureText('擎').width;
        if (textBaseline==0)
        {
            rtRight={ Top: yText, Bottom:yText+textHeight }
        }
        else if (textBaseline==1)
        {
            rtRight={ Top: yText-textHeight/2 };
            rtRight.Bottom=rtRight.Top+textHeight;
        }
        else if (textBaseline==2)
        {
            rtRight={ Bottom:yText };
            rtRight.Top=rtRight.Bottom-textHeight;
        }

        return rtRight;
    }

    this.DrawHorizontalMuText=function(aryText)
    {
        var maxWidth=[null,null];
        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            var width=item.Text[0].Width;
            if (!IFrameSplitOperator.IsNumber(maxWidth[0])) maxWidth[0]=width;
            else if (maxWidth[0]<width) maxWidth[0]=width;

            width=item.Text[1].Width;
            if (!IFrameSplitOperator.IsNumber(maxWidth[1])) maxWidth[1]=width;
            else if (maxWidth[1]<width) maxWidth[1]=width;
        }

        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            var message=item.Item;

            this.Canvas.textBaseline=message.TextBaseline;
            if (message.ExtendData && message.ExtendData.Font) this.Canvas.font=message.ExtendData.Font;
            else if (message.Font) this.Canvas.font=message.Font;

            if (message.ExtendData && message.ExtendData.PriceColor) this.Canvas.fillStyle=message.ExtendData.PriceColor;
            else this.Canvas.fillStyle=message.TextColor;

            this.Canvas.textAlign="right";
            var x=item.X+maxWidth[1];
            this.Canvas.fillText(item.Text[1].Text,x,item.Y);

            if (message.ExtendData && message.ExtendData.SplitColor) this.Canvas.fillStyle=message.ExtendData.SplitColor;
            else this.Canvas.fillStyle=message.TextColor;

            this.Canvas.textAlign="left";
            var splitWidth=this.Canvas.measureText('/').width;
            this.Canvas.fillText('/',x,item.Y);
            
            if (message.ExtendData && message.ExtendData.PercentageColor) this.Canvas.fillStyle=message.ExtendData.PercentageColor;
            else this.Canvas.fillStyle=message.TextColor;

            this.Canvas.textAlign="right";
            var x=item.X+maxWidth[1]+maxWidth[0]+splitWidth;
            this.Canvas.fillText(item.Text[0].Text,x,item.Y);

            var textWidth=maxWidth[1]+maxWidth[0]+splitWidth*4;
            if (this.RightTextMaxWidth<textWidth) this.RightTextMaxWidth=textWidth;
        }
    }

    //画Y轴Message[2,3]两个内部刻度
    this.DrawInsideClientHorizontal=function()
    {
        var border=this.GetBorder();
        if (border.DayBorder && IFrameSplitOperator.IsNonEmptyArray(border.DayBorder))
        {
            var item=border.DayBorder[0];
            var left=item.LeftEx;
            var item=border.DayBorder[border.DayBorder.length-1];
            var right=item.RightEx;
            var bottom=border.Bottom;
            var top=border.TopTitle;
        }
        else
        {
            var left=border.LeftEx;
            var right=border.RightEx;
            var bottom=border.Bottom;
            var top=border.TopTitle;
        }
       

        var pixelTatio = GetDevicePixelRatio();
        var yPrev = null; //上一个坐标y的值
        var yInsideText=null;
        for (var i = this.HorizontalInfo.length - 1; i >= 0; --i)  //从上往下画分割线
        {
            var item = this.HorizontalInfo[i];
            var y = this.GetYFromData(item.Value);
            if (y != null && yPrev!=null && Math.abs(y - yPrev) < this.MinYDistance) continue;  //两个坐标在近了 就不画了

            if (item.Message[2]) 
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.fillStyle = item.TextColor;
                this.Canvas.textAlign = "left";
                var yText=y;
                if (y >= bottom - 2) 
                {
                    this.Canvas.textBaseline = 'bottom';
                }
                else if (y <= top + 2) 
                {
                    this.Canvas.textBaseline = 'top';
                    yText+=this.YTextTopOffset;
                }
                else 
                {
                    this.Canvas.textBaseline = "middle";
                }

                var textObj={ X:left, Y:yText, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[0]}} ;
                if (!this.IsOverlayMaxMin || !this.IsOverlayMaxMin(textObj))
                {
                    this.Canvas.fillText(item.Message[2], left + 1*pixelTatio, yText);
                    if (yInsideText==null || yInsideText>yText)
                    {
                        this.YInsideOffset=this.Canvas.measureText(item.Message[2]).width+4*GetDevicePixelRatio();
                        yInsideText=yText;
                    }
                        
                }
            }

            if (item.Message[3])
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.fillStyle = item.TextColor;
                this.Canvas.textAlign = "right";
                var yText=y;
                if (y >= bottom - 2) 
                {
                    this.Canvas.textBaseline = 'bottom';
                }
                else if (y <= top + 2) 
                {
                    this.Canvas.textBaseline = 'top';
                    yText+=this.YTextTopOffset;
                }
                else 
                {
                    this.Canvas.textBaseline = "middle";
                }
                var textWidth = this.Canvas.measureText(item.Message[3]).width;
                var textObj={ X:right-textWidth, Y:yText, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[1]}} ;
                if (!this.IsOverlayMaxMin || !this.IsOverlayMaxMin(textObj))
                    this.Canvas.fillText(item.Message[3], right - 1*pixelTatio, yText);
            }
            yPrev = y;
        }
    }

    //Y刻度画在左边内部
    this.DrawInsideHorizontal = function () 
    {
        if (this.IsHScreen===true) return;  //横屏不画
        if (this.IsMinSize) return;
        if (this.ChartBorder.IsShowTitleOnly) return;
        if (this.IsShowYText[0]===false && this.IsShowYText[1]===false) return;

        this.DrawInsideClientHorizontal();

        var border=this.ChartBorder.GetBorder();

        var left = border.Left
        var right = border.Right;
        var bottom = border.Bottom;
        var top = border.TopTitle;
        var borderRight = this.ChartBorder.Right;
        var borderLeft = this.ChartBorder.Left;
        var titleHeight = this.ChartBorder.TitleHeight;

        var isDrawLeft= (borderLeft<10 || this.YTextPosition[0]==2) && this.IsShowYText[0]===true;
        var isDrawRight= (borderRight<10 || this.YTextPosition[1]==2) && this.IsShowYText[1]===true;

        if ( isDrawLeft || isDrawRight )
        {
            var pixelTatio = GetDevicePixelRatio();
            var yPrev = null; //上一个坐标y的值
            var yInsideText=null;
            for (var i = this.HorizontalInfo.length - 1; i >= 0; --i)  //从上往下画分割线
            {
                var item = this.HorizontalInfo[i];
                var y = this.GetYFromData(item.Value);
                if (y != null && yPrev!=null && Math.abs(y - yPrev) < this.MinYDistance) continue;  //两个坐标在近了 就不画了

                //坐标信息 左边 间距小于10 画在内部
                if (item.Message[0] != null && isDrawLeft) 
                {
                    if (item.Font != null) this.Canvas.font = item.Font;
                    this.Canvas.fillStyle = item.TextColor;
                    this.Canvas.textAlign = "left";
                    var textHeight=this.Canvas.measureText("擎").width;
                    var yText=y;
                    if (y >= bottom - 2) 
                    {
                        this.Canvas.textBaseline = 'bottom';
                    }
                    else if ((y-textHeight/2)<=top) 
                    {
                        this.Canvas.textBaseline = 'top';
                        yText+=this.YTextTopOffset;
                    }
                    else 
                    {
                        if (this.YTextBaseline==1) this.Canvas.textBaseline = "bottom";
                        else this.Canvas.textBaseline = "middle";
                    }

                    var textObj={ X:left, Y:yText, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[0]}} ;
                    if (!this.IsOverlayMaxMin || !this.IsOverlayMaxMin(textObj))
                    {
                        this.Canvas.fillText(item.Message[0], left + 1*pixelTatio, yText);
                        if (yInsideText==null || yInsideText>yText)
                        {
                            this.YInsideOffset=this.Canvas.measureText(item.Message[0]).width+4*GetDevicePixelRatio();
                            yInsideText=yText;
                        }
                            
                    }
                }

                if (item.Message[1] != null && isDrawRight)
                {
                    if (item.Font != null) this.Canvas.font = item.Font;
                    this.Canvas.fillStyle = item.TextColor;
                    this.Canvas.textAlign = "right";
                    var textHeight=this.Canvas.measureText("擎").width;
                    var yText=y;
                    if (y >= bottom - 2) 
                    {
                        this.Canvas.textBaseline = 'bottom';
                    }
                    else if (y-textHeight/2 <= top) 
                    {
                        this.Canvas.textBaseline = 'top';
                        yText+=this.YTextTopOffset;
                    }
                    else 
                    {
                        if (this.YTextBaseline==1) this.Canvas.textBaseline = "bottom";
                        else this.Canvas.textBaseline = "middle";
                    }
                    
                    if (Array.isArray(item.Message[1])) var text=item.Message[1][0];
                    else var text=item.Message[1];

                    var textWidth = this.Canvas.measureText(text).width;
                    var textObj={ X:right-textWidth, Y:yText, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[1]}} ;
                    if (!this.IsOverlayMaxMin || !this.IsOverlayMaxMin(textObj))
                        this.Canvas.fillText(text, right - 1*pixelTatio, yText);
                }
                yPrev = y;
            }
        }
    }

    this.GetXFromIndex=function(index)
    {
        var count=this.XPointCount;

        if (count==1)
        {
            if (index==0) return this.ChartBorder.GetLeft();
            else return this.ChartBorder.GetRight();
        }
        else if (count<=0)
        {
            return this.ChartBorder.GetLeft();
        }
        else if (index>=count)
        {
            return this.ChartBorder.GetRight();
        }
        else
        {
            var offset=this.ChartBorder.GetLeft()+this.ChartBorder.GetWidth()*index/count;
            return offset;
        }
    }

    //画X轴
    this.DrawVertical=function()
    {
        var border=this.GetBorder();
        var top=border.TopTitle;
        var bottom=border.Bottom;
        var right=border.RightEx;
        var pixelRatio = GetDevicePixelRatio(); //获取设备的分辨率
        //JSConsole.Chart.Log('[AverageWidthFrame.DrawVertical] bottom',bottom);
        //if (this.ChartBorder.Bottom<=5*GetDevicePixelRatio()) return;   //高度不够 不显示

        var mapX=null;
        if (this.GetVerticalXCache) mapX=this.GetVerticalXCache();

        var bottomTextExtend=null;
        if (this.XTextExtend)
        {
            bottomTextExtend=this.XTextExtend[0];
        }

        var bottomLineExtend=null;
        if (this.XLineExtend)
        {
            bottomLineExtend=this.XLineExtend[0];
        }

        var xPrev=null; //上一个坐标x的值
        var textRightPrev=null; //上一次刻度输出右边x坐标
        for(var i=0; i<this.VerticalInfo.length; ++i)
        {
            var item=this.VerticalInfo[i];
            var x=null;
            if (mapX && mapX.has(item.Value)) x=mapX.get(item.Value);
            else x=this.GetXFromIndex(item.Value);
            if (x>right) break;
            if (xPrev!=null && Math.abs(x-xPrev)<this.MinXDistance) continue;
            
            var item=this.VerticalInfo[i];
            var xFixed=ToFixedPoint(x);
            if (this.IsShowXLine)
            {
                if (item.LineType==2)   //虚线
                {
                    this.Canvas.strokeStyle=this.VerticalInfo[i].LineColor;
                    if (item.LineDash) this.Canvas.setLineDash(item.LineDash);
                    else this.Canvas.setLineDash([5*pixelRatio,5*pixelRatio]);   
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(xFixed,top);
                    this.Canvas.lineTo(xFixed,bottom);
                    this.Canvas.stroke();
                    this.Canvas.setLineDash([]);
                }
                else if (item.LineType==3)
                {

                }
                else if (item.LineType>0)   //实线
                {
                    if (g_JSChartResource.FrameXLineDash)
                    {
                        this.Canvas.strokeStyle=this.VerticalInfo[i].LineColor;
                        this.Canvas.setLineDash(g_JSChartResource.FrameXLineDash);   //虚线
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed,top);
                        this.Canvas.lineTo(xFixed,bottom);
                        this.Canvas.stroke();
                        this.Canvas.setLineDash([]);
                    }
                    else
                    {
                        this.Canvas.strokeStyle=this.VerticalInfo[i].LineColor;
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed,top);
                        this.Canvas.lineTo(xFixed,bottom);
                        this.Canvas.stroke();
                    }
                }
            }
            
            if (item.BG && this.DrawDayVertical)
            {
                this.DrawDayVertical(item, x, border);
            }

            if (this.VerticalInfo[i].Message[0]!=null && this.ChartBorder.Bottom>5*pixelRatio)
            {
                if (this.VerticalInfo[i].Font) this.Canvas.font=this.VerticalInfo[i].Font;

                var textLeft=0;
                
                this.Canvas.strokeStyle=item.TextColor;
                var testWidth=this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
                var textHeight=this.Canvas.measureText("擎").width;
                if (bottomTextExtend && bottomTextExtend.Align==1)
                {
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="top";
                    textLeft=x;
                }
                else
                {
                    if (x<testWidth/2)
                    {
                        this.Canvas.textAlign="left";
                        this.Canvas.textBaseline="top";
                        textLeft=x;
                    }
                    else if ((x + testWidth / 2) >= this.ChartBorder.GetChartWidth())
                    {
                        this.Canvas.textAlign = "right";
                        this.Canvas.textBaseline="top";
                        textLeft=x-testWidth;
                    }
                    else
                    {
                        this.Canvas.textAlign="center";
                        this.Canvas.textBaseline="top";
                        textLeft=x-(testWidth/2);
                    }
                }
                
                if (textRightPrev==null || textLeft>textRightPrev)
                {
                    var yText=bottom;
                    if (item.LineType==3)
                    {
                        var lineLength=this.ShortXLineLength*pixelRatio;
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed,yText);
                        this.Canvas.lineTo(xFixed,yText+lineLength);
                        this.Canvas.stroke();

                        yText+=lineLength+2*pixelRatio;
                    }

                    if (bottomLineExtend)
                    {
                        if (bottomLineExtend.Mode===1)
                        {
                            if (item.Value>1)
                            {
                                if (bottomLineExtend.Color) this.Canvas.strokeStyle=bottomLineExtend.Color;
                                this.Canvas.beginPath();
                                this.Canvas.moveTo(xFixed,bottom);
                                this.Canvas.lineTo(xFixed,border.ChartHeight);
                                this.Canvas.stroke();
                                x+=1;
                            }
                        }
                        else if (bottomLineExtend.Mode===2)
                        {
                            if (bottomLineExtend.Width>=1)
                            {
                                var lineLength=bottomLineExtend.Width;
                                if (bottomLineExtend.Color) this.Canvas.strokeStyle=bottomLineExtend.Color;
                                this.Canvas.beginPath();
                                this.Canvas.moveTo(xFixed,yText);
                                this.Canvas.lineTo(xFixed,yText+lineLength);
                                this.Canvas.stroke();
        
                                yText+=lineLength+2;
                            }
                        }
                    }

                    //item.TextBGColor="rgb(0,255,0)";
                    if (item.TextBGColor)   //文字背景色
                    {
                        var rtText={ Left:textLeft, Top:yText+this.XBottomOffset, Width:testWidth, Height:textHeight };
                        this.Canvas.fillStyle=item.TextBGColor;
                        this.Canvas.fillRect(rtText.Left-1, rtText.Top, rtText.Width+2, rtText.Height);
                    }

                    this.Canvas.fillStyle=item.TextColor;
                    this.Canvas.fillText(this.VerticalInfo[i].Message[0],x,yText+this.XBottomOffset);
                    textRightPrev=textLeft+testWidth;
                }
            }

            xPrev=x;
        }
    }

    //Y坐标转y轴数值
    this.GetYData=function(y,isLimit)
    {
        if (this.Logarithmic && this.GetYLogarithmicFromData)
        {
            return this.GetYLogarithmicData(y);
        }

        if (this.CoordinateType==1) //反转坐标
        {
            if (isLimit==false)
            {
                return (y-this.ChartBorder.GetTopEx())/this.ChartBorder.GetHeightEx()*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
            }
            else
            {
                if (y<this.ChartBorder.GetTopEx()) return this.HorizontalMin;
                if (y>this.ChartBorder.GetBottomEx()) return this.HorizontalMax;
    
                return (y-this.ChartBorder.GetTopEx())/this.ChartBorder.GetHeightEx()*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
            }
        }
        else
        {
            if (isLimit==false)
            {
                return (this.ChartBorder.GetBottomEx()-y)/this.ChartBorder.GetHeightEx()*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
            }
            else
            {
                if (y<this.ChartBorder.GetTopEx()) return this.HorizontalMax;
                if (y>this.ChartBorder.GetBottomEx()) return this.HorizontalMin;
    
                return (this.ChartBorder.GetBottomEx()-y)/this.ChartBorder.GetHeightEx()*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
            }
        }
    }

    //X坐标转x轴数值
    this.GetXData=function(x)
    {
        if (x<=this.ChartBorder.GetLeft()) return 0;
		if (x>=this.ChartBorder.GetRight()) return this.XPointCount;

		return (x-this.ChartBorder.GetLeft())*(this.XPointCount*1.0/this.ChartBorder.GetWidth());
    }

    //选中的画图工具X,Y轴坐标信息
    this.DrawPictureXCoordinate=function(drawPicture, range, option)
    {
        if (this.IsHScreen) return;
        if (!range) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(range.Points)) return;

        var border=this.GetBorder();
        var left=border.Left;
        var right=border.Right;

        this.Canvas.font=this.DrawPicture.Font;
        var fontHeight=this.GetFontHeight();
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline = "bottom";

        if (range.X)
        {
            var xRange=range.X;
            var xLeft=xRange.Min.X;
            var xRight=xRange.Max.X;
            if (xLeft<left) xLeft=left;
            if (xRight>right) xRight=right;

            this.Canvas.fillStyle=this.DrawPicture.BGColor;
            this.Canvas.fillRect(xLeft, border.Bottom, xRight-xLeft, fontHeight);
        }

        for(var i=0;i<range.Points.length;++i)
        {
            var item=range.Points[i];
            if (item.X<left || item.X>right) continue;

            var index=this.GetXData(item.X, false);
            var index=Math.round(index);
            var kItem=this.GetKItem(index);
            if (kItem)
            {
                var text=IFrameSplitOperator.FormatDateString(kItem.Date,null);
                if (ChartData.IsMinutePeriod(option.Period)) text+=" " + IFrameSplitOperator.FormatTimeString(kItem.Time, "HH:MM");
                else if (ChartData.IsMilliSecondPeriod(option.Period)) text+=" " + IFrameSplitOperator.FormatTimeString(kItem.Time, "HH:MM:SS.fff");
                var textWidth=this.Canvas.measureText(text).width+2;

                var textLeft=item.X-textWidth/2;
                if (textLeft<left) textLeft=left;
                this.Canvas.fillStyle=this.DrawPicture.TextBGColor;
                this.Canvas.fillRect(textLeft, border.Bottom, textWidth, fontHeight);

                this.Canvas.fillStyle=this.DrawPicture.TextColor;
                var yCenter=border.Bottom+fontHeight;
                this.Canvas.fillText(text,textLeft+1,yCenter);
            }
        }
    }

    this.GetKItem=function(currentIndex)
    {
        if (!this.Data) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return null;
        var index=this.Data.DataOffset+currentIndex;
        return this.Data.Data[index];
    }

    this.DrawPictureYCoordinate=function(drawPicture, range, option)
    {
        if (this.IsHScreen) return;
        if (!range) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(range.Points)) return;

        var border=this.GetBorder();
        var top=border.TopEx;
        var bottom=border.BottomEx;
        var right=border.Right;

        this.Canvas.font=this.DrawPicture.Font;
        var fontHeight=this.GetFontHeight();
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline = "bottom";

        var defaultfloatPrecision=2;
        if (option && option.Symbol) defaultfloatPrecision=GetfloatPrecision(option.Symbol);

        var textWidth=0;
        for(var i=0;i<range.Points.length; ++i)
        {
            var item=range.Points[i];
            var Value=this.GetYData(item.Y);
            var text=Value.toFixed(defaultfloatPrecision);
            var value=this.Canvas.measureText(text).width;
            if (textWidth<value) textWidth=value;

            range.Points[i].Text=text;
        }

        textWidth+=this.YTextPadding[1]+2;
        if (range.Y) 
        {
            var yRange=range.Y;
            var yTop=yRange.Min.Y;
            var yBottom=yRange.Max.Y;

            if (yRange.Min.Y<top) yTop=top;
            if (yRange.Max.Y>bottom) yBottom=bottom;

            this.Canvas.fillStyle=this.DrawPicture.BGColor;
            this.Canvas.fillRect(right, yTop, textWidth+5, yBottom-yTop);
        }

        
        for(var i=0;i<range.Points.length; ++i)
        {
            var item=range.Points[i];
            if (item.Y<top || item.Y>bottom) continue;

            this.Canvas.fillStyle=this.DrawPicture.TextBGColor;
            this.Canvas.fillRect(right, item.Y-fontHeight/2, textWidth, fontHeight);

            this.Canvas.fillStyle=this.DrawPicture.TextColor;
            var yText=item.Y+fontHeight/2;
            this.Canvas.fillText(item.Text,right+this.YTextPadding[1],yText);
        }

    }

    this.DrawPicturePointYCoordinate=function(drawPicture, option)
    {
        if (this.IsHScreen) return;

        if (!drawPicture.GetYCoordinatePoint) return;
        var aryPoint=drawPicture.GetYCoordinatePoint();
        if (!IFrameSplitOperator.IsNonEmptyArray(aryPoint)) return;

        var border=this.GetBorder();
        var top=border.TopEx;
        var bottom=border.BottomEx;
        var right=border.Right;

        this.Canvas.font=this.DrawPicture.Font;
        var fontHeight=this.GetFontHeight();
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline = "bottom";

        var defaultfloatPrecision=2;
        if (option && option.Symbol) defaultfloatPrecision=GetfloatPrecision(option.Symbol);

        for(var i=0; i<aryPoint.length; ++i)
        {
            var item=aryPoint[i];
            if (!item) continue;
            if (item.Y<top || item.Y>bottom) continue;

            var text=item.YValue.toFixed(defaultfloatPrecision);
            var textWidth=this.Canvas.measureText(text).width+2;
            textWidth+=this.YTextPadding[1];

            this.Canvas.fillStyle=this.DrawPicture.TextBGColor;
            this.Canvas.fillRect(right, item.Y-fontHeight/2, textWidth, fontHeight);

            this.Canvas.fillStyle=this.DrawPicture.TextColor;
            var yText=item.Y+fontHeight/2;
            this.Canvas.fillText(text,right+this.YTextPadding[1],yText);
        }
    }

    //字体外部设置好
    this.GetCustomItemTextInfo=function(item, bLeft,pixelTatio)
    {
        var text=bLeft?item.Message[0]:item.Message[1];
        var aryText=[];
        var width=0;
        if (Array.isArray(text))
        {
            for(var i=0;i<text.length;++i)
            {
                var item=text[i];
                if (item.Type===1)
                {
                    aryText.push({ Type: item.Type });
                }
                else
                {
                    var value=this.Canvas.measureText(text[i].Text).width;
                    if (value>width) width=value;
                    var outItem={ Text:text[i].Text, Width:value+2*pixelTatio };
                    if (item.TextColor) outItem.TextColor=item.TextColor;
                    aryText.push(outItem);
                }
            }

            if (width>0) width+=2*pixelTatio;
        }
        else
        {
            width=this.Canvas.measureText(text).width+2*pixelTatio;
            aryText.push( {Text:text, Width:width} );
        }
        
        return  { MaxWidth:width, Text:aryText };
    }

    this.DrawCustomItem=function(item, mapTextRect) //显示自定义Y刻度
    {
        if (!item.Message[1] && !item.Message[0]) return;
        if (item.Value>this.HorizontalMax || item.Value<this.HorizontalMin) 
        {
            this.SendDrawCountDownEvent( { IsShow:false } );
            return;
        }

        var border=this.GetBorder();
        var left=border.Left;
        var right=border.Right;
        var bottom=border.Bottom;
        var top=border.Top;
        var borderRight = this.ChartBorder.Right;
        var borderLeft = this.ChartBorder.Left;
        var titleHeight = this.ChartBorder.TitleHeight;

        if (this.IsHScreen)
        {
            borderLeft=this.ChartBorder.Top;
            borderRight=this.ChartBorder.Bottom;
            top=border.Top;
            bottom=border.Bottom;
        }

        var pixelTatio = GetDevicePixelRatio();
        var defaultTextHeight=18*pixelTatio;
        var textHeight=defaultTextHeight;
        
        var y = this.GetYFromData(item.Value);
        var position=0;
        var emptyBGColor;
        if (item.ExtendData && item.ExtendData.Custom)
        {
            var customItem=item.ExtendData.Custom;
            if (IFrameSplitOperator.IsNumber(customItem.Position)) position=customItem.Position;
            if (customItem.EmptyBGColor) emptyBGColor=customItem.EmptyBGColor;
        }

        if (item.Message[0])    // 左
        {
            if (borderLeft<10 || position==1)
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,true,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                var bgColor=item.LineColor;
                var rgb=this.RGBToStruct(item.LineColor);
                if (rgb) bgColor=`rgba(${rgb.R}, ${rgb.G}, ${rgb.B}, ${g_JSChartResource.FrameLatestPrice.BGAlpha})`;   //内部刻度 背景增加透明度
                
                var yText=y;
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        var bgTop=top;
                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=bgColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0) this.DrawLine(bgTop+itemText.Width,bottom,yText,item.LineColor,item.LineType,item);

                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        if (itemText.Type===1)
                        {

                        }
                        else
                        {
                            var bgTop=yText-textHeight/2-1*pixelTatio;
                            var textLeft=left + 1*pixelTatio
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,itemText.Width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(itemText.Text, textLeft + 1*pixelTatio, yText);
                            if (i==0) this.DrawLine(textLeft+itemText.Width,right,yText,item.LineColor,item.LineType,item);
    
                            yText+=textHeight+1*pixelTatio;
                        }
                    }
                }
            }
            else
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "right";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,true,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                
                var yText=y;
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        if (i==0) var bgTop=top-itemText.Width;
                        else var bgTop=top-textWidth;

                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=item.LineColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0) this.DrawLine(bgTop+itemText.Width,bottom,yText,item.LineColor,item.LineType,item);

                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        var bgTop=yText-textHeight/2-1*pixelTatio;
                        if (i==0)
                        {
                            var rectLeft=left-itemText.Width;
                            var textLeft=left;
                        }
                        else
                        {
                            var rectLeft=left-textWidth;
                            var textLeft=left-(textWidth-itemText.Width);
                        }

                        if (emptyBGColor)
                        {
                            this.Canvas.fillStyle=emptyBGColor;
                            this.Canvas.fillRect(rectLeft-1,bgTop,itemText.Width+1,textHeight);
                            this.Canvas.strokeStyle=item.LineColor;
                            this.Canvas.strokeRect(ToFixedPoint(rectLeft-1),ToFixedPoint(bgTop),ToFixedPoint(itemText.Width+1),ToFixedPoint(textHeight));
                            this.Canvas.fillStyle = item.LineColor;
                            this.Canvas.fillText(itemText.Text, textLeft - 1*pixelTatio, yText);
                        }
                        else
                        {
                            this.Canvas.fillStyle=item.LineColor;
                            this.Canvas.fillRect(rectLeft,bgTop,itemText.Width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(itemText.Text, textLeft - 1*pixelTatio, yText);
                        }
                        
                        if (i==0) this.DrawLine(left,right,yText,item.LineColor,item.LineType,item);
                        
                        yText+=textHeight+1*pixelTatio;
                    }
                }
            }
        }
        else if (item.Message[1])   //右
        {
            if (borderRight<10 || position==1)
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,false,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                var bgColor=item.LineColor;
                var rgb=this.RGBToStruct(item.LineColor);
                if (rgb) bgColor=`rgba(${rgb.R}, ${rgb.G}, ${rgb.B}, ${g_JSChartResource.FrameLatestPrice.BGAlpha})`;   //内部刻度 背景增加透明度
                
                var yText=y;
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        var bgTop=bottom-itemText.Width;
                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=bgColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0) this.DrawLine(top,bgTop,yText,item.LineColor,item.LineType,item);
                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        if (itemText.Type===1)
                        {
                            if (this.GetEventCallback)
                            {
                                var bgTop=yText-textHeight/2-1*pixelTatio;
                                var sendData=
                                { 
                                    Top:bgTop, Right:right, Height:null, 
                                    IsShow:true, BGColor:item.LineColor, TextColor:item.TextColor, PixelTatio:pixelTatio, Position:"Right", IsInside:true
                                };
                                if (this.SendDrawCountDownEvent(sendData))
                                {
                                    if (IFrameSplitOperator.IsPlusNumber(sendData.Height))
                                        yText+=textHeight+1*pixelTatio;
                                }
                            }
                        }
                        else
                        {
                            var bgTop=yText-textHeight/2-1*pixelTatio;
                            var textLeft=right-itemText.Width;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,itemText.Width,textHeight);  //文本背景区域
                            if (itemText.TextColor) this.Canvas.fillStyle=itemText.TextColor;
                            else this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(itemText.Text, textLeft + 1*pixelTatio, yText);
                            if (i==0) this.DrawLine(left,textLeft,yText,item.LineColor,item.LineType,item);
                            yText+=textHeight+1*pixelTatio;
                        }
                    }
                }

                if (item.Type==3 || item.Type==4)
                {
                    if (item.Title)
                    {
                        var width=this.Canvas.measureText(item.Title).width+2*pixelTatio;
                        if (this.IsHScreen)
                        {
                            var bgTop=bottom-itemText.Width-width;
                            var textLeft=y-textHeight/2-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,textHeight,width);
                            this.DrawHScreenText({X:y, Y:bgTop}, {Text:item.Title, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        }
                        else
                        {
                            var bgTop=y-textHeight/2-1*pixelTatio;
                            var textLeft=right-textWidth-width-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(item.Title, textLeft + 1*pixelTatio, y);
                        }
                    }
                }
            }
            else
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,false,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                var preTextRect=null;
                if (mapTextRect && mapTextRect.has(3)) preTextRect=mapTextRect.get(3);
                
                var yText=y;
                var rtText={ };
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        var bgTop=bottom;
                        //bgTop+=(textWidth-itemText.Width);
                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=item.LineColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0)  this.DrawLine(top,bgTop,yText,item.LineColor,item.LineType,item);

                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        if (itemText.Type===1)
                        {
                            if (this.GetEventCallback)
                            {
                                var bgTop=yText-textHeight/2-1*pixelTatio;
                                var sendData=
                                { 
                                    Top:bgTop, Left:right, Right:this.ChartBorder.GetChartWidth(), Height:null, 
                                    IsShow:true, BGColor:item.LineColor, TextColor:item.TextColor, PixelTatio:pixelTatio, Position:"Right", IsInside:false
                                };
                                if (this.SendDrawCountDownEvent(sendData))
                                {
                                    if (IFrameSplitOperator.IsPlusNumber(sendData.Height))
                                        yText+=textHeight+1*pixelTatio;
                                }
                            }
                        }
                        else
                        {
                            var bgTop=yText-textHeight/2-1*pixelTatio;
                            if (i==0 && textInfo.Text.length==0)
                            {
                                var textLeft=right;
                                rtText.Left=textLeft;
                                if (preTextRect && bgTop<preTextRect.Rect.Bottom)
                                {
                                    yText=preTextRect.Rect.Bottom;
                                    bgTop=yText-textHeight/2-1*pixelTatio;
                                }
                            }
                            else
                            {
                                var textLeft=right+textWidth-itemText.Width;
                            }

                            if (item.ExtendLine && item.ExtendLine[1])  //右侧延长线
                            {
                                var exLine=item.ExtendLine[1];
                                if (IFrameSplitOperator.IsNumber(exLine.Width))
                                {
                                    if (i==0) this.DrawLine(right,textLeft+exLine.Width,y,item.LineColor,item.LineType,item);
                                    textLeft+=exLine.Width;
                                }
                            }

                            if (emptyBGColor)
                            {
                                this.Canvas.fillStyle=emptyBGColor;
                                this.Canvas.fillRect(textLeft,bgTop,itemText.Width+1,textHeight);
                                this.Canvas.strokeStyle=item.LineColor;
                                this.Canvas.strokeRect(ToFixedPoint(textLeft),ToFixedPoint(bgTop),ToFixedRect(itemText.Width+1),ToFixedRect(textHeight));
                                this.Canvas.fillStyle = item.LineColor;
                                this.Canvas.fillText(itemText.Text, textLeft + 2*pixelTatio, yText);
                            }
                            else
                            {
                                this.Canvas.fillStyle=item.LineColor;
                                this.Canvas.fillRect(textLeft,bgTop,itemText.Width,textHeight);
                                if (itemText.TextColor) this.Canvas.fillStyle=itemText.TextColor;
                                else this.Canvas.fillStyle = item.TextColor;
                                this.Canvas.fillText(itemText.Text, textLeft + 1*pixelTatio, yText);
                            }
                           
                            if (i==0) this.DrawLine(left,right,y,item.LineColor,item.LineType,item);
                            
                            yText+=textHeight+1*pixelTatio;

                            rtText.Bottom=yText;
                        }
                    }
                }

                if (mapTextRect && IFrameSplitOperator.IsNumber(rtText.Left) && IFrameSplitOperator.IsNumber(rtText.Bottom))
                {
                    mapTextRect.set(3, { Rect:rtText, Item:item });
                }

                if (item.Type==3 || item.Type==4)
                {
                    if (item.Title)
                    {
                        var bgColor=item.LineColor;
                        var rgb=this.RGBToStruct(item.LineColor);
                        if (rgb) bgColor=`rgba(${rgb.R}, ${rgb.G}, ${rgb.B}, ${g_JSChartResource.FrameLatestPrice.BGAlpha})`;   //内部刻度 背景增加透明度
                        var width=this.Canvas.measureText(item.Title).width+2*pixelTatio;
                        if (this.IsHScreen)
                        {
                            var bgTop=bottom-width;
                            var textLeft=y-textHeight/2-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,textHeight,width);
                            this.DrawHScreenText({X:y, Y:bgTop}, {Text:item.Title, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        }
                        else
                        {
                            var bgTop=y-textHeight/2-1*pixelTatio;
                            var textLeft=right-width-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(item.Title, textLeft + 1*pixelTatio, y);
                        }
                    }
                }
            }
        }
    }

    this.DrawCustomAreaItem=function(item)    //自定义Y轴区域
    {
        if (!item.AreaData) return;
        if (this.IsHScreen) return; //暂时不支持横屏

        //item.AreaData;  //区域: { Value[], BGColor:, Position:[0=左, 1=右] }
        if (!IFrameSplitOperator.IsNonEmptyArray(item.AreaData.Value) || item.AreaData.Value.length!=2) return;

        var max=Math.max(item.AreaData.Value[0],item.AreaData.Value[1]);
        var min=Math.min(item.AreaData.Value[0],item.AreaData.Value[1]);
        if (min>=this.HorizontalMax) return;
        if (max<=this.HorizontalMin) return;

        if (max>this.HorizontalMax) max=this.HorizontalMax;
        if (min<this.HorizontalMin) min=this.HorizontalMin;

        var border=this.GetBorder();
        var left=border.Left;
        var right=border.Right;
        var borderRight = this.ChartBorder.Right;
        var borderLeft = this.ChartBorder.Left;

        var yTop=this.GetYFromData(max);
        var yBottom=this.GetYFromData(min);

        if (item.AreaData.Position.includes(0) && borderLeft>10) //左
        {
            var rtBG={ Left:0, Right:left-1, Top:yTop, Bottom:yBottom };
            rtBG.Height=rtBG.Bottom-rtBG.Top;
            rtBG.Width=rtBG.Right-rtBG.Left;
            this.Canvas.fillStyle=item.AreaData.BGColor;
            this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
            this.DrawCustomAreaText(rtBG, item, 0);
        }

        if (item.AreaData.Position.includes(1) && borderRight>10) //右
        {
            var rtBG={ Left:right+1, Top:yTop, Bottom:yBottom };
            rtBG.Height=rtBG.Bottom-rtBG.Top;
            if (this.YRightTextInfo && IFrameSplitOperator.IsNumber(this.YRightTextInfo.MainTextWidth))   //右侧自动调整 可以获取宽度
            {
                rtBG.Width=this.YRightTextInfo.MainTextWidth-1;
                rtBG.Right=rtBG.Left+rtBG.Width;
            }
            else
            {
                rtBG.Right=border.ChartWidth;
                rtBG.Width=rtBG.Right-rtBG.Left;
            }

            this.Canvas.fillStyle=item.AreaData.BGColor;
            this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
            this.DrawCustomAreaText(rtBG, item, 1);
        }
    }

    this.DrawCustomAreaText=function(rtBG, item, position) //position 0=左 1=右
    {
        if (item.Font != null) this.Canvas.font = item.Font;
        var fontHeight=this.GetFontHeight();
        if (rtBG.Height<fontHeight) return;

        var pixelTatio = GetDevicePixelRatio();
        var text, xText;
        if (position==0)
        {
            if (!item.Message[0]) return;
            this.Canvas.textAlign = "right";
            text=item.Message[0];
            xText=rtBG.Right-2*pixelTatio;
        }
        else if (position==1)
        {
            if (!item.Message[1]) return;
            this.Canvas.textAlign = "left";
            text=item.Message[1];
            xText=rtBG.Left+2*pixelTatio
        }

        var yText=rtBG.Top+rtBG.Height/2;
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.fillText(text, xText, yText);
    }

    this.SendDrawCountDownEvent=function(sendData)
    {
        if (!this.GetEventCallback) return false;
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAW_COUNTDOWN);
        if (!event || !event.Callback) return false;

        event.Callback(event,sendData,this);
        return true;
    }

    this.DrawDotLine=function(left,right,y, color, option)
    {
        var pixelTatio = GetDevicePixelRatio();
        this.Canvas.save();
        this.Canvas.strokeStyle=color;
        if (option && IFrameSplitOperator.IsPlusNumber(option.LineWidth)) this.Canvas.lineWidth=option.LineWidth*pixelTatio;
        if (option.LineDash) this.Canvas.setLineDash(option.LineDash);
        else this.Canvas.setLineDash([5*pixelTatio,5*pixelTatio]);   //虚线
        this.Canvas.beginPath();
        if (this.IsHScreen)
        {
            this.Canvas.moveTo(ToFixedPoint(y),left);
            this.Canvas.lineTo(ToFixedPoint(y),right);
        }
        else
        {
            this.Canvas.moveTo(left,ToFixedPoint(y));
            this.Canvas.lineTo(right,ToFixedPoint(y));
        }
        this.Canvas.stroke();
        this.Canvas.restore();
    }

    this.DrawLine=function(left,right,y, color,lineType, option)
    {
        if (lineType==-1) return;

        if (lineType==0)
        {
            var pixelRatio=GetDevicePixelRatio();
            this.Canvas.strokeStyle=color;
            var bChangeLineWidth=false;
            if (option && IFrameSplitOperator.IsPlusNumber(option.LineWidth))
            {
                this.Canvas.lineWidth=option.LineWidth*pixelRatio;
                bChangeLineWidth=true;
            }

            this.Canvas.beginPath();
            if (this.IsHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(y),left);
                this.Canvas.lineTo(ToFixedPoint(y),right);
            }
            else
            {
                this.Canvas.moveTo(left,ToFixedPoint(y));
                this.Canvas.lineTo(right,ToFixedPoint(y));
            }
            this.Canvas.stroke();

            if (bChangeLineWidth)
            {
                this.Canvas.lineWidth=pixelRatio;
            }
        }
        else
        {
            this.DrawDotLine(left,right,y, color, option);
        }
    }

    this.DrawHScreenText=function(center,data)
    {
        this.Canvas.textAlign = "left";
        this.Canvas.textBaseline = "middle";
        this.Canvas.fillStyle = data.Color;

        this.Canvas.save();
        this.Canvas.translate(center.X, center.Y);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(data.Text, data.XOffset, data.YOffset);
        this.Canvas.restore();
    }

    this.RGBToStruct=function(rgb)
    {
        if(/^(rgb|RGB)/.test(rgb))
        {
            var aColor = rgb.replace(/(?:\(|\)|rgb|RGB)*/g,"").split(",");
            var result={};
            if (aColor.length!=3) return null;

            result.R = Number(aColor[0]);
            result.G = Number(aColor[1]);
            result.B = Number(aColor[2]);
            return result;
        }
       
        return null;
    }

    this.GetMulitTextMaxWidth=function(aryData)
    {
        var width=null;

        for(var i=0;i<aryData.length;++i)
        {
            var item=aryData[i];
            var text=item.Text;
            if (!text) continue;

            var value=this.Canvas.measureText(text).width;
            if (width==null) width=value;
            else if(width<value) width=value;
        }

        return width;
    }

    this.GetScaleTextWidth=function()
    {
        var border=this.ChartBorder.GetBorder();
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        if (this.IsHScreen)
        {
            var borderTop=this.ChartBorder.Top;
            var borderBottom=this.ChartBorder.Bottom;
            var isDrawLeft=borderTop>10*pixelTatio && this.IsShowYText[0]===true && this.YTextPosition[0]!=2;
            var isDrawRight=borderBottom>10*pixelTatio && this.IsShowYText[1]===true && this.YTextPosition[1]!=2;
        }
        else
        {
            var borderRight=this.ChartBorder.Right;
            var borderLeft=this.ChartBorder.Left;
            var isDrawLeft=borderLeft>10 && this.IsShowYText[0]===true && this.YTextPosition[0]!=2;
            var isDrawRight=borderRight>10 && this.IsShowYText[1]===true && this.YTextPosition[1]!=2;
        }
       
        if (!isDrawRight && !isDrawLeft) return null;

        var width={ Left:null, Right:null };
        var rightExtendWidth=0;
        var isYPercentage=false;    //是否是百分比坐标
        if (this.YSplitOperator && this.YSplitOperator.CoordinateType==1) isYPercentage=true;

        var leftExtendLineWidth=0;
        var rightExtendLineWidth=0;
        if (IFrameSplitOperator.IsNonEmptyArray(this.YLineExtend))
        {
            if (this.YLineExtend[0] && this.YLineExtend[0].Width>1)
                leftExtendLineWidth=this.YLineExtend[0].Width;
            if (this.YLineExtend[1] && this.YLineExtend[1].Width>1)
                rightExtendLineWidth=this.YLineExtend[1].Width;
        }
       
        for(var i=0;i<this.HorizontalInfo.length;++i)
        {
            var textWidth=null;
            var item=this.HorizontalInfo[i];
            if (!item) continue;
            if (item.Font!=null) this.Canvas.font=item.Font;

            if (item.Message[0]!=null && isDrawLeft)
            {
                if (Array.isArray(item.Message[0]))
                {
                    textWidth=this.GetMulitTextMaxWidth(item.Message[0]);
                }
                else
                {
                    textWidth=this.Canvas.measureText(item.Message[0]).width;
                }

                if (width.Left==null || width.Left<textWidth)
                    width.Left=textWidth;
                
                //JSConsole.Chart.Log(`[ChartData::GetScaleTextWidth] ${item.Message[0]} ${textWidth}`);
            }

            if (item.Message[1]!=null && isDrawRight)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                if (Array.isArray(item.Message[1]))
                {
                    if (this.MultiTextFormat==1)    //显示1行 格式:价格/百分比
                    {
                        if (item.ExtendData)
                        {
                            if (item.ExtendData.Font) this.Canvas.font=item.ExtendData.Font;
                            var width1=this.Canvas.measureText(item.Message[1][0]).width;
                            var width2=this.Canvas.measureText(item.Message[1][1]).width;
                            var width3=this.Canvas.measureText('/').width;
                            textWidth=width1+width3;

                            if (rightExtendWidth<width2) rightExtendWidth=width2;

                            //JSConsole.Chart.Log(`[ChartData::GetScaleTextWidth] ${item.Message[1][1]}/${item.Message[1][0]} ${textWidth}, ${rightExtendWidth}`);
                        }
                    }
                    else if (this.MultiTextFormat==2)   //显示2行
                    {
                        textWidth=this.Canvas.measureText(item.Message[1][0]).width;
                        var textWidth2=this.Canvas.measureText(item.Message[1][1]).width;
                        if (textWidth<textWidth2) textWidth=textWidth2;
                    }
                    else if (this.MultiTextFormat==3)
                    {
                        textWidth=this.GetMulitTextMaxWidth(item.Message[0]);
                    }
                    else    //显示第1行
                    {
                        textWidth=this.Canvas.measureText(item.Message[1][0]).width;
                        if (isYPercentage) 
                        {
                            var perTextWidth=this.Canvas.measureText("-00.00%").width;
                            if (perTextWidth>textWidth) textWidth=perTextWidth;
                        }
                    }
                }
                else
                {
                    textWidth=this.Canvas.measureText(item.Message[1]).width;
                }
                
                if (width.Right==null || width.Right<textWidth)
                    width.Right=textWidth;
            }
        }

        
        if (IFrameSplitOperator.IsNumber(width.Right)) width.Right+=rightExtendWidth;
        if (IFrameSplitOperator.IsNumber(width.Left)) width.Left+=this.YTextPadding[0]+leftExtendLineWidth;
        if (IFrameSplitOperator.IsNumber(width.Right)) width.Right+=this.YTextPadding[1]+rightExtendLineWidth;
        
        return { TextWidth:width };
    }

    this.ClearToolbar=function()
    {
        if (!this.ToolbarID) return;

        var divToolbar=document.getElementById(this.ToolbarID);
        if (!divToolbar) return;
        this.ChartBorder.UIElement.parentNode.removeChild(divToolbar);
        this.ToolbarRect=null;
    }

    this.HideToolbar=function()
    {
        if (!this.ToolbarID) return;

        this.ToolbarRect=null;
        var divToolbar=document.getElementById(this.ToolbarID);
        if (!divToolbar) return;

        if (divToolbar.style.display!='none') divToolbar.style.display='none';
    }

    this.GetMainOverlayFrame=function()
    {
        if (!this.FrameData || !this.FrameData.SubFrameItem)  return null;

        var subFrame=this.FrameData.SubFrameItem;
        var leftFrame=null, rightFrame=null;
        for(var i=0;i<subFrame.OverlayIndex.length;++i)
        {
            var item=subFrame.OverlayIndex[i];
            var overlayFrame=item.Frame;
            if (overlayFrame.IsShowMainFrame==2) rightFrame=overlayFrame;
            else if (overlayFrame.IsShowMainFrame==1) leftFrame=overlayFrame;
        }

        if (!leftFrame && !rightFrame) return null;

        return [leftFrame, rightFrame];
    }
}

function MinuteFrame()
{
    this.newMethod=AverageWidthFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="MinuteFrame";
    this.DataWidth=1*GetDevicePixelRatio();
    this.DistanceWidth=1*GetDevicePixelRatio();
    this.MinuteCount=243;   //每天的分钟个数
    this.BeforeBGColor=g_JSChartResource.Minute.Before.BGColor;  //集合竞价背景
    this.AfterBGColor=g_JSChartResource.Minute.After.BGColor;
    this.MultiDayBorderPen=g_JSChartResource.MultiDayBorderPen;
    this.CustomHorizontalInfo=[];
    this.RightFrame=null;   //右侧多重坐标
    this.ToolbarID=Guid();  //工具条Div id
    this.ReDrawToolbar=false;
    this.DayCount=1;        //显示天数

    this.ModifyIndex=g_JSChartResource.MinuteToolbar.ModifyIndex;      //是否显示'改参数'菜单
    this.ChangeIndex=g_JSChartResource.MinuteToolbar.ChangeIndex;      //是否显示'换指标'菜单
    this.CloseIndex=g_JSChartResource.MinuteToolbar.CloseIndex;       //是否显示'关闭指标窗口'菜单
    this.MaxMinWindow=g_JSChartResource.MinuteToolbar.MaxMinWindow;
    this.TitleWindow=g_JSChartResource.MinuteToolbar.TitleWindow;
    this.ExportData=g_JSChartResource.MinuteToolbar.ExportData;      //是否显示'导出数据'菜单
    this.OverlayIndex=g_JSChartResource.MinuteToolbar.OverlayIndex;    //是否显示叠加指标

    this.ModifyIndexEvent;   //改参数 点击事件
    this.ChangeIndexEvent;   //换指标 点击事件
    this.ToolbarRect=null;   //保存工具条的位置
    this.IsShowPositionTitle=false; //是否显示持仓标题

    this.LastCalculateStatus={ Width:0, XPointCount:0 };    //最后一次计算宽度的状态
    this.BeforeCloseIcon=CloneData(g_JSChartResource.Minute.Before.CloseIcon);
    this.IsShowCloseButton=true,        //是否关闭集合竞价按钮

    this.BeforeOpenVerticalInfo=[];      //盘前集合竞价X轴
    this.AfterCloseVerticalInfo=[];      //收盘集合竞价X轴

    this.NightDayConfig=CloneData(g_JSChartResource.Minute.NightDay);

    this.DrawFrame=function()
    {
        if (!this.IsMinSize)
        {
            this.SplitXYCoordinate();
            this.DrawBeforeDataBG();
    
            this.YInsideOffset=0;

            if (this.BeforeDrawXYCallback) this.BeforeDrawXYCallback(this);

            this.DrawNightDayBG();  //绘制夜盘 日盘背景

            this.DrawTitleBG();
            this.DrawHorizontal();
            this.DrawVertical();
        }
        
        if (this.SizeChange==true || this.ReDrawToolbar==true) 
        {
            this.DrawToolbar();  //大小变动才画工具条
            this.ReDrawToolbar=false;
        }
    }

    //画边框
    this.SuperDrawBorder=this.DrawBorder;
    this.DrawBorder=function()
    {
        if (!this.IsShowBorder) return;
        if (this.IsMinSize) return;
        this.SuperDrawBorder();

        if (this.Identify==1)   //走势图和成交量中间用粗线分割开
        {
            var border=this.ChartBorder.GetBorder();
            var left=ToFixedPoint(border.Left);
            var top=ToFixedPoint(border.Top);
            var right=ToFixedPoint(border.Right);
    
            this.Canvas.strokeStyle=this.PenBorder;
            this.Canvas.beginPath();
            this.Canvas.moveTo(left,top);
            this.Canvas.lineTo(right,top);
            this.Canvas.save();
            this.Canvas.lineWidth=2 * GetDevicePixelRatio();
            this.Canvas.stroke();
            this.Canvas.restore();
        }
    }

    this.DrawVolTitle=function(symbol)
    {
        if (!MARKET_SUFFIX_NAME.IsShowMinuteVolTitle(symbol)) return;

        if (this.Identify==1)   //显示"成交量"
        {
            var pixelRatio=GetDevicePixelRatio();
            var left=this.ChartBorder.GetLeft()+2*pixelRatio+this.YInsideOffset;

            var top=this.ChartBorder.GetTopEx()+2*pixelRatio;

            this.Canvas.textAlign='left';
            this.Canvas.textBaseline='top';
            if (g_JSChartResource.Minute.VolBarColor || g_JSChartResource.Minute.VolTitleColor)
            {
                if (g_JSChartResource.Minute.VolBarColor) this.Canvas.fillStyle=g_JSChartResource.Minute.VolBarColor
                else this.Canvas.fillStyle=g_JSChartResource.Minute.VolTitleColor;
                var languageID=this.YSplitOperator.LanguageID;
                var text=g_JSChartLocalization.GetText('MVol-Vol',languageID);
                this.Canvas.fillText(text,left,top);
                left+=this.Canvas.measureText(text).width;
                left+=6*GetDevicePixelRatio();
            }
            
            if (this.IsShowPositionTitle)
            {
                text=g_JSChartLocalization.GetText('MVol-Position',languageID);
                this.Canvas.fillStyle=g_JSChartResource.Minute.PositionColor;
                this.Canvas.fillText(text,left,top);
            }
        }
    }

    this.DrawToolbar=function()
    {
        if (this.ToolbarButtonStyle==1) return;
        if (g_JSChartResource.IsDOMFrameToolbar===true) return;

        if (typeof($)=="undefined") return;

        if (this.Identify<2) return;
        if (!this.ChartBorder.UIElement) return;

        var divToolbar=document.getElementById(this.ToolbarID);
        if (divToolbar && this.SizeChange==false && this.ReDrawToolbar==false) return;

        if (!divToolbar)
        {
            divToolbar=document.createElement("div");
            divToolbar.className='klineframe-toolbar';
            divToolbar.id=this.ToolbarID;
            divToolbar.oncontextmenu = function() { return false;}; //屏蔽右键系统菜单
            //为divToolbar添加属性identify
            divToolbar.setAttribute("identify",this.Identify.toString());
            this.ChartBorder.UIElement.parentNode.appendChild(divToolbar);
        }

        if (!this.ModifyIndex && !this.ChangeIndex && !this.OverlayIndex && !this.CloseIndex)
        {
            if (divToolbar.style.display!='none')
                divToolbar.style.display='none';
            return;
        }

        //使用外城div尺寸 画图尺寸是被放大的
        var pixelTatio = GetDevicePixelRatio();
        var chartWidth=parseInt(this.ChartBorder.UIElement.parentElement.style.width.replace("px",""));  
        var chartHeight=parseInt(this.ChartBorder.UIElement.parentElement.style.height.replace("px",""));
        //JSConsole.Chart.Log('[KLineFrame::DrawToolbar] ',chartWidth,chartHeight,pixelTatio);

        var toolbarWidth=100;
        var toolbarHeight=this.ChartBorder.GetTitleHeight();
        var left=chartWidth-(this.ChartBorder.Right/pixelTatio)-toolbarWidth;
        var top=this.ChartBorder.GetTop()/pixelTatio;

        if (this.ToolbarRect)
        {
            //尺寸变动移动才重新设置DOM
            if (this.ToolbarRect.Left==left && this.ToolbarRect.Top==top && 
                this.ToolbarRect.Width==toolbarWidth && this.ToolbarRect.Height==toolbarHeight/pixelTatio)
            {
                return;
            }
        }

        this.ToolbarRect={ Left:left, Top:top, Width:toolbarWidth, Height:toolbarHeight/pixelTatio };

        const modifyButton=`<span class='index_param icon iconfont icon-index_param' id='modifyindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='调整指标参数'></span>`;
        const changeButton=`<span class='index_change icon iconfont icon-change_index' id='changeindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='切换指标'></span>`;
        const closeButton=`<span class='index_close icon iconfont icon-close' id='closeindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='关闭指标窗口'></span>`;

        var spanIcon=modifyButton+changeButton;
        if (this.CloseIndex)
        {
            spanIcon+=closeButton;
        }

        //var scrollPos=GetScrollPosition();
        //left = left+scrollPos.Left;
        //top = top+scrollPos.Top;
        divToolbar.style.left = left + "px";
        divToolbar.style.top = top + "px";
        divToolbar.style.width=toolbarWidth+"px";                   //宽度先不调整吧
        divToolbar.style.height=(toolbarHeight/pixelTatio)+'px';    //只调整高度
        divToolbar.innerHTML=spanIcon;

        var chart=this.ChartBorder.UIElement.JSChartContainer;
        var identify=this.Identify;
        if (!this.ModifyIndex)  //隐藏'改参数'
            $("#"+divToolbar.id+" .index_param").hide();
        else if (typeof(this.ModifyIndexEvent)=='function')  //绑定点击事件
            $("#"+divToolbar.id+" .index_param").click(
                {
                    Chart:this.ChartBorder.UIElement.JSChartContainer,
                    Identify:this.Identify
                },this.ModifyIndexEvent);

        if (!this.ChangeIndex)  //隐藏'换指标'
        {
            $("#"+divToolbar.id+" .index_change").hide();
        }  
        else if (typeof(this.ChangeIndexEvent)=='function')
        {
            $("#"+divToolbar.id+" .index_change").click(
                {
                    Chart:this.ChartBorder.UIElement.JSChartContainer,
                    Identify:this.Identify,
                    IsOverlay:false
                },this.ChangeIndexEvent);
        }

        $("#"+divToolbar.id+" .index_close").click(
            {
                Chart:this.ChartBorder.UIElement.JSChartContainer,
                Identify:this.Identify
            },
            function(event)
            {
                var hqChart=event.data.Chart;
                var id=event.data.Identify;
                hqChart.RemoveIndexWindow(id);
            });

        divToolbar.style.display = "block";
    }

    //手绘,不用DOM,使用DOM太麻烦了
    this.DrawToolbarV2=function(moveonPoint, mouseStatus)
    {
        if (g_JSChartResource.IsDOMFrameToolbar===true) return;

        if (this.Identify==0 && this.IsShowCloseButton) this.DrawCloseBeforeButton(moveonPoint, mouseStatus);  //盘前集合竞价关闭按钮

        if (this.ChartBorder.TitleHeight<5) return;

        var aryButton=[];
        if (this.Identify!=0 && this.Identify!=1) //价格图和成交量图只有自定义按钮
        {
            if (this.CloseIndex)  aryButton.push( { ID:JSCHART_BUTTON_ID.CLOSE_INDEX_WINDOW, Style:this.CloseWindowButton });
            if (this.MaxMinWindow) aryButton.push({ ID:JSCHART_BUTTON_ID.MAX_MIN_WINDOW, Style:this.MaxMinWindowButton })
            if (this.TitleWindow) aryButton.push({ ID:JSCHART_BUTTON_ID.TITLE_WINDOW, Style:this.TitleWindowButton });
            if (this.ExportData) aryButton.push( {ID:JSCHART_BUTTON_ID.EXPORT_DATA, Style:this.ExportDataButton});
            if (this.OverlayIndex) aryButton.push( { ID:JSCHART_BUTTON_ID.OVERLAY_INDEX, Style:this.OverlayIndexButton });
            if (this.ChangeIndex) aryButton.push( { ID:JSCHART_BUTTON_ID.CHANGE_INDEX, Style:this.ChangeIndexButton });
            if (this.ModifyIndex) aryButton.push( { ID:JSCHART_BUTTON_ID.MODIFY_INDEX_PARAM, Style:this.ModifyIndexParamButton });
        }

        if (IFrameSplitOperator.IsNonEmptyArray(this.CustomToolbar))
        {
            for(var i=0;i<this.CustomToolbar.length;++i)
            {
                var item=this.CustomToolbar[i];
                if (item.ID && item.Style) aryButton.push({ ID:item.ID, Style:item.Style, TooltipText:item.TooltipText, Data:item.Data });
            }
        }

        this.DrawTitleButton(aryButton, moveonPoint, mouseStatus);
    }

    this.DrawCloseBeforeButton=function(moveonPoint, mouseStatus)
    {
        if (this.Identify!=0) return;
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return;
        if (this.ChartBorder.LeftExtendWidth<10) return;

        var rtButton={ Left:border.Left, Top:border.TopEx, Width:this.BeforeCloseIcon.Size, Height:this.BeforeCloseIcon.Size };
        rtButton.Right=rtButton.Left+this.BeforeCloseIcon.Size;
        rtButton.Bottom=rtButton.Top+this.BeforeCloseIcon.Size;

        var item={ Rect:rtButton, Name:"集合竞价关闭按钮" , ID:JSCHART_BUTTON_ID.CLOSE_BEFOREOPEN_ID };
        var color=this.BeforeCloseIcon.Color;
        if (moveonPoint && 
            (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
        {
            color=this.BeforeCloseIcon.MoveOnColor;
            if (mouseStatus)
                mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:item, Frame:this, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
        }
            

        var font=`${this.BeforeCloseIcon.Size}px ${this.BeforeCloseIcon.Family}`;
        this.Canvas.font=font;
        this.Canvas.fillStyle=color;
        this.Canvas.textAlign = 'left';
        this.Canvas.textBaseline='top';
        this.Canvas.fillText(this.BeforeCloseIcon.Text,border.Left,border.TopEx);
        
        this.Buttons.push(item);
    }

    this.DrawMultiDayBeforeDataBG=function(border)
    {
        var dayBorder=border.DayBorder;
        var top=ToFixedPoint(border.Top);
        var bottom=ToFixedPoint(border.Bottom);
        var height=bottom-top;
        
        this.Canvas.strokeStyle=this.MultiDayBorderPen;
        for(var i=0; i<dayBorder.length; ++i)
        {
            var drawCount=0;
            var item=dayBorder[i];
            var left=ToFixedPoint(item.Left);
            var right=ToFixedPoint(item.LeftEx);
            var width=right-left;
            if (width>3)    //盘前
            {
                this.Canvas.fillStyle=this.BeforeBGColor;
                this.Canvas.fillRect(left,top,width,height);    
                ++drawCount;
            }

            var left=ToFixedPoint(item.RightEx);
            var right=ToFixedPoint(item.Right);
            var width=right-left;
            if (width>3)    //盘后
            {
                this.Canvas.fillStyle=this.AfterBGColor;
                this.Canvas.fillRect(left,top,width,height);
                ++drawCount;
            }

            if (drawCount==2 && i!=dayBorder.length-1)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(right,top);
                this.Canvas.lineTo(right,bottom);
                this.Canvas.stroke();
            }
        }
    }

    this.DrawCallAuctionVertical=function(verticalInfo, callAuctionData, border, isBeforeClose)
    {
        if (!callAuctionData) return;

        var top=border.TopTitle;
        var bottom=border.Bottom;
        var left=border.Left;
        var right=border.LeftEx;
        var pixelRatio = GetDevicePixelRatio(); //获取设备的分辨率

        var xPrev=null;         //上一个坐标x的值
        var textRightPrev=null; //上一次刻度输出右边x坐标

        for(var i in verticalInfo)
        {
            var item=verticalInfo[i];
            var x=this.GetLeftExtendXFromIndex(item.Value,callAuctionData);
            if (x>right) break;
            if (xPrev!=null && Math.abs(x-xPrev)<this.MinXDistance) continue;
            
            var xFixed=ToFixedPoint(x);
            if (this.IsShowXLine)
            {
                if (item.LineType==2)   //虚线
                {
                    this.Canvas.strokeStyle=item.LineColor;
                    this.Canvas.setLineDash([5*pixelRatio,5*pixelRatio]);   
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(xFixed,top);
                    this.Canvas.lineTo(xFixed,bottom);
                    this.Canvas.stroke();
                    this.Canvas.setLineDash([]);
                }
                else if (item.LineType==3)
                {

                }
                else if (item.LineType>0)   //实线
                {
                    if (g_JSChartResource.FrameXLineDash)
                    {
                        this.Canvas.strokeStyle=item.LineColor;
                        this.Canvas.setLineDash(g_JSChartResource.FrameXLineDash);   //虚线
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed,top);
                        this.Canvas.lineTo(xFixed,bottom);
                        this.Canvas.stroke();
                        this.Canvas.setLineDash([]);
                    }
                    else
                    {
                        this.Canvas.strokeStyle=item.LineColor;
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed,top);
                        this.Canvas.lineTo(xFixed,bottom);
                        this.Canvas.stroke();
                    }
                }
            }
            

            if (item.Message[0]!=null && this.ChartBorder.Bottom>5*pixelRatio)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;
                
                var textLeft=0;
                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.strokeStyle=item.TextColor;
                var testWidth=this.Canvas.measureText(item.Message[0]).width;
                if (x<testWidth/2)
                {
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="top";
                    textLeft=x;
                }
                else if ((x + testWidth / 2) >= border.ChartWidth)
                {
                    this.Canvas.textAlign = "right";
                    this.Canvas.textBaseline="top";
                    textLeft=x-testWidth;
                }
                else
                {
                    this.Canvas.textAlign="center";
                    this.Canvas.textBaseline="top";
                    textLeft=x-(testWidth/2);
                }
                
                if (textRightPrev==null || textLeft>textRightPrev)
                {
                    var yText=bottom;
                    if (item.LineType==3)
                    {
                        var lineLength=this.ShortXLineLength*pixelRatio;
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed,yText);
                        this.Canvas.lineTo(xFixed,yText+lineLength);
                        this.Canvas.stroke();

                        yText+=lineLength+2*pixelRatio;
                    }

                    this.Canvas.fillText(item.Message[0],x,yText+this.XBottomOffset);
                    textRightPrev=textLeft+testWidth;
                }
            }

            xPrev=x;
        }
    }

    //画集合竞价背景
    this.DrawBeforeDataBG=function()
    {
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder)
        {
            this.DrawMultiDayBeforeDataBG(border);
            return;
        }

        if (this.ChartBorder.LeftExtendWidth<10 && this.ChartBorder.RightExtendWidth<10) return;
        //if (this.Identify>=2) return;

        var top=ToFixedPoint(border.Top);
        var bottom=ToFixedPoint(border.Bottom);
        this.Canvas.fillStyle=this.BeforeBGColor;

        if (this.ChartBorder.LeftExtendWidth>10)    //盘前
        {
            var left=ToFixedPoint(border.Left);
            var right=ToFixedPoint(this.ChartBorder.GetLeft());
            var width=right-left;
            var height=bottom-top;
            
            this.Canvas.fillRect(left,top,width,height);

            this.DrawCallAuctionVertical(this.BeforeOpenVerticalInfo, this.YSplitOperator.BeforeOpenData, border, true);
        }

        if (this.ChartBorder.RightExtendWidth>10)   //盘后
        {
            this.Canvas.fillStyle=this.AfterBGColor;
            var left=ToFixedPoint(this.ChartBorder.GetRight());
            var right=ToFixedPoint(border.Right);
            var width=right-left;
            var height=bottom-top;

            this.Canvas.fillRect(left,top,width,height);
        }
    }

    this.DrawNightDayBG=function()
    {
        if (this.DayCount!=1) return;
        if (!this.HQChart) return;
        if (!this.HQChart.EnableNightDayBG) return;

        var symbol=this.HQChart.Symbol;
        if (!symbol) return;

        var xIndex=-1;
        //获取夜盘和日期的分界线X索引位置
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_MINUTE_NIGHT_DAY_X_INDEX)
        if (!event || !event.Callback) return;

        var sendData={ Symbol:symbol, XIndex:xIndex, MinuteTimeStringData:g_MinuteTimeStringData };
        event.Callback(event,sendData,this);
        xIndex=sendData.XIndex;
        if (xIndex<0) return;

        var border=this.ChartBorder.GetBorder();
        var x=this.GetXFromIndex(xIndex);

        var rtNight={ Left: border.Left, Top:border.TopEx, Right:x, Bottom:border.Bottom };
        rtNight.Width=rtNight.Right-rtNight.Left;
        rtNight.Height=rtNight.Bottom-rtNight.Top;

        this.Canvas.fillStyle = this.NightDayConfig.NightBGColor;
        this.Canvas.fillRect(rtNight.Left, rtNight.Top, rtNight.Width, rtNight.Height);

        if (this.Identify!=0) return;

        //显示 日盘夜盘文字
        this.Canvas.font=this.NightDayConfig.Font;
		this.Canvas.textBaseline = "bottom";
		this.Canvas.textAlign = 'left';
		var aryTitle=[{ Title:"夜盘", Position:1, Config:this.NightDayConfig.Night }, { Title:"日盘", Position:0,Config:this.NightDayConfig.Day }];
		var textHeight= this.Canvas.measureText("擎").width;
		for(var i=0;i<aryTitle.length;++i)
		{
			var item=aryTitle[i];
            var text=g_JSChartLocalization.GetText(item.Title,this.HQChart.LanguageID);
			var testWidth = this.Canvas.measureText(text).width;
			var rtItem=
			{ 
				Width:testWidth+item.Config.Margin.Left+item.Config.Margin.Right, 
				Height:textHeight+item.Config.Margin.Top+item.Config.Margin.Bottom,
				Bottom:border.Bottom
			};
			rtItem.Top=rtItem.Bottom-rtItem.Height;

			if (item.Position===1) 
			{
				rtItem.Right=x-1;
				rtItem.Left=rtItem.Right-rtItem.Width;
			}
			else 
			{
				rtItem.Left=x+1;
				rtItem.Right=rtItem.Left+rtItem.Width;
			}

			if (item.Config.BGColor)
			{
				this.Canvas.fillStyle = item.Config.BGColor;
				this.Canvas.fillRect(rtItem.Left, rtItem.Top, rtItem.Width, rtItem.Height);
			}

			if (item.Config.BorderColor)
			{
				this.Canvas.strokeStyle = item.Config.BorderColor;
				this.Canvas.strokeRect(ToFixedPoint(rtItem.Left), ToFixedPoint(rtItem.Top), ToFixedRect(rtItem.Width), ToFixedRect(rtItem.Height));
			}

            
			this.Canvas.fillStyle = item.Config.Color;
			this.Canvas.fillText(text, rtItem.Left+item.Config.Margin.Left, rtItem.Bottom-item.Config.Margin.Bottom );
		}
        
    }

    //选中的画图工具X轴坐标信息
    this.DrawPictureXCoordinate=function(drawPicture, range, option)
    {
        if (this.IsHScreen) return;
        if (!range) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(range.Points)) return;

        var border=this.GetBorder();
        var left=border.Left;
        var right=border.Right;

        this.Canvas.font=this.DrawPicture.Font;
        var fontHeight=this.GetFontHeight();

        if (range.X)
        {
            var xRange=range.X;
            var xLeft=xRange.Min.X;
            var xRight=xRange.Max.X;
            if (xLeft<left) xLeft=left;
            if (xRight>right) xRight=right;

            this.Canvas.fillStyle=this.DrawPicture.BGColor;
            this.Canvas.fillRect(xLeft, border.Bottom, xRight-xLeft, fontHeight);
        }

        for(var i=0;i<range.Points.length;++i)
        {
            var item=range.Points[i];
            if (item.X<left || item.X>right) continue;

            var index=parseInt(this.GetXData(item.X));
            var kItem=this.GetKItem(index,option);
            if (kItem)
            {
                //var text=IFrameSplitOperator.FormatDateString(kItem.Date,null);
                var text=IFrameSplitOperator.FormatTimeString(kItem.Time, "HH:MM");
                var textWidth=this.Canvas.measureText(text).width+2;

                var textLeft=item.X-textWidth/2;
                if (textLeft<left) textLeft=left;
                this.Canvas.fillStyle=this.DrawPicture.TextBGColor;
                this.Canvas.fillRect(textLeft, border.Bottom, textWidth, fontHeight);

                this.Canvas.fillStyle=this.DrawPicture.TextColor;
                var yCenter=border.Bottom+fontHeight;
                this.Canvas.fillText(text,textLeft+1,yCenter);
            }
        }
    }

    this.GetKItem=function(currentIndex,option)
    {
        if (!this.Data) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return null;
        if (currentIndex<this.Data.Data.length)
        {
            return this.Data.Data[currentIndex];
        }
        else
        {
            var kItem=this.Data.Data[this.Data.Data.length-1];
            var xDatetime=g_MinuteTimeStringData.GetTimeData(option.Symbol);
            var index=currentIndex%xDatetime.length;
            var timeItem=xDatetime[index];
            
            return { Date:kItem.Date, Time:timeItem };
        }
    }

    this.DrawDayVertical=function(dayItem, x, border)
    {
        if (!dayItem.BG) return;

        var bgItem=dayItem.BG;
        var xStart=this.GetXFromIndex(bgItem.Index.Start);
        var xEnd=this.GetXFromIndex(bgItem.Index.End);
        var maxWidth=xEnd-xStart;
        var bgHeight=this.ChartBorder.Bottom;
        if (IFrameSplitOperator.IsNumber(bgItem.Height)) bgHeight=bgItem.Height;

        if (bgItem.Color)
        {
            this.Canvas.fillStyle=bgItem.Color;
            var rtBG={Left:xStart, Width:maxWidth, Top:border.Bottom, Height: bgHeight };
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
        }

        if (IFrameSplitOperator.IsNonEmptyArray(dayItem.AryText))    //[ [{Text:, Color:},], []]
        {
            this.Canvas.textAlign="left";
            this.Canvas.textBaseline="top";
            var yText=border.Bottom+2;
            var lineHeight=this.Canvas.measureText("擎").width+2;
            for(var i=0,j=0;i<dayItem.AryText.length;++i)
            {
                var aryText=dayItem.AryText[i];
                var itemWidth=0;
                var aryOut=[];
                for(j=0;j<aryText.length;++j)
                {
                    var item=aryText[j];
                    var textWidth=this.Canvas.measureText(item.Text).width;
                    if (itemWidth+textWidth>maxWidth) break;

                    var newItem={ Text:item.Text, Width:textWidth, Color:item.Color, Space:item.Space };
                    itemWidth+=textWidth;
                    item.Width=textWidth;
                    if (item.Space>=1) itemWidth+=item.Space;
                    aryOut.push(newItem);
                }

                var xText=xStart+(maxWidth-itemWidth)/2;
                for(var j=0;j<aryOut.length;++j)
                {
                    var item=aryOut[j];
                    if (!IFrameSplitOperator.IsNumber(item.Width)) break;
                    if (item.Color) this.Canvas.fillStyle=item.Color;
                    else if (dayItem.TextColor) this.Canvas.fillStyle=dayItem.TextColor;

                    this.Canvas.fillText(item.Text,xText,yText);
                    xText+=item.Width;
                    if (item.Space>=1) xText+=item.Space;
                }

                yText+=lineHeight;
            }
        }
        
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) 
        {
            //计算自定义刻度
            if (this.YCustomSplit)
            {
                if (this.YSplitOperator && this.YSplitOperator.CustomCoordinate)
                    this.YSplitOperator.CustomCoordinate();
            }

            return;
        }

        if (this.XSplitOperator!=null) this.XSplitOperator.Operator();
        if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
    }

    this.GetMultiDayXFromIndex=function(index, border)
    {
        var dayBorder=border.DayBorder;
        var minuteIndex=index%this.MinuteCount;
        var dayIndex=parseInt(index/this.MinuteCount);
        if (dayIndex>=dayBorder.length) dayIndex=dayBorder.length-1;

        var client=dayBorder[dayIndex];
        var count=this.MinuteCount-1;

        if (minuteIndex>=count) 
        {
            return client.RightEx;
        }
        else
        {
            var width=(client.RightEx-client.LeftEx);
            var offset=client.LeftEx+width*minuteIndex/count;
            return offset;
        }
    }

    this.GetXFromIndex=function(index)
    {
        var count=this.XPointCount-1;
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return this.GetMultiDayXFromIndex(index, border);

        if (count==1)
        {
            if (index==0) return border.LeftEx;
            else return border.RightEx;
        }
        else if (count<=0)
        {
            return border.LeftEx;
        }
        else if (index>=count)
        {
            return border.RightEx;
        }
        else
        {
            var width=(border.RightEx-border.LeftEx);
            var offset=border.LeftEx+width*index/count;
            return offset;
        }
    }

    this.GetMultiDayXData=function(x,border)
    {
        var dayBorder=border.DayBorder;
        for(var i=0;i<dayBorder.length;++i)
        {
            var client=dayBorder[i];
            if (x>=client.Left && x<=client.Right)
            {
                var count=this.MinuteCount-1;
                var dayMinuteCount=this.MinuteCount*i;
                if (x<=client.LeftEx) return 0+dayMinuteCount;
                if (x>=client.RightEx) return count+dayMinuteCount;

                var width=client.RightEx-client.LeftEx;
                return (x-client.LeftEx)*(count*1.0/width)+dayMinuteCount;
            }
        }
    }

    //X坐标转x轴数值
    this.GetXData=function(x)
    {
        var count=this.XPointCount-1;
        if (count<0) count=0;

        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return this.GetMultiDayXData(x, border);

        if (x<=border.LeftEx) return 0;
        if (x>=border.RightEx) return count;

        var width=border.RightEx-border.LeftEx;
        return (x-border.LeftEx)*(count*1.0/width);
    }

    this.DrawCustomHorizontal=function()    //Y轴刻度定制显示
    {
        if (this.IsMinSize) return;
        for(var i in this.CustomHorizontalInfo)
        {
            var item=this.CustomHorizontalInfo[i];
            switch(item.Type)
            {
                case 0:
                case 1:
                    this.DrawCustomItem(item);  //自定义刻度
                    break;
            }
        }
    }

    this.GetLeftExtendXFromIndex=function(index, obj)
    {
        var count=obj.TotalCount-1;

        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return this.GetLeftExtendMultiDayXFromIndex(index, obj, border);

        var left=border.Left;
        var width=this.ChartBorder.LeftExtendWidth;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetLeftExtendMultiDayXFromIndex=function(index, obj, border)
    {
        var dayBorder=border.DayBorder;
        var client=dayBorder[obj.Index];
        var count=obj.TotalCount-1;

        var left=client.Left;
        var right=client.LeftEx;
        var width=right-left;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetLeftExtendMultiDayXData=function(x, obj, border)
    {
        var dayBorder=border.DayBorder;
        for(var i=0; i<dayBorder.length; ++i)
        {
            var client=dayBorder[i];
            if (x>=client.Left && x<=client.LeftEx)
            {
                if (!obj[i]) return null;
                var count=obj[i].TotalCount-1;
                var left=client.Left;
                var right=client.LeftEx;

                var width=right-left;
                var index=(x-left)*(count*1.0/width);

                return { DayIndex:parseInt(i), DataIndex:index };
            }
        }
    }

    this.GetLeftExtendXData=function(x, obj)
    {
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return this.GetLeftExtendMultiDayXData(x, obj, border);

        var count=obj.TotalCount-1;
        if (count<0) count=0;

        var left=border.Left;
        var right=border.LeftEx;

        if (x<=left) return 0;
        if (x>=right) return count;

        var width=right-left;
        return (x-left)*(count*1.0/width);
    }


    this.MoveXIndexLeft=function(step, obj)
    {
        JSConsole.Chart.Log("[MinuteFrame::MoveXIndexLeft] obj ", obj);
        if (obj.DataType==2)  //多日数据
        {
            var dayIndex=obj.IndexData.DayIndex;
            var dataIndex=obj.IndexData.DataIndex-step;
            var itemIndex=-1;
            if (obj.IndexData.Type==20) itemIndex=0;
            else if (obj.IndexData.Type==10) itemIndex=1;
            else if (obj.IndexData.Type==30) itemIndex=2;
            else return false;

            for(var i=dayIndex, j=itemIndex; i>=0; --i)
            {
                var dayItem=obj.Data[i];
                for(; j>=0; --j)
                {
                    var dataItem=dayItem[j];
                    if (!dataItem.DayItem || !dataItem.DayItem.Data) continue;

                    if (dataIndex==null) dataIndex=dataItem.DayItem.Data.length-1;
                    for(; dataIndex>=0;--dataIndex)
                    {
                        var item=dataItem.DayItem.Data[dataIndex];
                        if (!item) continue;
                        if (dataItem.Type==10)
                        {
                            var cursorIndex=this.MinuteCount*i+dataIndex;
                            obj.Point.X=this.GetXFromIndex(cursorIndex);
                            obj.Point.Y=this.GetYFromData(item.Close);
                            obj.IndexData.CursorIndex=cursorIndex;
                            obj.IndexData.DayIndex=i;
                            obj.IndexData.DataIndex=dataIndex;
                            obj.IndexData.Type=dataItem.Type;
                            return true;
                        }
                        else if (dataItem.Type==20)
                        {
                            if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                            obj.Point.X=this.GetLeftExtendXFromIndex(dataIndex,dataItem.DayItem);
                            obj.Point.Y=this.GetLeftExtendYFromData(item.Price);
                            obj.IndexData.CursorIndex=-1;
                            obj.IndexData.DayIndex=i;
                            obj.IndexData.DataIndex=dataIndex;
                            obj.IndexData.Type=dataItem.Type;
                            return true;
                        }
                        else if (dataItem.Type==30)
                        {
                            if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                            obj.Point.X=this.GetRightExtendXFromIndex(dataIndex,dataItem.DayItem);
                            obj.Point.Y=this.GetRightExtendYFromData(item.Price);
                            obj.IndexData.CursorIndex=-1;
                            obj.IndexData.DayIndex=i;
                            obj.IndexData.DataIndex=dataIndex;
                            obj.IndexData.Type=dataItem.Type;
                            return true;
                        }
                    }
                    
                    dataIndex=null;
                }

                j=2;
            }


            return false;
        }
        else if (obj.DataType==1)   //单日
        {
            var dayIndex=obj.IndexData.DayIndex;
            var dataIndex=obj.IndexData.DataIndex-step;
            var itemIndex=-1;
            if (obj.IndexData.Type==2) itemIndex=0;
            else if (obj.IndexData.Type==1) itemIndex=1;
            else if (obj.IndexData.Type==3) itemIndex=2;
            else return false;

            for(var i=itemIndex; i>=0; --i)
            {
                var dataItem=obj.Data[i];
                if (!dataItem || !dataItem.DayItem || !dataItem.DayItem.Data) continue;

                if (dataIndex==null) dataIndex=dataItem.DayItem.Data.length-1;
                for(; dataIndex>=0;--dataIndex)
                {
                    if (dataItem.Type==1)
                    {
                        var offset=dataItem.DayItem.DataOffset;
                        var item=dataItem.DayItem.Data[dataIndex+offset];
                        if (!item) continue;
                        var cursorIndex=dataIndex;
                        obj.Point.X=this.GetXFromIndex(cursorIndex);
                        obj.Point.Y=this.GetYFromData(item.Close);
                        obj.IndexData.CursorIndex=cursorIndex;
                        obj.IndexData.DayIndex=0;
                        obj.IndexData.DataIndex=dataIndex;
                        obj.IndexData.Type=dataItem.Type;
                        return true;
                    }
                    else if (dataItem.Type==2)
                    {
                        var item=dataItem.DayItem.Data[dataIndex];
                        if (!item) continue;
                        if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                        obj.Point.X=this.GetLeftExtendXFromIndex(dataIndex,dataItem.DayItem);
                        obj.Point.Y=this.GetLeftExtendYFromData(item.Price);
                        obj.IndexData.CursorIndex=-1;
                        obj.IndexData.DayIndex=0;
                        obj.IndexData.DataIndex=dataIndex;
                        obj.IndexData.Type=dataItem.Type;
                        return true;
                    }
                    else if (dataItem.Type==3)
                    {
                        var item=dataItem.DayItem.Data[dataIndex];
                        if (!item) continue;
                        if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                        obj.Point.X=this.GetRightExtendXFromIndex(dataIndex,dataItem.DayItem);
                        obj.Point.Y=this.GetRightExtendYFromData(item.Price);
                        obj.IndexData.CursorIndex=-1;
                        obj.IndexData.DayIndex=0;
                        obj.IndexData.DataIndex=dataIndex;
                        obj.IndexData.Type=dataItem.Type;
                        return true;
                    }
                }
                
                dataIndex=null;
            }
        }
    }

    this.MoveXIndexRight=function(step, obj)
    {
        JSConsole.Chart.Log("[MinuteFrame::MoveXIndexRight] obj ", obj);
        if (obj.DataType==2)  //多日数据
        {
            var dayIndex=obj.IndexData.DayIndex;
            var dataIndex=obj.IndexData.DataIndex+step;
            var itemIndex=-1;
            if (obj.IndexData.Type==20) itemIndex=0;
            else if (obj.IndexData.Type==10) itemIndex=1;
            else if (obj.IndexData.Type==30) itemIndex=2;
            else return false;

            for(var i=dayIndex, j=itemIndex; i<obj.Data.length; ++i)
            {
                var dayItem=obj.Data[i];
                for(; j<3; ++j)
                {
                    var dataItem=dayItem[j];
                    if (!dataItem.DayItem || !dataItem.DayItem.Data) continue;

                    if (dataIndex==null) dataIndex=0;
                    for(; dataIndex<dataItem.DayItem.Data.length;++dataIndex)
                    {
                        var item=dataItem.DayItem.Data[dataIndex];
                        if (!item) continue;
                        if (dataItem.Type==10)
                        {
                            var cursorIndex=this.MinuteCount*i+dataIndex;
                            obj.Point.X=this.GetXFromIndex(cursorIndex);
                            obj.Point.Y=this.GetYFromData(item.Close);
                            obj.IndexData.CursorIndex=cursorIndex;
                            obj.IndexData.DayIndex=i;
                            obj.IndexData.DataIndex=dataIndex;
                            obj.IndexData.Type=dataItem.Type;
                            return true;
                        }
                        else if (dataItem.Type==20)
                        {
                            if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                            obj.Point.X=this.GetLeftExtendXFromIndex(dataIndex,dataItem.DayItem);
                            obj.Point.Y=this.GetLeftExtendYFromData(item.Price);
                            obj.IndexData.CursorIndex=-1;
                            obj.IndexData.DayIndex=i;
                            obj.IndexData.DataIndex=dataIndex;
                            obj.IndexData.Type=dataItem.Type;
                            return true;
                        }
                        else if (dataItem.Type==30)
                        {
                            if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                            obj.Point.X=this.GetRightExtendXFromIndex(dataIndex,dataItem.DayItem);
                            obj.Point.Y=this.GetRightExtendYFromData(item.Price);
                            obj.IndexData.CursorIndex=-1;
                            obj.IndexData.DayIndex=i;
                            obj.IndexData.DataIndex=dataIndex;
                            obj.IndexData.Type=dataItem.Type;
                            return true;
                        }
                    }
                    
                    dataIndex=null;
                }

                j=0;
            }


            return false;
        }
        else if (obj.DataType==1)   //单日
        {
            var dayIndex=obj.IndexData.DayIndex;
            var dataIndex=obj.IndexData.DataIndex+step;
            var itemIndex=-1;
            if (obj.IndexData.Type==2) itemIndex=0;
            else if (obj.IndexData.Type==1) itemIndex=1;
            else if (obj.IndexData.Type==3) itemIndex=2;
            else return false;

            for(var i=itemIndex; i<obj.Data.length; ++i)
            {
                var dataItem=obj.Data[i];
                if (!dataItem.DayItem || !dataItem.DayItem.Data) continue;

                if (dataIndex==null) dataIndex=0;
                for(; dataIndex<dataItem.DayItem.Data.length;++dataIndex)
                {
                    if (dataItem.Type==1)
                    {
                        if (dataIndex>=this.XPointCount) break;
                        var offset=dataItem.DayItem.DataOffset;
                        var item=dataItem.DayItem.Data[dataIndex+offset];
                        if (!item) continue;
                        var cursorIndex=dataIndex;
                        obj.Point.X=this.GetXFromIndex(cursorIndex);
                        obj.Point.Y=this.GetYFromData(item.Close);
                        obj.IndexData.CursorIndex=cursorIndex;
                        obj.IndexData.DayIndex=0;
                        obj.IndexData.DataIndex=dataIndex;
                        obj.IndexData.Type=dataItem.Type;
                        return true;
                    }
                    else if (dataItem.Type==2)
                    {
                        var item=dataItem.DayItem.Data[dataIndex];
                        if (!item) continue;
                        if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                        obj.Point.X=this.GetLeftExtendXFromIndex(dataIndex,dataItem.DayItem);
                        obj.Point.Y=this.GetLeftExtendYFromData(item.Price);
                        obj.IndexData.CursorIndex=-1;
                        obj.IndexData.DayIndex=0;
                        obj.IndexData.DataIndex=dataIndex;
                        obj.IndexData.Type=dataItem.Type;
                        return true;
                    }
                    else if (dataItem.Type==3)
                    {
                        var item=dataItem.DayItem.Data[dataIndex];
                        if (!item) continue;
                        if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
                        obj.Point.X=this.GetRightExtendXFromIndex(dataIndex,dataItem.DayItem);
                        obj.Point.Y=this.GetRightExtendYFromData(item.Price);
                        obj.IndexData.CursorIndex=-1;
                        obj.IndexData.DayIndex=0;
                        obj.IndexData.DataIndex=dataIndex;
                        obj.IndexData.Type=dataItem.Type;
                        return true;
                    }
                }
                
                dataIndex=null;
            }
        }
    }

    //获取有效数据
    this.GetLeftExtendXValidData=function(x, obj)
    {
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder)
        {
            var indexData=this.GetLeftExtendXData(x, obj.Data);
            if (!indexData) return false;
            var index=parseInt(indexData.DataIndex.toFixed(0));
            var dayData=obj.Data[indexData.DayIndex];
            
            if (index>=0 && index<dayData.Data.length)
            {
                var item=dayData.Data[index];
                if (IFrameSplitOperator.IsNumber(item.Price)) 
                {
                    obj.IndexData.DataIndex=index;
                    return true;
                }
            }

            if (index<0) index=0;
            else if (index>=dayData.Data.length) index=dayData.Data.length-1;

            var findIndex=-1;
            for(var i=index; i>=0; --i)
            {
                var item=dayData.Data[i];
                if (item && IFrameSplitOperator.IsNumber(item.Price))
                {
                    findIndex=i;
                    break;
                }
            }
    
            if (findIndex<0) return false;
    
            obj.IndexData.DataIndex=findIndex;
            obj.IndexData.Point.X=this.GetLeftExtendXFromIndex(findIndex, dayData);  //调整X轴坐标

            JSConsole.Chart.Log(`[MinuteFrame::GetLeftExtendXValidData] DayIndex:${obj.IndexData.DayIndex}, Type:${obj.IndexData.Type}, x:${x}=>${obj.IndexData.Point.X}, index:${index}=>${findIndex}`);
            return true;
        }
        else
        {
            var index=this.GetLeftExtendXData(x, obj.Data);
            index=parseInt(index.toFixed(0));

            if (index>=0 && index<obj.Data.Data.length)
            {
                var item=obj.Data.Data[index];
                if (IFrameSplitOperator.IsNumber(item.Price)) 
                {
                    obj.IndexData.DataIndex=index;
                    return true;
                }
            }

            if (index<0) index=0;
            else if (index>=obj.Data.Data.length) index=obj.Data.Data.length-1;

            var findIndex=-1;
            for(var i=index; i>=0; --i)
            {
                var item=obj.Data.Data[i];
                if (IFrameSplitOperator.IsNumber(item.Price))
                {
                    findIndex=i;
                    break;
                }
            }

            if (findIndex<0)
            {
                for(var i=index+1; i<obj.Data.Data.length;++i)
                {
                    var item=obj.Data.Data[i];
                    if (IFrameSplitOperator.IsNumber(item.Price))
                    {
                        findIndex=i;
                        break;
                    }
                }
            }

            if (findIndex<0) return false;

            obj.IndexData.DataIndex=findIndex;
            obj.IndexData.Point.X=this.GetLeftExtendXFromIndex(findIndex, obj.Data);  //调整X轴坐标
            JSConsole.Chart.Log(`[MinuteFrame::GetLeftExtendXValidData] DayIndex:${obj.IndexData.DayIndex}, Type:${obj.IndexData.Type}, x:${x}=>${obj.IndexData.Point.X}, index:${index}=>${findIndex}`);
            return true;
        }
    }

    this.GetRightExtendXValidData=function(x, obj)
    {
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder)
        {
            var indexData=this.GetRightExtendXData(x, obj.Data);
            if (!indexData) return false;
            var index=parseInt(indexData.DataIndex.toFixed(0));
            var dayData=obj.Data[indexData.DayIndex];
            
            if (index>=0 && index<dayData.Data.length)
            {
                var item=dayData.Data[index];
                if (IFrameSplitOperator.IsNumber(item.Price)) 
                {
                    obj.IndexData.DataIndex=index;
                    return true;
                }
            }

            if (index<0) index=0;
            else if (index>=dayData.Data.length) index=dayData.Data.length-1;

            var findIndex=-1;
            for(var i=index; i>=0; --i)
            {
                var item=dayData.Data[i];
                if (item && IFrameSplitOperator.IsNumber(item.Price))
                {
                    findIndex=i;
                    break;
                }
            }
    
            if (findIndex<0) return false;
    
            obj.IndexData.DataIndex=findIndex;
            obj.IndexData.Point.X=this.GetRightExtendXFromIndex(findIndex, dayData);  //调整X轴坐标

            JSConsole.Chart.Log(`[MinuteFrame::GetRightExtendXValidData] DayIndex:${obj.IndexData.DayIndex}, Type:${obj.IndexData.Type}, x:${x}=>${obj.IndexData.Point.X}, index:${index}=>${findIndex}`);
            return true;
        }
        else
        {
            if (!obj || !obj.Data) return false;
            
            var index=this.GetRightExtendXData(x, obj.Data);
            index=parseInt(index.toFixed(0));

            if (index>=0 && index<obj.Data.Data.length)
            {
                var item=obj.Data.Data[index];
                if (IFrameSplitOperator.IsNumber(item.Price)) 
                {
                    obj.IndexData.DataIndex=index;
                    return true;
                }
            }

            if (index<0) index=0;
            else if (index>=obj.Data.Data.length) index=obj.Data.Data.length-1;

            var findIndex=-1;
            for(var i=index; i>=0; --i)
            {
                var item=obj.Data.Data[i];
                if (IFrameSplitOperator.IsNumber(item.Price))
                {
                    findIndex=i;
                    break;
                }
            }

            if (findIndex<0)
            {
                for(var i=index+1; i<obj.Data.Data.length;++i)
                {
                    var item=obj.Data.Data[i];
                    if (IFrameSplitOperator.IsNumber(item.Price))
                    {
                        findIndex=i;
                        break;
                    }
                }
            }

            if (findIndex<0) return false;

            obj.IndexData.DataIndex=findIndex;
            obj.IndexData.Point.X=this.GetRightExtendXFromIndex(findIndex, obj.Data);  //调整X轴坐标
            JSConsole.Chart.Log(`[MinuteFrame::GetRightExtendXValidData] DayIndex:${obj.IndexData.DayIndex}, Type:${obj.IndexData.Type}, x:${x}=>${obj.IndexData.Point.X}, index:${index}=>${findIndex}`);
            return true;
        }
    }
    
    this.GetLeftExtendYFromData=function(value,isLimit,obj)
    {
        if (!obj || !obj.Range) return this.GetYFromData(value,isLimit);

        var range=obj.Range;
        var border=this.ChartBorder.GetBorder();
        var height=border.BottomEx-border.TopEx;
        var offset=height*(value-range.Min)/(range.Max-range.Min);
        return border.BottomEx-offset;
    }

    this.GetLeftExtendYData=function(y, isLimit, obj)
    {
        if (!obj || !obj.Range) return this.GetYData(y,isLimit);

        var range=obj.Range;
        var border=this.ChartBorder.GetBorder();
        var height=border.BottomEx-border.TopEx;
        return (border.BottomEx-y)/height*(range.Max-range.Min)+range.Min;
    }

    this.GetRightExtendMultiDayXFromIndex=function(index, obj, border)
    {
        var dayBorder=border.DayBorder;
        var client=dayBorder[obj.Index];
        var count=obj.TotalCount-1;

        var left=client.RightEx;
        var right=client.Right;
        var width=right-left;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetRightExtendXFromIndex=function(index, obj)
    {
        var count=obj.TotalCount-1;

        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return this.GetRightExtendMultiDayXFromIndex(index, obj, border);

        var left=border.RightEx;
        var width=this.ChartBorder.RightExtendWidth;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetRightExtendYFromData=function(value,isLimit,obj)
    {
        return this.GetLeftExtendYFromData(value,isLimit,obj)
    }

    this.GetRightExtendYData=function(y, isLimit, obj)
    {
        if (!obj || !obj.Range) return this.GetYData(y,isLimit);

        return this.GetLeftExtendYData(y, isLimit, obj);
    }

    this.GetRightExtendMultiDayXData=function(x, obj, border)
    {
        var dayBorder=border.DayBorder;
        for(var i=0; i<dayBorder.length; ++i)
        {
            var client=dayBorder[i];
            if (x>=client.RightEx && x<=client.Right)
            {
                if (!obj[i]) return null;
                var count=obj[i].TotalCount-1;
                var left=client.RightEx;
                var right=client.Right;

                var width=right-left;
                var index=(x-left)*(count*1.0/width);

                return { DayIndex:parseInt(i), DataIndex:index };
            }
        }

        return null;
    }

    this.GetRightExtendXData=function(x, obj)
    {
        var border=this.ChartBorder.GetBorder();
        if (border.DayBorder) return this.GetRightExtendMultiDayXData(x, obj, border);

        var count=obj.TotalCount-1;
        if (count<0) count=0;

        var left=border.RightEx;
        var right=border.Right;

        if (x<=left) return 0;
        if (x>=right) return count;

        var width=right-left;
        return (x-left)*(count*1.0/width);
    }
}

//走势图 横屏框架
function MinuteHScreenFrame()
{
    this.newMethod=MinuteFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="MinuteHScreenFrame";
    this.IsHScreen=true;        //是否是横屏

    //画标题背景色
    this.DrawTitleBG=function()
    {
        if (this.ChartBorder.TitleHeight<=0) return;

        var border=this.ChartBorder.GetHScreenBorder();
        var left=ToFixedPoint(border.RightEx);
        var top=ToFixedPoint(border.Top);
        var bottom=ToFixedPoint(border.Bottom);
        var width=this.ChartBorder.TitleHeight;
        var height=bottom-top;

        this.Canvas.fillStyle=this.TitleBGColor;
        this.Canvas.fillRect(left,top,width,height);
    }

    this.DrawToolbar=function()
    {
        return;
    }

    //画集合竞价背景
    this.DrawBeforeDataBG=function()
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder)
        {
            this.DrawMultiDayBeforeDataBG(border);
            return;
        }

        if (this.ChartBorder.LeftExtendWidth<10 && this.ChartBorder.RightExtendWidth<10) return;
        
        var left=ToFixedPoint(border.Left);
        var right=ToFixedPoint(border.Right);
        this.Canvas.fillStyle=this.BeforeBGColor;
        
        if (this.ChartBorder.LeftExtendWidth>10)
        {
            var top=ToFixedPoint(border.Top);
            var bottom=ToFixedPoint(border.TopEx);
            var width=right-left;
            var height=bottom-top;
            
            this.Canvas.fillRect(left,top,width,height);
        }

        if (this.ChartBorder.RightExtendWidth>10)
        {
            var top=border.BottomEx;
            var bottom=border.Bottom;
            var width=right-left;
            var height=bottom-top;

            this.Canvas.fillRect(left,top,width,height);
        }
    }

    this.DrawMultiDayBeforeDataBG=function(border)
    {
        var dayBorder=border.DayBorder;
        var left=ToFixedPoint(border.Left);
        var right=ToFixedPoint(border.Right);
        var width=right-left;
        
        this.Canvas.strokeStyle=this.MultiDayBorderPen;
        for(var i=0; i<dayBorder.length; ++i)
        {
            var drawCount=0;
            var item=dayBorder[i];
            var top=ToFixedPoint(item.Top);
            var bottom=ToFixedPoint(item.TopEx);
            var height=bottom-top;
            if (height>3)    //盘前
            {
                this.Canvas.fillStyle=this.BeforeBGColor;
                this.Canvas.fillRect(left,top,width,height);    
                ++drawCount;
            }

            var top=ToFixedPoint(item.BottomEx);
            var bottom=ToFixedPoint(item.Bottom);
            var height=bottom-top;
            if (height>3)    //盘后
            {
                this.Canvas.fillStyle=this.AfterBGColor;
                this.Canvas.fillRect(left,top,width,height);
                ++drawCount;
            }

            if (drawCount==2 && i!=dayBorder.length-1)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(left,bottom);
                this.Canvas.lineTo(right,bottom);
                this.Canvas.stroke();
            }
        }
    }

    //Y坐标转y轴数值
    this.GetYData=function(x)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if (x<border.LeftEx) return this.HorizontalMin;
		if (x>border.RightEx) return this.HorizontalMax;

        var width=border.RightEx-border.LeftEx;
		return (x-border.LeftEx)/width*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
    }

    this.GetMultiDayXData=function(y,border)
    {
        var dayBorder=border.DayBorder;
        for(var i=0;i<dayBorder.length;++i)
        {
            var client=dayBorder[i];
            if (y>=client.Top && y<=client.Bottom)
            {
                var count=this.MinuteCount-1;
                var dayMinuteCount=this.MinuteCount*i;
                if (y<=client.TopEx) return 0+dayMinuteCount;
                if (y>=client.BottomEx) return count+dayMinuteCount;

                var width=client.BottomEx-client.TopEx;
                return (y-client.TopEx)*(count*1.0/width)+dayMinuteCount;
            }
        }
    }

    //X坐标转x轴数值
    this.GetXData=function(y)
    {
        var count=this.XPointCount-1;
        if (count<0) count=0;

        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder) return this.GetMultiDayXData(y, border);

        if (y<=border.TopEx) return 0;
		if (y>=border.BottomEx) return count;

        var height=(border.BottomEx-border.TopEx);
		return (y-border.TopEx)*(count*1.0/height);
    }

    this.GetMultiDayXFromIndex=function(index, border)
    {
        var dayBorder=border.DayBorder;
        var minuteIndex=index%this.MinuteCount;
        var dayIndex=parseInt(index/this.MinuteCount);
        if (dayIndex>=dayBorder.length) dayIndex=dayBorder.length-1;

        var client=dayBorder[dayIndex];
        var count=this.MinuteCount-1;

        if (minuteIndex>=count) 
        {
            return client.BottomEx;
        }
        else
        {
            var width=(client.BottomEx-client.TopEx);
            var offset=client.TopEx+width*minuteIndex/count;
            return offset;
        }
    }

    this.GetXFromIndex=function(index)
    {
        var count=this.XPointCount-1;
        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder) return this.GetMultiDayXFromIndex(index, border);

        if (count==1)
        {
            if (index==0) return border.TopEx;
            else return border.BottomEx;
        }
        else if (count<=0)
        {
            return border.TopEx;
        }
        else if (index>=count)
        {
            return border.BottomEx;
        }
        else
        {
            var height=border.BottomEx-border.TopEx;
            var offset=border.TopEx+height*index/count;
            return offset;
        }
    }
    
    this.GetYFromData=function(value)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if(value<=this.HorizontalMin) return border.LeftEx;
        if(value>=this.HorizontalMax) return border.RightEx;

        var width=(border.RightEx-border.LeftEx)*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
        return border.LeftEx+width;
    }

    this.DrawVolTitle=function(symbol)
    {
        if (!MARKET_SUFFIX_NAME.IsShowMinuteVolTitle(symbol)) return;

        if (this.Identify==1)   //显示"成交量"
        {
            var pixelRatio=GetDevicePixelRatio();
            var left=this.ChartBorder.GetRight()-2*pixelRatio;
            var top=this.ChartBorder.GetTopEx()+2*pixelRatio;

            var xText=left,yText=top;
            this.Canvas.save();
            this.Canvas.translate(xText, yText);
            this.Canvas.rotate(90 * Math.PI / 180);

            var x=this.YInsideOffset,y=0;
            this.Canvas.textAlign='left';
            this.Canvas.textBaseline='top';
            if (g_JSChartResource.Minute.VolBarColor || g_JSChartResource.Minute.VolTitleColor)
            {
                if (g_JSChartResource.Minute.VolBarColor) this.Canvas.fillStyle=g_JSChartResource.Minute.VolBarColor
                else this.Canvas.fillStyle=g_JSChartResource.Minute.VolTitleColor;
                var languageID=this.YSplitOperator.LanguageID;
                var text=g_JSChartLocalization.GetText('MVol-Vol',languageID);
                this.Canvas.fillText(text,x,y);
                x+=this.Canvas.measureText(text).width;
                x+=6*GetDevicePixelRatio();
            }
            
            if (this.IsShowPositionTitle)
            {
                text=g_JSChartLocalization.GetText('MVol-Position',languageID);
                this.Canvas.fillStyle=g_JSChartResource.Minute.PositionColor;
                this.Canvas.fillText(text,x,y);
            }

            this.Canvas.restore();
        }
    }

    //画Y轴
    this.DrawHorizontal=function()
    {
        var border=this.ChartBorder.GetHScreenBorder();

        var top=border.Top;
        var bottom=border.Bottom;
        var left=border.Left;
        var right=border.Right;
        var borderTop=this.ChartBorder.Top;
        var borderBottom=this.ChartBorder.Bottom;

        var yPrev=null; //上一个坐标y的值
        for(var i=this.HorizontalInfo.length-1; i>=0; --i)  //从左往右画分割线
        {
            var item=this.HorizontalInfo[i];
            var y=this.GetYFromData(item.Value);
            if (y!=null && Math.abs(y-yPrev)<this.MinYDistance) continue;  //两个坐标在近了 就不画了

            this.Canvas.strokeStyle=item.LineColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(y),top);
            this.Canvas.lineTo(ToFixedPoint(y),bottom);
            this.Canvas.stroke();

            if (y >= right - 2) 
            {
                this.Canvas.textBaseline = 'top';
                y = right;
            }
            else if (y <= left + 2) 
            {
                this.Canvas.textBaseline = 'bottom';
                y=left;
                if (y != null && Math.abs(y - yPrev) < 2*this.MinYDistance) continue;  //两个坐标在近了 就不画了
            }
            else 
            {
                this.Canvas.textBaseline = "middle";
            }

            //坐标信息 左边 间距小于10 不画坐标
            if (item.Message[0]!=null && borderTop>10)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.textAlign="right";

                var xText=y,yText=top;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(item.Message[0], -2, 0);
                this.Canvas.restore();
            }

            //坐标信息 右边 间距小于10 不画坐标
            if (item.Message[1]!=null && borderBottom>10)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.textAlign="left";
               
                var xText=y,yText=bottom;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(item.Message[1], 2, 0);
                this.Canvas.restore();
            }

            yPrev=y;
        }
    }

    this.DrawInsideClientHorizontal=function()
    {
        var border=this.GetBorder();
        var left=border.Left;
        var right=border.Right;
        var bottom=border.BottomEx;
        var top=border.TopEx;

        var pixelTatio = GetDevicePixelRatio();
        var yPrev = null; //上一个坐标y的值
        var yInsideText=null;
        for (var i = this.HorizontalInfo.length - 1; i >= 0; --i)  //从上往下画分割线
        {
            var item = this.HorizontalInfo[i];
            if (!item || !item.Message[2] || !item.Message[3]) continue;
            var y = this.GetYFromData(item.Value);
            if (y != null && yPrev!=null && Math.abs(y - yPrev) < this.MinYDistance) continue;  //两个坐标在近了 就不画了

            if (y >= right - 2) 
            {
                this.Canvas.textBaseline = 'top';
                y = right;
            }
            else if (y <= left + 2) 
            {
                this.Canvas.textBaseline = 'bottom';
                y=left;
                if (y != null && Math.abs(y - yPrev) < 2*this.MinYDistance) continue;  //两个坐标在近了 就不画了
            }
            else 
            {
                this.Canvas.textBaseline = "middle";
            }

            if (item.Message[2]) 
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.fillStyle = item.TextColor;
                this.Canvas.textAlign = "left";

                var xText=y,yText=top;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(item.Message[2], 2, 0);
                this.Canvas.restore();
            }

            if (item.Message[3])
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.fillStyle = item.TextColor;
                this.Canvas.textAlign = "right";

                var xText=y,yText=bottom;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(item.Message[3], -2, 0);
                this.Canvas.restore();
                
            }
            yPrev = y;
        }
    }

    //画X轴
    this.DrawVertical=function()
    {
        var border=this.ChartBorder.GetHScreenBorder();
        var left=border.Left;
        var right=border.Right;
        var bottom=border.Bottom;

        var xPrev=null; //上一个坐标x的值
        for(var i in this.VerticalInfo)
        {
            var x=this.GetXFromIndex(this.VerticalInfo[i].Value);
            if (x>bottom) break;
            if (xPrev!=null && Math.abs(x-xPrev)<this.MinXDistance) continue;

            this.Canvas.strokeStyle=this.VerticalInfo[i].LineColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(left,ToFixedPoint(x));
            this.Canvas.lineTo(right,ToFixedPoint(x));
            this.Canvas.stroke();

            if (this.VerticalInfo[i].Message[0]!=null)
            {
                if (this.VerticalInfo[i].Font!=null)
                    this.Canvas.font=this.VerticalInfo[i].Font;

                this.Canvas.fillStyle=this.VerticalInfo[i].TextColor;
                var testWidth=this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
                if (x<testWidth/2)
                {
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="top";
                }
                else if ((x + testWidth / 2) >= this.ChartBorder.GetChartHeight())
                {
                    this.Canvas.textAlign = "right";
                    this.Canvas.textBaseline = "top";
                }
                else
                {
                    this.Canvas.textAlign="center";
                    this.Canvas.textBaseline="top";
                }

                var xText=left,yText=x;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(this.VerticalInfo[i].Message[0], 0, 0);
                this.Canvas.restore();
            }

            xPrev=x;
        }
    }

    //Y刻度画在左边内部
    this.DrawInsideHorizontal = function () 
    {
        if (this.IsMinSize) return;
        if (this.IsShowYText[0]===false && this.IsShowYText[1]===false) return;

        this.DrawInsideClientHorizontal();

        var border=this.ChartBorder.GetHScreenBorder();
        var left = border.Left;
        var right = border.RightEx;
        var top=border.Top;
        var bottom=border.Bottom;
        var borderTop=this.ChartBorder.Top;
        var borderBottom=this.ChartBorder.Bottom;
        var titleHeight = this.ChartBorder.TitleHeight;
        var pixelTatio = GetDevicePixelRatio();
        
        if ( (borderTop<10*pixelTatio && this.IsShowYText[0]===true) || (borderBottom<10*pixelTatio && this.IsShowYText[1]===true) )
        {
            var pixelTatio = GetDevicePixelRatio();
            var yPrev = null; //上一个坐标y的值
            var yInsideText=null;
            for (var i = this.HorizontalInfo.length - 1; i >= 0; --i)  //从上往下画分割线
            {
                var item = this.HorizontalInfo[i];
                var y = this.GetYFromData(item.Value);
                if (y != null && yPrev!=null && Math.abs(y - yPrev) < this.MinYDistance) continue;  //两个坐标在近了 就不画了

                //坐标信息 左边 间距小于10 画在内部
                if (item.Message[0] != null && borderTop < 10*pixelTatio && this.IsShowYText[0]===true) 
                {
                    if (item.Font != null) this.Canvas.font = item.Font;
                    this.Canvas.fillStyle = item.TextColor;
                    this.Canvas.textAlign = "left";
                    if (y >= right - 2) this.Canvas.textBaseline = 'top';
                    else if (y <= left + 2) this.Canvas.textBaseline = 'bottom';
                    else this.Canvas.textBaseline = "middle";

                    var textObj={ X:left, Y:y, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[0]}} ;
                    var xText=y,yText=top;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(item.Message[0], 2*pixelTatio, 0);
                    this.Canvas.restore();

                    if (yInsideText==null || yInsideText<xText)
                    {
                        this.YInsideOffset=this.Canvas.measureText(item.Message[0]).width+4*GetDevicePixelRatio();
                        yInsideText=xText;
                    }
                }

                if (item.Message[1] != null && borderBottom < 10*pixelTatio && this.IsShowYText[1]===true)
                {
                    if (item.Font != null) this.Canvas.font = item.Font;
                    this.Canvas.fillStyle = item.TextColor;
                    this.Canvas.textAlign = "right";
                    if (y >= right - 2) this.Canvas.textBaseline = 'top';
                    else if (y <= left + 2) this.Canvas.textBaseline = 'bottom';
                    else this.Canvas.textBaseline = "middle";
                    var textWidth = this.Canvas.measureText(item.Message[1]).width;
                    var textObj={ X:right-textWidth, Y:y, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[1]}} ;

                    var xText=y,yText=bottom;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(item.Message[1], -2*pixelTatio, 0);
                    this.Canvas.restore();
                }
                yPrev = y;
            }
        }
    }

    this.GetLeftExtendXFromIndex=function(index, obj)
    {
        var count=obj.TotalCount-1;

        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder) return this.GetLeftExtendMultiDayXFromIndex(index, obj, border);

        var left=border.Top;
        var width=this.ChartBorder.LeftExtendWidth;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetLeftExtendMultiDayXFromIndex=function(index, obj, border)
    {
        var dayBorder=border.DayBorder;
        var client=dayBorder[obj.Index];
        var count=obj.TotalCount-1;

        var left=client.Top;
        var right=client.TopEx;
        var width=right-left;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetLeftExtendMultiDayXData=function(y, obj, border)
    {
        var dayBorder=border.DayBorder;
        for(var i=0; i<dayBorder.length; ++i)
        {
            var client=dayBorder[i];
            if (y>=client.Top && y<=client.TopEx)
            {
                if (!obj[i]) return null;
                var count=obj[i].TotalCount-1;
                var left=client.Top;
                var right=client.TopEx;

                var width=right-left;
                var index=(y-left)*(count*1.0/width);

                return { DayIndex:parseInt(i), DataIndex:index };
            }
        }

        return null;
    }

    this.GetLeftExtendXData=function(y, obj)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder) return this.GetLeftExtendMultiDayXData(y, obj, border);

        var count=obj.TotalCount-1;
        if (count<0) count=0;

        
        var left=border.Top;
        var right=border.TopEx;

        if (y<=left) return 0;
        if (y>=right) return count;

        var width=right-left;
        return (y-left)*(count*1.0/width);
    }

    this.GetLeftExtendYFromData=function(value,isLimit,obj)
    {
        if (!obj || !obj.Range) return this.GetYFromData(value,isLimit);

        var range=obj.Range;
        var border=this.ChartBorder.GetHScreenBorder();
        var width=border.RightEx-border.LeftEx;
        var offset=width*(value-range.Min)/(range.Max-range.Min);
        return border.LeftEx+offset;
    }

    this.GetLeftExtendYData=function(x, isLimit, obj)
    {
        if (!obj || !obj.Range) return this.GetYData(y,isLimit);

        var range=obj.Range;
        var border=this.ChartBorder.GetHScreenBorder();
        var width=border.RightEx-border.LeftEx;
        return (x-border.LeftEx)/width*(range.Max-range.Min)+range.Min;
    }

    this.GetRightExtendMultiDayXFromIndex=function(index, obj, border)
    {
        var dayBorder=border.DayBorder;
        var client=dayBorder[obj.Index];
        var count=obj.TotalCount-1;

        var left=client.BottomEx;
        var right=client.Bottom;
        var width=right-left;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetRightExtendXFromIndex=function(index, obj)
    {
        var count=obj.TotalCount-1;

        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder) return this.GetRightExtendMultiDayXFromIndex(index, obj, border);

        var left=border.BottomEx;
        var width=this.ChartBorder.RightExtendWidth;

        var offset=left+width*index/count;
        return offset;
    }

    this.GetRightExtendMultiDayXData=function(y, obj, border)
    {
        var dayBorder=border.DayBorder;
        for(var i=0; i<dayBorder.length; ++i)
        {
            var client=dayBorder[i];
            if (y>=client.BottomEx && y<=client.Bottom)
            {
                if (!obj[i]) return null;
                var count=obj[i].TotalCount-1;
                var left=client.BottomEx;
                var right=client.Bottom;

                var width=right-left;
                var index=(y-left)*(count*1.0/width);

                return { DayIndex:parseInt(i), DataIndex:index };
            }
        }

        return null;
    }

    this.GetRightExtendXData=function(y, obj)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if (border.DayBorder) return this.GetRightExtendMultiDayXData(y, obj, border);

        var count=obj.TotalCount-1;
        if (count<0) count=0;
       
        var left=border.BottomEx;
        var right=border.Bottom;

        if (y<=left) return 0;
        if (y>=right) return count;

        var width=right-left;
        return (y-left)*(count*1.0/width);
    }

    this.GetRightExtendYFromData=function(value,isLimit,obj)
    {
        if (!obj || !obj.Range) return this.GetYFromData(value,isLimit);

        return this.GetLeftExtendYFromData(value,isLimit,obj);
    }

    this.DrawNightDayBG=function()
    {
        if (this.DayCount!=1) return;
        if (!this.HQChart) return;
        if (!this.HQChart.EnableNightDayBG) return;

        var symbol=this.HQChart.Symbol;
        if (!symbol) return;

        var xIndex=-1;
        //获取夜盘和日期的分界线X索引位置
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_MINUTE_NIGHT_DAY_X_INDEX)
        if (!event || !event.Callback) return;

        var sendData={ Symbol:symbol, XIndex:xIndex, MinuteTimeStringData:g_MinuteTimeStringData };
        event.Callback(event,sendData,this);
        xIndex=sendData.XIndex;
        if (xIndex<0) return;

        var border=this.ChartBorder.GetHScreenBorder();
        var y=this.GetXFromIndex(xIndex);

        var rtNight={ Left: border.Left, Top:border.Top, Right:border.RightEx, Bottom:y };
        rtNight.Width=rtNight.Right-rtNight.Left;
        rtNight.Height=rtNight.Bottom-rtNight.Top;

        this.Canvas.fillStyle = this.NightDayConfig.NightBGColor;
        this.Canvas.fillRect(rtNight.Left, rtNight.Top, rtNight.Width, rtNight.Height);

        if (this.Identify!=0) return;

        //显示 日盘夜盘文字
        this.Canvas.font=this.NightDayConfig.Font;
		this.Canvas.textBaseline = "bottom";
		this.Canvas.textAlign = 'left';
		var aryTitle=[{ Title:"夜盘", Position:1, Config:this.NightDayConfig.Night }, { Title:"日盘", Position:0,Config:this.NightDayConfig.Day }];
		var textHeight= this.Canvas.measureText("擎").width;
		for(var i=0;i<aryTitle.length;++i)
		{
			var item=aryTitle[i];
            var text=g_JSChartLocalization.GetText(item.Title,this.HQChart.LanguageID);
			var testWidth = this.Canvas.measureText(text).width;
			var rtItem=
			{ 
				Height:testWidth+item.Config.Margin.Left+item.Config.Margin.Right, 
				Width:textHeight+item.Config.Margin.Top+item.Config.Margin.Bottom,
				Left:border.Left
			};
			rtItem.Right=rtItem.Left+rtItem.Width;

			if (item.Position===1) 
			{
				rtItem.Bottom=y-1;
				rtItem.Top=rtItem.Bottom-rtItem.Height;
			}
			else 
			{
				rtItem.Top=y+1;
				rtItem.Bottom=rtItem.Top+rtItem.Height;
			}

			if (item.Config.BGColor)
			{
				this.Canvas.fillStyle = item.Config.BGColor;
				this.Canvas.fillRect(rtItem.Left, rtItem.Top, rtItem.Width, rtItem.Height);
			}

			if (item.Config.BorderColor)
			{
				this.Canvas.strokeStyle = item.Config.BorderColor;
				this.Canvas.strokeRect(ToFixedPoint(rtItem.Left), ToFixedPoint(rtItem.Top), ToFixedRect(rtItem.Width), ToFixedRect(rtItem.Height));
			}

			this.Canvas.fillStyle = item.Config.Color;
            var xText=rtItem.Left;
            var yText=rtItem.Top;
            this.Canvas.save();
            this.Canvas.translate(xText,yText);
            this.Canvas.rotate(90 * Math.PI / 180);
			this.Canvas.fillText(text, item.Config.Margin.Left, -item.Config.Margin.Bottom);
            this.Canvas.restore();
		}
    }

}

function OverlayMinuteFrame()
{
    this.newMethod=MinuteFrame;     //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="OverlayMinuteFrame";
    this.IsShow=true;               //坐标是否显示
    this.IsShareY=false;            //使用和主框架公用Y轴
    this.IsCalculateYMaxMin=true;   //是否计算Y最大最小值
    this.IsShowMainFrame=0;         //是否显示在主框架坐标上 1=左边 2=右边

    this.Draw=function()
    {
        this.SplitXYCoordinate();
        if (this.IsShow)
        {

        }

        this.SizeChange=false;
        this.XYSplit=false;
        this.XSplit=false;
        this.YCustomSplit=false;            //自定义Y轴分割线
    }

    this.DrawToolbar=function()
    {
        return;
    }

    this.GetScaleTextWidth=function()
    {
        return { TextWidth:0 };
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) return;

        if (this.IsShareY)  //和主图指标共享Y轴坐标
        {
            this.HorizontalMax=this.MainFrame.HorizontalMax;
            this.HorizontalMin=this.MainFrame.HorizontalMin;
            this.HorizontalInfo=[];
            for(var i=0; i<this.MainFrame.HorizontalInfo.length; ++i)
            {
                var item=this.MainFrame.HorizontalInfo[i];
                this.HorizontalInfo.push(item);
            }
        }
        else    //独立Y轴坐标
        {
            if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
        }

        // if (this.XSplitOperator!=null) this.XSplitOperator.Operator(); 子坐标和主坐标X轴一致 所以不用计算
    }
}

function OverlayMinuteHScreenFrame()
{
    this.newMethod=MinuteHScreenFrame;     //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="OverlayMinuteHScreenFrame";
    this.IsShow=true;                   //坐标是否显示

    this.Draw=function()
    {
        this.SplitXYCoordinate();
        if (this.IsShow)
        {

        }

        this.SizeChange=false;
        this.XYSplit=false;
        this.XSplit=false;
        this.YCustomSplit=false;            //自定义Y轴分割线
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) return;

        if (this.IsShareY)  //和主图指标共享Y轴坐标
        {
            this.HorizontalMax=this.MainFrame.HorizontalMax;
            this.HorizontalMin=this.MainFrame.HorizontalMin;
            this.HorizontalInfo=[];
            for(var i in this.MainFrame.HorizontalInfo)
            {
                var item=this.MainFrame.HorizontalInfo[i];
                this.HorizontalInfo.push(item);
            }
        }
        else    //独立Y轴坐标
        {
            if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
        }
        
        // if (this.XSplitOperator!=null) this.XSplitOperator.Operator(); 子坐标和主坐标X轴一致 所以不用计算
    }
}

//K线框架
function KLineFrame()
{
    this.newMethod=AverageWidthFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='KLineFrame';
    this.ToolbarID=Guid();  //工具条Div id

    this.ModifyIndex=g_JSChartResource.KLineToolbar.ModifyIndex;      //是否显示'改参数'菜单
    this.ChangeIndex=g_JSChartResource.KLineToolbar.ChangeIndex;      //是否显示'换指标'菜单
    this.CloseIndex=g_JSChartResource.KLineToolbar.CloseIndex;       //是否显示'关闭指标窗口'菜单
    this.OverlayIndex=g_JSChartResource.KLineToolbar.OverlayIndex;    //是否显示叠加指标
    this.MaxMinWindow=g_JSChartResource.KLineToolbar.MaxMinWindow;
    this.TitleWindow=g_JSChartResource.KLineToolbar.TitleWindow;
    this.ExportData=g_JSChartResource.KLineToolbar.ExportData;      //是否显示'导出数据'菜单

    this.SelBorderColor=g_JSChartResource.SelFrameBorderColor;

    this.ModifyIndexEvent;   //改参数 点击事件
    this.ChangeIndexEvent;   //换指标 点击事件
    this.ToolbarRect=null;   //保存工具条的位置
    this.ReDrawToolbar=false;

    this.LastCalculateStatus={ Width:0, XPointCount:0 };    //最后一次计算宽度的状态

    this.CustomHorizontalInfo=[];   //定制Y轴刻度
    this.IsDrawTitleBG=false;
    this.IsShowNameArrow=false;

    this.CustomVerticalInfo=[];     //定制X轴刻度 Type:0,  Date:, Time: ,        Line:{ Color:线段颜色, Type:线段类型 0 直线 1 虚线 }
                                    //           Type:1,  Space: 第几个空白间距,  Line:{ Color:线段颜色, Type:线段类型 0 直线 1 虚线 }
    this.DrawCustomVerticalEvent;
    this.RightSpaceCount=0;

    this.Logarithmic=null; //{Up:上部 , Donw:下部 , OpenPrice:第一个开盘价}

    this.CustomToolbar=[];  //自定义toolbar按钮 { ID:, Html:, Click }  2.0版本 { ID, Style:{ 见 g_JSChartResource.Buttons.CloseWindow}}

    this.ToolbarType=0;

    this.DrawToolbar=function()
    {
        if (this.ToolbarButtonStyle==1) return;
        if (g_JSChartResource.IsDOMFrameToolbar===true) return;

        if (typeof($)=="undefined") return;
        
        if (!this.ChartBorder.UIElement || !this.ChartBorder.UIElement.parentNode) return;

        var divToolbar=document.getElementById(this.ToolbarID);
        if (divToolbar && this.SizeChange==false && this.ReDrawToolbar==false)  return;

        if (!divToolbar)
        {
            
            divToolbar=document.createElement("div");
            divToolbar.className='klineframe-toolbar';
            divToolbar.id=this.ToolbarID;
            divToolbar.oncontextmenu = function() { return false;}; //屏蔽右键系统菜单
            //为divToolbar添加属性identify
            divToolbar.setAttribute("identify",this.Identify.toString());
            this.ChartBorder.UIElement.parentNode.appendChild(divToolbar);
        }

        if (!this.ModifyIndex && !this.ChangeIndex && !this.OverlayIndex && !this.CloseIndex && !IFrameSplitOperator.IsNonEmptyArray(this.CustomToolbar))
        {
            if (divToolbar.style.display!='none')
                divToolbar.style.display='none';
            return;
        }

        //使用外城div尺寸 画图尺寸是被放大的
        var pixelTatio = GetDevicePixelRatio();
        var chartWidth=parseInt(this.ChartBorder.UIElement.parentElement.style.width.replace("px",""));  
        var chartHeight=parseInt(this.ChartBorder.UIElement.parentElement.style.height.replace("px",""));
        //JSConsole.Chart.Log('[KLineFrame::DrawToolbar] ',chartWidth,chartHeight,pixelTatio);

        var toolbarWidth=100;
        var toolbarHeight=this.ChartBorder.GetTitleHeight();
        var left=chartWidth-(this.ChartBorder.Right/pixelTatio)-toolbarWidth;
        var top=this.ChartBorder.GetTop()/pixelTatio;

        if (this.ToolbarRect)
        {
            //尺寸变动移动才重新设置DOM
            if (this.ToolbarRect.Left==left && this.ToolbarRect.Top==top && 
                this.ToolbarRect.Width==toolbarWidth && this.ToolbarRect.Height==toolbarHeight/pixelTatio)
            {
                return;
            }
        }

        this.ToolbarRect={ Left:left, Top:top, Width:toolbarWidth, Height:toolbarHeight/pixelTatio };

        const modifyButton=`<span class='index_param icon iconfont icon-index_param' id='modifyindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='调整指标参数'></span>`;
        const changeButton=`<span class='index_change icon iconfont icon-change_index' id='changeindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='切换指标'></span>`;
        const overlayButton=`<span class='index_overlay icon iconfont icon-overlay_index' id='overlayindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='叠加指标'></span>`;
        const closeButton=`<span class='index_close icon iconfont icon-close' id='closeindex' style='cursor:pointer;margin-left:2px;margin-right:2px;' title='关闭指标窗口'></span>`;

        var spanIcon=modifyButton+changeButton+overlayButton;

        if (this.Identify!==0 && this.CloseIndex)  //第1个窗口不能关闭
        {
            spanIcon+=closeButton;
        }

        if (IFrameSplitOperator.IsNonEmptyArray(this.CustomToolbar))
        {
            for(var i=0;i<this.CustomToolbar.length;++i)
            {
                var item=this.CustomToolbar[i];
                spanIcon+=item.Html;
            }
        }

        //var scrollPos=GetScrollPosition();
        //left = left+scrollPos.Left;
        //top = top+scrollPos.Top;
        divToolbar.style.left = left + "px";
        divToolbar.style.top = top + "px";
        divToolbar.style.width=toolbarWidth+"px";                   //宽度先不调整吧
        divToolbar.style.height=(toolbarHeight/pixelTatio)+'px';    //只调整高度
        divToolbar.innerHTML=spanIcon;

        var chart=this.ChartBorder.UIElement.JSChartContainer;
        var identify=this.Identify;
        if (!this.ModifyIndex)  //隐藏'改参数'
            $("#"+divToolbar.id+" .index_param").hide();
        else if (typeof(this.ModifyIndexEvent)=='function')  //绑定点击事件
            $("#"+divToolbar.id+" .index_param").click(
                {
                    Chart:this.ChartBorder.UIElement.JSChartContainer,
                    Identify:this.Identify
                },this.ModifyIndexEvent);

        if (!this.ChangeIndex)  //隐藏'换指标'
        {
            $("#"+divToolbar.id+" .index_change").hide();
        }  
        else if (typeof(this.ChangeIndexEvent)=='function')
        {
            $("#"+divToolbar.id+" .index_change").click(
                {
                    Chart:this.ChartBorder.UIElement.JSChartContainer,
                    Identify:this.Identify,
                    IsOverlay:false
                },this.ChangeIndexEvent);
        }

        if (!this.OverlayIndex)
        {
            $("#"+divToolbar.id+" .index_overlay").hide();
        }
        else
        {
            $("#"+divToolbar.id+" .index_overlay").click(
                {
                    Chart:this.ChartBorder.UIElement.JSChartContainer,
                    Identify:this.Identify,
                    IsOverlay:true
                },this.ChangeIndexEvent);
        }
        
        $("#"+divToolbar.id+" .index_close").click(
            {
                Chart:this.ChartBorder.UIElement.JSChartContainer,
                Identify:this.Identify
            },
            function(event)
            {
                var hqChart=event.data.Chart;
                var id=event.data.Identify;
                hqChart.RemoveIndexWindow(id);
            });


        if (IFrameSplitOperator.IsNonEmptyArray(this.CustomToolbar))
        {
            for(var i=0;i<this.CustomToolbar.length;++i)
            {
                var item=this.CustomToolbar[i];
                $("#"+item.ID).click(
                {
                    Chart:this.ChartBorder.UIElement.JSChartContainer,
                    Identify:this.Identify,
                    ID:item.ID
                },item.Click);
            }
        }

        divToolbar.style.display = "block";
    }

    //手绘,不用DOM,使用DOM太麻烦了
    this.DrawToolbarV2=function(moveonPoint, mouseStatus)
    {
        if (g_JSChartResource.IsDOMFrameToolbar===true) return;

        this.Buttons=[];
        this.LeftButtonWidth=0;
        if (this.IsMinSize==true) return;
        if (this.ChartBorder.TitleHeight<5) return;

        var aryButton=[];
        //第1个窗口不能关闭
        if (this.CloseIndex && this.Identify!==0)  aryButton.push( { ID:JSCHART_BUTTON_ID.CLOSE_INDEX_WINDOW, Style:this.CloseWindowButton });
        if (this.MaxMinWindow && this.Identify!=0) aryButton.push({ ID:JSCHART_BUTTON_ID.MAX_MIN_WINDOW, Style:this.MaxMinWindowButton });
        if (this.TitleWindow && this.Identify!=0) aryButton.push({ ID:JSCHART_BUTTON_ID.TITLE_WINDOW, Style:this.TitleWindowButton });
        if (this.ExportData) aryButton.push( {ID:JSCHART_BUTTON_ID.EXPORT_DATA, Style:this.ExportDataButton});
        if (this.OverlayIndex) aryButton.push( { ID:JSCHART_BUTTON_ID.OVERLAY_INDEX, Style:this.OverlayIndexButton });
        if (this.ChangeIndex) aryButton.push( { ID:JSCHART_BUTTON_ID.CHANGE_INDEX, Style:this.ChangeIndexButton });
        if (this.ModifyIndex) aryButton.push( { ID:JSCHART_BUTTON_ID.MODIFY_INDEX_PARAM, Style:this.ModifyIndexParamButton });

        if (IFrameSplitOperator.IsNonEmptyArray(this.CustomToolbar))
        {
            for(var i=0;i<this.CustomToolbar.length;++i)
            {
                var item=this.CustomToolbar[i];
                if (item.ID && item.Style) 
                {
                    var btnItem={ ID:item.ID, Style:item.Style, TooltipText:item.TooltipText, Data:item.Data };
                    
                    if (item.IsLeft===true) //左侧按钮
                    { 

                    }
                    else 
                    {
                        aryButton.push(btnItem); //右侧按钮
                    }   
                }
            }
        }

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_RIGHT_TOOLBAR);
            if (event && event.Callback)
            {
                var sendData={ PreventDefault:false, DefaultButton:aryButton, AryButton:null, FrameID:this.Identify };
                /*
                if (option)
                {
                    if (option.Overlay) sendData.Title=option.Overlay.Title;
                    if (option.OverlayID) sendData.OverlayID=option.OverlayID;
                }
                */
                event.Callback(event, sendData, this);
                if (sendData.PreventDefault) 
                {
                    this.DrawTitleButton(sendData.AryButton,moveonPoint, mouseStatus);
                    return;
                }
            }
        }


        this.DrawTitleButton(aryButton,moveonPoint, mouseStatus);
    }

    this.GetLeftToolbar=function(option)
    {
        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_LEFT_TOOLBAR);
            if (event && event.Callback)
            {
                var sendData={ PreventDefault:false, AryButton:null, FrameID:this.Identify };
                if (option)
                {
                    if (option.Overlay) sendData.Title=option.Overlay.Title;
                    if (option.OverlayID) sendData.OverlayID=option.OverlayID;
                }
                event.Callback(event, sendData, this);
                if (sendData.PreventDefault) return sendData.AryButton;
            }
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(this.CustomToolbar)) return null;

        var aryLeftButton=[];   //左侧按钮
        for(var i=0;i<this.CustomToolbar.length;++i)
        {
            var item=this.CustomToolbar[i];
            if (item.ID && item.Style) 
            {
                var btnItem={ ID:item.ID, Style:item.Style, TooltipText:item.TooltipText, Data:item.Data };
                if (item.IsLeft===true) aryLeftButton.push(btnItem);     //左侧按钮
            }
        }
        
        return aryLeftButton;
    }

    this.DrawFrame=function()
    {
        if (!this.IsMinSize)
        {
            this.SplitXYCoordinate();

            if (this.SizeChange==true) 
            {
                this.CalculateDataWidth();
                if (this.Logarithmic) this.SplitLogarithmicXYCoordinate();
            }
    
            if (this.BeforeDrawXYCallback) this.BeforeDrawXYCallback(this);
    
            this.DrawTitleBG();
            this.DrawCustomHorizontalArea();    //Y轴背景区域 在刻度前面绘制
            this.DrawHorizontal();
            this.DrawVertical();
        }
        
        if (this.SizeChange==true || this.ReDrawToolbar==true) 
        {
            this.DrawToolbar();  //大小变动才画工具条
            this.ReDrawToolbar=false;
        }
    }

    //isLimit 是否限制在当前屏坐标下
    this.GetXFromIndex=function(index,isLimit)
    {
        if (isLimit===false)
        {
            if (index>=0)
            {
                var offset=this.ChartBorder.GetLeft()+g_JSChartResource.FrameLeftMargin+this.DistanceWidth/2+this.DataWidth/2;
                for(var i=1;i<=index;++i)
                {
                    offset+=this.DistanceWidth+this.DataWidth;
                }
            }
            else
            {
                var offset=(this.ChartBorder.GetLeft()+g_JSChartResource.FrameLeftMargin)-(this.DistanceWidth/2+this.DataWidth+this.DistanceWidth);
                var absIndex=Math.abs(index);
                for(var i=1;i<absIndex;++i)
                {
                    offset-=(this.DistanceWidth+this.DataWidth);
                }
            }
        }
        else
        {
            if (index < 0) index = 0;
            if (index > this.xPointCount - 1) index = this.xPointCount - 1;

            var offset=this.ChartBorder.GetLeft()+g_JSChartResource.FrameLeftMargin+this.DistanceWidth/2+this.DataWidth/2;
            for(var i=1;i<=index;++i)
            {
                offset+=this.DistanceWidth+this.DataWidth;
            }
        }

        return offset;
    }

    //X坐标转x轴数值 isLimit=是否限制在当前屏坐标下
    this.GetXData=function(x,isLimit)
    {
        var distanceWidth=this.DistanceWidth;
        var dataWidth=this.DataWidth;
        var left=this.ChartBorder.GetLeft()+g_JSChartResource.FrameLeftMargin;
        var maxDataCount=10000*50;
        if (isLimit==false)
        {
            if (x<this.ChartBorder.GetLeft())
            {
                var index=-1;
                var xPoint=this.ChartBorder.GetLeft()-(distanceWidth/2+dataWidth+distanceWidth);
                while(index>-maxDataCount)
                {
                    if (xPoint<=x) 
                        break;
                    xPoint-=(dataWidth+distanceWidth);
                    --index;
                }
    
                return index;
            }
            else
            {
                var index=0;
                var xPoint=left+distanceWidth/2+dataWidth+distanceWidth;
                while(index<maxDataCount)  //自己算x的数值
                {
                    if (xPoint>=x) break;
                    xPoint+=(dataWidth+distanceWidth);
                    ++index;
                }

                return index;
            }
        }
        else
        {
            if (x<=this.ChartBorder.GetLeft()) return 0;
            if (x>=this.ChartBorder.GetRight()) return this.XPointCount-1;
            
            var right=this.ChartBorder.GetRight()-g_JSChartResource.FrameRightMargin;
            var index=0;
            var xPoint=left+distanceWidth/2+dataWidth+distanceWidth;
            while(xPoint<right && index<maxDataCount && index+1<this.XPointCount)  //自己算x的数值
            {
                if (xPoint>=x) break;
                xPoint+=(dataWidth+distanceWidth);
                ++index;
            }

            //var test=(x-this.ChartBorder.GetLeft())*(this.XPointCount*1.0/this.ChartBorder.GetWidth());
            return index;
        }
    }

    //计算数据宽度
    this.CalculateDataWidth=function()
    {
        if (this.XPointCount<2) return;

        //JSConsole.Chart.Log(`[KLineFrame::CalculateDataWidth] ZoomIndex=${this.ZoomIndex}, XPointCount=${this.XPointCount}, DataWidth=${this.DataWidth}, DistanceWidth=${this.DistanceWidth}`);
        var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;

        if (this.ZoomIndex>=0 && this.LastCalculateStatus.Width==width && this.LastCalculateStatus.XPointCount==this.XPointCount) //宽度没变 尝试使用原来的柱子宽度
        {
            var caclWidth=(this.DistanceWidth/2+g_JSChartResource.FrameLeftMargin)+(this.DataWidth + this.DistanceWidth)*(this.XPointCount-1);
            var caclWidth2=(this.DataWidth + this.DistanceWidth) * this.XPointCount;
            if (this.DataWidth<2) 
            {
                if (caclWidth2<= width) //当前的柱子宽度够用 就不调整了
                    return;
            }
            else
            {
                if (caclWidth<= width) //当前的柱子宽度够用 就不调整了
                    return;
            }
        }

        this.LastCalculateStatus.Width=width;
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        for(var i=0;i<ZOOM_SEED.length;++i)
        {
            if((ZOOM_SEED[i][0] + ZOOM_SEED[i][1]) * this.XPointCount < width)
            {
                this.ZoomIndex=i;
                this.DataWidth = ZOOM_SEED[i][0];
                this.DistanceWidth = ZOOM_SEED[i][1];
                this.TrimKLineDataWidth(width);
                JSConsole.Chart.Log('[KLineFrame::CalculateDataWidth] ZOOM_SEED, DataWidth, DistanceWidth, XPointCount', ZOOM_SEED[this.ZoomIndex], this.DataWidth,this.DistanceWidth,this.XPointCount);
                return;
            }
        }

        //太多了 就平均分了
        this.ZoomIndex=ZOOM_SEED.length-1;
        this.DataWidth=width/this.XPointCount;
        this.DistanceWidth=0;
    }

    this.OnSize=function(obj)
    {
        var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;
        var xPointCount=0;
        var y=this.DistanceWidth/2+g_JSChartResource.FrameLeftMargin+(this.DataWidth+this.DistanceWidth);
        for(;y<width; y+=(this.DataWidth+this.DistanceWidth), ++xPointCount)
        {
            
        }

        obj.CurCount=this.XPointCount;
        obj.CalcCount=xPointCount;
        obj.DataWidth=this.DataWidth;
        obj.DistanceWidth=this.DistanceWidth;
        obj.Changed=false;

        this.LastCalculateStatus.Width=width;
        if (obj.CurCount==obj.CalcCount) return obj;

        this.XPointCount=xPointCount;
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        if (this.Data)
        {
            this.Data.DataOffset+=(obj.CurCount-obj.CalcCount);
            if (this.Data.DataOffset<0) this.Data.DataOffset=0;
            obj.Changed=true;
        }
        return obj;
    }

    this.SetDataWidth=function(dataWidth)
    {
        var zoomIndex=ZOOM_SEED.length-1;
        for(var i in ZOOM_SEED)
        {
            var item=ZOOM_SEED[i];
            if (item[0]<=dataWidth) 
            {
                zoomIndex=parseInt(i)-1;
                break;
            }
        }

        this.ZoomIndex=zoomIndex;
        this.DataWidth=ZOOM_SEED[this.ZoomIndex][0];
        this.DistanceWidth=ZOOM_SEED[this.ZoomIndex][1];
        var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;
        var xPointCount=0;
        var y=this.DistanceWidth/2+g_JSChartResource.FrameLeftMargin+(this.DataWidth+this.DistanceWidth);
        for(;y<=width; y+=(this.DataWidth+this.DistanceWidth), ++xPointCount) { }

        this.XPointCount=xPointCount;
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        this.LastCalculateStatus.Width=width;

        var obj={ XPointCount:this.XPointCount, DataWidth:this.DataWidth, DistanceWidth:this.DistanceWidth };
        return obj;
    }

    this.TrimKLineDataWidth=function(width)
    {
        var dataWidth=ZOOM_SEED[this.ZoomIndex][0];
        var distanceWidth=ZOOM_SEED[this.ZoomIndex][1];
        if (dataWidth==1 && distanceWidth==0) 
        {
            this.DataWidth=width/this.XPointCount;
            return;
        }

        while(true)
        {
            if((this.DistanceWidth + this.DataWidth) * this.XPointCount + this.DistanceWidth > width)
            {
                this.DistanceWidth -= 0.01;
                break;
            }
            this.DistanceWidth += 0.01;
        }
    }

    //当前坐标信息 是否覆盖最大 最小值输出
    this.IsOverlayMaxMin=function(obj) 
    {
        if (!this.ChartKLine) return false;
        if (!this.ChartKLine.Max || !this.ChartKLine.Min) return false;

        var textWidth=this.Canvas.measureText(obj.Text.Value).width+4;    //刻度文字宽度
        if (obj.Text.TextAlign==='right') obj.X-=textWidth;
        var max=this.ChartKLine.Max, min=this.ChartKLine.Min;
        var isOverlayMax=false, isOverlayMin=false;
        const textHeight=20;    //字体高度
        if (max.X>=obj.X && max.X<=obj.X+textWidth) //最大值X 坐标不在 刻度文字范围内
        {
            var y1=max.Y+textHeight, y2=max.Y-textHeight;
            if ( (y1>=obj.Y-textHeight && y1<=obj.Y+textHeight) || (y2>=obj.Y-textHeight && y2<=obj.Y+textHeight))
                isOverlayMax=true; 
        }

        if (isOverlayMax==true) return true;

        if (min.X>=obj.X && min.X<=obj.X+textWidth)
        {
            var y1=min.Y+textHeight, y2=min.Y-textHeight;
            if ( (y1>=obj.Y-textHeight && y1<=obj.Y+textHeight) || (y2>=obj.Y-textHeight && y2<=obj.Y+textHeight))
                isOverlayMin=true; 
        }

        return isOverlayMax || isOverlayMin;
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) 
        {
            if (this.XSplit)
            {
                if (this.XSplitOperator) this.XSplitOperator.Operator();
            }

            if (this.YCustomSplit)
            {
                 //计算自定义刻度
                if (this.YSplitOperator && this.YSplitOperator.CustomCoordinate)
                    this.YSplitOperator.CustomCoordinate();
            }
           
            return;
        }

        if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
        if (this.XSplitOperator!=null) this.XSplitOperator.Operator();
        if (this.Logarithmic) this.SplitLogarithmicXYCoordinate();
    }

    this.SplitLogarithmicXYCoordinate=function()
    {
        var up=this.Logarithmic.Up;
        var down=this.Logarithmic.Down;
        var logHeight=0;    //对数额外高度
        var count=0;
        var maxCount=Math.max(up.length, down.length);

        var aryLogHeight=[];
        for(var i=0;i<maxCount;++i)
        {
            aryLogHeight[i]=i*2;
        }

        for(var i=0, j=aryLogHeight.length-1; i<up.length; ++i,--j)
        {
            var item=up[i];
            item.LogHeight=aryLogHeight[j];
            logHeight+=item.LogHeight;
            ++count;
        }

        for(var i=0, j=aryLogHeight.length-1;i<down.length; ++i,--j)
        {
            var item=down[i];
            item.LogHeight=aryLogHeight[j];
            logHeight+=item.LogHeight;
            ++count;
        }

        var heightRate=2*GetDevicePixelRatio(); 
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();
        var height=(bottom-top);
        var perHeight=(height-logHeight*heightRate)/count;
        if (perHeight<0) 
        {
            perHeight=0;
            heightRate=height/logHeight;
        }

        if (this.CoordinateType==1) //反转坐标
        {
            var itemTop=top;
            for(var i=down.length-1;i>=0;--i)   //上部
            {
                var item=down[i];
                item.Height=perHeight+(heightRate*item.LogHeight);
                item.Top=itemTop;
                item.Bottom=item.Top+item.Height;
                itemTop=item.Bottom;
            }

            var itemBottom=bottom;
            for(var i=up.length-1;i>=0;--i) //下部
            {   
                var item=up[i];
                item.Height=perHeight+(heightRate*item.LogHeight)
                item.Bottom=itemBottom;
                item.Top=itemBottom-item.Height;
                itemBottom=item.Top;
            }
        }
        else
        {
            var itemTop=top;
            for(var i=up.length-1;i>=0;--i)
            {
                var item=up[i];
                item.Height=perHeight+(heightRate*item.LogHeight);
                item.Top=itemTop;
                item.Bottom=item.Top+item.Height;
                itemTop=item.Bottom;
            }
    
            var itemBottom=bottom;
            for(var i=down.length-1;i>=0;--i)
            {
                var item=down[i];
                item.Height=perHeight+(heightRate*item.LogHeight)
                item.Bottom=itemBottom;
                item.Top=itemBottom-item.Height;
                itemBottom=item.Top;
            }
        }
        JSConsole.Chart.Log("[KLineFrame::SplitLogarithmicXYCoordinate]", this.Logarithmic);
    }

    this.GetYLogarithmicFromData=function(value, isLimit)
    {
        if (this.CoordinateType==1)
        {
            if(value<=this.HorizontalMin) return this.ChartBorder.GetTopEx();
            if(value>=this.HorizontalMax) return this.ChartBorder.GetBottomEx();

            if (value>this.Logarithmic.OpenPrice)
            {
                var up=this.Logarithmic.Up;
                for(var i in up)
                {
                    var item=up[i];
                    if (value>=item.Start && value<=item.End)
                    {
                        var itemHeight=item.Bottom-item.Top;
                        var height=itemHeight*(value-item.Start)/(item.End-item.Start);
                        return item.Top+height;
                    }
                }
            }
            else
            {
                var down=this.Logarithmic.Down;
                for(var i in down)
                {
                    var item=down[i];
                    if (value>=item.Start && value<=item.End)
                    {
                        var itemHeight=item.Bottom-item.Top;
                        var height=itemHeight*(value-item.Start)/(item.End-item.Start);
                        return item.Top+height;
                    }
                }
            }
        }
        else
        {
            if(value<=this.HorizontalMin) return this.ChartBorder.GetBottomEx();
            if(value>=this.HorizontalMax) return this.ChartBorder.GetTopEx();

            if (value>this.Logarithmic.OpenPrice)
            {
                var up=this.Logarithmic.Up;
                for(var i in up)
                {
                    var item=up[i];
                    if (value>=item.Start && value<=item.End)
                    {
                        var itemHeight=item.Bottom-item.Top;
                        var height=itemHeight*(value-item.Start)/(item.End-item.Start);
                        return item.Bottom-height;
                    }
                }
            }
            else
            {
                var down=this.Logarithmic.Down;
                for(var i in down)
                {
                    var item=down[i];
                    if (value>=item.Start && value<=item.End)
                    {
                        var itemHeight=item.Bottom-item.Top;
                        var height=itemHeight*(value-item.Start)/(item.End-item.Start);
                        return item.Bottom-height;
                    }
                }
            }
        }
    }

    this.GetYLogarithmicData=function(y)
    {
        if (this.CoordinateType==1) //反转坐标
        {
            if (y<this.ChartBorder.GetTopEx()) return this.HorizontalMin;
            if (y>this.ChartBorder.GetBottomEx()) return this.HorizontalMax;

            var up=this.Logarithmic.Up;
            for(var i in up)
            {
                var item=up[i];
                if (y>=item.Top && y<=item.Bottom)
                {
                    return (y-item.Top)/item.Height*(item.End-item.Start)+item.Start;
                }
            }

            var down=this.Logarithmic.Down;
            for(var i in down)
            {
                var item=down[i];
                if (y>=item.Top && y<=item.Bottom)
                {
                    return (y-item.Top)/item.Height*(item.End-item.Start)+item.Start;
                }
            }
        }
        else
        {
            if (y<this.ChartBorder.GetTopEx()) return this.HorizontalMax;
            if (y>this.ChartBorder.GetBottomEx()) return this.HorizontalMin;

            var up=this.Logarithmic.Up;
            for(var i in up)
            {
                var item=up[i];
                if (y>=item.Top && y<=item.Bottom)
                {
                    return (item.Bottom-y)/item.Height*(item.End-item.Start)+item.Start;
                }
            }

            var down=this.Logarithmic.Down;
            for(var i in down)
            {
                var item=down[i];
                if (y>=item.Top && y<=item.Bottom)
                {
                    return (item.Bottom-y)/item.Height*(item.End-item.Start)+item.Start;
                }
            }
        }
    }

    this.CalculateCount=function(zoomIndex)
    {
        var dataWidth=ZOOM_SEED[zoomIndex][0];
        var distanceWidth=ZOOM_SEED[zoomIndex][1];
        var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin-distanceWidth/2;
        return parseInt(width/(dataWidth + distanceWidth));
    }

    this.ZoomUp=function(cursorIndex)
    {
        if (this.ZoomIndex<=0) return false;
        if (this.Data.DataOffset<0) return false;
        var dataCount=this.Data.Data.length;
        var maxDataCount=dataCount+this.RightSpaceCount;

        var rightSpaceCount=0;
        var lastDataIndex = this.Data.DataOffset + this.XPointCount - 1;    //最右边的数据索引
        var lastCursorIndex=this.Data.DataOffset + cursorIndex.Index;
        if (lastDataIndex>=dataCount) 
        {
            rightSpaceCount=lastDataIndex-(this.Data.Data.length-1);    //计算右边预留空间
            lastDataIndex=this.Data.Data.length-1;
            if (rightSpaceCount>this.RightSpaceCount) rightSpaceCount=this.RightSpaceCount;
        }

        var xPointCount=this.CalculateCount(this.ZoomIndex-1);
        JSConsole.Chart.Log(`[KLineFrame::ZoomUp] old status. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${this.Data.Data.length} rightSpaceCount=${rightSpaceCount}`);

        var isShowAll=false;
        --this.ZoomIndex;
        if (cursorIndex.IsLockRight==true) //固定右边
        {
            var rightDataIndex=this.Data.DataOffset + this.XPointCount;    //最右边的数据索引
            if (xPointCount>rightDataIndex)
            {
                xPointCount=rightDataIndex;
                this.XPointCount=xPointCount;
                this.Data.DataOffset=0;
            }
            else
            {
                var dataOffset=lastDataIndex - (xPointCount-rightSpaceCount)+1;
                this.XPointCount=xPointCount;
                this.Data.DataOffset=dataOffset;
                if (this.Data.DataOffset<0) this.Data.DataOffset=0;
            }
        }
        else if (xPointCount>=maxDataCount) 
        {
            //xPointCount=maxDataCount;
            //this.XPointCount=xPointCount;
            this.Data.DataOffset=0;
            this.XPointCount=xPointCount;
            isShowAll=true;
            JSConsole.Chart.Log(`[KLineFrame::ZoomUp] Show all data. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount}`);
        }
        else
        {
            var dataOffset=lastDataIndex - (xPointCount-rightSpaceCount)+1;
            if (cursorIndex.ZoomType==1)    //以十字光标为中心左右放大
            {
                var moveOffset=(this.XPointCount-xPointCount)+1;
                var leftOffset=parseInt(cursorIndex.Index/this.XPointCount*moveOffset);
                var rightOffset=moveOffset-leftOffset;
                var offset=this.Data.DataOffset+leftOffset;
                if (offset<dataCount) dataOffset=this.Data.DataOffset+leftOffset;
            }

            this.XPointCount=xPointCount;
            this.Data.DataOffset=dataOffset;
            if (this.Data.DataOffset<0) this.Data.DataOffset=0;

            JSConsole.Chart.Log(`[KLineFrame::ZoomUp] calculate. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount} DataOffset=${this.Data.DataOffset}`);
        }
       
        this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
        this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
        if (!isShowAll)
        {
            var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;
            this.TrimKLineDataWidth(width);
        }
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        cursorIndex.Index=lastCursorIndex-this.Data.DataOffset;

        return true;
    }

    this.SetXShowCount=function(showCount)
    {
        var index=-1;
        var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;
        for(var i=0; i<ZOOM_SEED.length; ++i)
        {
            var item=ZOOM_SEED[i];
            var dataWidth=item[0];
            var distanceWidth=item[1];
            var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin-distanceWidth/2;
            var value=parseInt((width-distanceWidth/2)/(dataWidth + distanceWidth));
            if (value>=showCount)
            {
                index=i;
                this.XPointCount=showCount;
                this.ZoomIndex=index;
                this.DataWidth=dataWidth;
                this.DistanceWidth=distanceWidth;
                if (dataWidth<=1 && distanceWidth==0)
                    this.DataWidth=width/this.XPointCount;
                this.LastCalculateStatus.XPointCount=this.XPointCount;
                this.LastCalculateStatus.Width=width;

                return;
            }
        }

        //太多了 就平均分了
        this.XPointCount=showCount;
        this.ZoomIndex=ZOOM_SEED.length-1;
        this.DataWidth=width/this.XPointCount;
        this.DistanceWidth=0;
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        this.LastCalculateStatus.Width=width;
    }

    this.XCoordinateZoom=function(isMoveLeft)
    {
        var oldXPointCount=this.XPointCount;
        if (isMoveLeft) //放大  右边固定
        {
            if (this.ZoomIndex<=0) return false;
            if (this.Data.DataOffset<0) return false;
            var zoomIndex=this.ZoomIndex-1;
            var xPointCount=this.CalculateCount(zoomIndex);
            var dataCount=this.Data.Data.length;
            var moveOffset=oldXPointCount-xPointCount;
            if (moveOffset<=0) return false;
            this.Data.DataOffset+=moveOffset;
            if (this.Data.DataOffset>dataCount) this.Data.DataOffset=0;
        }
        else    //缩小
        {
            if (this.ZoomIndex+1>=ZOOM_SEED.length) return false;
            if (this.Data.DataOffset<0) return false;
            var zoomIndex=this.ZoomIndex+1;
            var xPointCount=this.CalculateCount(zoomIndex);

            var moveOffset=xPointCount-oldXPointCount;
            this.Data.DataOffset-=moveOffset;
            if (this.Data.DataOffset<0) this.Data.DataOffset=0;
        }
        
        
        //JSConsole.Chart.Log(`[KLineFrame::XCoordinateZoom] old (XPointCount=${oldXPointCount} ZoomIndex=${this.ZoomIndex})  DataCount= ${this.Data.Data.length} `);

        this.XPointCount=xPointCount;
        this.ZoomIndex=zoomIndex;
        this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
        this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
        var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;
        this.TrimKLineDataWidth(width);
        
        this.LastCalculateStatus.XPointCount=this.XPointCount;

        return true;
        //var lastCursorIndex=this.Data.DataOffset + cursorIndex.Index;

        
    }

    this.ZoomDown=function(cursorIndex, option) //缩小
    {
        if (this.ZoomIndex+1>=ZOOM_SEED.length) return false;
        if (this.Data.DataOffset<0) return false;
        if (this.Data.DataOffset<=0 && cursorIndex.IsLockRight==true) return false;
        var dataCount=this.Data.Data.length;
        var maxDataCount=dataCount+this.RightSpaceCount;
        //if (this.XPointCount>=maxDataCount) return false;

        var rightSpaceCount=0;
        var lastDataIndex = this.Data.DataOffset + this.XPointCount - 1;    //最右边的数据索引
        if (lastDataIndex>=this.Data.Data.length) 
        {
            rightSpaceCount=lastDataIndex-(this.Data.Data.length-1);    //计算右边预留空间
            lastDataIndex=this.Data.Data.length-1;
            if (rightSpaceCount>this.RightSpaceCount) rightSpaceCount=this.RightSpaceCount;
        }

        var xPointCount=this.CalculateCount(this.ZoomIndex+1);
        var lastCursorIndex=this.Data.DataOffset + cursorIndex.Index;

        JSConsole.Chart.Log(`[KLineFrame::ZoomDown] old status. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${this.Data.Data.length} lastCursorIndex=${lastCursorIndex} rightSpaceCount=${rightSpaceCount}`);

        var isShowAll=false;
        ++this.ZoomIndex;
        if (cursorIndex.IsLockRight==true) //固定右边
        {
            var rightDataIndex=this.Data.DataOffset + this.XPointCount;    //最右边的数据索引
            if (xPointCount>rightDataIndex)
            {
                xPointCount=rightDataIndex;
                this.XPointCount=xPointCount;
                this.Data.DataOffset=0;
            }
            else
            {
                var dataOffset=lastDataIndex - (xPointCount-rightSpaceCount)+1;
                this.XPointCount=xPointCount;
                this.Data.DataOffset=dataOffset;
                if (this.Data.DataOffset<0) this.Data.DataOffset=0;
            }
        }
        else if (xPointCount>=maxDataCount)     //所有数据无法显示完一屏
        {
            //xPointCount=maxDataCount;
            this.XPointCount=xPointCount;
            this.Data.DataOffset=0;
            //isShowAll=true; //数据铺满全屏, 不需要调整宽度
            JSConsole.Chart.Log(`[KLineFrame::ZoomDown] Show all data. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount}`);

            if (xPointCount-this.RightSpaceCount>dataCount)
            {
                if (option && option.ZoomDownloadDataCallback)
                {
                    option.ZoomDownloadDataCallback({ PageSize:xPointCount, DataCount:dataCount, RightSpaceCount:this.RightSpaceCount, Count:xPointCount-dataCount });
                }
            }
        }
        else
        {
            var dataOffset=lastDataIndex - (xPointCount-rightSpaceCount)+1;
            if (cursorIndex.ZoomType==1)    //当前十字光标位置左右同时缩小
            {
                var moveOffset=(xPointCount-this.XPointCount)+1;
                var leftOffset=parseInt(cursorIndex.Index/this.XPointCount*moveOffset);
                var rightOffset=moveOffset-leftOffset;
                var dataOffset=this.Data.DataOffset-leftOffset;
                if (dataOffset+(xPointCount-this.RightSpaceCount)>=dataCount) dataOffset=this.Data.DataOffset-moveOffset;
            }

            this.XPointCount=xPointCount;
            this.Data.DataOffset=dataOffset;
            if (this.Data.DataOffset<0) this.Data.DataOffset=0;

            JSConsole.Chart.Log(`[KLineFrame::ZoomDown] calculate. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount} DataOffset=${this.Data.DataOffset}`);
        }

        this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
        this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
        if (!isShowAll) 
        {
            var width=this.GetFrameWidth()-g_JSChartResource.FrameMargin;
            this.TrimKLineDataWidth(width);
        }
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        cursorIndex.Index=lastCursorIndex-this.Data.DataOffset;

        return true;
    }

    this.GetFrameWidth=function()
    {
        if (this.IsHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            return border.BottomEx-border.TopEx;
            //return this.ChartBorder.GetHeight();
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            return border.RightEx-border.LeftEx;
            //return this.ChartBorder.GetWidth();
        }
    }

    this.DrawCustomHorizontal=function()    //Y轴刻度定制显示
    {
        if (this.IsMinSize) return;
        if (this.ChartBorder.IsShowTitleOnly) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.CustomHorizontalInfo)) return;

        var aryHorizontal=this.CustomHorizontalInfo.slice();
        aryHorizontal.sort((left, right)=>{ return right.Value-left.Value; });
        var mapTextRect=new Map();  //key=position(1=左外 2=左内, 3=右外 4=右内), value:{ Rect:, Item: }  
        for(var i=0; i<aryHorizontal.length; ++i)
        {
            var item=aryHorizontal[i];
            switch(item.Type)
            {
                case 0: //最新价格刻度
                case 1: //固定价格刻度
                    this.DrawCustomItem(item, mapTextRect);  
                    break;
                case 2: //当前屏最后一个K线价格刻度
                case 3: //主图K线涨幅刻度
                case 4: //叠加K线涨幅刻度
                    this.DrawCustomItem(item, mapTextRect);  
                    break;
            }
        }
    }

    //Y轴面积背景
    this.DrawCustomHorizontalArea=function()
    {
        if (this.IsMinSize) return;
        if (this.ChartBorder.IsShowTitleOnly) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.CustomHorizontalInfo)) return;

        for(var i=0;i<this.CustomHorizontalInfo.length;++i)
        {
            var item=this.CustomHorizontalInfo[i];
            if (item.Type==5) this.DrawCustomAreaItem(item);
        }
    }

    this.DrawCustomVerticalItem=function(item)
    {
        this.Canvas.save(); 
        if (item.Data.Line.Type==1) this.Canvas.setLineDash([5,5]);   //虚线
        this.Canvas.strokeStyle=item.Data.Line.Color;
        this.Canvas.beginPath();
        if (item.IsHScreen)
        {
            this.Canvas.moveTo(item.Top,ToFixedPoint(item.X));
            this.Canvas.lineTo(item.Bottom,ToFixedPoint(item.X));
        }
        else
        {
            this.Canvas.moveTo(ToFixedPoint(item.X),item.Top);
            this.Canvas.lineTo(ToFixedPoint(item.X),item.Bottom);
        }
        this.Canvas.stroke();
        this.Canvas.restore();
    }

    this.DrawCustomVertical=function()  //X轴定制刻度显示
    {
        if (!this.CustomVerticalInfo) return;
        if (this.CustomVerticalInfo.length<=0) return;
        if (!this.Data) return;

        var isHScreen=this.IsHScreen;
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();
       
        var dataWidth=this.DataWidth;
        var distanceWidth=this.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;

        if (isHScreen) 
        {
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
            top=this.ChartBorder.GetLeftEx();
            bottom=this.ChartBorder.GetRightEx();
        }

        var j=0;
        for(var i=this.Data.DataOffset;i<this.Data.Data.length && j<this.XPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var kItem=this.Data.Data[i];
            for(var k in this.CustomVerticalInfo)
            {
                var item=this.CustomVerticalInfo[k];
                if (item.Type!=0) continue;

                if (IFrameSplitOperator.IsNumber(item.Time))
                {
                    if (kItem.Date!=item.Date || kItem.Time!=item.Time) continue;
                }
                else
                {
                    if (kItem.Date!=item.Date) continue;
                }

                var left=xOffset;
                var right=xOffset+dataWidth;
                var x=left+(right-left)/2;  

                var DrawData={X:x, Top:top, Bottom:bottom, Data:item , IsHScreen:isHScreen};
                this.DrawCustomVerticalItem(DrawData);
                if (this.DrawCustomVerticalEvent) 
                    this.DrawCustomVerticalEvent.Callback(this.DrawCustomVerticalEvent, DrawData, this);

                break;
            }
        }

        for(var i=1;j<this.XPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            for(var k in  this.CustomVerticalInfo)
            {
                var item=this.CustomVerticalInfo[k];
                if (item.Type!=1) continue;
                if (item.Space!=i) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                var x=left+(right-left)/2; 
                
                var DrawData={X:x, Top:top, Bottom:bottom, Data:item,IsHScreen:isHScreen };
                this.DrawCustomVerticalItem(DrawData);
                if (this.DrawCustomVerticalEvent) 
                    this.DrawCustomVerticalEvent.Callback(this.DrawCustomVerticalEvent, DrawData, this);

                break;
            }
        }
    }

    this.DrawSelectedBorder=function(option)
    {
        if (this.Identify===0) return;

        var border=this.IsHScreen==true?this.ChartBorder.GetHScreenBorder():this.ChartBorder.GetBorder();

        var left=ToFixedPoint(border.Left);
        var top=ToFixedPoint(border.Top);
        var right=ToFixedPoint(border.Right);
        var bottom=ToFixedPoint(border.Bottom);
        var height=bottom-top;

        this.Canvas.strokeStyle=this.SelBorderColor;

        if (option.Mode==1)
        {
            var xRight=ToFixedPoint(border.ChartWidth);
            this.Canvas.strokeRect(right,top,xRight-right-1,height);  //少一个像素让边框显示出来
        }
        else
        {
            this.Canvas.strokeRect(left,top,right-left-1,height);  //少一个像素让边框显示出来
        }
    }

    //是否在X轴坐标上
    //this.PtInVertical=function(x,y) { return false; }

    //缓存X轴坐标刻度
    this.GetVerticalXCache=function()
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.VerticalInfo)) return null;
        
        var dataWidth=this.DataWidth;
        var distanceWidth=this.DistanceWidth;
        var xPointCount=this.XPointCount;

        var setIndex=new Set();
        for(var i=0; i<this.VerticalInfo.length; ++i)
        {
            var item=this.VerticalInfo[i];
            setIndex.add(item.Value);
        }

        if (this.IsHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }

        var mapX=new Map();
        for(var i=0;i<xPointCount;++i, xOffset+=(dataWidth+distanceWidth))
        {
            var left=xOffset;
            var right=xOffset+dataWidth;
            var x=left+(right-left)/2;

            if (setIndex.has(i))
            {
                mapX.set(i, x);
            }
        }

        return mapX;
    }
}

function OverlayKLineFrame()
{
    this.newMethod=KLineFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='OverlayKLineFrame';

    this.MainFrame=null;    //主框架
    this.IsShareY=false;    //使用和主框架公用Y轴
    this.IsShowMainFrame=0; //是否显示在主框架坐标上 1=左边 2=右边
    this.IsCalculateYMaxMin=true;   //是否计算Y最大最小值
    this.RightOffset=50;
    this.PenBorder=g_JSChartResource.OverlayFrame.BolderPen; //'rgb(0,0,0)'
    this.IsShow=g_JSChartResource.KLineToolbar.IsShowOverlayFrame;              //坐标是否显示
    this.IsShowToolbar=g_JSChartResource.KLineToolbar.IsShowOverlayToolbar;    //是否显示工具条
    this.Title=null;
    this.TitleColor=g_JSChartResource.OverlayFrame.TitleColor;
    this.TitleFont=g_JSChartResource.OverlayFrame.TitleFont;
    this.IsShowTitle=true;

    this.IsYDrawMainFrame=false;  //Y轴自定刻度绘制在主图框架上
    this.BlankWidth=0;
    this.Style=0;       //0=Y轴在BlankWidth 1=Y轴在左边

    this.YLineExtend=[ { Width:2 }, null];    //[0]=左 [1]=右     { Width:5, Color:颜色,  }

    this.Buttons=[];

    this.CloseButton=CloneData(g_JSChartResource.Buttons.CloseOverlayIndex);
    this.ModifyIndexParamButton=CloneData(g_JSChartResource.Buttons.ModifyIndexParam);
    this.DrawSelectedBorder=null;

    this.KLineFrame_ReloadResource=this.ReloadResource;
    this.ReloadResource=function(resource)
    {
        this.KLineFrame_ReloadResource(resource);

        if (!resource)
        {
            this.CloseButton=CloneData(g_JSChartResource.Buttons.CloseOverlayIndex);
            this.ModifyIndexParamButton=CloneData(g_JSChartResource.Buttons.ModifyIndexParam);
            this.PenBorder=g_JSChartResource.OverlayFrame.BolderPen; //'rgb(0,0,0)'
            this.TitleColor=g_JSChartResource.OverlayFrame.TitleColor;
            this.TitleFont=g_JSChartResource.OverlayFrame.TitleFont;
        }
    }

    this.Draw=function()
    {
        this.Buttons=[];
        if (this.ChartBorder.IsShowTitleOnly) return;

        this.SplitXYCoordinate();

        if (this.IsShow)
        {
            this.DrawVertical();
            this.DrawHorizontal();
            this.DrawTitle();
        }
        
        this.SizeChange=false;
        this.XYSplit=false;
        this.XSplit=false;
        this.YCustomSplit=false;            //自定义Y轴分割线
    }


    //Y轴刻度线 x坐标
    this.GetXHorizontal=function()
    {
        var border=this.ChartBorder.GetBorder();
        var x=border.Right;
        x+=this.RightOffset;

        if (this.Style==1)
        {

        }
        else
        {
            x+=this.BlankWidth;
        }

        return x;
    }

    this.GetHorizontalWidth=function()
    {
        var width=null;
        if (this.YRightTextInfo && IFrameSplitOperator.IsNumber(this.TextWidthIndex))
            width=this.YRightTextInfo.AryOverlayWidth[this.TextWidthIndex];

        return width;
    }

    this.DrawTitle=function()   //画标题
    {
        if (!this.IsShowTitle) return;
        if (!this.Title) return;
        var border=this.ChartBorder.GetBorder();
        var top = this.ChartBorder.GetTopTitle();
        var bottom = border.Bottom;
        
        var xText=this.GetXHorizontal();
        var leftLine=null, rightLine=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.YLineExtend))
        {
            rightLine=this.YLineExtend[1];
            leftLine=this.YLineExtend[0];
        }
        
        if (this.Style==1)
        {
            this.Canvas.textBaseline="bottom";
            if (rightLine && rightLine.Width>0) xText+=rightLine.Width+1;
            else xText+=1;
        }
        else
        {
            this.Canvas.textBaseline="top";
            if (leftLine && leftLine.Width>0) xText-=leftLine.Width;
            else xText-=2;
        }
        
        var yText=top+(bottom-top)/2;
        this.Canvas.fillStyle=this.TitleColor;
        this.Canvas.font=this.TitleFont;
        this.Canvas.textAlign="center";
       
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(this.Title, 0, 0);
        this.Canvas.restore();
    }

    this.GetScaleTextWidth=function()
    {
        if (!this.IsShow) return null;

        var border=this.ChartBorder.GetBorder();
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        if (this.IsHScreen)
        {
            var borderBottom=this.ChartBorder.Bottom;
            var isDrawRight=borderBottom>10*pixelTatio && this.IsShowYText[1]===true && this.YTextPosition[1]!=2;
        }
        else
        {
            var borderRight=this.ChartBorder.Right;
            var isDrawRight=borderRight>10 && this.IsShowYText[1]===true && this.YTextPosition[1]!=2;
        }
        
        if (!isDrawRight) return null;

        var width={ Left:null, Right:0 };
        for(var i=0;i<this.HorizontalInfo.length;++i)
        {
            var textWidth=null;
            var item=this.HorizontalInfo[i];
            if (!item) continue;

            if (item.Message[1]!=null && isDrawRight)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                textWidth=this.Canvas.measureText(item.Message[1]).width;
                if (this.YTextPadding && IFrameSplitOperator.IsNumber(this.YTextPadding[1]))
                    textWidth+=this.YTextPadding[1];
                if (width.Right<textWidth) width.Right=textWidth;
            }
        }

        if (IFrameSplitOperator.IsNonEmptyArray(this.YLineExtend))
        {
            var line=this.YLineExtend[1];
            if (line && line.Width>0) width.Right+=line.Width;
        }

        return { TextWidth:width };
    }

    //同步主图坐标
    this.SyncMainHorizontalInfo=function()
    {
        if (!this.MainFrame) return false;

        if (this.MainFrame.YMaxMin)
        {
            this.YMaxMin.Max=this.MainFrame.YMaxMin.Max;
            this.YMaxMin.Min=this.MainFrame.YMaxMin.Min;
        }

        this.HorizontalMax=this.MainFrame.HorizontalMax;
        this.HorizontalMin=this.MainFrame.HorizontalMin;
        this.HorizontalInfo=[];
        for(var i=0;i<this.MainFrame.HorizontalInfo.length; ++i)
        {
            var item=this.MainFrame.HorizontalInfo[i];
            this.HorizontalInfo.push(item);
        }

        this.CoordinateType=this.MainFrame.CoordinateType;

        return true;
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) return;

        if (this.IsShareY)  //和主图指标共享Y轴坐标
        {
            this.SyncMainHorizontalInfo();
        }
        else    //独立Y轴坐标
        {
            if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
        }
    }

    //画Y轴
    this.DrawHorizontal=function()
    {
        var border=this.ChartBorder.GetBorder();
        var left=border.Left;
        var right=border.Right;
        var bottom = border.Bottom;
        var top = this.ChartBorder.GetTopTitle();
        var borderRight=this.ChartBorder.Right;
        right+=this.RightOffset;
        var xLine=this.GetXHorizontal();
        if (IFrameSplitOperator.IsNumber(this.BlankWidth)) right+=this.BlankWidth;

        var rightExtendText=null;   //右侧文字设置
        if (IFrameSplitOperator.IsNonEmptyArray(this.YTextExtend))
        {
            rightExtendText=this.YTextExtend[1];
        }

        var leftLine=null, rightLine=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.YLineExtend))
        {
            rightLine=this.YLineExtend[1];
            leftLine=this.YLineExtend[0];
        }

        var rightWidth=this.GetHorizontalWidth();  //右侧宽度
        var yPrev=null; //上一个坐标y的值
        for(var i=this.HorizontalInfo.length-1; i>=0; --i)  //从上往下画分割线
        {
            var item=this.HorizontalInfo[i];
            var y=this.GetYFromData(item.Value);
            if (y!=null && Math.abs(y-yPrev)<this.MinYDistance) continue;  //两个坐标在近了 就不画了

            if (y >= bottom - 2) this.Canvas.textBaseline = 'bottom';
            else if (y <= top + 2) this.Canvas.textBaseline = 'top';
            else this.Canvas.textBaseline = "middle";

        
            if (leftLine && leftLine.Width>0)   //左边
            {
                this.Canvas.strokeStyle=this.PenBorder;
                this.Canvas.beginPath();
                this.Canvas.moveTo(xLine-leftLine.Width,ToFixedPoint(y));
                this.Canvas.lineTo(xLine,ToFixedPoint(y));
                this.Canvas.stroke();
            }
               
            if (rightLine && rightLine.Width>0)
            {
                this.Canvas.strokeStyle=this.PenBorder;
                this.Canvas.beginPath();
                this.Canvas.moveTo(xLine+rightLine.Width,ToFixedPoint(y));
                this.Canvas.lineTo(xLine,ToFixedPoint(y));
                this.Canvas.stroke();
            }

            //坐标信息 右边 间距小于10 不画坐标
            if (item.Message[1]!=null && borderRight>10)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                var text=item.Message[1];
                if (Array.isArray(item.Message[1])) text=item.Message[1][0];

                if (rightExtendText && rightExtendText.Align)
                {
                    var textWidth=rightWidth;
                    this.Canvas.textAlign="right";
                    var xRight=border.Right+this.RightOffset+textWidth-this.YTextPadding[1];
                    this.Canvas.fillText(text,xRight,y);
                }
                else
                {
                    var xText=right+2;
                    if (rightLine && rightLine.Width>0) xText+=rightLine.Width;
                    this.Canvas.fillStyle=item.TextColor;
                    this.Canvas.textAlign="left";
                    this.Canvas.fillText(text,xText,y);
                }
            }

            yPrev=y;
        }
    }

    //画X轴
    this.DrawVertical=function()
    {
        var border=this.ChartBorder.GetBorder();
        var top=border.TopEx;
        var bottom=border.BottomEx;
        var right=this.GetXHorizontal();

        this.Canvas.strokeStyle=this.PenBorder;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(right),ToFixedPoint(top));
        this.Canvas.lineTo(ToFixedPoint(right),ToFixedPoint(bottom));
        this.Canvas.stroke();
    }

    this.DrawToolbar=function(moveonPoint, isMinSize, mouseStatus)
    {
        this.Buttons=[];
        if (isMinSize==true) return;
        if (this.ChartBorder.IsShowTitleOnly) return;
        if (this.ChartBorder.TitleHeight<5) return;
        if (!this.IsShowToolbar) return;

        var aryButton=[];
        aryButton.push( { ID:JSCHART_BUTTON_ID.MODIFY_OVERLAY_INDEX_PARAM, Style:this.ModifyIndexParamButton });
        aryButton.push( { ID:JSCHART_BUTTON_ID.CLOSE_OVERLAY_INDEX, Style:this.CloseWindowButton });

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_OVERLAY_TOOLBAR);
            if (event && event.Callback)
            {
                var sendData={ PreventDefault:false, DefaultButton:aryButton, AryButton:null, Guid:this.Guid };

                event.Callback(event, sendData, this);
                if (sendData.PreventDefault) 
                {
                    this.DrawToolbarButton(sendData.AryButton,moveonPoint, mouseStatus);
                    return;
                }
            }
        } 

        this.DrawToolbarButton(aryButton, moveonPoint, mouseStatus);
    }

    this.DrawToolbarButton=function(aryButton, moveonPoint, mouseStatus)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryButton)) return;

        var border=this.ChartBorder.GetBorder();
        var yButton=border.Top+this.ChartBorder.TitleHeight/2;
        var rightWidth=this.GetHorizontalWidth();
        var xBotton=border.Right+this.RightOffset+rightWidth-this.CloseButton.MerginLeft;

        for(var i=aryButton.length-1;i>=0;--i)
        {
            var item=aryButton[i];
            var size=item.Style.Size;
            var font=`${size}px ${item.Style.Family}`;
            var rtButton={ Left:xBotton-size-item.Style.MerginLeft, Top:yButton-size/2, Right:xBotton, Bottom:yButton+size/2, Width:size+item.Style.MerginLeft, Height:size };
            var color=this.CloseButton.Color;
            if (moveonPoint && (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
            {
                color=item.Style.MoveOnColor;
                if (mouseStatus)
                    mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:item, Frame:this, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
            }

            this.Canvas.fillStyle=color;
            this.Canvas.font=font;
            this.Canvas.textAlign="right";
            this.Canvas.textBaseline="middle";
            this.Canvas.fillText(item.Style.Text, xBotton, yButton);

            this.Buttons.push({ ID:item.ID, Rect:rtButton });

            xBotton=rtButton.Left;
        }
    }

    this.DrawCustomItem=function(item, mapTextRect) //显示自定义Y刻度
    {
        if (!this.IsShow && !this.IsYDrawMainFrame) return;

        if (!item.Message[1] && !item.Message[0]) return;
        if (item.Value>this.HorizontalMax || item.Value<this.HorizontalMin) 
        {
            this.SendDrawCountDownEvent( { IsShow:false } );
            return;
        }

        var border=this.GetBorder();
        var left=border.Left;
        var right=border.Right+this.RightOffset;
        if (this.IsYDrawMainFrame) right=border.Right
        var bottom=border.Bottom;
        var top=border.Top;
        var borderRight = this.ChartBorder.Right;
        var borderLeft = this.ChartBorder.Left;
        var titleHeight = this.ChartBorder.TitleHeight;

        if (this.IsHScreen)
        {
            borderLeft=this.ChartBorder.Top;
            borderRight=this.ChartBorder.Bottom;
            top=border.Top;
            bottom=border.Bottom;
        }

        var pixelTatio = GetDevicePixelRatio();
        var defaultTextHeight=18*pixelTatio;
        var textHeight=defaultTextHeight;
        
        var y = this.GetYFromData(item.Value);
        var position=0;
        var emptyBGColor;
        if (item.ExtendData && item.ExtendData.Custom)
        {
            var customItem=item.ExtendData.Custom;
            if (IFrameSplitOperator.IsNumber(customItem.Position)) position=customItem.Position;
            if (customItem.EmptyBGColor) emptyBGColor=customItem.EmptyBGColor;
        }

        if (item.Message[0])    // 左
        {
            if (borderLeft<10 || position==1)
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,true,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                var bgColor=item.LineColor;
                var rgb=this.RGBToStruct(item.LineColor);
                if (rgb) bgColor=`rgba(${rgb.R}, ${rgb.G}, ${rgb.B}, ${g_JSChartResource.FrameLatestPrice.BGAlpha})`;   //内部刻度 背景增加透明度
                
                var yText=y;
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        var bgTop=top;
                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=bgColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0) this.DrawLine(bgTop+itemText.Width,bottom,yText,item.LineColor,item.LineType,item);

                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        if (itemText.Type===1)
                        {

                        }
                        else
                        {
                            var bgTop=yText-textHeight/2-1*pixelTatio;
                            var textLeft=left + 1*pixelTatio
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,itemText.Width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(itemText.Text, textLeft + 1*pixelTatio, yText);
                            if (i==0) this.DrawLine(textLeft+itemText.Width,right,yText,item.LineColor,item.LineType,item);
    
                            yText+=textHeight+1*pixelTatio;
                        }
                    }
                }
            }
            else
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "right";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,true,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                
                var yText=y;
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        if (i==0) var bgTop=top-itemText.Width;
                        else var bgTop=top-textWidth;

                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=item.LineColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0) this.DrawLine(bgTop+itemText.Width,bottom,yText,item.LineColor,item.LineType,item);

                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        var bgTop=yText-textHeight/2-1*pixelTatio;
                        if (i==0)
                        {
                            var rectLeft=left-itemText.Width;
                            var textLeft=left;
                        }
                        else
                        {
                            var rectLeft=left-textWidth;
                            var textLeft=left-(textWidth-itemText.Width);
                        }

                        if (emptyBGColor)
                        {
                            this.Canvas.fillStyle=emptyBGColor;
                            this.Canvas.fillRect(rectLeft-1,bgTop,itemText.Width+1,textHeight);
                            this.Canvas.strokeStyle=item.LineColor;
                            this.Canvas.strokeRect(ToFixedPoint(rectLeft-1),ToFixedPoint(bgTop),ToFixedPoint(itemText.Width+1),ToFixedPoint(textHeight));
                            this.Canvas.fillStyle = item.LineColor;
                            this.Canvas.fillText(itemText.Text, textLeft - 1*pixelTatio, yText);
                        }
                        else
                        {
                            this.Canvas.fillStyle=item.LineColor;
                            this.Canvas.fillRect(rectLeft,bgTop,itemText.Width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(itemText.Text, textLeft - 1*pixelTatio, yText);
                        }
                        
                        if (i==0) this.DrawLine(left,right,yText,item.LineColor,item.LineType,item);
                        
                        yText+=textHeight+1*pixelTatio;
                    }
                }
            }
        }
        else if (item.Message[1])   //右
        {
            if (borderRight<10 || position==1)
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,false,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                var bgColor=item.LineColor;
                var rgb=this.RGBToStruct(item.LineColor);
                if (rgb) bgColor=`rgba(${rgb.R}, ${rgb.G}, ${rgb.B}, ${g_JSChartResource.FrameLatestPrice.BGAlpha})`;   //内部刻度 背景增加透明度
                
                var yText=y;
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        var bgTop=bottom-itemText.Width;
                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=bgColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,textWidth);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0) this.DrawLine(top,bgTop,yText,item.LineColor,item.LineType,item);
                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        if (itemText.Type===1)
                        {
                            if (this.GetEventCallback)
                            {
                                var bgTop=yText-textHeight/2-1*pixelTatio;
                                var sendData=
                                { 
                                    Top:bgTop, Right:right, Height:null, 
                                    IsShow:true, BGColor:item.LineColor, TextColor:item.TextColor, PixelTatio:pixelTatio, Position:"Right", IsInside:true
                                };
                                if (this.SendDrawCountDownEvent(sendData))
                                {
                                    if (IFrameSplitOperator.IsPlusNumber(sendData.Height))
                                        yText+=textHeight+1*pixelTatio;
                                }
                            }
                        }
                        else
                        {
                            var bgTop=yText-textHeight/2-1*pixelTatio;
                            var textLeft=right-itemText.Width;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,textWidth,textHeight);  //文本背景区域
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(itemText.Text, textLeft + 1*pixelTatio, yText);
                            if (i==0) this.DrawLine(left,textLeft,yText,item.LineColor,item.LineType,item);
                            yText+=textHeight+1*pixelTatio;
                        }
                    }
                }

                if (item.Type==3 || item.Type==4)
                {
                    if (item.Title)
                    {
                        var width=this.Canvas.measureText(item.Title).width+2*pixelTatio;
                        if (this.IsHScreen)
                        {
                            var bgTop=bottom-itemText.Width-width;
                            var textLeft=y-textHeight/2-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,textHeight,width);
                            this.DrawHScreenText({X:y, Y:bgTop}, {Text:item.Title, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        }
                        else
                        {
                            var bgTop=y-textHeight/2-1*pixelTatio;
                            var textLeft=right-textWidth-width-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(item.Title, textLeft + 1*pixelTatio, y);
                        }
                    }
                }
            }
            else
            {
                if (item.Font != null) this.Canvas.font = item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var textInfo=this.GetCustomItemTextInfo(item,false,pixelTatio);
                var textWidth=textInfo.MaxWidth;
                var fontHeight=this.GetFontHeight();
                textHeight=fontHeight>defaultTextHeight? fontHeight:defaultTextHeight;
                var preTextRect=null;
                if (mapTextRect && mapTextRect.has(3)) preTextRect=mapTextRect.get(3);
                
                var yText=y;
                var rtText={ };
                for(var i=0;i<textInfo.Text.length;++i)
                {
                    var itemText=textInfo.Text[i];
                    if (this.IsHScreen)
                    {
                        var bgTop=bottom;
                        //bgTop+=(textWidth-itemText.Width);
                        var textLeft=yText-textHeight/2-1*pixelTatio;
                        this.Canvas.fillStyle=item.LineColor;
                        this.Canvas.fillRect(textLeft,bgTop,textHeight,itemText.Width);
                        this.DrawHScreenText({X:yText, Y:bgTop}, {Text:itemText.Text, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        if (i==0)  this.DrawLine(top,bgTop,yText,item.LineColor,item.LineType,item);

                        yText-=textHeight+1*pixelTatio;
                    }
                    else
                    {
                        if (itemText.Type===1)
                        {
                            if (this.GetEventCallback)
                            {
                                var bgTop=yText-textHeight/2-1*pixelTatio;
                                var sendData=
                                { 
                                    Top:bgTop, Left:right, Right:this.ChartBorder.GetChartWidth(), Height:null, 
                                    IsShow:true, BGColor:item.LineColor, TextColor:item.TextColor, PixelTatio:pixelTatio, Position:"Right", IsInside:false
                                };
                                if (this.SendDrawCountDownEvent(sendData))
                                {
                                    if (IFrameSplitOperator.IsPlusNumber(sendData.Height))
                                        yText+=textHeight+1*pixelTatio;
                                }
                            }
                        }
                        else
                        {
                            var bgTop=yText-textHeight/2-1*pixelTatio;
                            if (i==0)
                            {
                                var textLeft=right;
                                rtText.Left=textLeft;
                                if (preTextRect && bgTop<preTextRect.Rect.Bottom)
                                {
                                    yText=preTextRect.Rect.Bottom;
                                    bgTop=yText-textHeight/2-1*pixelTatio;
                                }
                            }
                            else
                            {
                                var textLeft=right+textWidth-itemText.Width;
                            }

                            if (emptyBGColor)
                            {
                                this.Canvas.fillStyle=emptyBGColor;
                                this.Canvas.fillRect(textLeft,bgTop,itemText.Width+1,textHeight);
                                this.Canvas.strokeStyle=item.LineColor;
                                this.Canvas.strokeRect(ToFixedPoint(textLeft),ToFixedPoint(bgTop),ToFixedRect(itemText.Width+1),ToFixedRect(textHeight));
                                this.Canvas.fillStyle = item.LineColor;
                                this.Canvas.fillText(itemText.Text, textLeft + 2*pixelTatio, yText);
                            }
                            else
                            {
                                this.Canvas.fillStyle=item.LineColor;
                                this.Canvas.fillRect(textLeft,bgTop,itemText.Width,textHeight);
                                this.Canvas.fillStyle = item.TextColor;
                                this.Canvas.fillText(itemText.Text, textLeft + 1*pixelTatio, yText);
                            }
                           
                            if (i==0) this.DrawLine(left,right,y,item.LineColor,item.LineType,item);
                            
                            yText+=textHeight+1*pixelTatio;

                            rtText.Bottom=yText;
                        }
                    }
                }

                if (mapTextRect && IFrameSplitOperator.IsNumber(rtText.Left) && IFrameSplitOperator.IsNumber(rtText.Bottom))
                {
                    mapTextRect.set(3, { Rect:rtText, Item:item });
                }

                if (item.Type==3 || item.Type==4)
                {
                    if (item.Title)
                    {
                        var bgColor=item.LineColor;
                        var rgb=this.RGBToStruct(item.LineColor);
                        if (rgb) bgColor=`rgba(${rgb.R}, ${rgb.G}, ${rgb.B}, ${g_JSChartResource.FrameLatestPrice.BGAlpha})`;   //内部刻度 背景增加透明度
                        var width=this.Canvas.measureText(item.Title).width+2*pixelTatio;
                        if (this.IsHScreen)
                        {
                            var bgTop=bottom-width;
                            var textLeft=y-textHeight/2-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,textHeight,width);
                            this.DrawHScreenText({X:y, Y:bgTop}, {Text:item.Title, Color:item.TextColor, XOffset:1*pixelTatio, YOffset:2*pixelTatio});
                        }
                        else
                        {
                            var bgTop=y-textHeight/2-1*pixelTatio;
                            var textLeft=right-width-1*pixelTatio;
                            this.Canvas.fillStyle=bgColor;
                            this.Canvas.fillRect(textLeft,bgTop,width,textHeight);
                            this.Canvas.fillStyle = item.TextColor;
                            this.Canvas.fillText(item.Title, textLeft + 1*pixelTatio, y);
                        }
                    }
                }
            }
        }
    }
}

//K线横屏框架
function KLineHScreenFrame()
{
    this.newMethod=KLineFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='KLineHScreenFrame';
    this.IsHScreen=true;        //是否是横屏

    this.DrawSelectedBorder=null;

    //画标题背景色
    this.DrawTitleBG=function()
    {
        if (this.ChartBorder.TitleHeight<=0) return;

        var border=this.ChartBorder.GetHScreenBorder();
        var left=ToFixedPoint(border.RightTitle);
        var top=ToFixedPoint(border.Top);
        var bottom=ToFixedPoint(border.Bottom);
        var width=this.ChartBorder.TitleHeight;
        var height=bottom-top;

        this.Canvas.fillStyle=this.TitleBGColor;
        this.Canvas.fillRect(left,top,width,height);
    }

    this.DrawToolbar=function()
    {
        return;
    }

    this.GetYFromData=function(value,isLimit)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if (isLimit===false)
        {
            var width=(border.RightEx-border.LeftEx)*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
            return border.LeftEx+width;
        }
        else
        {
            if(value<=this.HorizontalMin) return border.LeftEx;
            if(value>=this.HorizontalMax) return border.RightEx;
    
            var width=(border.RightEx-border.LeftEx)*(value-this.HorizontalMin)/(this.HorizontalMax-this.HorizontalMin);
            return border.LeftEx+width;
        }
    }

    //画Y轴
    this.DrawHorizontal=function()
    {
        var border=this.ChartBorder.GetHScreenBorder();
        var top=border.Top;
        var bottom=border.Bottom;
        var borderTop=this.ChartBorder.Top;
        var borderBottom=this.ChartBorder.Bottom;
        var left=border.Left;
        var right=border.Right;

        var yPrev=null; //上一个坐标y的值
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率

        var isDrawLeft=borderTop>10*pixelTatio && this.IsShowYText[0]===true && this.YTextPosition[0]!=2;
        var isDrawRight=borderBottom>10*pixelTatio && this.IsShowYText[1]===true && this.YTextPosition[1]!=2;

        for(var i=this.HorizontalInfo.length-1; i>=0; --i)  //从左往右画分割线
        {
            var item=this.HorizontalInfo[i];
            var y=this.GetYFromData(item.Value);
            if (y!=null && Math.abs(y-yPrev)<this.MinYDistance) continue;  //两个坐标在近了 就不画了

            if (y!=left)
            {
                if (item.LineType==2)
                {
                    this.Canvas.strokeStyle=item.LineColor;
                    this.Canvas.setLineDash([5*pixelTatio,5*pixelTatio]);   //虚线
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(ToFixedPoint(y),top);
                    this.Canvas.lineTo(ToFixedPoint(y),bottom);
                    this.Canvas.stroke();
                    this.Canvas.setLineDash([]);
                }
                else if (item.LineType>0)
                {
                    this.Canvas.strokeStyle=item.LineColor;
                    if (g_JSChartResource.FrameYLineDash)
                    {
                        this.Canvas.setLineDash(g_JSChartResource.FrameYLineDash);   //虚线
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(ToFixedPoint(y),top);
                        this.Canvas.lineTo(ToFixedPoint(y),bottom);
                        this.Canvas.stroke();
                        this.Canvas.setLineDash([]);
                    }
                    else
                    {
                        this.Canvas.beginPath();
                        this.Canvas.moveTo(ToFixedPoint(y),top);
                        this.Canvas.lineTo(ToFixedPoint(y),bottom);
                        this.Canvas.stroke();
                    }
                }
            }
            
            //坐标信息 左边 间距小于10 不画坐标
            if (item.Message[0]!=null && isDrawLeft)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.textAlign="right";
                this.Canvas.textBaseline="middle";

                var xText=y,yText=top;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(item.Message[0], -2, 0);
                this.Canvas.restore();
            }

            //坐标信息 右边 间距小于10 不画坐标
            if (item.Message[1]!=null && isDrawRight)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.textAlign="left";
                this.Canvas.textBaseline="middle";
                var text;
                if (Array.isArray(item.Message[1])) //横屏只支持单行
                {
                    text=item.Message[1][0];
                }
                else
                {
                    text=item.Message[1];
                }

                var xText=y,yText=bottom;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(text, 2, 0);
                this.Canvas.restore();
            }

            yPrev=y;
        }
    }

    //Y刻度画在左边内部
    this.DrawInsideHorizontal = function () 
    {
        if (this.IsMinSize) return;
        if (this.IsShowYText[0]===false && this.IsShowYText[1]===false) return;

        var left = this.ChartBorder.GetLeft();
        var right = this.ChartBorder.GetRightEx();
        var top=this.ChartBorder.GetTop();
        var bottom=this.ChartBorder.GetBottom();
        var borderTop=this.ChartBorder.Top;
        var borderBottom=this.ChartBorder.Bottom;
        var titleHeight = this.ChartBorder.TitleHeight;
        var pixelTatio = GetDevicePixelRatio();
        
        var isDrawLeft= (borderTop<10*pixelTatio || this.YTextPosition[0]==2) && this.IsShowYText[0]===true;
        var isDrawRight= (borderBottom<10*pixelTatio || this.YTextPosition[1]==2) && this.IsShowYText[1]===true;

        if ( isDrawLeft || isDrawRight )
        {
            var pixelTatio = GetDevicePixelRatio();
            var yPrev = null; //上一个坐标y的值
            for (var i = this.HorizontalInfo.length - 1; i >= 0; --i)  //从上往下画分割线
            {
                var item = this.HorizontalInfo[i];
                var y = this.GetYFromData(item.Value);
                if (y != null && yPrev!=null && Math.abs(y - yPrev) < this.MinYDistance) continue;  //两个坐标在近了 就不画了

                //坐标信息 左边 间距小于10 画在内部
                if (item.Message[0] != null && isDrawLeft) 
                {
                    if (item.Font != null) this.Canvas.font = item.Font;
                    this.Canvas.fillStyle = item.TextColor;
                    this.Canvas.textAlign = "left";
                    if (y >= right - 2) this.Canvas.textBaseline = 'top';
                    else if (y <= left + 2) this.Canvas.textBaseline = 'bottom';
                    else this.Canvas.textBaseline = "middle";

                    var textObj={ X:left, Y:y, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:item.Message[0]}} ;
                    var xText=y,yText=top;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(item.Message[0], -2, 0);
                    this.Canvas.restore();
                }

                if (item.Message[1] != null && isDrawRight)
                {
                    if (item.Font != null) this.Canvas.font = item.Font;
                    this.Canvas.fillStyle = item.TextColor;
                    this.Canvas.textAlign = "right";
                    if (y >= right - 2) this.Canvas.textBaseline = 'top';
                    else if (y <= left + 2) this.Canvas.textBaseline = 'bottom';
                    else this.Canvas.textBaseline = "middle";

                    if (Array.isArray(item.Message[1])) var text=item.Message[1][0];
                    else var text=item.Message[1];

                    var textWidth = this.Canvas.measureText(text).width;
                    var textObj={ X:right-textWidth, Y:y, Text:{ BaseLine:this.Canvas.textBaseline, TextAlign: this.Canvas.textAlign, Font:this.Canvas.font, Value:text}} ;

                    var xText=y,yText=bottom;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(text, -2, 0);
                    this.Canvas.restore();
                }
                yPrev = y;
            }
        }
    }

    this.GetXFromIndex=function(index,isLimit)
    {
        if (isLimit===false)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            if (index>=0)
            {
                var offset=border.TopEx+ g_JSChartResource.FrameLeftMargin + this.DistanceWidth/2+this.DataWidth/2;
                for(var i=1;i<=index;++i)
                {
                    offset+=this.DistanceWidth+this.DataWidth;
                }
            }
            else
            {
                var offset=border.TopEx-(this.DistanceWidth/2+this.DataWidth+this.DistanceWidth);
                var absIndex=Math.abs(index);
                for(var i=1;i<absIndex;++i)
                {
                    offset-=(this.DistanceWidth+this.DataWidth);
                }
            }
        }
        else
        {
            if (index < 0) index = 0;
            if (index > this.xPointCount - 1) index = this.xPointCount - 1;
    
            var border=this.ChartBorder.GetHScreenBorder();
            var offset=border.TopEx+ g_JSChartResource.FrameLeftMargin + this.DistanceWidth/2+this.DataWidth/2;
            for(var i=1;i<=index;++i)
            {
                offset+=this.DistanceWidth+this.DataWidth;
            }
        }
       
        return offset;
    }

    //画X轴
    this.DrawVertical=function()
    {
        var mapX=null;
        if (this.GetVerticalXCache) mapX=this.GetVerticalXCache();

        var border=this.ChartBorder.GetHScreenBorder();
        var left=border.Left;
        var right=border.RightTitle;
        var bottom=border.Bottom;
        var pixelRatio = GetDevicePixelRatio(); //获取设备的分辨率
        var xPrev=null; //上一个坐标x的值
        for(var i=0; i<this.VerticalInfo.length; ++i)
        {
            var item=this.VerticalInfo[i];
            var x=null;
            if (mapX && mapX.has(item.Value)) x=mapX.get(item.Value);
            else x=this.GetXFromIndex(item.Value);

            if (x>=bottom) break;
            if (xPrev!=null && Math.abs(x-xPrev)<80) continue;

            if (item.LineType==2)
            {
                this.Canvas.strokeStyle=this.VerticalInfo[i].LineColor;
                this.Canvas.setLineDash([5*pixelRatio,5*pixelRatio]);   //虚线
                this.Canvas.beginPath();
                this.Canvas.moveTo(left,ToFixedPoint(x));
                this.Canvas.lineTo(right,ToFixedPoint(x));
                this.Canvas.stroke();
                this.Canvas.setLineDash([]);
            }
            else if (item.LineType>0)
            {
                this.Canvas.strokeStyle=this.VerticalInfo[i].LineColor;
                if (g_JSChartResource.FrameXLineDash)
                {
                    this.Canvas.setLineDash(g_JSChartResource.FrameXLineDash);   //虚线
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(left,ToFixedPoint(x));
                    this.Canvas.lineTo(right,ToFixedPoint(x));
                    this.Canvas.stroke();
                    this.Canvas.setLineDash([]);
                }
                else    //实线
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(left,ToFixedPoint(x));
                    this.Canvas.lineTo(right,ToFixedPoint(x));
                    this.Canvas.stroke();
                } 
            }
            

            if (this.VerticalInfo[i].Message[0]!=null)
            {
                if (this.VerticalInfo[i].Font!=null)
                    this.Canvas.font=this.VerticalInfo[i].Font;

                this.Canvas.fillStyle=this.VerticalInfo[i].TextColor;
                var testWidth=this.Canvas.measureText(this.VerticalInfo[i].Message[0]).width;
                if (x<testWidth/2)
                {
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="top";
                }
                else
                {
                    this.Canvas.textAlign="center";
                    this.Canvas.textBaseline="top";
                }

                var xText=left,yText=x;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(this.VerticalInfo[i].Message[0], 0, this.XBottomOffset);
                this.Canvas.restore();
            }

            xPrev=x;
        }
    }

    //Y坐标转y轴数值
    this.GetYData=function(x,isLimit)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        if (isLimit===false)
        {
            var width=border.RightEx-border.LeftEx;
            return (x-border.LeftEx)/width*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
        }
        else
        {
            if (x<border.LeftEx) return this.HorizontalMin;
            if (x>border.RightEx) return this.HorizontalMax;
    
            var width=border.RightEx-border.LeftEx;
            return (x-border.LeftEx)/width*(this.HorizontalMax-this.HorizontalMin)+this.HorizontalMin;
        }
    }

    //X坐标转x轴数值
    this.GetXData=function(y,isLimit)
    {
        var border=this.ChartBorder.GetHScreenBorder();
        var left=border.TopEx+g_JSChartResource.FrameLeftMargin;
        var right=border.BottomEx;
        var distanceWidth=this.DistanceWidth;
        var dataWidth=this.DataWidth;
        var maxDataCount=10000*10;
        if (isLimit==false)
        {
            if (y<left)
            {
                var index=-1;
                var xPoint=left-(distanceWidth/2+dataWidth+distanceWidth);
                while(index>-maxDataCount)
                {
                    if (xPoint<=y) 
                        break;
                    xPoint-=(dataWidth+distanceWidth);
                    --index;
                }
    
                return index;
            }
            else
            {
                var index=0;
                var xPoint=left+distanceWidth/2+dataWidth+distanceWidth;
                while(index<maxDataCount)  //自己算x的数值
                {
                    if (xPoint>=y) break;
                    xPoint+=(dataWidth+distanceWidth);
                    ++index;
                }

                return index;
            }
        }
        else
        {
            if (y<=border.TopEx) return 0;
            if (y>=border.BottomEx) return this.XPointCount-1;

            var index=0;
            var xPoint=left+distanceWidth/2+ dataWidth+distanceWidth;
            while(xPoint<right && index<maxDataCount && index+1<this.XPointCount)  //自己算x的数值
            {
                if (xPoint>y) break;
                xPoint+=(dataWidth+distanceWidth);
                ++index;
            }
            return index;
        }

		//return (y-this.ChartBorder.GetTop())*(this.XPointCount*1.0/this.ChartBorder.GetHeight());
    }

    this.DrawBottons=function()
    {
    }

    //计算数据宽度
    /*
    this.CalculateDataWidth=function()
    {
        if (this.XPointCount<2) return;

        var width=this.ChartBorder.GetHeight()-g_JSChartResource.FrameMargin;

        for(var i=0;i<ZOOM_SEED.length;++i)
        {
            if((ZOOM_SEED[i][0] + ZOOM_SEED[i][1]) * this.XPointCount < width)
            {
                this.ZoomIndex=i;
                this.DataWidth = ZOOM_SEED[i][0];
                this.DistanceWidth = ZOOM_SEED[i][1];
                if (i == 0) break;      // 如果是最大的缩放因子，不再调整数据宽度

                this.TrimKLineDataWidth(width);
                return;
            }
        }
    }
    */

    /*
    this.ZoomUp=function(cursorIndex)
    {
        if (this.ZoomIndex<=0) return false;
        if (this.Data.DataOffset<0) return false;
        var dataCount=this.Data.Data.length;
        var maxDataCount=dataCount+this.RightSpaceCount;
        if (this.XPointCount>=dataCount) return false;

        var rightSpaceCount=0;
        var lastDataIndex = this.Data.DataOffset + this.XPointCount - 1;    //最右边的数据索引
        var lastCursorIndex=this.Data.DataOffset + cursorIndex.Index;
        if (lastDataIndex>=dataCount) 
        {
            rightSpaceCount=lastDataIndex-(dataCount-1);    //计算右边预留空间
            lastDataIndex=dataCount-1;
            if (rightSpaceCount>this.RightSpaceCount) rightSpaceCount=this.RightSpaceCount;
        }
        
        var xPointCount=this.CalculateCount(this.ZoomIndex-1);
        JSConsole.Chart.Log(`[KLineHScreenFrame::ZoomUp] old status. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${this.Data.Data.length} rightSpaceCount=${rightSpaceCount}`);
        
        --this.ZoomIndex;
        if (xPointCount>=maxDataCount) 
        {
            xPointCount=maxDataCount;
            this.XPointCount=xPointCount;
            this.Data.DataOffset=0;

            JSConsole.Chart.Log(`[KLineHScreenFrame::ZoomUp] Show all data. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount}`);
        }
        else
        {
            this.XPointCount=xPointCount;
            this.Data.DataOffset = lastDataIndex - (this.XPointCount-rightSpaceCount)+1;

            JSConsole.Chart.Log(`[KLineHScreenFrame::ZoomUp] calculate. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount} DataOffset=${this.Data.DataOffset}`);
        }

        this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
	    this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
        var width=this.ChartBorder.GetHeight()-g_JSChartResource.FrameMargin;
        this.TrimKLineDataWidth(width);
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        cursorIndex.Index=lastCursorIndex-this.Data.DataOffset;

        return true;
    }

    this.ZoomDown=function(cursorIndex)
    {
        if (this.ZoomIndex+1>=ZOOM_SEED.length) return false;
        if (this.Data.DataOffset<0) return false;
        var dataCount=this.Data.Data.length;
        var maxDataCount=dataCount+this.RightSpaceCount;
        if (this.XPointCount>=dataCount) return false;

        var rightSpaceCount=0;
        var lastDataIndex = this.Data.DataOffset + this.XPointCount - 1;    //最右边的数据索引
        if (lastDataIndex>=this.Data.Data.length) 
        {
            rightSpaceCount=lastDataIndex-(this.Data.Data.length-1);    //计算右边预留空间
            lastDataIndex=this.Data.Data.length-1;
            if (rightSpaceCount>this.RightSpaceCount) rightSpaceCount=this.RightSpaceCount;
        }

        var xPointCount=this.CalculateCount(this.ZoomIndex+1);
        var lastCursorIndex=this.Data.DataOffset + cursorIndex.Index;
        JSConsole.Chart.Log(`[KLineHScreenFrame::ZoomDown] old status. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${this.Data.Data.length} lastCursorIndex=${lastCursorIndex} rightSpaceCount=${rightSpaceCount}`);

        ++this.ZoomIndex;
        if (xPointCount>=maxDataCount) 
        {
            xPointCount=maxDataCount;
            this.XPointCount=xPointCount;
            this.Data.DataOffset=0;
            
            JSConsole.Chart.Log(`[KLineHScreenFrame::ZoomDown] Show all data. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount}`);
        }
        else
        {
            this.XPointCount=xPointCount;
            this.Data.DataOffset = lastDataIndex - (this.XPointCount-rightSpaceCount)+1;

            JSConsole.Chart.Log(`[KLineHScreenFrame::ZoomDown] calculate. XPointCount=${xPointCount} ZoomIndex=${this.ZoomIndex} DataCount= ${dataCount} DataOffset=${this.Data.DataOffset}`);
        }

        this.DataWidth = ZOOM_SEED[this.ZoomIndex][0];
	    this.DistanceWidth = ZOOM_SEED[this.ZoomIndex][1];
        var width=this.ChartBorder.GetHeight()-g_JSChartResource.FrameMargin;
        this.TrimKLineDataWidth(width);
        this.LastCalculateStatus.XPointCount=this.XPointCount;
        cursorIndex.Index=lastCursorIndex-this.Data.DataOffset;

        return true;
    }
    */
}


function OverlayKLineHScreenFrame()
{
    this.newMethod=KLineHScreenFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='OverlayKLineHScreenFrame';
    this.MainFrame=null;    //主框架
    this.IsShareY=false;    //使用和主框架公用Y轴
    this.IsCalculateYMaxMin=true;   //是否计算Y最大最小值
    this.RightOffset=50;
    this.PenBorder=g_JSChartResource.OverlayFrame.BolderPen; //'rgb(0,0,0)'
    this.IsShow=true;   //坐标是否显示
    this.Title=null;
    this.TitleColor=g_JSChartResource.OverlayFrame.TitleColor;
    this.TitleFont=g_JSChartResource.OverlayFrame.TitleFont;

    this.Draw=function()
    {
        this.SplitXYCoordinate();

        if (this.IsShow)
        {
            this.DrawVertical();
            this.DrawHorizontal();
            this.DrawTitle();
        }
        
        this.SizeChange=false;
        this.XYSplit=false;
        this.XSplit=false;
        this.YCustomSplit=false;            //自定义Y轴分割线
    }

    this.DrawTitle=function()   //画标题
    {
        /*
        if (!this.Title) return;
        var top = this.ChartBorder.GetTopTitle();
        var bottom = this.ChartBorder.GetBottom();
        var right=this.ChartBorder.GetRight();
        right+=this.RightOffset;

        this.Canvas.fillStyle=this.TitleColor;
        this.Canvas.font=this.TitleFont;
        this.Canvas.textAlign="center";
        this.Canvas.textBaseline="top";

        var xText=right-2,yText=top+(bottom-top)/2;
        this.Canvas.save();
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.fillText(this.Title, 0, 0);
        this.Canvas.restore();
        */
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) return;
        if (this.IsShareY)  //和主图指标共享Y轴坐标
        {
            this.HorizontalMax=this.MainFrame.HorizontalMax;
            this.HorizontalMin=this.MainFrame.HorizontalMin;
            this.HorizontalInfo=[];
            for(var i in this.MainFrame.HorizontalInfo)
            {
                var item=this.MainFrame.HorizontalInfo[i];
                this.HorizontalInfo.push(item);
            }
        }
        else
        {
            if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
        }
        // if (this.XSplitOperator!=null) this.XSplitOperator.Operator(); 子坐标和主坐标X轴一致 所以不用计算
    }

    //画Y轴
    this.DrawHorizontal=function()
    {
        /*
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var bottom = this.ChartBorder.GetBottom();
        var top = this.ChartBorder.GetTopTitle();
        var borderRight=this.ChartBorder.Right;
        right+=this.RightOffset;

        var yPrev=null; //上一个坐标y的值
        for(var i=this.HorizontalInfo.length-1; i>=0; --i)  //从上往下画分割线
        {
            var item=this.HorizontalInfo[i];
            var y=this.GetYFromData(item.Value);
            if (y!=null && Math.abs(y-yPrev)<this.MinYDistance) continue;  //两个坐标在近了 就不画了

            if (y >= bottom - 2) this.Canvas.textBaseline = 'bottom';
            else if (y <= top + 2) this.Canvas.textBaseline = 'top';
            else this.Canvas.textBaseline = "middle";

            this.Canvas.strokeStyle=this.PenBorder;
            this.Canvas.beginPath();
            this.Canvas.moveTo(right-2,ToFixedPoint(y));
            this.Canvas.lineTo(right,ToFixedPoint(y));
            this.Canvas.stroke();

            //坐标信息 右边 间距小于10 不画坐标
            if (item.Message[1]!=null && borderRight>10)
            {
                if (item.Font!=null) this.Canvas.font=item.Font;

                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.textAlign="left";
                this.Canvas.fillText(item.Message[1],right+2,y);
            }

            yPrev=y;
        }
        */
    }

    //画X轴
    this.DrawVertical=function()
    {
        /*
        var top=this.ChartBorder.GetTopEx();
        //var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var bottom=this.ChartBorder.GetBottomEx();
        right+=this.RightOffset;

        this.Canvas.strokeStyle=this.PenBorder;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(right),ToFixedPoint(top));
        this.Canvas.lineTo(ToFixedPoint(right),ToFixedPoint(bottom));
        this.Canvas.stroke();
        */
    }

    this.GetScaleTextWidth=function()
    {
        return { TextWidth:0 };
    }
}

function SubFrameItem()
{
    this.Frame;
    this.Height;
    this.OverlayIndex=[];   //叠加指标
    //this.Interval=60;       //子坐标间间距
}

function OverlayIndexItem()
{
    this.Frame;
    this.ChartPaint=[];
    this.Identify=Guid();
    this.Scprit;        //脚本

    this.UpdateFrameMaxMin=function()   //调整坐标最大 最小值
    {
        var value={ Max:null, Min:null }
        if (this.Frame.IsShareY)    //共享Y轴坐标
        {
            this.Frame.XYSplit=true;
            return;
        }

        if (this.Frame.YSpecificMaxMin) //固定坐标
        {
            value.Max=this.Frame.YSpecificMaxMin.Max;
            value.Min=this.Frame.YSpecificMaxMin.Min;
        }
        else
        {
            for(var i=0;i<this.ChartPaint.length;++i)
            {
                var paint=this.ChartPaint[i];
                if (paint.IsShow==false) continue;      //隐藏的图形不计算
                var range=paint.GetMaxMin();
                if (range==null || range.Max==null || range.Min==null) continue;

                if (IFrameSplitOperator.IsNumber(range.Max))
                {
                    if (value.Max==null || value.Max<range.Max) value.Max=range.Max;
                }

                if (IFrameSplitOperator.IsNumber(range.Min))
                {
                    if (value.Min==null || value.Min>range.Min) value.Min=range.Min;
                }
            }
        }

        if (!IFrameSplitOperator.IsNumber(this.Frame.YMaxMin.Max) || this.Frame.YMaxMin.Max!=value.Max)
        {
            this.Frame.YMaxMin.Max=value.Max;
            this.Frame.XYSplit=true;
        }

        if (!IFrameSplitOperator.IsNumber(this.Frame.YMaxMin.Min) || this.Frame.YMaxMin.Min!=value.Min)
        {
            this.Frame.YMaxMin.Min=value.Min;
            this.Frame.XYSplit=true;
        }

        if (this.Frame.XYSplit)
        {
            var max=10, min=0;
            if (value.Max!=null) max=value.Max;
            if (value.Min!=null) min=value.Min;

            this.Frame.HorizontalMax=max;
            this.Frame.HorizontalMin=min;  
        }
        else
        {
            this.Frame.XYSplit=true;
        }
    }
}

//行情框架
function HQTradeFrame()
{
    this.SubFrame=new Array();              //SubFrameItem 数组
    this.SizeChange=true;                   //大小是否改变
    this.ChartBorder;
    this.Canvas;                            //画布
    this.ScreenImageData;                   //截图
    this.Data;                              //主数据
    this.Position;                          //画布的位置
    this.SizeChange=true;
    this.MinSubFrameHeight=g_JSChartResource.DragSubFrameBorder.MinFrameHeight;
    this.DragBorderHeight=g_JSChartResource.DragSubFrameBorder.TopBorderHeight; //拖拽边框高度

    this.AutoLeftBorder=null;       //{ Blank:10 留白宽度, MinWidth:最小宽度 }
    this.AutoRightBorder=null;      //{ Blank:10 留白宽度, MinWidth:最小宽度 } 
    this.OverlayBlankWidth=30;
    this.AuotRightWidth;            //右边主坐标刻度宽度 (自动模式)

    //固定模式右侧宽度
    this.FixedRightWidth={ Main:60, Overlay:80 };

    this.ZoomWindowsInfo=null;      //附图指标缩放,备份信息
    this.ZoomStartWindowIndex=1;    //允许缩放窗口起始位置

    this.GetExtendChartByClassName;
    this.GetEventCallback;

    this.OnMoveFromeBorder=function(index, yMove)
    {
        if (this.SubFrame.length<=0) return false;

        var topFrame=this.SubFrame[index];
        var bottomFrame=null;
        for(var i=index+1;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (item.Height>0)
            {
                bottomFrame=item;
                break;
            }
        }

        if (!topFrame || !bottomFrame) return false;

        var bottomBackup=topFrame.Frame.ChartBorder.Bottom;
        var topBackup=bottomFrame.Frame.ChartBorder.Top;

        topFrame.Frame.ChartBorder.Bottom-=yMove;
        bottomFrame.Frame.ChartBorder.Top+=yMove;

        var height=topFrame.Frame.ChartBorder.GetHeightEx();
        var height2=bottomFrame.Frame.ChartBorder.GetHeightEx();
        
        //缩小的时候 小于最小高度 不处理
        if ((height<this.MinSubFrameHeight && yMove<0) || (height2<this.MinSubFrameHeight && yMove>0)) 
        {
            topFrame.Frame.ChartBorder.Bottom=bottomBackup;
            bottomFrame.Frame.ChartBorder.Top=topBackup;
            return false;
        }
        
        return true;
    }

    this.ReDrawToolbar=function()
    {
        for(var i in this.SubFrame)
        {
            this.SubFrame[i].Frame.ReDrawToolbar=true;
        }
    }

    this.SetFrameBorderSizeChange=function()
    {
        var firstFrame=this.SubFrame[0];
        if (!firstFrame || !firstFrame.Frame) return;

        var splitOper=firstFrame.Frame.YSplitOperator;  
        if (!splitOper) return;
        if (splitOper.CoordinateType==2) //对数坐标 需要重新计算Y轴分割
        {
            firstFrame.Frame.XYSplit=true;
        }
    }

    this.CancelZoomUpDownFrameY=function(obj)
    {
        var index=obj.Index;
        if (this.SubFrame.length<=0) return false;
        if (!this.SubFrame[index]) return false;

        var subFrame=this.SubFrame[index];
        var frame=subFrame.Frame;
        if (obj.IsOverlay)
        {
            var overlayItem=subFrame.OverlayIndex[obj.OverlayIndex];
            if (!overlayItem) return false;
            if (!overlayItem.Frame.IsShareY) frame=overlayItem.Frame;
        }
        var splitOper=frame.YSplitOperator;

        if (splitOper.FixedYMaxMin)
        {
            splitOper.FixedYMaxMin=null;
            splitOper.EnableZoomUpDown=false;
            frame.XYSplit=true;
            for(var i in subFrame.OverlayIndex)
            {
                var item=subFrame.OverlayIndex[i];
                if (item.Frame.IsShareY) item.Frame.XYSplit=true;
            }
            
            JSConsole.Chart.Log(`[HQTradeFrame::CancelZoomUpDownFrameY]`);
            return true;
        }

        return false;
    }

    this.OnZoomUpDownFrameY=function(obj, yMove)
    {
        var index=obj.Index;
        if (this.SubFrame.length<=0) return false;
        if (!this.SubFrame[index]) return false;

        var subFrame=this.SubFrame[index];
        var frame=subFrame.Frame;
        if (obj.IsOverlay)
        {
            var overlayItem=subFrame.OverlayIndex[obj.OverlayIndex];
            if (!overlayItem) return false;
            if (!overlayItem.Frame.IsShareY) frame=overlayItem.Frame;
        }
       
        var top=frame.ChartBorder.GetTopEx();
        var bottom=frame.ChartBorder.GetBottomEx();

        var maxValue=frame.HorizontalMax;
        var minValue=frame.HorizontalMin;

        var moveStep=(maxValue-minValue)*Math.abs(yMove)/(bottom-top);

        var splitOper=frame.YSplitOperator;

        var newFixedYMaxMin={ Max:maxValue, Min:minValue };
        if (obj.Position==1)
        {
            var step=yMove>0 ? -moveStep:moveStep;
            newFixedYMaxMin.Max+=step;
        }
        else if (obj.Position==2)
        {
            var step=yMove>0 ? -moveStep:moveStep;
            newFixedYMaxMin.Min+=step;
        }
        else if (obj.Position==0)
        {
            var step=yMove>0 ? moveStep:-moveStep;
            newFixedYMaxMin.Max+=step;
            newFixedYMaxMin.Min-=step;
        }
        else
        {
            return false;
        }

        if (newFixedYMaxMin.Max>newFixedYMaxMin.Min) 
        {
            splitOper.FixedYMaxMin=newFixedYMaxMin;
            splitOper.EnableZoomUpDown=true;
            frame.XYSplit=true;

            for(var i=0;i<subFrame.OverlayIndex.length;++i)
            {
                var item=subFrame.OverlayIndex[i];
                if (item.Frame.IsShareY) item.Frame.XYSplit=true;
            }
            
            JSConsole.Chart.Log(`[HQTradeFrame::OnZoomUpDownFrameY] Max=${newFixedYMaxMin.Max}, Min=${newFixedYMaxMin.Min}`);
            return true;
        }

        return false;
    }

    this.OnUpDonwFrameY=function(obj, yMove)
    {
        var index=obj.Index;
        if (this.SubFrame.length<=0) return false;
        if (!this.SubFrame[index]) return false;

        var subFrame=this.SubFrame[index];
        var frame=subFrame.Frame;
        var top=frame.ChartBorder.GetTopEx();
        var bottom=frame.ChartBorder.GetBottomEx();
        var splitOper=frame.YSplitOperator;
        if (!splitOper) return false;

        var maxValue=frame.HorizontalMax;
        var minValue=frame.HorizontalMin;

        var moveStep=(maxValue-minValue)*Math.abs(yMove)/(bottom-top);
        var step=yMove>0 ? -moveStep:moveStep;
        var newFixedYMaxMin={ Max:maxValue, Min:minValue };
        newFixedYMaxMin.Max-=step;
        newFixedYMaxMin.Min-=step;

        splitOper.FixedYMaxMin=newFixedYMaxMin;
        splitOper.EnableZoomUpDown=true;
        frame.XYSplit=true;

        for(var i in subFrame.OverlayIndex)
        {
            var item=subFrame.OverlayIndex[i];
            if (item.Frame.IsShareY) item.Frame.XYSplit=true;
        }
        
        JSConsole.Chart.Log(`[HQTradeFrame::OnUpDonwFrameY] Max=${newFixedYMaxMin.Max}, Min=${newFixedYMaxMin.Min}, yMove=${yMove}, moveStep=${moveStep}`);
        return true;
    }

    this.ClearUpDonwFrameYData=function(option)   //清空上下拖拽的数据
    {
        if (this.SubFrame.length<=0) return;

        if (option)
        {
            var index=option.Index;
            if (index<0 || index>=this.SubFrame.length) return;

            var item=this.SubFrame[index];
            if (!item || !item.Frame || !item.Frame.YSplitOperator) return;

            var splitOper=item.Frame.YSplitOperator;
            if (splitOper.EnableZoomUpDown==true) splitOper.FixedYMaxMin=null;
        }
        else
        {
            for(var i=0;i<this.SubFrame.length;++i)
            {
                var item=this.SubFrame[i];
                if (!item || !item.Frame || !item.Frame.YSplitOperator) continue;
    
                var splitOper=item.Frame.YSplitOperator;
                if (splitOper.EnableZoomUpDown==true) splitOper.FixedYMaxMin=null;
            }
        }
    }

    this.ClearCoordinateText=function(option) //清空X，Y轴刻度文字， 线段保留
    {
        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (!item.Frame) continue;

            item.Frame.ClearCoordinateText(option);
        }
    }

    

    this.RestoreIndexWindows=function()
    {
        if (!this.ZoomWindowsInfo) return false;

        var subFrame=this.SubFrame[this.ZoomWindowsInfo.FrameID];

        for(var i=this.ZoomStartWindowIndex;i<this.ZoomWindowsInfo.Data.length; ++i)
        {
            var restoreItem=this.ZoomWindowsInfo.Data[i];
            var frameItem=this.SubFrame[i];
            frameItem.Height=restoreItem.Height;
            frameItem.Frame.IsMinSize=false;
            frameItem.Frame.ReDrawToolbar=true;
            frameItem.Frame.XSplitOperator.ShowText=restoreItem.ShowXText;
            frameItem.Frame.XYSplit=true;

            for(var j=0; j<frameItem.OverlayIndex.length; ++j)
            {
                var overlayItem=frameItem.OverlayIndex[j];
                overlayItem.Frame.IsMinSize=false;
            }
        }

        this.ZoomWindowsInfo=null;

        return true;
    }

    this.ZoomIndexWindow=function(frameID, option)
    {
        var subFrame=this.SubFrame[frameID];
        if (!subFrame) return false;

        subFrame.Frame.ChartBorder.IsShowTitleOnly=false;

        if (this.ZoomWindowsInfo)   //还原
        {
            return this.RestoreIndexWindows();
        }
        else    //放大
        {
            var zoomInfo={ FrameID:frameID, Data:[] };    //备份下放大前各个窗口的高度
            for(var i=0; i<this.SubFrame.length; ++i)
            {
                var item=this.SubFrame[i];
                zoomInfo.Data[i]={ Height:item.Height, ShowXText:item.Frame.XSplitOperator.ShowText };
            }
            this.ZoomWindowsInfo=zoomInfo;

            var totalHeight=0;
            for(var i=this.ZoomStartWindowIndex;i<this.SubFrame.length;++i)
            {
                var item=this.SubFrame[i];
                var frame=item.Frame;
                frame.XYSplit=true;
                
                totalHeight+=item.Height;
                
                if (i!=frameID)
                {
                    item.Height=0;
                    frame.IsMinSize=true;  //最小化
                    frame.HideToolbar();
                    frame.XSplitOperator.ShowText=false;

                    for(var j=0; j<item.OverlayIndex.length; ++j)
                    {
                        var overlayItem=item.OverlayIndex[j];
                        overlayItem.Frame.IsMinSize=true;
                    }
                }
            }
            subFrame.Height=totalHeight;
            subFrame.Frame.XSplitOperator.ShowText=true;

            return true;
        }
    }

    //保存高度比例
    this.SaveSubFrameHeightRate=function()
    {
        var height=this.ChartBorder.GetHeight();

        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var subHeight=item.Frame.ChartBorder.GetHeight();
            var rate=(subHeight/height)*100;
            item.Height=rate;
        }
    }

    this.ShowIndexTitleOnly=function(frameID, option)
    {
        var item=this.SubFrame[frameID];
        if (!item && !item.Frame) return false;
        var frame=item.Frame;
        if (!frame.ChartBorder) return false;

        var subChartBorder=frame.ChartBorder;
        if (subChartBorder.TitleHeight<10) return false;

        this.RestoreIndexWindows();

        if (subChartBorder.IsShowTitleOnly)
        {
            subChartBorder.IsShowTitleOnly=false;
        }
        else
        {
            subChartBorder.IsShowTitleOnly=true;
        }

        return true;
    }

    this.CalculateChartBorder=function()    //计算每个子框架的边框信息
    {
        if (this.SubFrame.length<=0) return;

        var top=this.ChartBorder.GetTop();
        var height=this.ChartBorder.GetHeight();
        var totalHeight=0;
        var totalTitleHeight=0;
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var frame=item.Frame;
            if (frame && frame.ChartBorder && frame.ChartBorder.IsShowTitleOnly && item.Height>0)
                totalTitleHeight+=frame.ChartBorder.TitleHeight;
            else
                totalHeight+=item.Height;
        }

        height-=totalTitleHeight;
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var frame=item.Frame;

            item.Frame.ChartBorder.Top=top;
            item.Frame.ChartBorder.Left=this.ChartBorder.Left;
            item.Frame.ChartBorder.Right=this.ChartBorder.Right;
            item.Frame.ChartBorder.LeftExtendWidth=this.ChartBorder.LeftExtendWidth;
            item.Frame.ChartBorder.RightExtendWidth=this.ChartBorder.RightExtendWidth;

            if (frame && frame.ChartBorder && frame.ChartBorder.IsShowTitleOnly && item.Height>0)
            {
                var frameHeight=item.Frame.ChartBorder.Top+frame.ChartBorder.TitleHeight;
                item.Frame.ChartBorder.Bottom=this.ChartBorder.GetChartHeight()-frameHeight;
                top=frameHeight;
            }
            else
            {
                var frameHeight=height*(item.Height/totalHeight)+top;
                item.Frame.ChartBorder.Bottom=this.ChartBorder.GetChartHeight()-frameHeight;
                top=frameHeight;
            }
        }

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SIZE_FRAME);
            if (event && event.Callback)
            {
                var sendData={ SubFrame:this.SubFrame };
                event.Callback(event, sendData, this);
            }
        }
    }

    this.SetExtendWidth=function(obj)
    {
        if (!obj) return;
        var leftWidth=null, rightWidth=null;
        if (IFrameSplitOperator.IsNumber(obj.Left)) 
        {
            leftWidth=obj.Left;
            this.ChartBorder.LeftExtendWidth=leftWidth;
        }

        if (IFrameSplitOperator.IsNumber(obj.Right)) 
        {
            rightWidth=obj.Right;
            this.ChartBorder.RightExtendWidth=rightWidth;
        }

        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            if (leftWidth!=null) item.Frame.ChartBorder.LeftExtendWidth=leftWidth;
            if (rightWidth!=null) item.Frame.ChartBorder.RightExtendWidth=rightWidth;
        }
    }

    this.CalculateChartBorder2=function()   //计算每个子框架的边框信息(思维导图用)
    {
        if (this.SubFrame.length<=0) return;

        var top=this.ChartBorder.Top;
        var bottom=this.ChartBorder.Bottom;
        var height=this.ChartBorder.GetHeight();
        var totalHeight=0;

        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            totalHeight+=item.Height;
        }

        var tempHeight=0;
        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            item.Frame.ChartBorder.Top=top;
            item.Frame.ChartBorder.Left=this.ChartBorder.Left;
            item.Frame.ChartBorder.Right=this.ChartBorder.Right;
            item.Frame.ChartBorder.X=this.ChartBorder.X;
            item.Frame.ChartBorder.Y=this.ChartBorder.Y;
            item.Frame.ChartBorder.Width=this.ChartBorder.Width;
            item.Frame.ChartBorder.Height=this.ChartBorder.Height;
            var frameHeight=height*(item.Height/totalHeight);
            tempHeight+=frameHeight;
            bottom=this.ChartBorder.Bottom+(height-tempHeight);
            item.Frame.ChartBorder.Bottom=bottom;
            top+=frameHeight;
        }
    }

    this.GetScaleTextWidth=function()
    {
        var width={ Left:null, Right:null, OverlayRight:0 };
        var aryOverlayWidth=[];// 叠加坐标
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            if (item.Height<=0) continue;
            var frame=item.Frame;
            if (!frame) continue;
            if (!frame.XSplitOperator) continue; 
            
            var maxValue=frame.HorizontalMax;   //最大最小要还原
            var minValue=frame.HorizontalMin;

            frame.YSplitOperator.Operator();
            var value=frame.GetScaleTextWidth();

            //数据原始范围存储在YMaxMin, 不需要还原HorizontalMax,HorizontalMin
            //frame.HorizontalMax=maxValue;
            //frame.HorizontalMin=minValue;

            if (value && value.TextWidth)
            {
                var widthItem=value.TextWidth;
                if (IFrameSplitOperator.IsNumber(widthItem.Left))
                {
                    if (width.Left==null || width.Left<widthItem.Left) width.Left=widthItem.Left;
                }

                if (IFrameSplitOperator.IsNumber(widthItem.Right))
                {
                    if (width.Right==null || width.Right<widthItem.Right) width.Right=widthItem.Right;
                }
            }

            //右侧叠加指标
            if (IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex))
            {
                for(var j=0, k=0; j<item.OverlayIndex.length; ++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    if (!overlayItem.Frame) continue;

                    if (overlayItem.Frame.IsShareY)
                    {
                        if (overlayItem.Frame.SyncMainHorizontalInfo)
                            overlayItem.Frame.SyncMainHorizontalInfo();

                        var value=overlayItem.Frame.GetScaleTextWidth();
                    }
                    else
                    {
                        var maxValue=overlayItem.Frame.HorizontalMax;   //最大最小要还原
                        var minValue=overlayItem.Frame.HorizontalMin;
    
                        overlayItem.Frame.YSplitOperator.Operator();
                        var value=overlayItem.Frame.GetScaleTextWidth();
                        
                        //数据原始范围存储在YMaxMin, 不需要还原HorizontalMax,HorizontalMin
                        //overlayItem.Frame.HorizontalMax=maxValue;
                        //overlayItem.Frame.HorizontalMin=minValue;
                    }

                    overlayItem.RightWidth={ Index:-1, Width:0 }; 
                    if (!value || !value.TextWidth) continue;
                    var widthItem=value.TextWidth;
                    if (!IFrameSplitOperator.IsNumber(widthItem.Right)) continue;

                    overlayItem.RightWidth.Index=k;
                    overlayItem.RightWidth.Width=widthItem.Right;
                    
                    if (aryOverlayWidth[k])
                    {
                        aryOverlayWidth[k][i]=overlayItem.RightWidth;
                    }
                    else
                    {
                        aryOverlayWidth[k]=[];
                        aryOverlayWidth[k][i]=overlayItem.RightWidth;
                    }

                    ++k;
                }
            }
        }

        var overlayWidth=[];
        for(var i=0; i<aryOverlayWidth.length; ++i)
        {
            var colItem=aryOverlayWidth[i];
            var max=0;
            for(var j=0; j<colItem.length; ++j)
            {
                if (!colItem[j]) continue;
                var item=colItem[j].Width;
                if (max<item) max=item;
            }

            if (max>0) max+=this.OverlayBlankWidth

            for(var j=0; j<colItem.length; ++j)
            {
                if (!colItem[j]) continue;
                colItem[j].Width=max;
            }

            overlayWidth[i]=max;
        }

        for(var i=0;i<overlayWidth.length;++i)
        {
            var value=overlayWidth[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;
            width.OverlayRight+=value;
        }

        width.AryOverlayWidth=overlayWidth;

        return width;
    }

    this.IsFrameXYSplit=function()
    {
        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            if (item.Frame.XYSplit) return true;

            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Frame.XYSplit) return true;
            }

        }
        return false;
    }

    this.Draw=function(option)
    {
        if (this.SizeChange===true) 
        {
            this.CalculateChartBorder();
        }

        var isSplash=false; //是否过场动画
        if (option && option.IsEnableSplash===true) isSplash=true;
        if (isSplash==false && (this.AutoLeftBorder || this.AutoRightBorder) && this.IsFrameXYSplit())
        {
            this.AutoRightOverlayWidth=[];
            var textWidth=this.GetScaleTextWidth();
            var bSizeChange=false;
            if (IFrameSplitOperator.IsNumber(textWidth.Left) && this.AutoLeftBorder)
            {
                var blank=0;
                if (IFrameSplitOperator.IsNumber(this.AutoLeftBorder.Blank)) blank=this.AutoLeftBorder.Blank;
                var value=textWidth.Left+blank;
                if (IFrameSplitOperator.IsNumber(this.AutoLeftBorder.MinWidth))
                {
                    if (this.AutoLeftBorder.MinWidth>value) value=this.AutoLeftBorder.MinWidth;
                }
                if (this.IsHScreen) this.ChartBorder.Top=value;
                else this.ChartBorder.Left=value;

                for(var i=0; i<this.SubFrame.length; ++i)
                {
                    var item=this.SubFrame[i];
                    if (this.IsHScreen) item.Frame.ChartBorder.Top=value;
                    else item.Frame.ChartBorder.Left=value;
                }
            }

            if (IFrameSplitOperator.IsNumber(textWidth.Right))
            {
                if (this.AutoRightBorder)   //自动调整右侧间距
                {
                    var rightTextInfo={ };
                    var blank=0;
                    if (IFrameSplitOperator.IsNumber(this.AutoRightBorder.Blank)) blank=this.AutoRightBorder.Blank;
                    var value=textWidth.Right+blank;
                    if (IFrameSplitOperator.IsNumber(this.AutoRightBorder.MinWidth))
                    {
                        if (this.AutoRightBorder.MinWidth>value) value=this.AutoRightBorder.MinWidth;
                    }

                    this.AuotRightWidth=value;
                    rightTextInfo.MainTextWidth=value;  //主图坐标宽度
                    if (IFrameSplitOperator.IsNonEmptyArray(textWidth.AryOverlayWidth)) rightTextInfo.AryOverlayWidth=textWidth.AryOverlayWidth;

                    if (IFrameSplitOperator.IsPlusNumber(textWidth.OverlayRight))
                    {
                        this.AuotRightWidth=value;
                        value+=textWidth.OverlayRight;
                    }

                    if (this.GetExtendChartRightWidth)
                    {
                        var extendWidth=this.GetExtendChartRightWidth();

                        if (this.GetExtendChartByClassName)
                        {
                            var finder=this.GetExtendChartByClassName("StockChip");
                            if (finder && finder.Chart) 
                            {
                                finder.Chart.Left=value;
                            }
                        }

                        value+=extendWidth;
                    }

                    if (this.IsHScreen) 
                    {
                        if (this.ChartBorder.Bottom!=value) bSizeChange=true;
                        this.ChartBorder.Bottom=value;
                    }
                    else  
                    {
                        if (this.ChartBorder.Right!=value) bSizeChange=true;
                        this.ChartBorder.Right=value;
                    }

                    for(var i=0; i<this.SubFrame.length; ++i)
                    {
                        var item=this.SubFrame[i];
                        if (this.IsHScreen) item.Frame.ChartBorder.Bottom=value;
                        else item.Frame.ChartBorder.Right=value;

                        item.Frame.ReDrawToolbar=true;
                        item.Frame.YRightTextInfo=rightTextInfo;

                        for(var j=0;j<item.OverlayIndex.length;++j)
                        {
                            var overlayItem=item.OverlayIndex[j];
                            overlayItem.Frame.YRightTextInfo=rightTextInfo;
                        }
                    }
                }
                else
                {
                    var rightTextInfo={ };
                    rightTextInfo.MainTextWidth=this.FixedRightWidth.Main;
                    if (textWidth.OverlayRight==0) //无叠加直接最右边
                    {
                        if (this.IsHScreen)
                            rightTextInfo.MainTextWidth=this.ChartBorder.Bottom;
                        else 
                            rightTextInfo.MainTextWidth=this.ChartBorder.Right;
                    }
                    else if (IFrameSplitOperator.IsNonEmptyArray(textWidth.AryOverlayWidth))
                    {
                        for(var i=0;i<textWidth.AryOverlayWidth.length;++i) 
                            textWidth.AryOverlayWidth[i]=this.FixedRightWidth.Overlay;

                        rightTextInfo.AryOverlayWidth=textWidth.AryOverlayWidth;
                    }

                    for(var i=0; i<this.SubFrame.length; ++i)
                    {
                        var item=this.SubFrame[i];

                        item.Frame.ReDrawToolbar=true;
                        item.Frame.YRightTextInfo=rightTextInfo;

                        for(var j=0;j<item.OverlayIndex.length;++j)
                        {
                            var overlayItem=item.OverlayIndex[j];
                            overlayItem.Frame.YRightTextInfo=rightTextInfo;
                        }
                    }
                }
            }

            this.SetSizeChage(true);
        }

        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            if (item.Height<=0) continue;

            item.Frame.Draw();

            if (this.AutoRightBorder)
            {
                var rightOffset=this.AuotRightWidth;

                for(var j=0, index=0; j<item.OverlayIndex.length; ++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    //把主坐标部分设置给子坐标下来
                    overlayItem.Frame.DataWidth=item.Frame.DataWidth;
                    overlayItem.Frame.DistanceWidth=item.Frame.DistanceWidth;
                    overlayItem.Frame.XPointCount=item.Frame.XPointCount;
                    overlayItem.Frame.RightOffset=rightOffset;
                    overlayItem.Frame.BlankWidth=0;
                    overlayItem.Frame.TextWidthIndex=index;
                    if (IFrameSplitOperator.IsNumber(this.OverlayBlankWidth)) overlayItem.Frame.BlankWidth=this.OverlayBlankWidth;
                    
                    overlayItem.Frame.Draw();
                    if (overlayItem.RightWidth) rightOffset+=overlayItem.RightWidth.Width;
                    if (overlayItem.Frame.IsShow) ++index;
                }
            }
            else
            {
                var rightOffset=this.FixedRightWidth.Main;
                if (item.Frame.RightTextMaxWidth>rightOffset) rightOffset=item.Frame.RightTextMaxWidth;

                for(var j =0, index=0; j<item.OverlayIndex.length;++j)
                {
                    var overlayItem=item.OverlayIndex[j];
                    //把主坐标部分设置给子坐标下来
                    overlayItem.Frame.DataWidth=item.Frame.DataWidth;
                    overlayItem.Frame.DistanceWidth=item.Frame.DistanceWidth;
                    overlayItem.Frame.XPointCount=item.Frame.XPointCount;
                    overlayItem.Frame.RightOffset=rightOffset;
                    overlayItem.Frame.BlankWidth=0;
                    overlayItem.Frame.TextWidthIndex=index;
                    if (IFrameSplitOperator.IsNumber(this.OverlayBlankWidth)) overlayItem.Frame.BlankWidth=this.OverlayBlankWidth;

                    overlayItem.Frame.Draw();
                    if (overlayItem.Frame.IsShow) 
                    {
                        rightOffset+=this.FixedRightWidth.Overlay;
                        ++index;
                    }
                    
                }
            }
        }

        this.SizeChange=false;
    }

    this.DrawOveraly=function(bDrawFirst)
    {
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            if (item.Height<=0) continue;   //高度是0 不画

            for(var j=0;j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                for(var k=0; k<overlayItem.ChartPaint.length; ++k)
                {
                    var chartItem=overlayItem.ChartPaint[k];
                    if (chartItem.IsShow)
                    {
                        if (bDrawFirst)
                        {
                            if (chartItem.IsDrawFirst) chartItem.Draw();
                        }
                        else
                        {
                            if (!chartItem.IsDrawFirst) chartItem.Draw();
                        }
                    }
                }
            }
        }
    }

    this.DrawOveralySelectedStatus=function(selectedInfo)
    {
        if (!selectedInfo.MoveOn.Identify && !selectedInfo.Selected.Identify) return;

        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            for(var j in item.OverlayIndex)
            {
                var overlayItem=item.OverlayIndex[j];
                for(var k in overlayItem.ChartPaint)
                {
                    var chart=overlayItem.ChartPaint[k];
                    if (!chart.IsShow) continue;
                    if (!chart.Identify) continue;
                    if (chart.Identify!=selectedInfo.MoveOn.Identify && chart.Identify!=selectedInfo.Selected.Identify) continue;
                    if (chart.DrawSelectedStatus) 
                        chart.DrawSelectedStatus();
                }
            }
        }
    }

    this.PtInOveralyChart=function(x,y)
    {
        var result=null;
        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            for(var j in item.OverlayIndex)
            {
                var overlayItem=item.OverlayIndex[j];
                for(var k in overlayItem.ChartPaint)
                {
                    var chart=overlayItem.ChartPaint[k];
                    if (!chart.IsShow) continue;
                    if (chart.IsHideScriptIndex()) continue;
                    if (chart.PtInChart) 
                    {
                        result=chart.PtInChart(x,y);
                        if (result) 
                            return result;
                    }
                }
            }
        }

        return null;
    }

    this.DrawPictureCoordinate=function(drawPicture, option)
    {
        if (!drawPicture || !drawPicture.Frame) return false;
        if (!IFrameSplitOperator.IsNonEmptyArray(drawPicture.Point)) return false;
        if (!drawPicture.GetXYCoordinate) return false;

        var range=drawPicture.GetXYCoordinate();
        if (range && range.IsShowYCoordinate===false)   //隐藏Y轴刻度信息
        {
            
        }
        else
        {
            drawPicture.Frame.DrawPictureYCoordinate(drawPicture, range, option);
        }

        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (!item || !item.Frame) continue;
            if (!item.Frame.XSplitOperator.ShowText) continue;

            item.Frame.DrawPictureXCoordinate(drawPicture, range, option);
            break;
        }

        return true;
    }

    this.DrawLock=function()
    {
        for (var i in this.SubFrame)
        {
            var item = this.SubFrame[i];
            item.Frame.DrawLock();
        }
    }

    this.DrawLogo=function()
    {
        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (item.Frame.DrawLogo)
            {
                item.Frame.DrawLogo();
                break;
            }
        }
    }

    this.CalculateLock=function()
    {
        for (var i in this.SubFrame)
        {
            var item = this.SubFrame[i];
            item.Frame.CalculateLock();
        }
    }

    this.DrawInsideHorizontal = function () 
    {
        for (var i in this.SubFrame) 
        {
          var item = this.SubFrame[i];
          if (item.Height<=0) continue;
          if (item.Frame.DrawInsideHorizontal) item.Frame.DrawInsideHorizontal();
        }
    }

    this.DrawCustomHorizontal=function()    //定制Y轴自定义刻度
    {
        for (var i in this.SubFrame) 
        {
            var item = this.SubFrame[i];
            if (item.Frame.DrawCustomHorizontal) item.Frame.DrawCustomHorizontal();

            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Frame && overlayItem.Frame.DrawCustomHorizontal) 
                    overlayItem.Frame.DrawCustomHorizontal();
            }           
        }
    }

    this.DrawEx=function(option)
    {
        for(var i in this.SubFrame)
        {
            var item = this.SubFrame[i];
            if ((item.Frame.ClassName=="MinuteFrame"||item.Frame.ClassName=="MinuteHScreenFrame")  && i==1)
            {
                item.Frame.DrawVolTitle(option.Symbol);
            }
        }
    }

    this.DrawCustomVertical=function(event)
    {
        for (var i=0; i<this.SubFrame.length; ++i) 
        {
            var item = this.SubFrame[i];
            item.Frame.DrawCustomVerticalEvent=event;
            if (item.Frame.DrawCustomVertical) item.Frame.DrawCustomVertical();     
        }
    }

    this.DrawToolbar=function(mouseStatus)
    {
        var moveonPoint=null;
        if (mouseStatus && mouseStatus.MoveOnPoint) moveonPoint=mouseStatus.MoveOnPoint;
        for (var i=0; i<this.SubFrame.length; ++i)
        {
            var item = this.SubFrame[i];
            if (item.Height<=0) continue;
            var frame=item.Frame;
            if (!frame) continue;
            
            if (frame.ToolbarButtonStyle==1)
            {
                if (frame.DrawToolbarV2) frame.DrawToolbarV2(moveonPoint, mouseStatus);
            }

            for(var j=0;j<item.OverlayIndex.length;++j)
            {
                var overlayItem=item.OverlayIndex[j];
                var overlayFrame=overlayItem.Frame;
                if (!overlayFrame.IsShow) continue;
                if (overlayFrame.DrawToolbar) overlayFrame.DrawToolbar(moveonPoint, frame.IsMinSize, mouseStatus);
            }
        }
    }

    this.SetSizeChage=function(sizeChange)
    {
        this.SizeChange=sizeChange;

        for(var i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            item.Frame.SizeChange=sizeChange;

            for(var j in item.OverlayIndex)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Frame) overlayItem.Frame.SizeChange=sizeChange;
            }
        }

        //画布的位置
        if (this.ChartBorder.UIElement)
        {
            this.Position={
                X:this.ChartBorder.UIElement.offsetLeft,
                Y:this.ChartBorder.UIElement.offsetTop,
                W:this.ChartBorder.UIElement.clientWidth,
                H:this.ChartBorder.UIElement.clientHeight
            };
        }
    }

    this.SetBeforeDrawXYCallback=function(callback)
    {
        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            item.Frame.BeforeDrawXYCallback=callback;
        }
    }

    //图形快照
    this.Snapshot=function()
    {
        this.ScreenImageData=this.Canvas.getImageData(0,0,this.ChartBorder.GetChartWidth(),this.ChartBorder.GetChartHeight());
    }

    this.GetXData=function(x)
    {
        return this.SubFrame[0].Frame.GetXData(x);
    }

    this.GetYData=function(y,outObject) //outObject 可以保存返回的额外数据
    {
        var frame;
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var left=item.Frame.ChartBorder.GetLeft();
            var top=item.Frame.ChartBorder.GetTopEx();
            var width=item.Frame.ChartBorder.GetWidth();
            var height=item.Frame.ChartBorder.GetHeightEx();

            item.Frame.Canvas.beginPath();
            item.Frame.Canvas.rect(left,top,width,height);
            if (item.Frame.Canvas.isPointInPath(left,y))
            {
                frame=item.Frame;
                if (outObject) outObject.FrameID=i;
                break;
            }
        }

        if (frame!=null) 
        {
            if (frame.RightFrame) outObject.RightYValue=frame.RightFrame.GetYData(y);    //右侧子坐标

            var yValue=frame.GetYData(y);
            if (frame.YSplitOperator.CoordinateType==1) //百分比坐标 右边显示百分比信息
            {
                var  firstOpenPrice=frame.YSplitOperator.GetFirstOpenPrice();
                outObject.RightYValue=((yValue-firstOpenPrice)/firstOpenPrice*100).toFixed(2)+'%';
            }

            if (frame.GetMainOverlayFrame)
            {
                var aryOverlayFrame=frame.GetMainOverlayFrame();
                if (aryOverlayFrame) 
                {
                    if (aryOverlayFrame[0]) //左侧
                    {
                        var leftFrame=aryOverlayFrame[0];
                        var value=leftFrame.GetYData(y);
                        outObject.RightYValue=yValue;
                        yValue=value;
                    }

                    if (aryOverlayFrame[1]) //右侧
                    {
                        var rightFrame=aryOverlayFrame[1];
                        var value=rightFrame.GetYData(y);
                        outObject.RightYValue=value;
                    }
                }
            }

            return yValue;
        }
    }

    this.PtInFrame=function(x,y)    //鼠标哪个指标窗口
    {
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var left=item.Frame.ChartBorder.GetLeft();
            var top=item.Frame.ChartBorder.GetTop();
            var width=item.Frame.ChartBorder.GetWidth();
            var height=item.Frame.ChartBorder.GetHeight();

            item.Frame.Canvas.beginPath();
            item.Frame.Canvas.rect(left,top,width,height);
            if (item.Frame.Canvas.isPointInPath(x,y))
            {
                return i;   //转成整形
            }
        }

        var bottom=this.ChartBorder.GetBottom();
        var chartHeight=this.ChartBorder.GetChartHeight();
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();

        //底部
        if (x>=left && x<=right && y>bottom && y<chartHeight) 
            return -3;

        return -1;
    }

    this.PtInChartFrame=function(x,y)   //鼠标在图形区域, 取出上下空白
    {
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var left=item.Frame.ChartBorder.GetLeft();
            var top=item.Frame.ChartBorder.GetTopEx();
            var width=item.Frame.ChartBorder.GetWidth();
            var height=item.Frame.ChartBorder.GetHeightEx();

            item.Frame.Canvas.beginPath();
            item.Frame.Canvas.rect(left,top,width,height);
            if (item.Frame.Canvas.isPointInPath(x,y))
            {
                return i;   //转成整形
            }
        }

        return -1;
    }

    this.PtInButtons=function(x,y)
    {
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            if (item.Height<=0) continue;
            var button=item.Frame.PtInButtons(x,y);
            if (button) 
            {
                button.Frame=item.Frame;
                button.FrameID=i;
                return button;
            }

            for(var j=0;j<item.OverlayIndex.length;++j)
            {
                var overlayItem=item.OverlayIndex[j];
                var overlayFrame=overlayItem.Frame;
                if (!overlayFrame || !overlayFrame.PtInButtons) continue;
                var button=overlayFrame.PtInButtons(x,y);
                if (button) 
                {
                    button.IndexID=overlayItem.Identify;
                    button.FrameID=i;
                    button.OverlayFrame=overlayFrame;
                    button.Frame=item.Frame;
                    return button;
                }
                    
            }
        }

        return null
    }

    //是否在X轴坐标上
    this.PtInFrameBottom=function(x,y)
    {
        var left=this.ChartBorder.GetLeft();
        var top=this.ChartBorder.GetBottom();
        var width=this.ChartBorder.GetWidth();
        var height=this.ChartBorder.Bottom;
        
        this.Canvas.beginPath();
        this.Canvas.rect(left,top,width,height);
        if (this.Canvas.isPointInPath(x,y)) return true;
        return false;
    }

    this.PtInFrameVertical=function(x, y)
    {
        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (item.Height<=0) continue;
            if (!item.Frame.PtInVertical) continue;

            if (item.Frame.PtInVertical(x, y))
            {
                return { Frame:item.Frame };
            }
        }

        return null;
    }

    this.GetXFromIndex=function(index)
    {
        return this.SubFrame[0].Frame.GetXFromIndex(index);
    }

    this.GetYFromData=function(value)
    {
        return this.SubFrame[0].Frame.GetYFromData(value);
    }

    this.ZoomUp=function(cursorIndex)
    {
        var result=this.SubFrame[0].Frame.ZoomUp(cursorIndex);
        this.UpdateAllFrame();
        return result;
    }

    this.ZoomDown=function(cursorIndex, option)
    {
        var result=this.SubFrame[0].Frame.ZoomDown(cursorIndex, option);
        this.UpdateAllFrame();
        return result;
    }

    this.SetXShowCount=function(showCount)
    {
        var result=this.SubFrame[0].Frame.SetXShowCount(showCount);
        this.UpdateAllFrame();
        return result;
    }

    this.GetXShowCount=function()
    {
        var xPointcount=-1;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.SubFrame)) return xPointcount;

        var subFrame=this.SubFrame[0];
        if (!subFrame.Frame) return xPointcount;

        xPointcount=subFrame.Frame.XPointCount;
        return xPointcount;
    }

    this.XCoordinateZoom=function(step, isMoveLeft)
    {
        var result=this.SubFrame[0].Frame.XCoordinateZoom(step, isMoveLeft);
        this.UpdateAllFrame();
        return result;
    }

    //设置重新计算刻度坐标
    this.ResetXYSplit=function()
    {
        for(let i in this.SubFrame)
        {
            this.SubFrame[i].Frame.XYSplit=true;
        }
    }

    this.ResetXSplit=function()
    {
        for(let i in this.SubFrame)
        {
            this.SubFrame[i].Frame.XSplit=true;
        }
    }

    //清空Y轴坐标的最大最小值
    this.ClearYCoordinateMaxMin=function(windowIndex)
    {
        if (IFrameSplitOperator.IsNumber(windowIndex))
        {
            var subItem=this.SubFrame[windowIndex];
            if (!subItem || !subItem.Frame) return;

            var frame=subItem.Frame;
            if (frame.YMaxMin)
            {
                frame.YMaxMin.Max=null;
                frame.YMaxMin.Min=null;
            }
        }
        else
        {
            for(var i=0;i<this.SubFrame.length;++i)
            {
                var subItem=this.SubFrame[i];
                var frame=subItem.Frame;
                if (frame.YMaxMin)
                {
                    frame.YMaxMin.Max=null;
                    frame.YMaxMin.Min=null;
                }
            }
        }
    }

    this.SetLanguage=function(languageID)
    {
        for(let i in this.SubFrame)
        {
            var item=this.SubFrame[i];
            if (item && item.Frame )
            {
                if (item.Frame.YSplitOperator) item.Frame.YSplitOperator.LanguageID=languageID;
                if (item.Frame.XSplitOperator) item.Frame.XSplitOperator.LanguageID=languageID;
            }
        }
    }

    this.GetCurrentPageSize=function()  //获取当前页显示的数据个数
    {
        if (this.SubFrame.length<=0) return null;
        var item=this.SubFrame[0];
        if (!item || !item.Frame) return null;

        return item.Frame.XPointCount;
    }

    this.OnSize=function()
    {
        var obj={};
        this.SubFrame[0].Frame.OnSize(obj);
        this.UpdateAllFrame();
        return obj;
    }

    this.SetDataWidth=function(dataWidth)
    {
        var obj=this.SubFrame[0].Frame.SetDataWidth(dataWidth);
        this.UpdateAllFrame();
        return obj;
    }

    this.UpdateAllFrame=function()
    {
        var mainFrame=this.SubFrame[0].Frame;
        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (i>0)    //第1个窗口主坐标已经算好了
            {
                item.Frame.XPointCount= mainFrame.XPointCount;
                item.Frame.ZoomIndex= mainFrame.ZoomIndex;
                item.Frame.DataWidth= mainFrame.DataWidth;
                item.Frame.DistanceWidth= mainFrame.DistanceWidth;
                item.Frame.LastCalculateStatus.Width=mainFrame.LastCalculateStatus.Width;
                item.Frame.LastCalculateStatus.XPointCount=mainFrame.LastCalculateStatus.XPointCount;
            }

            for(var j in item.OverlayIndex)
            {
                var overlayItem=this.SubFrame[i].OverlayIndex[j];
                overlayItem.Frame.XPointCount= mainFrame.XPointCount;
                overlayItem.Frame.ZoomIndex= mainFrame.ZoomIndex;
                overlayItem.Frame.DataWidth= mainFrame.DataWidth;
                overlayItem.Frame.DistanceWidth= mainFrame.DistanceWidth;
                overlayItem.Frame.LastCalculateStatus.Width=mainFrame.LastCalculateStatus.Width;
                overlayItem.Frame.LastCalculateStatus.XPointCount=mainFrame.LastCalculateStatus.XPointCount;
            }
        }
    }

    //鼠标是否在边框上
    this.PtInFrameBorder=function(x,y)
    {
        var height=this.DragBorderHeight;
        for(var i=0;i<this.SubFrame.length-1;++i)
        {
            var item=this.SubFrame[i];
            if (item.Frame.Heigh<=0) continue;
            var bottom=item.Frame.ChartBorder.GetBottom();
            var left=item.Frame.ChartBorder.GetLeft();
            var right=item.Frame.ChartBorder.GetRight();

            item.Frame.Canvas.beginPath();
            item.Frame.Canvas.rect(left,bottom-height/2,(right-left),height);
            if (item.Frame.Canvas.isPointInPath(x,y))
            {
                return { Index:i, Bottom:true };
            }
        }
        return null;
    }

    this.IsEnableDragY=function(index)
    {
        if (!this.SubFrame) return false;
        var item=this.SubFrame[index];
        if (!item || !item.Frame || !item.Frame.YSplitOperator) return false;
        var split=item.Frame.YSplitOperator;
        if (typeof(split.IsEnableDragY)!='function') return false;

        return split.IsEnableDragY();
    }

    this.IsEnableOverlayDragY=function(index, overlayIndex)
    {
        if (!this.SubFrame) return false;
        var item=this.SubFrame[index];
        var overlayItem=item.OverlayIndex[overlayIndex];
        if (!overlayItem || !overlayItem.Frame) return false;

        var split=overlayItem.Frame.YSplitOperator;
        if (overlayItem.Frame.IsShareY)
            split=overlayItem.Frame.MainFrame.YSplitOperator;
        
        if (!split || typeof(split.IsEnableDragY)!='function') return false;

        return split.IsEnableDragY();
    }

    this.PtInFrameY=function(x,y)
    {
        var rightExtendWith=0;
        if (this.GetExtendChartByClassName)
        {
            var finder=this.GetExtendChartByClassName("StockChip");
            if (finder && finder.Chart) rightExtendWith=finder.Chart.Width;
        }

        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (item.Frame.Heigh<=0) continue;
            var rightWidth=item.Frame.ChartBorder.Right;
            rightWidth-=rightExtendWith;

            var border=item.Frame.ChartBorder.GetBorder();
            var bottom=border.Bottom;
            var top=border.TopTitle;
            var left=border.Left;
            var right=border.Right;

            var maxTopHegith=30;
            var barHegith=(bottom-top);
            if (barHegith/3>maxTopHegith)
            {
                var barTop=top+maxTopHegith;
                var barBottom=bottom-maxTopHegith;
            }
            else
            {
                var internal=barHegith/3;
                var barTop=top+internal;
                var barBottom=bottom-internal;
            }

            var position=0;
            if (y<barTop) position=1;
            else if (y>barBottom) position=2;

            if (rightWidth>=10)
            {
                if (IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex))
                {
                    var overlayItem=item.OverlayIndex[0];
                    var rightOffset=overlayItem.Frame.RightOffset;
                    item.Frame.Canvas.beginPath();
                    item.Frame.Canvas.rect(right,top,rightOffset,(bottom-top));
                    if (item.Frame.Canvas.isPointInPath(x,y))
                    {
                        return { Index:i, Right:true, Left:false, Position:position, IsOverlay:false };    //Position 1=上面 2 下面 0=中间(TODO)
                    }

                    var overlayRight=right+rightOffset;
                    for(var j=0;j<item.OverlayIndex.length;++j)
                    {
                        var overlayItem=item.OverlayIndex[j];
                        if (!overlayItem.RightWidth || !IFrameSplitOperator.IsNumber(overlayItem.RightWidth.Width)) continue;
                        var overlayWidth=overlayItem.RightWidth.Width;

                        item.Frame.Canvas.beginPath();
                        item.Frame.Canvas.rect(overlayRight,top,overlayWidth,(bottom-top));
                        if (item.Frame.Canvas.isPointInPath(x,y))
                        {
                            return { Index:i, Right:true, Left:false , Position:position, IsOverlay:true, OverlayIndex:j };    //Position 1=上面 2 下面 0=中间(TODO)
                        }

                        overlayRight+=overlayWidth;
                    }
                }
                else
                {
                    item.Frame.Canvas.beginPath();
                    item.Frame.Canvas.rect(right,top,rightWidth,(bottom-top));
                    if (item.Frame.Canvas.isPointInPath(x,y))
                    {
                        return { Index:i, Right:true, Left:false , Position:position, IsOverlay:false };    //Position 1=上面 2 下面 0=中间(TODO)
                    }
                }
            }

            var leftWidth=item.Frame.ChartBorder.Left;
            if (leftWidth>=10)
            {
                item.Frame.Canvas.beginPath();
                item.Frame.Canvas.rect(0,top,leftWidth,(bottom-top));
                if (item.Frame.Canvas.isPointInPath(x,y))
                {
                    return { Index:i, Right:false, Left:true, Position:position,IsOverlay:false };
                }
            }
 
        }
        return null;
    }

    this.SetDayCount=function(dayCount)
    {
        this.ChartBorder.MultiDayMinute.Count=dayCount;
        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (!item.Frame) continue;

            item.Frame.DayCount=dayCount;
            item.Frame.ChartBorder.MultiDayMinute.Count=dayCount;
        }
    }

    //设置多日分时宽度
    this.SetMultiDayMinuteWidth=function(obj)
    {
        if (!obj) return;
        if (IFrameSplitOperator.IsNumber(obj.Left)) this.ChartBorder.MultiDayMinute.Left=obj.Left;
        if (IFrameSplitOperator.IsNumber(obj.Right)) this.ChartBorder.MultiDayMinute.Right=obj.Right;

        for(var i=0;i<this.SubFrame.length;++i)
        {
            var item=this.SubFrame[i];
            if (!item.Frame) continue;

            if (IFrameSplitOperator.IsNumber(obj.Left)) item.Frame.ChartBorder.MultiDayMinute.Left=obj.Left;
            if (IFrameSplitOperator.IsNumber(obj.Right)) item.Frame.ChartBorder.MultiDayMinute.Right=obj.Right;
        }
    }
}

//行情框架横屏
function HQTradeHScreenFrame()
{
    this.newMethod=HQTradeFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.IsHScreen=true;        //是否是横屏

    this.CalculateChartBorder=function()    //计算每个子框架的边框信息
    {
        if (this.SubFrame.length<=0) return;
        var border=this.ChartBorder.GetHScreenBorder();
        var right=this.ChartBorder.Right;
        var left=border.Right;
        var width=border.Right-border.Left;
        var totalHeight=0;
        var totalTitleHeight=0;

        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var frame=item.Frame;
            if (frame && frame.ChartBorder && frame.ChartBorder.IsShowTitleOnly && item.Height>0)
                totalTitleHeight+=frame.ChartBorder.TitleHeight;
            else
                totalHeight+=item.Height;
        }

        width-=totalTitleHeight;
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var frame=item.Frame;
            item.Frame.ChartBorder.Top=this.ChartBorder.Top;
            item.Frame.ChartBorder.Bottom=this.ChartBorder.Bottom;
            item.Frame.ChartBorder.LeftExtendWidth=this.ChartBorder.LeftExtendWidth;
            item.Frame.ChartBorder.RightExtendWidth=this.ChartBorder.RightExtendWidth;

            if (frame && frame.ChartBorder && frame.ChartBorder.IsShowTitleOnly && item.Height>0)
            {
                var frameWidth=frame.ChartBorder.TitleHeight;
                item.Frame.ChartBorder.Right=right;
                item.Frame.ChartBorder.Left=left-frameWidth;
                
                right+=frameWidth;
                left-=frameWidth;
            }
            else
            {
                var frameWidth=width*(item.Height/totalHeight);
                item.Frame.ChartBorder.Right=right;
                item.Frame.ChartBorder.Left=left-frameWidth;
                
                right+=frameWidth;
                left-=frameWidth;
            }
        }
    }

    this.GetYData=function(x,outObject)
    {
        var frame;
        for(var i=0; i<this.SubFrame.length; ++i)
        {
            var item=this.SubFrame[i];
            var left=item.Frame.ChartBorder.GetLeftEx();
            var top=item.Frame.ChartBorder.GetTop();
            var width=item.Frame.ChartBorder.GetWidthEx();
            var height=item.Frame.ChartBorder.GetHeight();

            item.Frame.Canvas.beginPath();
            item.Frame.Canvas.rect(left,top,width,height);
            if (item.Frame.Canvas.isPointInPath(x,top))
            {
                frame=item.Frame;
                if (outObject) outObject.FrameID=i;
                break;
            }
        }

        if (frame!=null) 
        {
            var xValue= frame.GetYData(x);

            if (frame.GetMainOverlayFrame)
            {
                var aryOverlayFrame=frame.GetMainOverlayFrame();
                if (aryOverlayFrame) 
                {
                    if (aryOverlayFrame[0]) //左侧
                    {
                        var leftFrame=aryOverlayFrame[0];
                        var value=leftFrame.GetYData(x);
                        outObject.RightYValue=xValue;
                        xValue=value;
                    }

                    if (aryOverlayFrame[1]) //右侧
                    {
                        var rightFrame=aryOverlayFrame[1];
                        var value=rightFrame.GetYData(x);
                        outObject.RightYValue=value;
                    }
                }
            }
            
            return xValue;
        }
    }
}

//深度图框架
function DepthChartFrame()
{
    this.newMethod=AverageWidthFrame;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ScreenImageData;                   //截图
    this.Position;                          //画布的位置
    this.ClassName="DepthChartFrame";

    //X轴价格 最大,最小
    this.VerticalRange={ Max:88, Min:8, Center:null, MaxDiffer:null, Differ:null, Step:0.05 };
    this.AskPrice;
    this.BidPrice;
    this.MinZoom=0.05;  //最小缩放

    this.SetPriceList=function(aryAskPrice, aryBidPrice)
    {
        this.AskPrice=aryAskPrice;
        this.BidPrice=aryBidPrice;
    }

    this.DrawFrame=function()
    {
        this.SplitXYCoordinate();
        this.DrawHorizontal();
        this.DrawVertical();
    }

    this.GetXFromIndex=function(value)
    {
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var width=this.ChartBorder.GetWidth();
        var offset=width*(value-this.VerticalRange.Min)/(this.VerticalRange.Max-this.VerticalRange.Min);
        return left+offset;
    }

    this.GetXData=function(x)
    {
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var width=this.ChartBorder.GetWidth();

        return (x-left)/width*(this.VerticalRange.Max-this.VerticalRange.Min)+this.VerticalRange.Min;
    }

    this.GetXFromPrice=function(price)
    {
        var isAskPrice=false;
        var find=this.GetPrice(this.BidPrice, price);
        if (find==null) 
        {
            find=this.GetPrice(this.AskPrice, price);
            isAskPrice=true;
        }

        if (find==null) 
        {
            if (this.BidPrice && Array.isArray(this.BidPrice) && this.BidPrice.length>0)
            {
                var minPrice=this.BidPrice[0];
                if (price<minPrice) 
                {
                    isAskPrice=false;
                    find= minPrice;
                }
            }
        }

        if (find==null)   
        {      
            if (this.AskPrice && Array.isArray(this.AskPrice) && this.AskPrice.length>0)
            {
                var maxPrice=this.AskPrice[this.AskPrice.length-1];
                if (price>maxPrice) 
                {
                    isAskPrice=true;
                    find=maxPrice;
                }
            }
        }

        if (find==null) return null;

        var x=this.GetXFromIndex(find);

        return { X:x, Price:find, IsAsk:isAskPrice };
    }

    this.GetPrice=function(aryPrice, price)
    {
        if (!aryPrice || !Array.isArray(aryPrice) || aryPrice.length<=0) return null;

        if (price<aryPrice[0] || price>aryPrice[aryPrice.length-1]) return null;

        var lastPrice=null;
        for(var i in aryPrice)
        {
            var item=aryPrice[i];
            if (price==item)
            {
                return item;
            }

            if (price<item)
                return lastPrice;

            lastPrice=item;
        }
    }

    //分割x,y轴坐标信息
    this.SplitXYCoordinate=function()
    {
        if (this.XYSplit==false) return;
        if (this.YSplitOperator!=null) this.YSplitOperator.Operator();
        if (this.XSplitOperator!=null) this.XSplitOperator.Operator();
    }

    //图形快照
    this.Snapshot=function()
    {
        this.ScreenImageData=this.Canvas.getImageData(0,0,this.ChartBorder.GetChartWidth(),this.ChartBorder.GetChartHeight());
    }

    this.SetSizeChage=function(sizeChange)
    {
        this.SizeChange=sizeChange;

        //画布的位置
        this.Position={
            X:this.ChartBorder.UIElement.offsetLeft,
            Y:this.ChartBorder.UIElement.offsetTop,
            W:this.ChartBorder.UIElement.clientWidth,
            H:this.ChartBorder.UIElement.clientHeight
        };
    }

    this.PtInFrame=function(x,y)    //鼠标哪个指标窗口
    {
        var left=this.ChartBorder.GetLeft();
        var top=this.ChartBorder.GetTop();
        var width=this.ChartBorder.GetWidth();
        var height=this.ChartBorder.GetHeight();

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,width,height);
        if (this.Canvas.isPointInPath(x,y))
            return 0;

        return -1;
    }

    this.PtInFrameBorder=function(x,y)
    {
        return null;
    }

    this.ZoomUp=function()  //放大
    {
        var xRange=this.VerticalRange;
        var differ=xRange.Differ;
        var minDiffer=xRange.MaxDiffer*this.MinZoom;
        if (differ<minDiffer) return false;

        var offsetDiffer=xRange.Differ*xRange.Step;
        differ-=offsetDiffer;
        xRange.Differ=differ;
        xRange.Min=xRange.Center-xRange.Differ;
        xRange.Max=xRange.Center+xRange.Differ;

        return true;
    }

    this.ZoomDown=function() //缩小
    {
        var xRange=this.VerticalRange;
        var differ=xRange.Differ;
        if (differ==xRange.MaxDiffer) return false;

        var offsetDiffer=xRange.Differ*xRange.Step;
        differ+=offsetDiffer;
        if (differ>xRange.MaxDiffer) differ=xRange.MaxDiffer;

        xRange.Differ=differ;
        xRange.Min=xRange.Center-xRange.Differ;
        xRange.Max=xRange.Center+xRange.Differ;

        return true;
    }
}

//历史K线数据
function HistoryData()
{
    this.Date;
    this.YClose;
    this.Open;
    this.Close;
    this.High;
    this.Low;
    this.Vol;
    this.Amount;
    this.Time;      //mmhh 或者 mmhhss
    this.FlowCapital=null;   //流通股本
    this.Position=null;   //持仓量
    this.IsVirtual=false;   //是否为虚拟数据
    this.IsNonTrade=false;  //非交易日  

    //期货
    this.YFClose=null;   //前结算价
    this.FClose=null;    //结算价

    //指数才有的数据
    this.Stop;  //停牌家数
    this.Up;    //上涨
    this.Down;  //下跌
    this.Unchanged; //平盘

    this.ExtendData;    //扩展数据

    this.BFactor;   //前复权
    this.AFactor;   //后复权

    this.RightSeed; //本地计算的复权系数

    /*
    { 
        PriceOffset: 每个单元的价格间距,  
        High: [ { Price:, Value:, Text: Color ,Font:{ Weight:}}, ..... ], 
        Low:[ { Price:, Value:, Text: Color , Font:{ Weight:}}, ..... ] , 
        Order:  //订单信息
        [ 
            { 
                Price:,  
                Ask:{ Color:, Value: , Text:, BG:, Font:{ Weight:} } 
                Bid:{ Color:, Value:,  Text:, BG:, Font:{ Weight:} }, 
                //横线柱子 Width K线宽度比值, Height:高度 Type:0=长度由Width决定， 1=当收盘价小于Price后，线就不需要在继续延伸 2=当收盘价大于Price后，线就不需要在继续延伸了
                HBar:{ Color:, Width, Height: 1, Type:0,1,2 },
                Vol:{ Value:, BG:, Text:, Color: }
            }, 
            ........
        ] 
    }
    */
    this.OrderFlow; //订单流 
    this.ColorData; //自定义颜色 {Type:0=空心 1=实心, Line:{ Color:'上下线颜色'}, Border:{Color:柱子边框颜色}, BarColor:柱子颜色};

    /*
    { 
        PriceOffset:每个单元的价格间距,
        Order:
        [
            { Price:价格, Color:颜色, Value: }
        ]
    }
    */
    this.HeatMap; 
}

//数据复制
HistoryData.Copy=function(data)
{
    var newData=new HistoryData();

    newData.Date=data.Date;
    if (IFrameSplitOperator.IsNumber(data.Time)) newData.Time=data.Time;

    newData.YClose=data.YClose;
    newData.Open=data.Open;
    newData.Close=data.Close;
    newData.High=data.High;
    newData.Low=data.Low;
    newData.Vol=data.Vol;
    newData.Amount=data.Amount;
    
    if (IFrameSplitOperator.IsNumber(data.FlowCapital)) newData.FlowCapital=data.FlowCapital;
    if (IFrameSplitOperator.IsNumber(data.Position)) newData.Position=data.Position;
    if (IFrameSplitOperator.IsNumber(data.YFClose)) newData.YFClose=data.YFClose;
    if (IFrameSplitOperator.IsNumber(data.FClose)) newData.FClose=data.FClose;

    //指数涨停家数
    if (IFrameSplitOperator.IsNumber(data.Stop)) newData.Stop=data.Stop;
    if (IFrameSplitOperator.IsNumber(data.Up)) newData.Up=data.Up;
    if (IFrameSplitOperator.IsNumber(data.Down)) newData.Down=data.Down;
    if (IFrameSplitOperator.IsNumber(data.Unchanged)) newData.Unchanged=data.Unchanged;

    //复权因子
    if (IFrameSplitOperator.IsNumber(data.BFactor)) newData.BFactor=data.BFactor;
    if (IFrameSplitOperator.IsNumber(data.AFactor)) newData.AFactor=data.AFactor;

    if (IFrameSplitOperator.IsBool(data.IsVirtual)) newData.IsVirtual=data.IsVirtual;
    if (IFrameSplitOperator.IsBool(data.IsNonTrade)) newData.IsNonTrade=data.IsNonTrade;

    if (data.OrderFlow) newData.OrderFlow=data.OrderFlow;
    if (data.ColorData) newData.ColorData=data.ColorData;
    if (data.ExtendData) newData.ExtendData=data.ExtendData;
    if (data.HeatMap) newData.HeatMap=data.HeatMap;

    return newData;
}

//把数据 src 复制到 dest中
HistoryData.CopyTo=function(dest,src)
{
    dest.Date=src.Date;
    if (IFrameSplitOperator.IsNumber(src.Time)) dest.Time=src.Time;

    dest.YClose=src.YClose;
    dest.Open=src.Open;
    dest.Close=src.Close;
    dest.High=src.High;
    dest.Low=src.Low;
    dest.Vol=src.Vol;
    dest.Amount=src.Amount;
    
    if (IFrameSplitOperator.IsNumber(src.FlowCapital)) dest.FlowCapital=src.FlowCapital;
    if (IFrameSplitOperator.IsNumber(src.Position)) dest.Position=src.Position;
    if (IFrameSplitOperator.IsNumber(src.YFClose)) dest.YFClose=src.YFClose;
    if (IFrameSplitOperator.IsNumber(src.FClose)) dest.FClose=src.FClose;

    if (IFrameSplitOperator.IsNumber(src.Stop)) dest.Stop=src.Stop;
    if (IFrameSplitOperator.IsNumber(src.Up)) dest.Up=src.Up;
    if (IFrameSplitOperator.IsNumber(src.Down)) dest.Down=src.Down;
    if (IFrameSplitOperator.IsNumber(src.Unchanged)) dest.Unchanged=src.Unchanged;

    if (IFrameSplitOperator.IsNumber(src.BFactor)) dest.BFactor=src.BFactor;
    if (IFrameSplitOperator.IsNumber(src.AFactor)) dest.AFactor=src.AFactor;

    if (IFrameSplitOperator.IsBool(src.IsVirtual)) dest.IsVirtual=src.IsVirtual;
    if (IFrameSplitOperator.IsBool(src.IsNonTrade)) dest.IsNonTrade=src.IsNonTrade;

    if (src.OrderFlow) dest.OrderFlow=src.OrderFlow;
    if (src.ColorData) dest.ColorData=src.ColorData;
    if (src.HeatMap) dest.HeatMap=src.HeatMap;
    if (src.ExtendData) dest.ExtendData=src.ExtendData;
}

//数据复权拷贝
HistoryData.CopyRight=function(data,seed)
{
    var newData=new HistoryData();
    newData.Date=data.Date;
    if (IFrameSplitOperator.IsNumber(data.Time)) newData.Time=data.Time;

    newData.YClose=data.YClose*seed;
    newData.Open=data.Open*seed;
    newData.Close=data.Close*seed;
    newData.High=data.High*seed;
    newData.Low=data.Low*seed;

    newData.Vol=data.Vol;
    newData.Amount=data.Amount;
    newData.FlowCapital=data.FlowCapital;
    newData.Position=data.Position;
    newData.YFClose=data.YFClose;
    newData.FClose=data.FClose;

    if (data.ColorData) newData.ColorData=data.ColorData;       //K线颜色
    if (data.ExtendData) newData.ExtendData=data.ExtendData;    //扩张数据

    return newData;
}

function MinuteData()
{
    this.Close;
    this.Open;
    this.High;
    this.Low;
    this.Vol;           //量
    this.Amount;        //金额
    this.DateTime;
    this.Increase;      //涨幅
    this.Risefall;      //涨跌
    this.AvPrice;       //均价
    this.Lead=null;     //领先指标
    this.Time;          //时间
    this.Date;              //日期
    this.Position=null;     //持仓量
    this.YClearing;         //昨结算价
    this.YClose;            //昨收价

    this.ExtendData;    //扩展数据
}

//盘前集合竞价
function BeforeOpenData()
{
    this.Time;
    this.Date;
    this.Price;     //匹配的价格
    this.AvPrice;   //均价
    this.Vol=[];    //[0]=匹配量 [1]=未匹配量
    this.ColorID;   //0=平盘 1=红 2=绿  3 ...自定义颜色 
    this.YClose;            //昨收价    
}

//收盘集合竞价
function AfterCloseData()
{
    this.Time;
    this.Date;
    this.Price;     //匹配的价格
    this.AvPrice;   //均价
    this.Vol=[];    //[0]=匹配量 [1]=未匹配量
    this.ColorID;   //0=平盘 1=红 2=绿  3 ...自定义颜色    
    this.YClose;            //昨收价 
}

//单指标数据
function SingleData()
{
    this.Date;  //日期
    this.Time;  //时间
    this.Value; //数据  (可以是一个数组)
}

var KLINE_INFO_TYPE=
{
    INVESTOR:1,         //互动易
    ANNOUNCEMENT:2,     //公告
    PFORECAST:3,        //业绩预告

    ANNOUNCEMENT_QUARTER_1:4,   //一季度报
    ANNOUNCEMENT_QUARTER_2:5,   //半年报
    ANNOUNCEMENT_QUARTER_3:6,   //2季度报
    ANNOUNCEMENT_QUARTER_4:7,   //年报

    RESEARCH:8,                 //调研
    BLOCKTRADING:9,             //大宗交易
    TRADEDETAIL:10,              //龙虎榜

    //公告预留类型
    ANNOUNCEMENT_EX_START:100,
    ANNOUNCEMENT_EX_END:200,
}

function KLineInfoData()
{
    this.ID;
    this.Date;
    this.Time;  //时间
    this.Title;
    this.InfoType;
    this.ExtendData;    //扩展数据
}

//外部数据计算方法接口
function DataPlus () 
{ 
    this.PeriodCallback=new Map();  //key=周期id value={ Period, Callback(period,data,self): }

    this.GetPeriodCallback=function(period)
    {
        if (!this.PeriodCallback.has(period)) return null;
        
        return this.PeriodCallback.get(period);
    }

    this.AddPeriodCallback=function(obj)
    {
        if (!IFrameSplitOperator.IsNumber(obj.Period) || !obj.Callback) return;

        var item={ Period:obj.Period, Callback:obj.Callback };
        this.PeriodCallback.set(obj.Period, item);
    }

    this.RemovePeriodCallback=function(obj)
    {
        if (!this.PeriodCallback.has(obj.ID)) return;
        this.PeriodCallback.delete(obj.ID);
    }
}; 

var g_DataPlus=new DataPlus();


function ChartData()
{
    this.Data=new Array();
    this.DataOffset=0;                        //数据偏移
    this.Period=0;                            //周期 0 日线 1 周线 2 月线 3年线
    this.Right=0;                             //复权 0 不复权 1 前复权 2 后复权
    this.Symbol;                              //股票代码

    this.Data2=new Array();                   //第1组数据 走势图:历史分钟数据

    this.GetCloseMA=function(dayCount)
    {
        var result=new Array();
        for (var i = 0, len = this.Data.length; i < len; i++)
        {
            if (i < dayCount)
            {
                result[i]=null;
                continue;
            }

            var sum = 0;
            for (var j = 0; j < dayCount; j++)
            {
                sum += this.Data[i - j].Close;
            }
            result[i]=sum / dayCount;
        }
        return result;
    }

    this.GetVolMA=function(dayCount)
    {
    var result=new Array();
    for (var i = 0, len = this.Data.length; i < len; i++)
    {
        if (i < dayCount)
        {
            result[i]=null;
            continue;
        }

        var sum = 0;
        for (var j = 0; j < dayCount; j++)
        {
            sum += this.Data[i - j].Vol;
        }
        result[i]=sum / dayCount;
    }
    return result;
    }

    this.GetAmountMA=function(dayCount)
    {
        var result=new Array();
        for (var i = 0, len = this.Data.length; i < len; i++)
        {
            if (i < dayCount)
            {
                result[i]=null;
                continue;
            }

            var sum = 0;
            for (var j = 0; j < dayCount; j++)
            {
                sum += this.Data[i - j].Amount;
            }
            result[i]=sum / dayCount;
        }
        return result;
    }

    //获取收盘价
    this.GetClose=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Close;
        }

        return result;
    }

    this.GetYClose=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].YClose;
        }

        return result;
    }

    this.GetHigh=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].High;
        }

        return result;
    }

    this.GetLow=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Low;
        }

        return result;
    }

    this.GetOpen=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Open;
        }

        return result;
    }

    this.GetVol=function(unit)
    {
        var value=1;
        if (IFrameSplitOperator.IsNumber(unit)) value=unit;
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Vol/value;
        }

        return result;
    }

    this.GetAmount=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Amount;
        }

        return result;
    }

    this.GetPosition=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Position;
        }

        return result;
    }

    this.GetSettlementPrice=function()  //结算价
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].FClose;
        }

        return result;
    }

    this.GetIsEqual=function()
    {
        var result=[];
        for(var i in this.Data)
        {
            var item=this.Data[i];
            result[i]=(item.Close==item.Open? 1:0);
        }

        return result;
    }

    this.GetIsUp=function()
    {
        var result=[];
        for(var i in this.Data)
        {
            var item=this.Data[i];
            result[i]=(item.Close>item.Open? 1:0);
        }

        return result;
    }

    this.GetIsDown=function()
    {
        var result=[];
        for(var i in this.Data)
        {
            var item=this.Data[i];
            result[i]=(item.Close<item.Open? 1:0);
        }

        return result;
    }

    this.GetLead=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Lead;
        }

        return result;
    }

    this.GetDate=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Date;
        }

        return result;
    }

    this.GetTime=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Time;
        }

        return result;
    }

    this.GetUp=function()   //上涨家数
    {
        var result=[];
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Up;
        }

        return result;
    }

    this.GetDown=function() //下跌家数
    {
        var result=[];
        for(var i in this.Data)
        {
            result[i]=this.Data[i].Down;
        }

        return result;
    }

    this.GetYear=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=parseInt(this.Data[i].Date/10000);
        }

        return result;
    }

    this.GetMonth=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=parseInt(this.Data[i].Date%10000/100);
        }

        return result;
    }

    //分时图均价
    this.GetAvPrice=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            var value=this.Data[i].AvPrice;
            if (IFrameSplitOperator.IsNumber(value))
                result[i]=value;
            else 
                result[i]=0;
        }

        return result;
    }

    //获取数据日期和时间范围
    this.GetDateRange=function()
    {
        if (!this.Data || this.Data.length<=0) return null;

        var start=this.Data[0];
        var end=this.Data[this.Data.length-1];
        var range={ Start:{Date:start.Date}, End:{Date:end.Date} };
        if (IFrameSplitOperator.IsNumber(start.Time)) range.Start.Time=start.Time;
        if (IFrameSplitOperator.IsNumber(end.Time)) range.End.Time=end.Time;

        return range;
    }

    this.GetDateList=function()
    {
        if (!this.Data || this.Data.length<=0) return null;
        var aryDate=[];
        var setDate=new Set();
        for(var i=0;i<this.Data.length; ++i)
        {
            var item=this.Data[i];
            if (!IFrameSplitOperator.IsNumber(item.Date)) continue;

            if (setDate.has(item.Date)) continue;

            setDate.add(item.Date);
            aryDate.push(item.Date);
        }

        return aryDate;
    }

    //计算分钟
    this.GetMinutePeriodData=function(period)
    {
        var result = new Array();
        var periodDataCount = 5;
        if (period == 5)
            periodDataCount = 5;
        else if (period == 6)
            periodDataCount = 15;
        else if (period == 7)
            periodDataCount = 30;
        else if (period == 8)
            periodDataCount = 60;
        else if (period==11)
            periodDataCount=120;
        else if (period==12)
            periodDataCount=240;
        else if (period>CUSTOM_MINUTE_PERIOD_START && period<=CUSTOM_MINUTE_PERIOD_END)
        {
            periodDataCount=period-CUSTOM_MINUTE_PERIOD_START;
            return this.GetMinuteCustomPeriodData(periodDataCount);
        }
        else
            return this.Data;
        var bFirstPeriodData = false;
        var newData = null;
        var preTime=null;   //上一次的计算时间
        for (var i = 0; i < this.Data.length; )
        {
            bFirstPeriodData = true;
            for (var j = 0; j < periodDataCount && i < this.Data.length; ++i)
            {
                if (bFirstPeriodData)
                {
                    newData = new HistoryData();
                    result.push(newData);
                    bFirstPeriodData = false;
                }
                var minData = this.Data[i];
                if (minData == null)
                {
                    ++j;
                    continue;    
                } 
                if (minData.Time==925 && (preTime==null || preTime!=924))  //9：25, 9:30 不连续就不算个数
                {

                }
                else if (minData.Time == 930 && (preTime==null || preTime!=929) )
                {

                }
                else if (minData.Time == 1300 && (preTime==null || preTime!=1259) ) //1点的数据 如果不是连续的 就不算个数
                {

                }
                else
                    ++j;
                newData.Date = minData.Date;
                newData.Time = minData.Time;
                preTime=newData.Time;
                if (minData.Open==null || minData.Close==null)
                    continue;
                if (newData.Open==null || newData.Close==null)
                {
                    newData.Open=minData.Open;
                    newData.High=minData.High;
                    newData.Low=minData.Low;
                    newData.YClose=minData.YClose;
                    newData.Close=minData.Close;
                    newData.Vol=minData.Vol;
                    newData.Amount=minData.Amount;    
                    newData.FlowCapital=minData.FlowCapital;  
                    newData.Position=minData.Position;
                    newData.YFClose=minData.YFClose;
                    newData.FClose=minData.FClose;
                }
                else
                {
                    if (newData.High<minData.High) 
                        newData.High=minData.High;
                    if (newData.Low>minData.Low) 
                        newData.Low=minData.Low;
                    newData.Close=minData.Close;
                    newData.Vol+=minData.Vol;
                    if (minData.Amount!=null) newData.Amount+=minData.Amount;
                    newData.Position=minData.Position;
                    newData.FlowCapital=minData.FlowCapital;  
                    newData.FClose=minData.FClose;
                }

                if (i+1 < this.Data.length) //判断下一个数据是否是不同日期的
                {
                    var nextItem=this.Data[i+1];
                    if (nextItem && nextItem.Date!=minData.Date)    //不同日期的, 周期结束
                    {
                        ++i;
                        break;
                    }
                }
            }
        }
        return result;
    }

    //自定义分钟
    this.GetMinuteCustomPeriodData=function(count)
    {
        var result = new Array();
        var periodDataCount = count;
        var bFirstPeriodData = false;
        var newData = null;
        for (var i = 0; i < this.Data.length; )
        {
            bFirstPeriodData = true;
            for (var j = 0; j < periodDataCount && i < this.Data.length; ++i, ++j)
            {
                if (bFirstPeriodData)
                {
                    newData = new HistoryData();
                    result.push(newData);
                    bFirstPeriodData = false;
                }
                var minData = this.Data[i];
                if (minData == null) continue;    
                
                newData.Date = minData.Date;
                newData.Time = minData.Time;
                if (minData.Open==null || minData.Close==null) continue;
                if (newData.Open==null || newData.Close==null)
                {
                    newData.Open=minData.Open;
                    newData.High=minData.High;
                    newData.Low=minData.Low;
                    newData.YClose=minData.YClose;
                    newData.Close=minData.Close;
                    newData.Vol=minData.Vol;
                    newData.Amount=minData.Amount;    
                    newData.FlowCapital=minData.FlowCapital; 
                    newData.Position=minData.Position; 
                    newData.YFClose=minData.YFClose; 
                    newData.FClose=minData.FClose; 
                }
                else
                {
                    if (newData.High<minData.High)  newData.High=minData.High;
                    if (newData.Low>minData.Low) newData.Low=minData.Low;
                    newData.Close=minData.Close;
                    newData.Vol+=minData.Vol;
                    if (minData.Amount!=null) newData.Amount+=minData.Amount;   //null数据不相加
                    newData.Position=minData.Position;
                    newData.FlowCapital=minData.FlowCapital;  
                    newData.FClose=minData.FClose; 
                }
            }
        }
        return result;
    }
    //计算周,月,年
    this.GetDayPeriodData=function(period)
    {
        if (period>CUSTOM_DAY_PERIOD_START && period<=CUSTOM_DAY_PERIOD_END)
            return this.GetDayCustomPeriodData(period-CUSTOM_DAY_PERIOD_START);
        
        var isBit=MARKET_SUFFIX_NAME.IsBIT(this.Symbol);

        var result=new Array();
        var index=0;
        var startDate=0;
        var weekCount=2;
        var newData=null;
        for(var i in this.Data)
        {
            var isNewData=false;
            var dayData=this.Data[i];

            switch(period)
            {
                case 1: //周线
                    if (isBit)  var fridayDate=ChartData.GetSunday(dayData.Date); //数字货币全年的
                    else var fridayDate=ChartData.GetFirday(dayData.Date);
                    
                    if (fridayDate!=startDate)
                    {
                        isNewData=true;
                        startDate=fridayDate;
                    }
                    break;
                case 21: //双周
                    if (isBit)  var fridayDate=ChartData.GetSunday(dayData.Date); //数字货币全年的
                    else var fridayDate=ChartData.GetFirday(dayData.Date);

                    if (fridayDate!=startDate)
                    {
                        ++weekCount;
                        if (weekCount>=2) 
                        {
                            isNewData=true;
                            weekCount=0;
                        }
                        startDate=fridayDate;
                    }
                    break;
                case 2: //月线
                    if (parseInt(dayData.Date/100)!=parseInt(startDate/100))
                    {
                        isNewData=true;
                        startDate=dayData.Date;
                    }
                    break;
                case 3: //年线
                    if (parseInt(dayData.Date/10000)!=parseInt(startDate/10000))
                    {
                        isNewData=true;
                        startDate=dayData.Date;
                    }
                    break;
                case 22://半年:
                    var halfYear=ChartData.GetHalfYear(dayData.Date);
                    if (halfYear!=startDate)
                    {
                        isNewData=true;
                        startDate=halfYear;
                    }
                    break;
                case 9: //季线
                    var now=ChartData.GetQuarter(dayData.Date);
                    now=parseInt(dayData.Date/10000)*10+now;
                    var last=ChartData.GetQuarter(startDate);
                    last=parseInt(startDate/10000)*10+last;
                    if (now!=last)
                    {
                        isNewData=true;
                        startDate=dayData.Date;
                    }
                    break;
            }

            if (isNewData)
            {
                newData=new HistoryData();
                newData.Date=dayData.Date;
                result.push(newData);

                if (dayData.Open==null || dayData.Close==null) continue;

                newData.Open=dayData.Open;
                newData.High=dayData.High;
                newData.Low=dayData.Low;
                newData.YClose=dayData.YClose;
                newData.Close=dayData.Close;
                newData.Vol=dayData.Vol;
                newData.Amount=dayData.Amount;
                newData.FlowCapital=dayData.FlowCapital;
                newData.Position=dayData.Position; 
                newData.YFClose=dayData.YFClose; 
                newData.FClose=dayData.FClose; 
            }
            else
            {
                if (newData==null) continue;
                if (dayData.Open==null || dayData.Close==null) continue;

                if (newData.Open==null || newData.Close==null)
                {
                    newData.Open=dayData.Open;
                    newData.High=dayData.High;
                    newData.Low=dayData.Low;
                    newData.YClose=dayData.YClose;
                    newData.Close=dayData.Close;
                    newData.Vol=dayData.Vol;
                    newData.Amount=dayData.Amount;
                    newData.FlowCapital=dayData.FlowCapital;
                    newData.Position=dayData.Position; 
                    newData.YFClose=dayData.YFClose; 
                    newData.FClose=dayData.FClose; 
                }
                else
                {
                    if (newData.High<dayData.High) newData.High=dayData.High;
                    if (newData.Low>dayData.Low) newData.Low=dayData.Low;

                    newData.Close=dayData.Close;
                    newData.Vol+=dayData.Vol;
                    if (dayData.Amount!=null) newData.Amount+=dayData.Amount;
                    newData.Position=dayData.Position;
                    newData.FlowCapital=dayData.FlowCapital;
                    newData.Date=dayData.Date;
                    newData.FClose=dayData.FClose; 
                }
            }
        }

        return result;
    }

    this.GetDayCustomPeriodData=function(count)
    {
        var result = [];
        var periodDataCount = count;
        var bFirstPeriodData = false;
        var newData = null;
        for (var i = 0; i < this.Data.length; )
        {
            bFirstPeriodData = true;
            for (var j = 0; j < periodDataCount && i < this.Data.length; ++i, ++j)
            {
                if (bFirstPeriodData)
                {
                    newData = new HistoryData();
                    result.push(newData);
                    bFirstPeriodData = false;
                }
                var dayData = this.Data[i];
                if (dayData == null) continue;    
                
                newData.Date = dayData.Date;
                
                if (dayData.Open==null || dayData.Close==null) continue;
                if (newData.Open==null || newData.Close==null)
                {
                    newData.Open=dayData.Open;
                    newData.High=dayData.High;
                    newData.Low=dayData.Low;
                    newData.YClose=dayData.YClose;
                    newData.Close=dayData.Close;
                    newData.Vol=dayData.Vol;
                    newData.Amount=dayData.Amount;    
                    newData.FlowCapital=dayData.FlowCapital;  
                    newData.Position=dayData.Position;  
                    newData.YFClose=dayData.YFClose; 
                    newData.FClose=dayData.FClose; 
                }
                else
                {
                    if (newData.High<dayData.High)  newData.High=dayData.High;
                    if (newData.Low>dayData.Low) newData.Low=dayData.Low;
                    newData.Close=dayData.Close;
                    newData.Vol+=dayData.Vol;
                    if (dayData.Amount!=null) newData.Amount+=dayData.Amount;
                    newData.Position=dayData.Position;
                    newData.FlowCapital=dayData.FlowCapital;
                    newData.FClose=dayData.FClose;  
                }
            }
        }
        return result;
    }

    //周期数据 1=周 2=月 3=年
    this.GetPeriodData=function(period)
    {
        //外部自定义周期计算函数
        var itemCallback=g_DataPlus.GetPeriodCallback(period);
        if (itemCallback) return itemCallback.Callback(period,this.Data,this);

        if (MARKET_SUFFIX_NAME.IsBIT(this.Symbol))
        {
            if (period==5 || period==6 || period==7 || period==8 || (period>CUSTOM_MINUTE_PERIOD_START && period<=CUSTOM_MINUTE_PERIOD_END)) //分钟K线
            {
                var periodDataCount = 5;
                if (period == 5)
                    periodDataCount = 5;
                else if (period == 6)
                    periodDataCount = 15;
                else if (period == 7)
                    periodDataCount = 30;
                else if (period == 8)
                    periodDataCount = 60;
                else if (period==11)
                    periodDataCount = 120;
                else if (period==12)
                    periodDataCount = 240;
                else if (period>CUSTOM_MINUTE_PERIOD_START && period<=CUSTOM_MINUTE_PERIOD_END)
                    periodDataCount=period-CUSTOM_MINUTE_PERIOD_START;

                return this.GetMinuteCustomPeriodData(periodDataCount);
            }
        }

        //if (period==1 || period==2 || period==3 || period==9 || period==21 || period==22 || (period>CUSTOM_DAY_PERIOD_START && period<=CUSTOM_DAY_PERIOD_END)) 
        if (ChartData.IsDayPeriod(period,false)) return this.GetDayPeriodData(period);
        
        //if (period==5 || period==6 || period==7 || period==8 || period==11 || period==12 || (period>CUSTOM_MINUTE_PERIOD_START && period<=CUSTOM_MINUTE_PERIOD_END)) return this.GetMinutePeriodData(period);
        if (ChartData.IsMinutePeriod(period,false)) return this.GetMinutePeriodData(period);
    }

    //复权  0 不复权 1 前复权 2 后复权
    this.GetRightData=function(right, option)
    {
        var result=[];
        if (this.Data.length<=0) return result;

        if (option && option.AlgorithmType==1)  //使用复权因子计算
        {
            for(var i=0;i<this.Data.length;++i)
            {
                var item=this.Data[i];
                var seed=(right==1?item.BFactor:item.AFactor);
                result[i]=HistoryData.CopyRight(item,seed);
            }

            return result;
        }

        if (right==1)
        {
            var index=this.Data.length-1;
            var seed=1; //复权系数
            var yClose=this.Data[index].YClose;

            result[index]=HistoryData.Copy(this.Data[index]);
            result[index].RightSeed=seed;

            for(--index; index>=0; --index)
            {
                if (yClose!=this.Data[index].Close) break;
                var newItem=HistoryData.Copy(this.Data[index]);
                newItem.RightSeed=seed;
                result[index]=newItem;

                yClose=this.Data[index].YClose;
            }

            for(; index>=0; --index)
            {
                var value=this.Data[index].Close;
                if(yClose!=value && value!=0)
                    seed *= yClose/value;

                var newItem=HistoryData.CopyRight(this.Data[index],seed);
                newItem.RightSeed=seed;
                result[index]=newItem

                yClose=this.Data[index].YClose;
            }
        }
        else if (right==2)
        {
            var index=0;
            var seed=1;
            var close=this.Data[index].Close;
            result[index]=HistoryData.Copy(this.Data[index]);
            result[index].RightSeed=seed;

            for(++index;index<this.Data.length;++index)
            {
                if (close!=this.Data[index].YClose) break;
                var newItem=HistoryData.Copy(this.Data[index]);
                newItem.RightSeed=seed;
                result[index]=newItem;
                close=this.Data[index].Close;
            }

            for(;index<this.Data.length;++index)
            {
                if(close!=this.Data[index].YClose)
                    seed *= close/this.Data[index].YClose;

                var newItem=HistoryData.CopyRight(this.Data[index],seed);
                newItem.RightSeed=seed;
                result[index]=newItem;

                close=this.Data[index].Close;
            }
        }

        return result;
    }

    this.GetRightDate=this.GetRightData;

    //叠加数据和主数据拟合,去掉主数据没有日期的数据
    this.GetOverlayData=function(overlayData, bApiPeriod)
    {
        var result=[];

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j>=overlayData.length)
            {
                result[i]=new HistoryData();
                result[i].Date=date;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;

            if (overlayDate==date)
            {
                result[i]=new HistoryData();
                result[i].Date=overlayData[j].Date;
                result[i].YClose=overlayData[j].YClose;
                result[i].Open=overlayData[j].Open;
                result[i].High=overlayData[j].High;
                result[i].Low=overlayData[j].Low;
                result[i].Close=overlayData[j].Close;
                result[i].Vol=overlayData[j].Vol;
                result[i].Amount=overlayData[j].Amount;

                //涨跌家数数据
                result[i].Stop=overlayData[j].Stop;
                result[i].Up=overlayData[j].Up;
                result[i].Down=overlayData[j].Down;
                result[i].Unchanged=overlayData[j].Unchanged;

                ++j;
                ++i;
            }
            else if (overlayDate<date)
            {
                ++j;
            }
            else
            {
                result[i]=new HistoryData();
                result[i].Date=date;
                ++i;
            }
        }

        return result;
    }

    this.GetOverlayMinuteData=function(overlayData, bApiPeriod)
    {
        var result=[];

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j>=overlayData.length)
            {
                result[i]=new HistoryData();
                result[i].Date=date;
                result[i].Time=time;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;
            var overlayTime=overlayData[j].Time;

            if (overlayDate==date && overlayTime==time)
            {
                result[i]=new HistoryData();
                result[i].Date=overlayData[j].Date;
                result[i].Time=overlayData[j].Time;
                result[i].YClose=overlayData[j].YClose;
                result[i].Open=overlayData[j].Open;
                result[i].High=overlayData[j].High;
                result[i].Low=overlayData[j].Low;
                result[i].Close=overlayData[j].Close;
                result[i].Vol=overlayData[j].Vol;
                result[i].Amount=overlayData[j].Amount;

                //涨跌家数数据
                result[i].Stop=overlayData[j].Stop;
                result[i].Up=overlayData[j].Up;
                result[i].Down=overlayData[j].Down;
                result[i].Unchanged=overlayData[j].Unchanged;

                ++j;
                ++i;
            }
            else if (overlayDate<date || (overlayDate==date && overlayTime<time))
            {
                ++j;
            }
            else
            {
                result[i]=new HistoryData();
                result[i].Date=date;
                result[i].Time=time;
                ++i;
            }
        }

        return result;
    }

    /*
        技术指标数据方法
    */
    //以主图数据 拟合,返回 SingleData 数组
    this.GetFittingData=function(overlayData)
    {
        var result=new Array();

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j>=overlayData.length)
            {
                result[i]=null;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;

            if (overlayDate==date)
            {
                var item=new SingleData();
                item.Date=overlayData[j].Date;
                item.Value=overlayData[j].Value;
                result[i]=item;
                ++j;
                ++i;
            }
            else if (overlayDate<date)
            {
                ++j;
            }
            else
            {
                result[i]=new SingleData();
                result[i].Date=date;
                ++i;
            }
        }

        return result;
    }

    // 缺省数据使用 emptyValue填充
    this.GetFittingData2=function(overlayData,emptyValue)
    {
        var result=new Array();

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j>=overlayData.length)
            {
                result[i]=new SingleData();
                result[i].Date=date;
                result[i].Value=emptyValue;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;

            if (overlayDate==date)
            {
                var item=new SingleData();
                item.Date=overlayData[j].Date;
                item.Value=overlayData[j].Value;
                result[i]=item;
                ++j;
                ++i;
            }
            else if (overlayDate<date)
            {
                ++j;
            }
            else
            {
                result[i]=new SingleData();
                result[i].Date=date;
                result[i].Value=emptyValue;
                ++i;
            }
        }

        return result;
    }

    //日期转化 对应数据索引
    this.GetDateIndex=function(data)
    {
        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j>=data.length) break;

            var dateItem=data[j];

            if (dateItem.Date==date)
            {
                dateItem.Index=i;
                ++j;
            }
            else if (dateItem.Date<date)
            {
                ++j;
            }
            else
            {
                ++i;
            }
        }
    }

    //日期 时间转化 对应数据索引
    this.GetDateTimeIndex=function(data)
    {
        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j>=data.length) break;

            var dateTimeItem=data[j];

            if (dateTimeItem.Date==date && dateTimeItem.Time==time)
            {
                dateTimeItem.Index=i;
                ++j;
            }
            else if (dateTimeItem.Date<date || (dateTimeItem.Date==date && dateTimeItem.Time<time))
            {
                ++j;
            }
            else
            {
                ++i;
            }
        }
    }

    /*
    this.GetMinuteFittingData=function(overlayData)
    {
        var result=[];
        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j>=overlayData.length)
            {
                result[i]=null;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;
            var overlayTime=overlayData[j].Time;
            const overlayItem=overlayData[j];

            if (overlayDate==date && overlayTime==time)
            {
                var item=new SingleData();
                item.Date=overlayItem.Date;
                item.Time=overlayItem.Time;
                item.Value=overlayItem.Value;
                result[i]=item;
                ++j;
                ++i;
            }
            else if (overlayDate<date || (overlayDate==date && overlayTime<time))
            {
                ++j;
            }
            else
            {
                var item=new SingleData();
                item.Date=date;
                item.Time=time;
                result[i]=item;
                ++i;
            }
        }

        return result;
    }
    */

    //分钟数据拟合  精确匹配
    this.GetMinuteFittingData=function(overlayData)
    {
        var result=[];
        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j>=overlayData.length)
            {
                result[i]=null;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;
            var overlayTime=overlayData[j].Time;
            const overlayItem=overlayData[j];

            if (overlayDate==date && overlayTime==time)
            {
                var item=new SingleData();
                item.Date=overlayItem.Date;
                item.Time=overlayItem.Time;
                item.Value=overlayItem.Value;
                result[i]=item;
                ++j;
                ++i;
            }
            else if (overlayDate<date || (overlayDate==date && overlayTime<time))
            {
                ++j;
            }
            else
            {
                var item=new SingleData();
                item.Date=date;
                item.Time=time;
                result[i]=item;
                ++i;
            }
        }

        return result;
    }

    //分钟数据拟合  数据顺延
    this.GetMinuteFittingDataV2=function(overlayData)
    {
        var result=[];
        var latestItem=null;
        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j>=overlayData.length)
            {
                result[i]=null;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;
            var overlayTime=overlayData[j].Time;
            const overlayItem=overlayData[j];

            if (overlayDate==date && overlayTime==time)
            {
                var item=new SingleData();
                item.Date=overlayItem.Date;
                item.Time=overlayItem.Time;
                item.Value=overlayItem.Value;
                result[i]=item;
                latestItem=overlayItem;
                ++j;
                ++i;
            }
            else if (overlayDate<date || (overlayDate==date && overlayTime<time))
            {
                //数据更新到最新数据上
                var index=result.length-1;
                if (index>=0)
                {
                    var item=result[index];
                    if (item)
                    {
                        if (overlayDate<item.Date || ((overlayDate==item.Date && overlayTime<item.Time)))
                            item.Value=overlayItem.Value;
                    } 
                }
                
                latestItem=overlayItem;
                ++j;
            }
            else
            {
                var item=new SingleData();
                item.Date=date;
                item.Time=time;
                if (latestItem) item.Value=latestItem.Value;
                result[i]=item;
                ++i;
            }
        }

        return result;
    }



    //把财报数据拟合到主图数据,返回 SingleData 数组
    this.GetFittingFinanceData=function(financeData)
    {
        var result=[];

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j<financeData.length)
            {
                var fDate=financeData[j].Date;
                if (date<fDate)
                {
                    ++i;
                    continue;
                }
            }
            
            if (j+1<financeData.length)
            {
                if (financeData[j].Date<date && financeData[j+1].Date<=date)
                {
                    ++j;
                    continue;
                }
            }

            var item=new SingleData();
            item.Date=date;
            if (j<financeData.length)
            {
                item.Value=financeData[j].Value;
                item.FinanceDate=financeData[j].Date;   //财务日期 调试用
            }
            else
            {
                item.Value=null;
                item.FinanceDate=null;
            }
            result[i]=item;

            ++i;
        }

        return result;
    }

    //财务数据拟合到分钟数据上 返回 SingleData 数组
    this.GetMinuteFittingFinanceData=function(financeData)
    {
        var result=[];
        if (!Array.isArray(financeData) || financeData.length<=0) return result;

        var i=0;
        var firstItem=financeData[0];
        for(i=0;i<this.Data.length;++i)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;
            if (date>firstItem.Date || (date==firstItem.Date && time>=firstItem.Time))
            {
                break;
            }    
        }

        for(var j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j+1<financeData.length)
            {
                if ((financeData[j].Date<date && financeData[j+1].Date<=date) ||
                    (financeData[j].Date==date && financeData[j].Time<time && financeData[j+1].Time<=time) )
                {
                    ++j;
                    continue;
                }
            }

            var item=new SingleData();
            item.Date=date;
            item.Time=time;
            if (j<financeData.length)
            {
                item.Value=financeData[j].Value;
                item.FinanceDate=financeData[j].Date;   //财务日期 调试用
                item.FinanceTime=financeData[j].Time;   //财务日期 调试用
            }
            else
            {
                item.Value=null;
                item.FinanceDate=null;
                item.FinanceTime=null;
            }
            result[i]=item;

            ++i;
        }

        return result;
    }

    //日线拟合交易数据, 不做平滑处理
    this.GetFittingTradeData=function(tradeData, nullValue, bExactMatch)
    {
        var result=[];
        var bMatch=false;

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j<tradeData.length)
            {
                if (tradeData[j].Date>date)
                {
                    var item=new SingleData();
                    item.Date=date;
                    item.Value=nullValue;
                    result[i]=item;
                    ++i;
                    continue;
                }
            }

            if (j+1<tradeData.length)
            {
                if (tradeData[j].Date<date && tradeData[j+1].Date<=date)
                {
                    ++j;
                    bMatch=false;
                    continue;
                }
            }

            var item=new SingleData();
            item.Date=date;
            item.Value=nullValue;
            item.FinanceDate=null;
            if (j<tradeData.length)
            {
                var tradeItem=tradeData[j];
                if (this.Period==0 && bExactMatch===true) //日线完全匹配
                {
                    if (tradeItem.Date==item.Date)
                    {
                        item.Value=tradeItem.Value;
                        item.FinanceDate=tradeItem.Date;   //财务日期 调试用
                        bMatch=true;
                    }
                }
                else    //其他日线周期
                {
                    if (bMatch==false)
                    {
                        item.Value=tradeItem.Value;
                        item.FinanceDate=tradeItem.Date;   //财务日期 调试用
                        bMatch=true;
                    }
                }
            }
           
            result[i]=item;
            ++i;
        }

        return result;
    }

    this.GetMinuteFittingTradeData=function(tradeData, nullValue,bExactMatch)
    {
        var result=[];
        var bMatch=false;

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (j<tradeData.length)
            {
                if (tradeData[j].Date>date || (tradeData[j].Date==date && tradeData[j].Time>time))
                {
                    var item=new SingleData();
                    item.Date=date;
                    item.Time=time;
                    item.Value=nullValue;
                    result[i]=item;
                    ++i;
                    continue;
                }
            }

            if (j+1<tradeData.length)
            {
                if ( (tradeData[j].Date<date && tradeData[j+1].Date<=date) || 
                    (tradeData[j].Date==date && tradeData[j].Time<time && tradeData[j+1].Time<=time) )
                {
                    ++j;
                    bMatch=false;
                    continue;
                }
            }

            var item=new SingleData();
            item.Date=date;
            item.FinanceDate=null;
            item.Time=time;
            item.Value=nullValue;
            if (j<tradeData.length)
            {
                var tradeItem=tradeData[j];
                if (this.Period==4 && bExactMatch===true) //1分钟线完全匹配
                {
                    if (tradeItem.Date==item.Date && tradeItem.Time==item.Time)  //完全匹配
                    {
                        item.Value=tradeItem.Value;
                        item.FinanceDate=tradeItem.Date;   //财务日期 调试用
                        item.FinanceTime=tradeItem.Time;
                        bMatch=true;
                    }
                }
                else    //其他日线周期
                {
                    if (bMatch==false)
                    {
                        item.Value=tradeItem.Value;
                        item.FinanceDate=tradeItem.Date;   //财务日期 调试用
                        item.FinanceTime=tradeItem.Time;
                        bMatch=true;
                    }
                }
            }

            result[i]=item;
            ++i;
        }

        return result;
    }

    //市值计算 financeData.Value 是股数
    this.GetFittingMarketValueData=function(financeData)
    {
        var result=[];

        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;
            var price=this.Data[i].Close;

            if (j+1<financeData.length)
            {
                if (financeData[j].Date<date && financeData[j+1].Date<=date)
                {
                    ++j;
                    continue;
                }
            }

            var item=new SingleData();
            item.Date=date;
            item.Value=financeData[j].Value*price;  //市值计算 收盘价*股数
            item.FinanceDate=financeData[j].Date;   //财务日期 调试用
            result[i]=item;

            ++i;
        }

        return result;
    }

    //月线数据拟合
    this.GetFittingMonthData=function(overlayData)
    {
        var result=new Array();

        var preDate=null;
        for(var i=0,j=0;i<this.Data.length;)
        {
            var date=this.Data[i].Date;

            if (j>=overlayData.length)
            {
                result[i]=null;
                ++i;
                continue;;
            }

            var overlayDate=overlayData[j].Date;

            if (overlayDate==date)
            {
                var item=new SingleData();
                item.Date=overlayData[j].Date;
                item.Value=overlayData[j].Value;
                item.Text=overlayData[j].Text;
                result[i]=item;
                ++j;
                ++i;
            }
            else if (preDate!=null && preDate<overlayDate && date>overlayDate)
            {
                var item=new SingleData();
                item.Date=date;
                item.OverlayDate=overlayData[j].Date;
                item.Value=overlayData[j].Value;
                item.Text=overlayData[j].Text;
                result[i]=item;
                ++j;
                ++i;
            }
            else if (overlayDate<date)
            {
                ++j;
            }
            else
            {
                result[i]=new SingleData();
                result[i].Date=date;
                ++i;
            }

            preDate=date;
        }

        return result;
    }

    this.GetValue=function()
    {
        var result=[];
        for(var i in this.Data)
        {
            if (this.Data[i] && this.Data[i].Value!=null)
            { 
                var item=this.Data[i].Value;
                if (!isNaN(item))
                    result[i]=item;
                else if (item instanceof Array)   //支持数组
                    result[i]=item;
                else
                    result[i]=null;
            }
            else
                result[i]=null;
        }

        return result;
    }

    this.GetObject=function()
    {
        var result=[];
        for(var i in this.Data)
        {
            if (this.Data[i] && this.Data[i].Value)
            { 
                var item=this.Data[i].Value;
                result[i]=item;
            }
            else
                result[i]=null;
        }

        return result;
    }

    this.GetPeriodSingleData=function(period)
    {
        var result=new Array();
        var index=0;
        var startDate=0;
        var weekCount=2;
        var newData=null;
        for(var i in this.Data)
        {
            var isNewData=false;
            var dayData=this.Data[i];
            if (dayData==null || dayData.Date==null) continue;

            switch(period)
            {
                case 1: //周线
                    var fridayDate=ChartData.GetFirday(dayData.Date);
                    if (fridayDate!=startDate)
                    {
                        isNewData=true;
                        startDate=fridayDate;
                    }
                    break;
                case 21: //双周
                    var fridayDate=ChartData.GetFirday(dayData.Date);
                    if (fridayDate!=startDate)
                    {
                        ++weekCount;
                        if (weekCount>=2) 
                        {
                            isNewData=true;
                            weekCount=0;
                        }
                        startDate=fridayDate;
                    }
                    break;
                case 2: //月线
                    if (parseInt(dayData.Date/100)!=parseInt(startDate/100))
                    {
                        isNewData=true;
                        startDate=dayData.Date;
                    }
                    break;
                case 3: //年线
                    if (parseInt(dayData.Date/10000)!=parseInt(startDate/10000))
                    {
                        isNewData=true;
                        startDate=dayData.Date;
                    }
                    break;
                case 9: //季线
                    var now=ChartData.GetQuarter(dayData.Date);
                    now=parseInt(dayData.Date/10000)*10+now;
                    var last=ChartData.GetQuarter(startDate);
                    last=parseInt(startDate/10000)*10+last;
                    if (now!=last)
                    {
                        isNewData=true;
                        startDate=dayData.Date;
                    }
                    break;
            }

            if (isNewData)
            {
                newData=new SingleData();
                newData.Date=dayData.Date;
                newData.Value=dayData.Value;
                result.push(newData);
            }
            else
            {
                if (newData==null) continue;
                if (dayData.Value==null || isNaN(dayData.Value)) continue;
                if (newData.Value==null || isNaN(newData.Value)) newData.Value=dayData.Value;
            }
        }

        return result;
    }

    /*
        分钟数据方法
        this.GetClose()     每分钟价格
        this.GetVol()       每分钟成交量
    */

    //分钟均线
    this.GetMinuteAvPrice=function()
    {
        var result=new Array();
        for(var i in this.Data)
        {
            result[i]=this.Data[i].AvPrice;
        }

        return result;
    }

    this.MergeMinuteData=function(data) //合并数据
    {
        if (!this.Data || this.Data.length<=0)
        {
            this.Data=data;
            return true;
        }

        var sourceFirstItem=this.Data[0];
        var firstItemID=0;
        var firstItem=null;
        for(var i=0;i<data.length;++i)  //查找比原始数据起始位置大的数据位置
        {
            var item=data[i];
            if (item.Date>sourceFirstItem.Date)
            {
                firstItemID=i;
                firstItem=item;
                break;
            }

            if (item.Date==sourceFirstItem.Date && item.Time>=sourceFirstItem.Time)
            {
                firstItemID=i;
                firstItem=item;
                break;
            }
        }

        if (firstItem==null) return false;

        var index=null;
        var bFind=false;    //第1个数据是否完全匹配
        for(var i=this.Data.length-1; i>=0;--i)
        {
            var date=this.Data[i].Date;
            var time=this.Data[i].Time;

            if (firstItem.Date>date || (firstItem.Date==date  &&  firstItem.Time>=time) )
            {
                index=i;
                if (firstItem.Date==date && firstItem.Time==time) bFind=true;
                break;
            }
        }

        if (index==null) return false;

        var j=index;        //原始数据插入位置
        var i=firstItemID;  //合并数据起始位置
        if (bFind==true)    //第1个数据匹配,覆盖
        {
            var item=data[i];
            if (j-1>0)
            {
                var preItem=this.Data[j-1];
                if (!item.YClose) item.YClose=preItem.Close;    //前收盘如果没有就是上一记录的收盘

                //流通股使用上一个数据的
                if (!IFrameSplitOperator.IsNumber(item.FlowCapital) && IFrameSplitOperator.IsNumber(preItem.FlowCapital)) 
                    item.FlowCapital=preItem.FlowCapital;
            }
            var newItem=HistoryData.Copy(item);
            this.Data[j]=newItem;
            ++j;
            ++i;
        }
        else            //从下一个数据开始插入
        {
            ++j;
        }

        for(;i<data.length; )
        {
            var item=data[i];
            if (j>=this.Data.length-1)
            {
                if (j-1>0)
                {
                    var preItem=this.Data[j-1];
                    if (!item.YClose) item.YClose=preItem.Close;    //前收盘如果没有就是上一记录的收盘

                    //流通股使用上一个数据的
                    if (!IFrameSplitOperator.IsNumber(item.FlowCapital) && IFrameSplitOperator.IsNumber(preItem.FlowCapital)) 
                    item.FlowCapital=preItem.FlowCapital;
                }
                //if (j-1>0 && !item.YClose) item.YClose=this.Data[j-1].YClose;   //前收盘如果没有就是上一记录的收盘
                //if (j-1>0 && !IFrameSplitOperator.IsNumber(item.FlowCapital) && IFrameSplitOperator.IsNumber(this.Data[j-1].FlowCapital)) item.FlowCapital=this.Data[j-1].FlowCapital;
                var newItem=HistoryData.Copy(item);
                this.Data[j]=newItem;
                ++j;
                ++i;
            }
            else
            {
                var oldItem=this.Data[j];
                if (oldItem.Date==item.Date && oldItem.Time==item.Time) //更新数据
                {
                    HistoryData.CopyTo(oldItem,item);
                    ++j;
                    ++i;
                }
                else
                {
                    ++j;
                }
            }
        }

        //JSConsole.Chart.Log('[ChartData::MergeMinuteData] ', this.Data, data);

        return true;
    }

    //跨周期转化
    this.ConverPeriod=function(data, curPeriod, changePeriod) //把数据用data, 日期时间不变, curPeriod=当前周期  changePeriod=需要转换周期
    {
        var result=[];
        var tempItem=null;
        var isMinute=ChartData.IsMinutePeriod(curPeriod,true);
        var isMinute2=ChartData.IsMinutePeriod(changePeriod,true);
        var isMimToMin=isMinute && isMinute2;
        var isMinToDay=isMinute && !isMinute2;
        var isDayToDay=!isMinute && !isMinute2;

        for(var i=0,j=0; i<this.Data.length; ++i)
        {
            var item=this.Data[i];  //原始数据
            for(;j<data.length;++j)
            {
                var periodItem=data[j];

                if (isMimToMin)  //都是分钟数据
                {
                    if ( (periodItem.Date>item.Date) || (periodItem.Date==item.Date && periodItem.Time>=item.Time) )
                    {
                        tempItem=periodItem;
                        break;
                    }
                }
                else if (isMinToDay || isDayToDay)    //分钟 => 日线, 日线 => 日线
                {
                    if (periodItem.Date>=item.Date)
                    {
                        tempItem=periodItem;
                        break;
                    }
                }
            }
            
            var newItem=null;
            if (tempItem) 
            {
                newItem=HistoryData.Copy(tempItem);
                newItem.PDate=tempItem.Date;
                newItem.PTime=tempItem.Time;
            }
            else newItem=new HistoryData();
            
            newItem.Date=item.Date;
            if (isMimToMin || isMinToDay) newItem.Time=item.Time;
            result.push(newItem);
        }

        JSConsole.Chart.Log('[ChartData::ConverPeriod] result', result);
        return result;
    }

    this.GetRef=function(n)
    {
        let result=[];

        for(var i=0 ;i<this.Data.length; ++i )
        {
            result[i]=null;
            var itemDate=this.Data[i];  //原始数据

            if (i-n<0) 
            {
                var newData=new HistoryData();
                newData.Date=itemDate.Date;
                newData.Time=itemDate.Time;
                result[i]=newData;
                continue;
            }

            var itemData=this.Data[i-n];
            var newData=HistoryData.Copy(itemData);
            newData.Date=itemDate.Date;
            newData.Time=itemDate.Time;

            result[i]=newData;
        }

        return result;
    }

    //拟合其他K线数据指标   
    this.FitKLineIndex=function(kLineData, outVar, peirod, indexPeriod)
    {
        var count=this.Data.length;         //原始K线数据
        var indexCount=kLineData.length;    //拟合K线数据
        var isMinutePeriod=[ChartData.IsMinutePeriod(peirod,true), ChartData.IsMinutePeriod(indexPeriod,true) ]; //0=原始K线 1=需要拟合的K线
        var isDayPeriod=[ChartData.IsDayPeriod(peirod,true), ChartData.IsDayPeriod(indexPeriod,true)  ];   //0=原始K线 1=需要拟合的K线
        var firstItem=ChartData.GetKLineDataTime(this.Data[0]);

        //计算拟合以后的数据索引
        var aryFixDataID=[];
        var indexStart=indexCount;
        for(var i=0;i<indexCount;++i)
        {
            var item=ChartData.GetKLineDataTime(kLineData[i]);

            if ( (isDayPeriod[0] && isDayPeriod[1]) || (isMinutePeriod[0] && isDayPeriod[1]) )   //日线(拟合) => 日线(原始)    日线(拟合 => 分钟(原始)
            {
                if (item.Date>=firstItem.Date)
                {
                    indexStart = i;
                    break;
                }
            }
            else if (isMinutePeriod[0] && isMinutePeriod[1]) //分钟(拟合 => 分钟(原始)
            {
                if (item.Date>firstItem.Date)
                {
                    indexStart = i;
                    break;
                }

                if (item.Date == firstItem.Date && item.Time >= firstItem.Time )
                {
                    indexStart = i;
                    break;
                }
            }
        }

        for(var i=0, j=indexStart; i<count; )
        {
            var item=ChartData.GetKLineDataTime(this.Data[i]);
            if (j>=indexCount)
            {
                var fitItem={ Date:item.Date, Time:item.Time, Index:-1 };
                aryFixDataID[i]=fitItem;
                ++i;
                continue;
            }

            var destItem=ChartData.GetKLineDataTime(kLineData[j]);
            if ( (isDayPeriod[0] && isDayPeriod[1]) || (isMinutePeriod[0] && isDayPeriod[1]) )  //日线(拟合) => 日线(原始)    日线(拟合 => 分钟(原始)
            {
                if (destItem.Date == item.Date)
                {
                    var fitItem={ Date:item.Date, Time:item.Time, Index:j, Data2:destItem.Date, Time2:destItem.Time };
                    aryFixDataID[i]=fitItem;
                    ++i;
                }
                else 
                {
                    if (j+1<indexCount)
                    {
                        var nextDestItem=ChartData.GetKLineDataTime(kLineData[j+1]);
                        if ( destItem.Date<=item.Date && nextDestItem.Date>item.Date )
                        {
                            var fitItem={ Date:item.Date, Time:item.Time, Index:j+1, Data2:nextDestItem.Date, Time2:nextDestItem.Time };
                            aryFixDataID[i]=fitItem;
                            ++i;
                        }
                        else if (nextDestItem.Date <= item.Date )
                        {
                            ++j;
                        }
                        else
                        {
                            var fitItem={ Date:item.Date, Time:item.Time, Index:-1 };
                            aryFixDataID[i]=fitItem;
                            ++i;
                        }
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
            else if (isMinutePeriod[0] && isMinutePeriod[1])    //分钟(拟合 => 分钟(原始)
            {
                if (destItem.Date == item.Date && destItem.Time == item.Time)
                {
                    var fitItem={ Date:item.Date, Time:item.Time, Index:j, Data2:destItem.Date, Time2:destItem.Time };
                    aryFixDataID[i]=fitItem;
                    ++i;
                }
                else
                {
                    if (j+1<indexCount)
                    {
                        var nextDestItem=ChartData.GetKLineDataTime(kLineData[j+1]);
                        if ( (destItem.Date<item.Date && nextDestItem.Date>item.Date) || 
                            (destItem.Date == item.Date && destItem.Time < item.Time && nextDestItem.Date == item.Date && nextDestItem.Time > item.Time) ||
                            (destItem.Date == item.Date && destItem.Time < item.Time && nextDestItem.Date > item.Date) ||
                            (destItem.Date < item.Date && nextDestItem.Date == item.Date && nextDestItem.Time > item.Time) )
                        {
                            var fitItem={ Date:item.Date, Time:item.Time, Index:j+1, Data2:nextDestItem.Date, Time2:nextDestItem.Time };
                            aryFixDataID[i]=fitItem;
                            ++i;
                        }
                        else if (nextDestItem.Date < item.Date || (nextDestItem.Date == item.Date && nextDestItem.Time <= item.Time) )
                        {
                            ++j;
                        }
                        else
                        {
                            var fitItem={ Date:item.Date, Time:item.Time, Index:-1 };
                            aryFixDataID[i]=fitItem;
                            ++i;
                        }
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
        }

        //拟合数据
        var result=[];
        for(var i in outVar)
        {
            var item=outVar[i];
            if (Array.isArray(item.Data)) 
            {
                var data=[];
                result[i]={ Data:data, Name:item.Name } ;
                for(var j=0;j<aryFixDataID.length;++j)
                {
                    var dataItem=aryFixDataID[j];
                    data[j]=null;
                    if ( dataItem && dataItem.Index>=0 && dataItem.Index<item.Data.length )
                        data[j]=item.Data[dataItem.Index];
                }
            }
            else 
            {
                result[i]={ Data:item.Data, Name:item.Name} ;
            }
        }

        return result;
    }

    //获取数据索引
    this.FindDataIndexByDateTime=function(aryDateTime) //aryDateTime=[ { Date:, Time:, Index:-1 }, ......]
    {
        var findCount=0;
        for(var i in aryDateTime)
        {
            aryDateTime[i].Index=-1;
        }

        for(var i in this.Data)
        {
            var item=this.Data[i];
            for(var j in aryDateTime)
            {
                var findItem=aryDateTime[j];
                if (findItem.Index>=0) continue;

                if (IFrameSplitOperator.IsNumber(findItem.Time))
                {
                    if (findItem.Date==item.Date && findItem.Time==item.Time)
                    {
                        findItem.Index=parseInt(i);
                        ++findCount;
                        break;
                    }
                }
                else
                {
                    if (findItem.Date==item.Date)
                    {
                        findItem.Index=parseInt(i);
                        ++findCount;
                        break;
                    }
                }

                if (findCount>=aryDateTime.length) break;
            }
        }
    }

    //深拷贝数据
    this.CloneData=function(className)
    {
        var result=[];
        if (className=="HistoryData")
        {
            for(var i in this.Data)
            {
                var item=this.Data[i];
                var newItem=HistoryData.Copy(item);
                result.push(newItem);
            }
        }
        return result;
    }

    this.GetAPIDataIndex=function(date,time)
    {
        var result=[];
        if (date && time)
        {
            var count=this.Data.length;         //原始K线数据
            var indexCount=date.length;         //拟合数据
            var firstItem=ChartData.GetKLineDataTime(this.Data[0]);
            var indexStart=indexCount;  //拟合数据的起始位置

            var indexStart=indexCount;  //拟合数据的起始位置
            for(var i=0;i<indexCount;++i)
            {
                var itemDate=date[i];
                var itemTime=time[i];
    
               if (itemDate>firstItem.Date || (itemDate == firstItem.Date && itemTime >= firstItem.Time))
                {
                    indexStart = i;
                    break;
                }
            }

            for(var i=0, j=indexStart; i<count; )
            {
                var item=this.Data[i];
                if (j>=indexCount)
                {
                    var fitItem={ KDate:item.Date, KTime:item.Time, KIndex:i, Index:-1 };
                    result[i]=fitItem;
                    ++i;
                    continue;
                }

                var itemDate=date[j];
                var itemTime=time[j];
                if (itemDate == item.Date && itemTime == item.Time)
                {
                    var fitItem={ KDate:item.Date, KTime:item.Time, KIndex:i, Index:j, Data:itemDate, Time:itemTime };
                    result[i]=fitItem;
                    ++i;
                }
                else
                {
                    if (j+1<indexCount)
                    {
                        var nextItemDate=date[j+1];
                        var nextItemTime=time[j+1];

                        if ( (itemDate<item.Date && nextItemDate>item.Date) || 
                            (itemDate == item.Date && itemTime < item.Time && nextItemDate == item.Date && nextItemTime > item.Time) ||
                            (itemDate == item.Date && itemTime < item.Time && nextItemDate > item.Date) ||
                            (itemDate < item.Date && nextItemDate == item.Date && nextItemTime > item.Time) )
                        {
                            var fitItem={ KDate:item.Date, KTime:item.Time, KIndex:i, Index:j, Data:itemDate, Time:itemTime };
                            result[i]=fitItem;
                            ++i;
                        }
                        else if (nextItemDate < item.Date || (nextItemDate == item.Date && nextItemTime <= item.Time) )
                        {
                            ++j;
                        }
                        else
                        {
                            var fitItem={ KDate:item.Date, KTime:item.Time, KIndex:i, Index:-1 };
                            result[i]=fitItem;
                            ++i;
                        }
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
        }
        else if (date)
        {
            var count=this.Data.length;         //原始K线数据
            var indexCount=date.length;         //拟合数据
            var firstItem=ChartData.GetKLineDataTime(this.Data[0]);

            var indexStart=indexCount;  //拟合数据的起始位置
            for(var i=0;i<indexCount;++i)
            {
                var item=date[i];
    
                if (item>=firstItem.Date)
                {
                    indexStart = i;
                    break;
                }
            }

            for(var i=0, j=indexStart; i<count; )
            {
                var item=this.Data[i];
                if (j>=indexCount)
                {
                    var fitItem={ KDate:item.Date, KIndex:i, Index:-1 };
                    result[i]=fitItem;
                    ++i;
                    continue;
                }

                var destDate=date[j];
                if (destDate == item.Date)
                {
                    var fitItem={ KDate:item.Date, KIndex:i, Index:j, Data:destDate };
                    result[i]=fitItem;
                    ++i;
                }
                else 
                {
                    if (j+1<indexCount)
                    {
                        var nextDestDate=date[j+1];
                        if ( destDate<=item.Date && nextDestDate>item.Date )
                        {
                            var fitItem={ KDate:item.Date, KIndex:i, Index:j, Data:destDate };
                            result[i]=fitItem;
                            ++i;
                        }
                        else if (nextDestDate <= item.Date )
                        {
                            ++j;
                        }
                        else
                        {
                            var fitItem={ KDate:item.Date, KIndex:i, Index:-1 };
                            result[i]=fitItem;
                            ++i;
                        }
                    }
                    else
                    {
                        ++j;
                    }
                }
            }
        }
        return result;
    }

    //K线数据拟合
    this.FixKData=function(aryKData, period)
    {
        if (ChartData.IsDayPeriod(period,true))
        {
            return this.FixKData_Day(aryKData);
        }
        else if (ChartData.IsMinutePeriod(period,true))
        {
            return this.FixKData_Minute(aryKData);
        }
        
        return null;
    }

    this.FixKData_Day=function(aryKData)
    {
        var result=[];
        var nOverlayDataCount=aryKData.length;
        for(var i=0,j=0; i<this.Data.length;)
        {
            var kItem=this.Data[i];
            if (j<nOverlayDataCount)
            {
                var fItem=aryKData[j];
                if (fItem.Date>kItem.Date)
                {
                    ++i;
                    continue;
                }
            }

            if (j+1<nOverlayDataCount)
            {
                var fItem = aryKData[j];
                var fItem2 = aryKData[j + 1];

                if (fItem.Date < kItem.Date && fItem2.Date <= kItem.Date)
                {
                    ++j;
                    continue;
                }
            }

            var item=new HistoryData();
            item.Date=kItem.Date;
            var index=j<nOverlayDataCount ? j : nOverlayDataCount-1;
            var fItem=aryKData[index];

            item.Close = fItem.Close;
			item.High = fItem.High;
			item.Low = fItem.Low;
			item.Open = fItem.Open;
			item.YClose = fItem.YClose;
			item.Amount = fItem.Amount;
            item.Vol = fItem.Vol;
            item.ExDate = fItem.Date;   //对应叠加数据的日期 调试用

            result[i]=item;
            ++i;
        }

        return result;
    }

    this.FixKData_Minute=function(aryKData)
    {
        var result=[];
        var nOverlayDataCount=aryKData.length;
        for(var i=0,j=0; i<this.Data.length;)
        {
            var kItem=this.Data[i];
            var kDateTime=ChartData.DateTimeToNumber(kItem);

            if (j<nOverlayDataCount)
            {
                var fItem=aryKData[j];
                var fDateTime=ChartData.DateTimeToNumber(fItem);
                if (fDateTime>kDateTime)
                {
                    ++i;
                    continue;
                }
            }

            if (j+1<nOverlayDataCount)
            {
                var fItem = aryKData[j];
                var fItem2 = aryKData[j + 1];
                var fDateTime=ChartData.DateTimeToNumber(fItem);
                var fDateTime2=ChartData.DateTimeToNumber(fItem2);

                if (fDateTime < kDateTime && fDateTime2 <= kDateTime)
                {
                    ++j;
                    continue;
                }
            }

            var item=new HistoryData();
            item.Date=kItem.Date;
            item.Time=kItem.Time;
            var index=j<nOverlayDataCount ? j : nOverlayDataCount-1;
            var fItem=aryKData[index];

            item.Close = fItem.Close;
			item.High = fItem.High;
			item.Low = fItem.Low;
			item.Open = fItem.Open;
			item.YClose = fItem.YClose;
			item.Amount = fItem.Amount;
            item.Vol = fItem.Vol;
            item.ExDate = fItem.Date;   //对应叠加数据的日期 调试用
            item.ExTime=fItem.Time;     //对应叠加数据的日期 调试用

            result[i]=item;
            ++i;
        }

        return result;
    }

    //获取K线的索引范围 start={ Date, Time };
    this.GetDataRange=function(start, end)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return null;

        var range={  }; //{Start:{Date, Time, Index,}, End:{Date, Time, Index}}

        for(var i=0; i<this.Data.length; ++i)
        {
            var item=this.Data[i];
            if (item.Date==start.Date)
            {
                if (IFrameSplitOperator.IsNumber(start.Time))
                {
                    if (item.Time==start.Time)  range.Start={ Index:i, Date:item.Date, Time:item.Time };
                }
                else
                {
                    range.Start={ Index:i, Date:item.Date };
                }
            }

            if (item.Date=end.Date)
            {
                if (IFrameSplitOperator.IsNumber(end.Time))
                {
                    if (item.Time==end.Time)  range.End={ Index:i, Date:item.Date, Time:item.Time };
                }
                else
                {
                    range.End={ Index:i, Date:item.Date };
                }
                
            }

            if (range.Start && range.End) return range;
        }

        return null;
    }

    //导出单数组数据
    this.ExportArrayData=function(aryKData,option)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return null;

        var start=0, end=this.Data.length-1;
        //限制范围
        if (option && option.Start && option.End && IFrameSplitOperator.IsNumber(option.Start.Index) && IFrameSplitOperator.IsNumber(option.End.Index))
        {
            start=option.Start.Index;
            end=option.End.Index;
        }

        var aryData=[];
        for(var i=start; i<=end && i<this.Data.length; ++i)
        {
            aryData[i]=this.Data[i];
        }

        return aryData;
    }

    this.ExportBoolData=function(aryKData,option)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return null;

        var start=0, end=this.Data.length-1;
        //限制范围
        if (option && option.Start && option.End && IFrameSplitOperator.IsNumber(option.Start.Index) && IFrameSplitOperator.IsNumber(option.End.Index))
        {
            start=option.Start.Index;
            end=option.End.Index;
        }

        var aryValue=[];
        for(var i=start; i<=end && i<this.Data.length; ++i)
        {
            var item=this.Data[i];
            aryValue[i]=false;

            if (!IFrameSplitOperator.IsPlusNumber(item)) continue;

            aryValue[i]=true;
        }

        return aryValue;
    }

    //导出K线数据
    this.ExportKLineData=function(option)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return null;

        var start=0, end=this.Data.length-1;
        //限制范围
        if (option && option.Start && option.End && IFrameSplitOperator.IsNumber(option.Start.Index) && IFrameSplitOperator.IsNumber(option.End.Index))
        {
            start=option.Start.Index;
            end=option.End.Index;
        }

        var aryDate=[], aryOpen=[], aryHigh=[], aryLow=[], aryVol=[], aryAmount=[], aryClose=[], aryTime=[];
        for(var i=start; i<=end && i<this.Data.length; ++i)
        {
            var item=this.Data[i];

            aryDate[i]=item.Date;
            aryOpen[i]=item.Open;
            aryHigh[i]=item.High;
            aryLow[i]=item.Low;
            aryClose[i]=item.Close;
            aryVol[i]=item.Vol;
            aryAmount[i]=item.Amount;
            aryTime[i]=item.Time;
        }

        if (option)
        {
            if (option.IsOverlay)   //叠加股票不返回时间,日期
            {
                var result=
                [
                    {Name:"Open", Data:aryOpen }, {Name:"High", Data:aryHigh }, {Name:"Low", Data:aryLow}, {Name:"Close", Data:aryClose },
                    {Name:"Vol", Data:aryVol}, { Name:"Amount", Data:aryAmount}
                ];

                return result;
            }
        }

        var result=[  {Name:"Date", Data:aryDate} ];

        if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period) || ChartData.IsMilliSecondPeriod(this.Period))
            result.push({ Name:"Time", Data:aryTime} );

        result.push
        (
            {Name:"Open", Data:aryOpen }, {Name:"High", Data:aryHigh }, {Name:"Low", Data:aryLow}, {Name:"Close", Data:aryClose },
            {Name:"Vol", Data:aryVol}, { Name:"Amount", Data:aryAmount}
        );

        return result;
    }

    //导出分时图数据
    this.ExportMinuteData=function(option)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return null;

        var aryDate=[], aryOpen=[], aryHigh=[], aryLow=[], aryVol=[], aryAmount=[], aryClose=[], aryTime=[];
        var aryPosition=[], aryAvPrice=[];
        var start=0, end=this.Data.length-1;

        //限制范围
        if (option && option.Start && option.End && IFrameSplitOperator.IsNumber(option.Start.Index) && IFrameSplitOperator.IsNumber(option.End.Index))
        {
            start=option.Start.Index;
            end=option.End.Index;
        }

        for(var i=start;i<=end && i<this.Data.length;++i)
        {
            var item=this.Data[i];

            aryDate[i]=item.Date;
            aryOpen[i]=item.Open;
            aryHigh[i]=item.High;
            aryLow[i]=item.Low;
            aryClose[i]=item.Close;
            aryVol[i]=item.Vol;
            aryAmount[i]=item.Amount;
            aryTime[i]=item.Time;
            aryAvPrice[i]=item.AvPrice;
            aryPosition[i]=item.Position
        }

        var result=
        [
            {Name:"Open", Data:aryOpen }, {Name:"High", Data:aryHigh }, {Name:"Low", Data:aryLow}, {Name:"Close", Data:aryClose },
            {Name:"Vol", Data:aryVol}, { Name:"Amount", Data:aryAmount}, {Name:"AvPrice", Data:aryAvPrice}, {Name:"Position", Data: aryPosition}
        ];

        if (option)
        {
            if (option.IsOverlay)   //叠加股票不返回时间,日期
                return result;
        }

        result.splice(0,0,{Name:"Date", Data:aryDate}, { Name:"Time", Data:aryTime});

        return result;
    }
}

ChartData.DateTimeToNumber=function(kItem)
{
    return kItem.Date*10000+kItem.Time;
}

ChartData.GetKLineDataTime=function(kLineItem)   //获取K线的 日期和时间 如果时间没有就用0
{
    var result={ Date:kLineItem.Date, Time:0 };
    if (IFrameSplitOperator.IsNumber(kLineItem.Time)) result.Time=kLineItem.Time;

    return result;
}

ChartData.GetFirday=function(value)
{
    var date=new Date(parseInt(value/10000),(value/100%100-1),value%100);
    var day=date.getDay();
    if (day==5) return value;

    var timestamp=date.getTime();
    if (day<5)
    {
        var prevTimestamp=(24*60*60*1000)*(5-day);
        timestamp+=prevTimestamp;
    }
    else
    {
        var prevTimestamp=(24*60*60*1000)*(day-5);
        timestamp-=prevTimestamp;
    }

    date.setTime(timestamp);
    var fridayDate= date.getFullYear()*10000+(date.getMonth()+1)*100+date.getDate();
    var week=date.getDay();
    return fridayDate;

}

ChartData.GetSunday=function(value)
{
    var date=new Date(parseInt(value/10000),(value/100%100-1),value%100);
    var day=date.getDay();
    if (day==0) return value;

    var timestamp=date.getTime();
    if (day>0)
    {
        var prevTimestamp=(24*60*60*1000)*(7-day);
        timestamp+=prevTimestamp;
    }

    date.setTime(timestamp);
    var sundayDate= date.getFullYear()*10000+(date.getMonth()+1)*100+date.getDate();
    var week=date.getDay();
    return sundayDate;
}

ChartData.GetQuarter=function(value)
{
    var month=parseInt(value%10000/100);
    if (month==1 || month==2 || month==3) return 1;
    else if (month==4 || month==5 || month==6) return 2;
    else if (month==7 || month==8 || month==9) return 3;
    else if (month==10 || month==11 || month==12) return 4;
    else return 0;
}

ChartData.GetHalfYear=function(value)
{
    var year=parseInt(value/10000);
    var day=value%10000;
    if (day<=630) return year*10000+630;
    return year*10000+1231;
}

//是否是日线周期  0=日线 1=周线 2=月线 3=年线 9=季线 21=双周 22=半年 [40001-50000) 自定义日线 (isIncludeBase 是否包含基础日线周期)
var CUSTOM_DAY_PERIOD_START=40000, CUSTOM_DAY_PERIOD_END=49999;
ChartData.IsDayPeriod=function(period, isIncludeBase)
{
    if (period==1 || period==2 || period==3 || period==9 || period==21 || period==22) return true;
    if (period>CUSTOM_DAY_PERIOD_START && period<=CUSTOM_DAY_PERIOD_END) return true;
    if (period==0 && isIncludeBase==true) return true;

    return false;
}

//是否是分钟周期 4=1分钟 5=5分钟 6=15分钟 7=30分钟 8=60分钟 11=120分钟 12=240分钟 [20001-30000) 自定义分钟 (isIncludeBase 是否包含基础1分钟周期)
var CUSTOM_MINUTE_PERIOD_START=20000, CUSTOM_MINUTE_PERIOD_END=29999;
ChartData.IsMinutePeriod=function(period,isIncludeBase)
{
    if (period==5 || period==6 || period==7 || period==8 ||period==11 || period==12) return true;
    if (period>CUSTOM_MINUTE_PERIOD_START && period<=CUSTOM_MINUTE_PERIOD_END) return true;
    if (period==4 && isIncludeBase==true) return true;

    return false;
}

//是否是秒周期 [30001-32000)
var CUSTOM_SECOND_PERIOD_START=30000, CUSTOM_SECOND_PERIOD_END=32000;
ChartData.IsSecondPeriod=function(period)
{
    if (period>CUSTOM_SECOND_PERIOD_START && period<=CUSTOM_SECOND_PERIOD_END) return true;
    return false;
}

var CUSTOM_MILLISECOND_PERIOD_START=50000, CUSTOM_MILLISECOND_PERIOD_END=60000;
ChartData.IsMilliSecondPeriod=function(period)
{
    if (period>CUSTOM_MILLISECOND_PERIOD_START && period<=CUSTOM_MILLISECOND_PERIOD_END) return true;
    return false;
}



//是否是分笔图 10=分笔
ChartData.IsTickPeriod=function(period)
{
    return period==10;
}

//获取周期名字
ChartData.GetPeriodName=function(period)
{
    var mapName=new Map(
    [
        [0, '日线'],[1, '周线'],[2, '月线'],[3, '年线'],[9, '季线'], [21,'双周'],[22,"半年"],
        [4, '1分'], [5, '5分'], [6, '15分'],[7, '30分'],[8, '60分'],[11, '2小时'],[12, '4小时'],
        [10, '分笔']
    ]);

    if (mapName.has(period)) return mapName.get(period);

    return '';
}



function TooltipData()              //提示信息
{
    this.ChartPaint;
    this.Data;
    this.Type=0;
}

function Rect(x,y,width,height)
{
    this.X=x,
    this.Y=y;
    this.Width=width;
    this.Height=height;
}

//图形外部挂接
function ChartPaintFactory()
{
    //[key:name, { Create:function(option) { return new class(); }} ]
    this.DataMap=new Map(
    [
        ["ChartKLine", { Create:function(option) { return new ChartKLine(); } }],   //K线图
        ["ChartMinuteVolumBar",{ Create:function(option) { return new ChartMinuteVolumBar(); } }],   //分时成交量柱子
        ["ChartMinutePriceLine",{ Create:function(option) { return new ChartMinutePriceLine();} }]
    ]); 

    this.Create=function(name, option)
    {
        if (!this.DataMap.has(name)) 
        {
            JSConsole.Warn(`[ChartPaintFactory::Create] can't find class=${name}.`);
            return null;
        }

        var item=this.DataMap.get(name);
        return item.Create(option);
    }

    this.Add=function(name, option)
    {
        this.DataMap.set(name, { Create:option.Create } );
    }
}

var g_ChartPaintFactory=new ChartPaintFactory();

//图新画法接口类
function IChartPainting()
{
    this.Canvas;                        //画布
    this.ChartBorder;                   //边框信息
    this.ChartFrame;                    //框架画法
    this.Name;                          //名称
    this.ClassName='IChartPainting';    //类名
    this.Data=new ChartData();          //数据区
    this.Script;                        //图形对应的指标脚本 (只有指标图形才有)

    this.NotSupportMessage=null;
    this.MessageFont=g_JSChartResource.Index.NotSupport.Font;
    this.MessageColor=g_JSChartResource.Index.NotSupport.TextColor;
    this.IsDrawFirst=false;
    this.IsShow=true;
    this.IsVisible=true;    //是否显示 (预留给外部单独设置线段显隐)
    this.GetEventCallback;

    this.SelectedLineWidth=g_JSChartResource.SelectedChart.LineWidth;
    this.SelectedLineColor=g_JSChartResource.SelectedChart.LineColor;
    this.SelectedRadius=g_JSChartResource.SelectedChart.Radius;
    this.SelectedPointMinSpace=g_JSChartResource.SelectedChart.MinSpace; //点和点间最小间距
    this.SelectedBGColor=g_JSChartResource.SelectedChart.BGColor;

    this.DrawSelectedStatus;    //function()  { }   //选中状态
    this.PtInChart;             //function(x,y) { }

    this.IsFullRangeMaxMin=false;   //this.GetMaxMin() true=计算全部的最大最小值 false=计算可视范围的最大最小值
    this.IsExcludeYValue=false;     //不参与Y轴计算

    this.Draw=function()
    {

    }

    //数据导出 数据格式 [{ Title:数据名称, Data:[] }]
    //this.ExportData=function(aryKData) { }  

    this.GetBorder=function()
    {
        if (this.ChartFrame.IsHScreen) return this.ChartBorder.GetHScreenBorder();
        return this.ChartBorder.GetBorder();
    }

    this.ClipClient=function(isHScreen)          //裁剪客户端
    {
        if (isHScreen==true)
        {
            var left=this.ChartBorder.GetLeftEx();
            var right=this.ChartBorder.GetRightEx();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=this.ChartBorder.GetTopEx();
            var bottom=this.ChartBorder.GetBottomEx();
        }

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        //this.Canvas.stroke(); //调试用
        this.Canvas.clip();
    }

    this.GetYFromData=function(value,isLimit)
    {
        return this.ChartFrame.GetYFromData(value,isLimit);
    }

    this.IsMinuteFrame=function()
    {
        var isMinute=(this.ChartFrame.ClassName=="MinuteFrame" || this.ChartFrame.ClassName=="MinuteHScreenFrame" ||
            this.ChartFrame.ClassName=="OverlayMinuteFrame" || this.ChartFrame.ClassName=="OverlayMinuteHScreenFrame" );

        return isMinute
    }

    this.DrawNotSupportmessage=function()
    {
        this.Canvas.font=this.MessageFont;
        this.Canvas.fillStyle=this.MessageColor;

        var left=this.ChartBorder.GetLeft();
        var width=this.ChartBorder.GetWidth();
        var top=this.ChartBorder.GetTopEx();
        var height=this.ChartBorder.GetHeightEx();

        var x=left+width/2;
        var y=top+height/2;

        this.Canvas.textAlign="center";
        this.Canvas.textBaseline="middle";
        this.Canvas.fillText(this.NotSupportMessage,x,y);
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        return false;
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        if (this.ChartFrame.GlobalOption && this.ChartFrame.GlobalOption.IsValueFullRange)
        {
            start=0;
            xPointCount=this.Data.Data.length;
        }
        
        var range={};
        range.Min=null;
        range.Max=null;

        if(!this.Data || !this.Data.Data) return range;

        for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null || isNaN(value)) continue;

            if (range.Max==null) range.Max=value;
            if (range.Min==null) range.Min=value;

            if (range.Max<value) range.Max=value;
            if (range.Min>value) range.Min=value;
        }

        return range;
    }

    this.GetDynamicFont=function(dataWidth, distanceWidth,  maxSize, minSize, zoom, fontname)    //根据宽度自动获取对应字体
    {
        var pixelTatio = GetDevicePixelRatio();
        maxSize*=pixelTatio;
        minSize*=pixelTatio;

        if (maxSize==minSize)   //固定大小
        {
            var font=`${maxSize.toFixed(0)}px ${fontname}` ;
            return font;
        }

        var fontSize=(dataWidth+distanceWidth);
        if (zoom)
        {
            if (zoom.Type==0) 
            {
                if (zoom.Value>0) fontSize=(dataWidth*zoom.Value);
            }
            else if (zoom.Type==1)
            {
                if (zoom.Value>0) fontSize=(dataWidth+distanceWidth)*zoom.Value;
            }
            else if (zoom.Type==2)
            {
                if (IFrameSplitOperator.IsNumber(zoom.Value)) 
                    fontSize=(dataWidth+distanceWidth) + (2*zoom.Value)*pixelTatio;
            }
        }

        if (fontSize<minSize) fontSize=minSize;
        else if (fontSize>maxSize) fontSize=maxSize;

        var font=`${fontSize.toFixed(0)}px ${fontname}` ;

        /*
        if (dataWidth < 5) font =4*pixelTatio + 'px Arial';           //字体根据数据宽度动态调整
        else if (dataWidth < 7) font = 6*pixelTatio +'px Arial';
        else if (dataWidth < 9) font = 8*pixelTatio +'px Arial';
        else if (dataWidth < 11) font =10*pixelTatio +'px Arial';
        else if (dataWidth < 13) font =12*pixelTatio +'px Arial';
        else if (dataWidth < 15) font =14*pixelTatio + 'px Arial';
        else font =16*pixelTatio + 'px Arial';
        */
        
        return font;
    }

    this.GetLockRect=function()
    {
        return this.ChartFrame.GetLockRect();
    }

    this.SetFillStyle=function(color, x0, y0, x1, y1)
    {
        if (Array.isArray(color))
        {
            let gradient = this.Canvas.createLinearGradient(x0, y0, x1, y1);
            var offset=1/(color.length-1);
            for(var i=0; i<color.length; ++i)
            {
                var value=i*offset;
                gradient.addColorStop(value, color[i]);
            }
            this.Canvas.fillStyle=gradient;
        }
        else
        {
            this.Canvas.fillStyle=color;
        }
    }

    this.GetDynamicIconSize=function(dataWidth, distanceWidth, maxSize, minSize, zoom)
    {
        var pixelTatio = GetDevicePixelRatio();
        maxSize*=pixelTatio;
        minSize*=pixelTatio;

        if (maxSize==minSize) return maxSize;

        var iconSize=(dataWidth+distanceWidth)-2*pixelTatio;

        if (zoom)
        {
            if (zoom.Type==0) 
            {
                if (zoom.Value>0) iconSize=(dataWidth*zoom.Value);
            }
            else if (zoom.Type==1)
            {
                if (zoom.Value>0) iconSize=(dataWidth+distanceWidth)*zoom.Value;
            }
            else if (zoom.Type==2)
            {
                if (IFrameSplitOperator.IsNumber(zoom.Value)) 
                    iconSize=(dataWidth+distanceWidth) + (2*zoom.Value)*pixelTatio;
            }
        }

        if (iconSize<minSize) iconSize=minSize;
        else if (iconSize>maxSize) iconSize=maxSize;

        return iconSize;
    }

    this.GetFontHeight=function(font)
    {
        return GetFontHeight(this.Canvas, font, "擎");
    }

    //选中图形画点
    this.DrawLinePoint=function(option)
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        if (bHScreen) return;
        if (!this.IsShow) return;

        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        var pixelRatio=GetDevicePixelRatio();
        this.Canvas.save();
        this.ClipClient(bHScreen);
        this.Canvas.lineWidth=this.SelectedLineWidth*pixelRatio;
        this.Canvas.strokeStyle=this.SelectedLineColor;
        if (this.SelectedBGColor) this.Canvas.fillStyle=this.SelectedBGColor;

        var radius=this.SelectedRadius;
        var pointSpace=Math.ceil(this.SelectedPointMinSpace/(dataWidth+distanceWidth));
        if (pointSpace<=0) pointSpace=1;
        if (isMinute) 
        {
            var barWidth=(border.Right-border.Left)/xPointCount;
            pointSpace=Math.ceil(this.SelectedPointMinSpace/barWidth);
        }

        var valueType=0;
        var firstOpen=null, firstOverlayOpen=null;
        if (option)
        {
            if (option.KLineClose) valueType=1;                 //K线收盘价
            else if (option.MinuteVolBar) 
            {
                valueType=2;          //分时图柱子
            }
            else if (option.MinuteOverlayPrice) //叠加分时图价格
            {
                if (option.OverlayType==1) valueType=1;
                else valueType=3;    
            }
            else if (option.OverlayKLine) 
            {
                valueType=4;  //叠加K线
                firstOpen=this.GetFirstOpen();
            }
            else if (option.StackedBar) valueType=5;            //叠加柱子
        }
        
        for(var i=this.Data.DataOffset,j=0,k=0;i<this.Data.Data.length && j<xPointCount;++i,++j,++k,xOffset+=(dataWidth+distanceWidth))
        {
            var value=null;
            if (valueType==1)   //K线收盘价
            {
                var kItem=this.Data.Data[i];
                if (IFrameSplitOperator.IsNumber(kItem.Close)) value=kItem.Close
            }
            else if (valueType==2)
            {
                var kItem=this.Data.Data[i];
                if (IFrameSplitOperator.IsNumber(kItem.Vol)) value=kItem.Vol
            }
            else if (valueType==3)
            {
                var minItem=this.Data.Data[i];
                var mainItem=this.MainData.Data[i];
                if (!minItem || !IFrameSplitOperator.IsNumber(minItem.Close) || !IFrameSplitOperator.IsNumber(minItem.YClose)) continue;
                if (!mainItem || !IFrameSplitOperator.IsNumber(mainItem.Close) || !IFrameSplitOperator.IsNumber(mainItem.YClose)) continue;
                var price=minItem.Close;
                var value=price/minItem.YClose*mainItem.YClose;
            }
            else if (valueType==4)
            {
                var data=this.Data.Data[i];
                if (firstOverlayOpen==null) firstOverlayOpen=data.Open;
                value=data.Close/firstOverlayOpen*firstOpen;
            }
            else if (valueType==5)
            {
                var bars=this.Data.Data[i];
                if (!IFrameSplitOperator.IsNonEmptyArray(bars)) continue;
                var maxValue=0, minValue=0;
                for(var k=0;k<bars.length;++k)
                {
                    var barValue=bars[k];
                    if (!IFrameSplitOperator.IsNumber(barValue)) continue;
                    if (barValue==0) continue;
                    if (barValue>0) maxValue+=barValue;
                    else if (barValue<0) minValue+=barValue;
                }

                value=(maxValue+minValue)/2;
            }
            else
            {
                value=this.Data.Data[i];
            }
            
            if (value==null) continue;

            if (k<pointSpace) continue;
            k=0
            
            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }
            
            var y=this.GetYFromData(value,false);

            if (x>chartright) break;

            this.Canvas.beginPath();
            this.Canvas.arc(x,y,radius,0,360,false);
            this.Canvas.closePath();
            if (this.SelectedBGColor)  this.Canvas.fill();
            this.Canvas.stroke();
        }
        
        this.Canvas.restore();
    }

    //点是否在线段上
    this.PtInLine=function(x, y, option)
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        if (bHScreen) return;

        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        if (x<xOffset || x>chartright) return null;
        if (y>border.BottomEx || y<border.TopEx) return null;

        var ptStart={}, ptEnd={};
        var valueType=0;
        if (option)
        {
            if (option.KLineClose) 
            {
                valueType=1;  //K线收盘价
            }
            else if (option.MinuteOverlayPrice) //走势图叠加线
            {
                if (option.OverlayType==1)  valueType=1;    //价格线
                else valueType=3;                           //百分比
            }
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=null;
            if (valueType==1)   //K线收盘价
            {
                var kItem=this.Data.Data[i];
                if (IFrameSplitOperator.IsNumber(kItem.Close)) value=kItem.Close
            }
            else if (valueType==3)
            {
                var minItem=this.Data.Data[i];
                var mainItem=this.MainData.Data[i];
                if (!minItem || !IFrameSplitOperator.IsNumber(minItem.Close) || !IFrameSplitOperator.IsNumber(minItem.YClose)) continue;
                if (!mainItem || !IFrameSplitOperator.IsNumber(mainItem.Close) || !IFrameSplitOperator.IsNumber(mainItem.YClose)) continue;
                var price=minItem.Close;
                var value=price/minItem.YClose*mainItem.YClose;
            }
            else
            {
                value=this.Data.Data[i];
            }
           
            if (value==null) continue;

            if (isMinute)
            {
                var xLine=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var xLine=left+(right-left)/2;
            }

            var yLine=this.GetYFromData(value,false);

            if (xLine<x)
            {
                ptStart.X=xLine;
                ptStart.Y=yLine;
            }
            else if (xLine==x)
            {
                ptStart.X=ptEnd.X=xLine;
                ptStart.Y=ptEnd.Y=yLine;
                break;
            }
            else
            {
                ptEnd.X=xLine;
                ptEnd.Y=yLine;
                break;
            }
            
            if (x>chartright) break;
        }

        if (!IFrameSplitOperator.IsNumber(ptStart.X) || !IFrameSplitOperator.IsNumber(ptStart.Y)) return null;
        if (!IFrameSplitOperator.IsNumber(ptEnd.X) || !IFrameSplitOperator.IsNumber(ptEnd.Y)) return null;

        if (x==ptStart.X && y==ptStart.Y) 
            return { Identify:this.Identify, Chart:this };
        if (x==ptEnd.X && y==ptEnd.Y) 
            return { Identify:this.Identify, Chart:this };

        var lineWidth=5;
        this.Canvas.beginPath();
        if (ptStart.X==ptEnd.X) //竖线
        {
            this.Canvas.moveTo(ptStart.X-lineWidth,ptStart.Y);
            this.Canvas.lineTo(ptStart.X+lineWidth,ptStart.Y);
            this.Canvas.lineTo(ptEnd.X+lineWidth,ptEnd.Y);
            this.Canvas.lineTo(ptEnd.X-lineWidth,ptEnd.Y);
        }
        else
        {
            this.Canvas.moveTo(ptStart.X,ptStart.Y+lineWidth);
            this.Canvas.lineTo(ptStart.X,ptStart.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y+lineWidth);
        }
        this.Canvas.closePath();
        if (this.Canvas.isPointInPath(x,y))
            return { Identify:this.Identify, Chart:this };

        return null;
    }

    //option={ BarWidth:柱子宽度(空为K线宽度) }
    this.PtInBar=function(x, y, option)
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return null;
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        if (bHScreen) return null;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;
        var lockRect=this.GetLockRect();
        if (lockRect) chartright=lockRect.Left;

        if (x<xOffset || x>chartright) return null;
        if (y>border.BottomEx || y<border.TopEx) return null;

        var isMinute=this.IsMinuteFrame();
        var yBottom=this.ChartFrame.GetYFromData(0);

        var barWidth=null;
        var isMinuteVolBar=false;
        var isStackedBar=false;
        if (option)
        {
            if (option.BarWidth>0) barWidth=option.BarWidth;
            if (option.MinuteVolBar==true)
            {
                isMinuteVolBar=true;
                barWidth=4;
            }
            else if (option.StackedBar==true)
            {
                isStackedBar=true;
            }
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            if (isMinute)
            {
                var xLine=this.ChartFrame.GetXFromIndex(j);
                var left=xLine-barWidth/2;
                var right=left+barWidth;
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
            }
            
            if (isMinuteVolBar)
            {
                if (!IFrameSplitOperator.IsNumber(value.Vol)) continue;
                var yBar=this.ChartFrame.GetYFromData(value.Vol);
                var barTop=yBar, barBottom=yBottom;
            }
            else if (isStackedBar)
            {
                var maxValue=0, minValue=0;
                if (!IFrameSplitOperator.IsNonEmptyArray(value)) continue;
                for(var k=0;k<value.length;++k)
                {
                    var barValue=value[k];
                    if (!IFrameSplitOperator.IsNumber(barValue)) continue;
                    if (barValue==0) continue;

                    if (barValue>0) maxValue+=barValue;
                    else if (barValue<0) minValue+=barValue;
                }

                var barTop=this.ChartFrame.GetYFromData(maxValue);
                var barBottom=this.ChartFrame.GetYFromData(minValue);
            }
            else
            {
                var yBar=this.ChartFrame.GetYFromData(value);
                var barTop=yBar, barBottom=yBottom;
            }

            if (barTop>barBottom)
            {
                barTop=yBottom;
                barBottom=yBar;
            }

            var barLeft=left, barRight=right;
            if (barWidth>0)
            {
                barLeft=left+(right-left)/2-barWidth/2;
                barRight=barLeft+barWidth;
            }

            if (x>=barLeft && x<=barRight && y>=barTop && y<=barBottom)
                return { Identify:this.Identify, Chart:this };

            if (right>x) break;
        }

        return null;
    }

    this.PtInKBar=function(x,y,option)
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return null;
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        if (isHScreen) return null;
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }

        if (x<xOffset || x>chartright) return null;
        if (y>border.BottomEx || y<border.TopEx) return null;
        
        var firstOverlayOpen=null;
        var kBarType=0;
        var firstOpen=null;
        if (option && option.OverlayKLine) 
        {
            kBarType=1;  //叠加K线
            firstOpen=this.GetFirstOpen();
        }
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            if (firstOverlayOpen==null) firstOverlayOpen=data.Open;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            if (x>=left && x<=right)
            {
                if (kBarType==1)
                {
                    var yLow=this.GetYFromData(data.Low/firstOverlayOpen*firstOpen,false);
                    var yHigh=this.GetYFromData(data.High/firstOverlayOpen*firstOpen,false);
                }
                else
                {
                    var yLow=this.GetYFromData(data.Low, false);
                    var yHigh=this.GetYFromData(data.High, false);
                }
                
                if (y<=yLow && y>=yHigh)
                    return { Identify:this.Identify, Chart:this };
            }

            if (right>x) break;
        }
    }

    this.IsShowIndexTitleOnly=function()
    {
        if (this.ChartFrame && this.ChartFrame.ChartBorder && this.ChartFrame.ChartBorder.IsShowTitleOnly) return true;

        return false;
    }

    //是否隐藏指标
    this.IsHideScriptIndex=function()
    {
        if (this.Script && this.Script.IsShow==false) return true;
        return false;
    }

    //导出单数组数据
    this.ExportArrayData=function(aryKData, option)
    {
        var data=this.Data.ExportArrayData(aryKData, option);
        return [ { Name:this.Name, Data:data }];
    }

    this.ExportBoolData=function(aryKData, option)
    {
        var data=this.Data.ExportBoolData(aryKData, option);
        return [ { Name:this.Name, Data:data }];
    }

    //获取单数组的数据某一个数据 indexData={ Index:数据索引 }
    this.GetArrayItemData=function(indexData)
    {
        if (!indexData) return null;
        if (!IFrameSplitOperator.IsNumber(indexData.Index)) return null;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return null;
        var index=indexData.Index;
        if (index<0 || index>=this.Data.Data.length) return null;

        var item=this.Data.Data[index];

        return [ { Value:item, Color:this.Color, Name: this.Name } ];
    }
}


//缩放因子
/*
var ZOOM_SEED=
[
    [49,10],	[46,9],		[43,8],
    [41,7.5],	[39,7],		[37,6],
    [31,5.5],	[27,5],		[23,4.5],
    [21,4],		[18,3.5],	[16,3],
    [13,2.5],	[11,2],		[8,1.5],
    [6,1],		[3,0.6],	[2.2,0.5],
    //太多了卡,
    //[1.1,0.3],
    //[0.9,0.2],	[0.7,0.15],
    //[0.6,0.12],	[0.5,0.1],	[0.4,0.08],
    //[0.3,0.06],	[0.2,0.04],	[0.1,0.02]
];
*/


var ZOOM_SEED=  //0=柱子宽度  1=间距
[
    [48,10],	[44,10], 
    [40,9],     [36,9],	
    [32,8],     [28,8],	
    [24,7],     [20,7], 
    [18,6],     [16,6],
    [15,5],     [13,5],
    [9,4], [7,4], [5,4], 

    [3,3],
    [3,1], [2,1], [1,1], [1,0],

    //[0.5,0],[0.4,0],[0.3,0],[0.2,0],[0.1,0]
];


//K线画法 支持横屏
function ChartKLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartKLine';    //类名
    this.Symbol;        //股票代码
    this.DrawType=0;    // 0=实心K线柱子  1=收盘价线 2=美国线 3=空心K线柱子 4=收盘价面积图 5=订单流 6=空心K线柱子2(全部空心) 7=订单流样式2 8=订单流样式3  
                        // 9=自定义颜色K线 
                        // 10=renko 
                        // 11=Heikin Ashi 
                        // 12=line break 
                        // 13=high low 
                        // 14=外部自定义图 
                        // 15=HLC Area 
                        // 16=kagi
                        // 17=订单流样式4
                        // 18=订单流样式5

    this.CloseLineColor=g_JSChartResource.CloseLineColor;
    this.CloseLineAreaColor=g_JSChartResource.CloseLineAreaColor;
    this.CloseLineWidth=g_JSChartResource.CloseLineWidth;
    this.UpColor=g_JSChartResource.UpBarColor;
    this.DownColor=g_JSChartResource.DownBarColor;
    this.UnchagneColor=g_JSChartResource.UnchagneBarColor;          //平盘
    this.ColorData;             //五彩K线颜色 >0：g_JSChartResource.UpBarColor 其他：g_JSChartResource.DownBarColor
    this.TradeData;             //交易系统 包含买卖数据{Buy:, Sell:, Name:指标名称 }
    this.TradeIcon=g_JSChartResource.KLine.TradeIcon;
    this.TooltipRect=[];                    //2位数组 0 数据序号 1 区域
    this.InfoTooltipRect=[];                //2维数组 0 数据,  1 区域
    this.TradeIconTooltipRect=[];           //2维数组 0 数据,  1 区域

    this.IsShowMaxMinPrice=true;                 //是否显示最大最小值
    this.IsShowKTooltip=true;                    //是否显示K线tooltip
    this.TextFont=g_JSChartResource.KLine.MaxMin.Font;
    this.TextColor=g_JSChartResource.KLine.MaxMin.Color;

    this.InfoData;          //信息地雷 key=日期  value=信息数据
    this.InfoPosition=0;    // 0=K线上 1 底部

    this.PtMax;     //最大值的位置
    this.PtMin;     //最小值的位置

    this.TickSymbol='╳';    //分笔显示的图标
    this.TickFontName='arial';
    this.Period;            //周期
    this.ShowRange={ };     //K线显示范围 { Start:, End:,  DataCount:, ShowCount: }
    this.CustomKLine;       //自定义K线, key=date*1000000+time,  key={ Color:, DrawType: }
    this.DrawKRange={ Start:null, End:null };   //当前屏K线的索引{ Start: , End:}

    this.IsThinAKBar=true;      //美国线 柱子是否是线段 (false=柱子)
    this.OneLimitBarType=0;    //一字板颜色类型 4个价格全部都在同一个价位上 0=使用平盘颜色 1=跟昨收比较

    this.HighLowBarColor=g_JSChartResource.HighLowBarColor;
    this.HighLowTextConfig=
    { 
        FontName:g_JSChartResource.HighLowText.FontName, 
        MaxSize:g_JSChartResource.HighLowText.MaxSize, 
        MinSize:g_JSChartResource.HighLowText.MinSize, 
        Color:g_JSChartResource.HighLowText.Color,  //未用
        MaxText:g_JSChartResource.HighLowText.MaxText
    };

    this.HLCAreaConfig=
    {
        HighLineColor:g_JSChartResource.HLCArea.HighLineColor,
        LowLineColor:g_JSChartResource.HLCArea.LowLineColor,
        CloseLineColor:g_JSChartResource.HLCArea.CloseLineColor,
        LineWidth:g_JSChartResource.HLCArea.LineWidth,

        UpAreaColor:g_JSChartResource.HLCArea.UpAreaColor,
        DownAreaColor:g_JSChartResource.HLCArea.DownAreaColor,
    }

    //虚线柱子
    this.VirtualBarConfig={ Color:g_JSChartResource.VirtualKLine.Color, LineDash:g_JSChartResource.VirtualKLine.LineDash };

    //DrawType==14 自定义图形
    this.FFKChart;

    /*
    this.CustomKLine=new Map([
        [20210415*1000000, { Color:'rgb(255,0,255)', DrawType:3, BGColor:"rgba(135,206,250,0.5)" }],
        [20210412*1000000, { DrawType:3 }],
        [20210108*1000000, { DrawType:3,BGColor:"rgba(135,206,250,0.5)"  }],
        [20210122*1000000, {Color:'rgb(122,135,155)'}]
    ]);
    */

    //订单流配置
    this.OrderFlow=
    { 
        UpColor:{BG:g_JSChartResource.OrderFlow.UpColor.BG, Border:g_JSChartResource.OrderFlow.UpColor.Border },
        DownColor:{ BG:g_JSChartResource.OrderFlow.DownColor.BG, Border:g_JSChartResource.OrderFlow.DownColor.Border },
        UnchagneColor: { BG:g_JSChartResource.OrderFlow.UnchagneColor.BG, Border:g_JSChartResource.OrderFlow.UnchagneColor.Border },
        Text:{ Color: g_JSChartResource.OrderFlow.Text.Color , Family:g_JSChartResource.OrderFlow.Text.Family, FontMaxSize:g_JSChartResource.OrderFlow.Text.FontMaxSize, MaxValue:g_JSChartResource.OrderFlow.Text.MaxValue },
        Line:{ UpDownColor: g_JSChartResource.OrderFlow.Line.UpDownColor, MiddleColor:g_JSChartResource.OrderFlow.Line.MiddleColor },
        POCGBColor:g_JSChartResource.OrderFlow.POCGBColor,

        ShowType:0,  //显示类型 0, 1

        AskBarColor:g_JSChartResource.OrderFlow.AskBarColor,
        BidBarColor:g_JSChartResource.OrderFlow.BidBarColor,

        AlwaysShowOrderText:g_JSChartResource.OrderFlow.AlwaysShowOrderText,

        IsShowAskText:true,
        IsShowAskBar:false,     //是否显示横向柱子

        IsShowBidText:true,
        IsShowBidBar:false,     //是否显示横向柱子

        IsShowPOCBG:true,
    }

    this.OrderFlow_Style2=
    {
        BarWidth:g_JSChartResource.OrderFlow_Style2.BarWidth,
        //柱子颜色
        UpColor:g_JSChartResource.OrderFlow_Style2.UpColor,
        DownColor:g_JSChartResource.OrderFlow_Style2.DownColor,
        UnchagneColor:g_JSChartResource.OrderFlow_Style2.UnchagneColor,
    }

    this.OrderFlow_Style3=
    {
        BarWidth:g_JSChartResource.OrderFlow_Style3.BarWidth,
        //柱子颜色
        UpColor:g_JSChartResource.OrderFlow_Style3.UpColor,
        DownColor:g_JSChartResource.OrderFlow_Style3.DownColor,
        UnchagneColor:g_JSChartResource.OrderFlow_Style3.UnchagneColor,
    }

    this.OrderFlow_Style4=
    {
        //柱子颜色
        UpColor:g_JSChartResource.OrderFlow_Style4.UpColor,
        DownColor:g_JSChartResource.OrderFlow_Style4.DownColor,
        UnchagneColor:g_JSChartResource.OrderFlow_Style4.UnchagneColor,
        KBarType:1, //0=不显示K线柱子 1=左侧显示K线
        VolBarSpace:g_JSChartResource.OrderFlow_Style4.VolBarSpace,  //间距
        KBarWidth:g_JSChartResource.OrderFlow_Style4.KBarWidth,
        LeftMargin:g_JSChartResource.OrderFlow_Style4.LeftMargin,
        RightMargin:g_JSChartResource.OrderFlow_Style4.RightMargin,
    }

    this.OrderFlow_Style5=
    {
        AskBarColor:g_JSChartResource.OrderFlow_Style5.AskBarColor,  //左
        BidBarColor:g_JSChartResource.OrderFlow_Style5.BidBarColor,    //右
        LeftMargin:g_JSChartResource.OrderFlow_Style5.LeftMargin,
        RightMargin:g_JSChartResource.OrderFlow_Style5.RightMargin,
    }

    this.IsShowOrderText=false;

    this.AryOrderFlowBorder=[]; //订单流边框 临时变量

    this.ChartHeatMap;  //=new ChartHeatMap();

    //未回补的价格缺口
    this.PriceGap={ Enable:false, Count:1 };
    this.PriceGapStyple=
    { 
        Line:{ Color:g_JSChartResource.PriceGapStyple.Line.Color }, 
        Text:{ Color:g_JSChartResource.PriceGapStyple.Text.Color, Font: g_JSChartResource.PriceGapStyple.Text.Font } 
    };
    this.AryPriceGapCache=[];   //缺口数据 { }
    
    this.ReloadResource=function(resource)
    {
        this.TextFont=g_JSChartResource.KLine.MaxMin.Font;
        this.TextColor=g_JSChartResource.KLine.MaxMin.Color;

        this.CloseLineColor=g_JSChartResource.CloseLineColor;
        this.CloseLineAreaColor=g_JSChartResource.CloseLineAreaColor;
        this.CloseLineWidth=g_JSChartResource.CloseLineWidth;

        this.UpColor=g_JSChartResource.UpBarColor;
        this.DownColor=g_JSChartResource.DownBarColor;
        this.UnchagneColor=g_JSChartResource.UnchagneBarColor;          //平盘
        this.HighLowBarColor=g_JSChartResource.HighLowBarColor;

        this.OrderFlow.UpColor={BG:g_JSChartResource.OrderFlow.UpColor.BG, Border:g_JSChartResource.OrderFlow.UpColor.Border };
        this.OrderFlow.DownColor={ BG:g_JSChartResource.OrderFlow.DownColor.BG, Border:g_JSChartResource.OrderFlow.DownColor.Border };
        this.OrderFlow.UnchagneColor= { BG:g_JSChartResource.OrderFlow.UnchagneColor.BG, Border:g_JSChartResource.OrderFlow.UnchagneColor.Border };
        this.OrderFlow.Text={ Color: g_JSChartResource.OrderFlow.Text.Color , Family:g_JSChartResource.OrderFlow.Text.Family, FontMaxSize:g_JSChartResource.OrderFlow.Text.FontMaxSize, MaxValue:g_JSChartResource.OrderFlow.Text.MaxValue };
        this.OrderFlow.Line={ UpDownColor: g_JSChartResource.OrderFlow.Line.UpDownColor, MiddleColor:g_JSChartResource.OrderFlow.Line.MiddleColor };
    }

    this.ClearCustomKLine=function()
    {
        this.CustomKLine=null;
    }

    this.GetCustomKLine=function(kItem)
    {
        if (!this.CustomKLine) return null;
        if (!kItem) return null;

        var key=kItem.Date*1000000;
        if (IFrameSplitOperator.IsNumber(kItem.Time)) key+=kItem.Time;
        if (!this.CustomKLine.has(key)) return null;

        var value=this.CustomKLine.get(key);
        return value;
    }

    this.DrawHeatMap=function()
    {
        if (!this.ChartHeatMap) return;

        this.ChartHeatMap.Canvas=this.Canvas;
        this.ChartHeatMap.ChartBorder=this.ChartBorder;
        this.ChartHeatMap.ChartFrame=this.ChartFrame;
        this.ChartHeatMap.Data=this.Data;

        this.ChartHeatMap.Draw();
    }

    this.ClearHeatMap=function()
    {
        this.ChartHeatMap=null;
    }

    this.CreateHeatMap=function()
    {
        this.ChartHeatMap=new ChartHeatMap();
    }

    this.DrawAKLine=function()  //美国线
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var upColor=this.UpColor;
        var downColor=this.DownColor;
        var unchagneColor=this.UnchagneColor; 

        var ptMax={X:null,Y:null,Value:null,Align:'left'};
        var ptMin={X:null,Y:null,Value:null,Align:'left'};
        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        var eventUnchangeKLine=null;    //定制平盘K线颜色事件
        if (this.GetEventCallback)
        {
            eventUnchangeKLine=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_UNCHANGE_KLINE_COLOR);
        }

        var preKItemInfo=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            var yOpen=this.GetYFromData(data.Open,false);
            var yClose=this.GetYFromData(data.Close,false);
            this.DrawKRange.End=i;

            var kItemInfo={ Data:data, Coordinate:{ X:x, Low:yLow, High:yHigh, Close:yClose, Open:yOpen, Left:left, Right:right }};

            if (ptMax.Value==null || ptMax.Value<data.High)     //求最大值
            {
                ptMax.X=x;
                ptMax.Y=yHigh;
                ptMax.Value=data.High;
                ptMax.Align=j<xPointCount/2?'left':'right';
            }

            if (ptMin.Value==null || ptMin.Value>data.Low)      //求最小值
            {
                ptMin.X=x;
                ptMin.Y=yLow;
                ptMin.Value=data.Low;
                ptMin.Align=j<xPointCount/2?'left':'right';
            }

            unchagneColor=this.UnchagneColor; 

            if (data.Open<data.Close) 
            {
                this.Canvas.strokeStyle=this.UpColor; //阳线
            }
            else if (data.Open>data.Close) 
            {
                this.Canvas.strokeStyle=this.DownColor; //阳线
            }
            else 
            {
                if (eventUnchangeKLine && eventUnchangeKLine.Callback)
                {
                    var sendData={ KItem:data, DataIndex:i, DefaultColor:unchagneColor, BarColor:null };
                    eventUnchangeKLine.Callback(eventUnchangeKLine, sendData, this);
                    if (sendData.BarColor) unchagneColor=sendData.BarColor;
                }
                this.Canvas.strokeStyle=unchagneColor; //平线
            }

            if (this.ColorData) ///五彩K线颜色设置
            {
                if (i<this.ColorData.length)
                    upColor=downColor=unchagneColor=(this.ColorData[i]>0?this.UpColor:this.DownColor);
                else
                    upColor=downColor=unchagneColor=this.DownColor;
            }

            if (this.IsThinAKBar==false && dataWidth>=9)
            {
                var coordinateInfo={YLow:yLow, YHigh:yHigh, YOpen:yOpen, YClose:yClose, X:x, Left:left, Right:right };
                var colorInfo={ UpColor:upColor, DownColor:downColor, UnchangeColor:unchagneColor };
                this.DrawAKBar(data, dataWidth, isHScreen, coordinateInfo, colorInfo);
            }
            else
            {
                this.Canvas.beginPath();   //最高-最低
                if (isHScreen)
                {
                    if (data.High==data.Low && dataWidth<4)
                    {
                        this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                        this.Canvas.lineTo(yLow-1,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                        this.Canvas.lineTo(yLow,ToFixedPoint(x));
                    }
                }
                else
                {
                    if (data.High==data.Low && dataWidth<4)
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                        this.Canvas.lineTo(ToFixedPoint(x),yLow+1);
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                        this.Canvas.lineTo(ToFixedPoint(x),yLow);
                    }
                }
                
                this.Canvas.stroke();

                if (dataWidth>=4)
                {
                    this.Canvas.beginPath();    //开盘
                    if (isHScreen)
                    {
                        this.Canvas.moveTo(ToFixedPoint(yOpen),left);
                        this.Canvas.lineTo(ToFixedPoint(yOpen),x);
                    }
                    else
                    {
                        this.Canvas.moveTo(left,ToFixedPoint(yOpen));
                        this.Canvas.lineTo(x,ToFixedPoint(yOpen));
                    }
                    this.Canvas.stroke();

                    this.Canvas.beginPath();    //收盘
                    if (isHScreen)
                    {
                        this.Canvas.moveTo(ToFixedPoint(yClose),right);
                        this.Canvas.lineTo(ToFixedPoint(yClose),x);
                    }
                    else
                    {
                        this.Canvas.moveTo(right,ToFixedPoint(yClose));
                        this.Canvas.lineTo(x,ToFixedPoint(yClose));
                    }
                    this.Canvas.stroke();
                }
            }

            if(this.Data.DataType==0)
            {
                var infoItem={Xleft:left,XRight:right, YMax:yHigh, XCenter:x, YMin:yLow, DayData:data, Index:j};
                this.DrawInfo(infoItem);
            }

            if (this.PriceGap.Enable && preKItemInfo)
            {
                this.CheckPriceGap(kItemInfo);

                var value=this.IsPriceGap(kItemInfo,preKItemInfo);
                if (value>0)
                    this.AryPriceGapCache.push({ Data:[preKItemInfo, kItemInfo], Type:value });
            }
    
            preKItemInfo=kItemInfo;
        }

        this.PtMax=ptMax;
        this.PtMin=ptMin;
    }

    this.DrawAKBar=function(data, dataWidth, isHScreen, coordinateInfo, colorInfo)
    {
        var barWidth=dataWidth/3;
        var left=ToFixedRect(coordinateInfo.Left);
        var aryX=[left, ToFixedRect(left+barWidth), ToFixedRect(left+barWidth*2), ToFixedRect(left+barWidth*3)];
        var yHigh=coordinateInfo.YHigh, yLow=coordinateInfo.YLow, yOpen=coordinateInfo.YOpen, yClose=coordinateInfo.YClose;

        if (data.Open<data.Close) 
        {
            this.Canvas.strokeStyle=colorInfo.UpColor; //阳线
            this.Canvas.fillStyle=colorInfo.UpColor;
        }
        else if (data.Open>data.Close) 
        {
            this.Canvas.strokeStyle=colorInfo.DownColor; //阳线
            this.Canvas.fillStyle=colorInfo.DownColor;
        }
        else 
        {
            this.Canvas.strokeStyle=colorInfo.UnchangeColor; //平线
            this.Canvas.fillStyle=colorInfo.UnchangeColor;
        }

        //最高-最低
        if (isHScreen)
        {
            if (data.High==data.Low)
            {
                var yTop=yHigh-barWidth/2;
                this.Canvas.fillRect(yTop,aryX[1],barWidth,aryX[2]-aryX[1]);
            }
            else
            {
                this.Canvas.fillRect(yHigh,aryX[1],(yLow-yHigh),aryX[2]-aryX[1]);
            }
        }
        else
        {
            if (data.High==data.Low)
            {
                var yTop=yHigh-barWidth/2;
                this.Canvas.fillRect(aryX[1],yTop,aryX[2]-aryX[1],barWidth);
            }
            else
            {
                this.Canvas.fillRect(aryX[1],yHigh,aryX[2]-aryX[1],(yLow-yHigh));
            }
        }

        //开盘
        var yTop=yOpen-barWidth/2;
        if (isHScreen)
        {
            this.Canvas.fillRect(yTop,aryX[0],(barWidth),aryX[1]-aryX[0]);
        }
        else
        {
            this.Canvas.fillRect(aryX[0],yTop,aryX[1]-aryX[0],(barWidth));
        }
       

        //收盘
        var yTop=yClose-barWidth/2;
        if (isHScreen)
        {
            this.Canvas.fillRect(yTop,aryX[2],(barWidth),aryX[3]-aryX[2]);
        }
        else
        {
            this.Canvas.fillRect(aryX[2],yTop,aryX[3]-aryX[2],(barWidth));
        }
    }

    this.DrawCloseArea=function()   //收盘价面积图
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            var borderLeft=border.TopEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var borderLeft=border.LeftEx;
        }
        

        var bFirstPoint=true;
        var firstPoint=null;
       
        this.Canvas.beginPath();
        this.Canvas.strokeStyle=this.CloseLineColor;
        if (IFrameSplitOperator.IsNumber(this.CloseLineWidth)) this.Canvas.lineWidth=this.CloseLineWidth;
        var ptLast=null;
        if (this.Data.DataOffset>0) //把最左边的一个点连上
        {
            var data=this.Data.Data[this.Data.DataOffset-1];
            if (data && IFrameSplitOperator.IsNumber(data.Close))
            {
                var x=borderLeft;
                var yClose=this.GetYFromData(data.Close,false);
                if (isHScreen) 
                {
                    this.Canvas.moveTo(yClose,x);
                    firstPoint={ X:yClose, Y:x };
                }
                else 
                {
                    this.Canvas.moveTo(x,yClose);
                    firstPoint={ X:x, Y:yClose };
                }
                bFirstPoint=false;
            }
        }

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        var preKItemInfo=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yClose=this.GetYFromData(data.Close,false);
            this.DrawKRange.End=i;

            if (bFirstPoint)
            {
                if (isHScreen) 
                {
                    this.Canvas.moveTo(yClose,x);
                    firstPoint={ X:yClose, Y:x };
                }
                else 
                {
                    this.Canvas.moveTo(x,yClose);
                    firstPoint={ X:x, Y:yClose };
                }
                bFirstPoint=false;
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(yClose,x);
                else this.Canvas.lineTo(x,yClose);
            }

            if (i==this.Data.Data.length-1)
            {
                ptLast={ X:x, Y:yClose, XLeft:left, XRight:right, KItem:data, ChartRight:chartright };
            }

            if (this.PriceGap.Enable )
            {
                var yLow=this.GetYFromData(data.Low, false);
                var yHigh=this.GetYFromData(data.High, false);
                var yOpen=this.GetYFromData(data.Open, false);

                var kItemInfo={ Data:data, Coordinate:{ X:x, Low:yLow, High:yHigh, Close:yClose, Open:yOpen, Left:left, Right:right }};

                if (preKItemInfo)
                {
                    this.CheckPriceGap(kItemInfo);
                    var value=this.IsPriceGap(kItemInfo,preKItemInfo);
                    if (value>0) this.AryPriceGapCache.push({ Data:[preKItemInfo, kItemInfo], Type:value });
                }

                preKItemInfo=kItemInfo;
            }
        }

        this.DrawLastPointEvent(ptLast);  //通知外部绘制最后一个点

        if (bFirstPoint) return;

        this.Canvas.stroke();
        if (isHScreen)
        {
            this.Canvas.lineTo(border.Left,x);
            this.Canvas.lineTo(border.Left,firstPoint.Y);
        }
        else
        {
            this.Canvas.lineTo(x,border.Bottom);
            this.Canvas.lineTo(firstPoint.X,border.Bottom);
        }
        this.Canvas.closePath();
        if (Array.isArray(this.CloseLineAreaColor))
        {
            if (isHScreen)
            {
                let gradient = this.Canvas.createLinearGradient(this.ChartBorder.GetRightEx(),this.ChartBorder.GetTop(), this.ChartBorder.GetLeft(),this.ChartBorder.GetTop());
                gradient.addColorStop(0, this.CloseLineAreaColor[0]);
                gradient.addColorStop(1, this.CloseLineAreaColor[1]);
                this.Canvas.fillStyle=gradient;
            }
            else
            {
                let gradient = this.Canvas.createLinearGradient(firstPoint.X,this.ChartBorder.GetTopEx(), firstPoint.X,this.ChartBorder.GetBottom());
                gradient.addColorStop(0, this.CloseLineAreaColor[0]);
                gradient.addColorStop(1, this.CloseLineAreaColor[1]);
                this.Canvas.fillStyle=gradient;
            }
        }
        else
        {
            this.Canvas.fillStyle=this.CloseLineAreaColor;
        }
        this.Canvas.fill();
    }

    this.DrawCloseLine=function()   //收盘价线
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }
        
        var bFirstPoint=true;
        this.Canvas.beginPath();
        this.Canvas.strokeStyle=this.CloseLineColor;
        if (IFrameSplitOperator.IsNumber(this.CloseLineWidth)) this.Canvas.lineWidth=this.CloseLineWidth;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        var preKItemInfo=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yClose=this.GetYFromData(data.Close,false);
            this.DrawKRange.End=i;

            if (bFirstPoint)
            {
                if (isHScreen) this.Canvas.moveTo(yClose,x);
                else this.Canvas.moveTo(x,yClose);
                bFirstPoint=false;
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(yClose,x);
                else this.Canvas.lineTo(x,yClose);
            }

            if (this.PriceGap.Enable )
            {
                var yLow=this.GetYFromData(data.Low, false);
                var yHigh=this.GetYFromData(data.High, false);
                var yOpen=this.GetYFromData(data.Open, false);

                var kItemInfo={ Data:data, Coordinate:{ X:x, Low:yLow, High:yHigh, Close:yClose, Open:yOpen, Left:left, Right:right }};

                if (preKItemInfo)
                {
                    this.CheckPriceGap(kItemInfo);
                    var value=this.IsPriceGap(kItemInfo,preKItemInfo);
                    if (value>0) this.AryPriceGapCache.push({ Data:[preKItemInfo, kItemInfo], Type:value });
                }

                preKItemInfo=kItemInfo;
            }
        }

        if (bFirstPoint==false) this.Canvas.stroke();
    }

    this.DrawKBar=function()        //蜡烛头
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }

        var ptMax={X:null,Y:null,Value:null,Align:'left'};
        var ptMin={X:null,Y:null,Value:null,Align:'left'};
        
        var upColor=this.UpColor;
        var downColor=this.DownColor;
        var unchagneColor=this.UnchagneColor; 

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        var ptLast=null;
        this.DrawKRange.Start=this.Data.DataOffset;

        var eventUnchangeKLine=null;    //定制平盘K线颜色事件
        if (this.GetEventCallback)
        {
            eventUnchangeKLine=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_UNCHANGE_KLINE_COLOR);
        }

        var preKItemInfo=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            var kItemInfo={ Data:data, Coordinate:{ X:x, Low:yLow, High:yHigh, Close:yClose, Open:yOpen, Left:left, Right:right }};

            this.DrawKRange.End=i;
            if (ptMax.Value==null || ptMax.Value<data.High)     //求最大值
            {
                ptMax.X=x;
                ptMax.Y=yHigh;
                ptMax.Value=data.High;
                ptMax.Align=j<xPointCount/2?'left':'right';
            }

            if (ptMin.Value==null || ptMin.Value>data.Low)      //求最小值
            {
                ptMin.X=x;
                ptMin.Y=yLow;
                ptMin.Value=data.Low;
                ptMin.Align=j<xPointCount/2?'left':'right';
            }

            if (this.ColorData) ///五彩K线颜色设置
            {
                if (i<this.ColorData.length)
                    upColor=downColor=unchagneColor=(this.ColorData[i]>0?this.UpColor:this.DownColor);
                else
                    upColor=downColor=unchagneColor=this.DownColor;
            }

            var kLineOption=this.GetCustomKLine(data);

            if (data.IsNonTrade)  //非交易日 绘制虚线柱子
            {
                this.DrawVirtualBar(data, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
            }
            else if (kLineOption)
            {
                var barColor=kLineOption.Color;
                if (!barColor)
                {
                    if (data.Open<data.Close) barColor=upColor;
                    else if (data.Open>data.Close) barColor=downColor;
                    else barColor=unchagneColor;
                }

                var drawType=this.DrawType;
                if (IFrameSplitOperator.IsNumber(kLineOption.DrawType)) drawType=kLineOption.DrawType;

                this.DrawKBar_Custom(data, dataWidth, barColor, drawType, kLineOption, x, y, left, right, yLow, yHigh, yOpen, yClose, border, isHScreen);
            }
            else if (this.DrawType==9 && data.ColorData)
            {
                this.DrawColorKBar(data, data.ColorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
            }
            else if (data.Open<data.Close)       //阳线
            {
                this.DrawKBar_Up(data, dataWidth, upColor, this.DrawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
            }
            else if (data.Open>data.Close)  //阴线
            {
                this.DrawKBar_Down(data, dataWidth, downColor, this.DrawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
            }
            else // 平线
            {
                var barColor=unchagneColor;
                if (eventUnchangeKLine && eventUnchangeKLine.Callback)
                {
                    var sendData={ KItem:data, DataIndex:i, DefaultColor:barColor, BarColor:null };
                    eventUnchangeKLine.Callback(eventUnchangeKLine, sendData, this);
                    if (sendData.BarColor) barColor=sendData.BarColor;
                }

                this.DrawKBar_Unchagne(data, dataWidth, barColor, this.DrawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
            }
            
            if (this.IsShowKTooltip && !isHScreen)    //添加tooltip区域
            {
                var yTop=Math.min(yOpen,yClose);
                var yBottom=Math.max(yOpen,yClose);
                if (Math.abs(yOpen-yClose)<5)   //高度太小了, 上下各+5px
                {
                    yTop=Math.min(yHigh,yTop-5);
                    yBottom=Math.max(yLow,yBottom+5);
                }

                if (data.IsNonTrade)
                {
                    yTop=yHigh;
                    yBottom=yLow;
                }

                var rect=new Rect(left,yTop,dataWidth,yBottom-yTop);
                //this.Canvas.fillStyle="rgb(0,0,100)";
                //this.Canvas.fillRect(rect.X,rect.Y,rect.Width,rect.Height);
                this.TooltipRect.push([i,rect]);    //[0]数据索引 [1]数据区域
            }

            if(this.Data.DataType==0 || this.Data.DataType==1)
            {
                var infoItem={Xleft:left,XRight:right, XCenter:x, YMax:yHigh, YMin:yLow, DayData:data, Index:j};
                this.DrawInfo(infoItem);
            }

            if (i==this.Data.Data.length-1)
            {
                ptLast={ X:x, Y:yClose, XLeft:left, XRight:right, KItem:data, ChartRight:chartright };
            }

            if (this.PriceGap.Enable && preKItemInfo)
            {
                this.CheckPriceGap(kItemInfo);

                var value=this.IsPriceGap(kItemInfo,preKItemInfo);
                if (value>0)
                    this.AryPriceGapCache.push({ Data:[preKItemInfo, kItemInfo], Type:value });
            }
    
            preKItemInfo=kItemInfo;
        }

        this.DrawLastPointEvent(ptLast);  //通知外部绘制最后一个点

        this.PtMax=ptMax;
        this.PtMin=ptMin;
    }

    this.DrawKBar_Up=function(data, dataWidth, upColor, drawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen) //阳线
    {
        var isEmptyBar=(drawType==3 || drawType==6);
        if (dataWidth>=4)
        {
            if (isEmptyBar)
            {
                if ((dataWidth%2)!=0) dataWidth-=1;
            }

            this.Canvas.strokeStyle=upColor;
            if (data.High>data.Close)   //上影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(drawType==3?Math.max(yClose,yOpen):yClose),ToFixedPoint(x));
                }
                else
                {
                    if (isEmptyBar)
                    {
                        var xFixed=left+dataWidth/2;
                        this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(Math.min(yClose,yOpen)));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yClose));
                    }
                    
                }
                this.Canvas.stroke();
                y=yClose;
            }
            else
            {
                y=yClose;
            }

            this.Canvas.fillStyle=upColor;
            if (isHScreen)
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (isEmptyBar) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(y),ToFixedPoint(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                    }
                }
            }
            else
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (isEmptyBar) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(y),ToFixedRect(dataWidth),ToFixedRect(yOpen-y));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,yOpen)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yOpen-y)));
                    }
                }
            }

            if (data.Open>data.Low) //下影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(drawType==3?Math.min(yClose,yOpen):y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    if (isEmptyBar)
                    {
                        var xFixed=left+dataWidth/2;
                        this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(Math.max(yClose,yOpen)));
                        this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yLow));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                    }
                    
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.strokeStyle=upColor;
            this.Canvas.stroke();
        }
    }

    this.DrawKBar_Down=function(data, dataWidth, downColor, drawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen) //阴线
    {
        var isEmptyBar=(drawType==6);
        if (dataWidth>=4)
        {
            if (isEmptyBar)
            {
                if ((dataWidth%2)!=0) dataWidth-=1;
            }

            this.Canvas.strokeStyle=downColor;
            if (data.High>data.Close)   //上影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yOpen),ToFixedPoint(x));
                }
                else
                {
                    if (isEmptyBar)
                    {
                        var xFixed=left+dataWidth/2;
                        this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(Math.min(yClose,yOpen)));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yOpen));
                    }
                }
                this.Canvas.stroke();
                y=yOpen;
            }
            else
            {
                y=yOpen
            }

            this.Canvas.fillStyle=downColor;
            if (isHScreen)
            {
                if (Math.abs(yClose-y)<1) this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                else this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yClose-y),ToFixedRect(dataWidth));
            }
            else
            {
                if (Math.abs(yClose-y)<1) 
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (isEmptyBar) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(Math.min(y,yClose)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yClose-y)));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,yClose)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yClose-y)));
                    }
                   
                }
            }

            if (data.Open>data.Low) //下影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    if (isEmptyBar)
                    {
                        var xFixed=left+dataWidth/2;
                        this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(Math.max(yClose,yOpen)));
                        this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yLow));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                    }
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.strokeStyle=downColor;
            this.Canvas.stroke();
        }
    }

    this.DrawKBar_Unchagne=function(data, dataWidth, unchagneColor, drawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen) //平线
    {
        if (this.OneLimitBarType===1&& this.IsOneLimitBar(data))    //一字板
        {
            unchagneColor=this.GetOneLimitBarColor(data);
        }

        if (dataWidth>=4)
        {
            if ((dataWidth%2)!=0) dataWidth-=1;
            this.Canvas.strokeStyle=unchagneColor;
            this.Canvas.beginPath();
            if (data.High>data.Close)   //上影线
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(y,ToFixedPoint(x));
                    this.Canvas.lineTo(yOpen,ToFixedPoint(x));
                }
                else
                {
                    var xFixed=ToFixedPoint(left+dataWidth/2);
                    this.Canvas.moveTo(xFixed,y);
                    this.Canvas.lineTo(xFixed,yOpen);
                }
                y=yOpen;
            }
            else
            {
                y=yOpen;
            }

            if (isHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(left));
                this.Canvas.lineTo(ToFixedPoint(y),ToFixedPoint(right));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(left),ToFixedPoint(y));
                this.Canvas.lineTo(ToFixedPoint(left+dataWidth),ToFixedPoint(y));
            }

            if (data.Open>data.Low) //下影线
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    var xFixed=ToFixedPoint(left+dataWidth/2);
                    this.Canvas.moveTo(xFixed,ToFixedPoint(y));
                    this.Canvas.lineTo(xFixed,ToFixedPoint(yLow));
                }
            }

            this.Canvas.stroke();
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                if (data.High==data.Low)
                {
                    this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                    this.Canvas.lineTo(yLow-1,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                    this.Canvas.lineTo(yLow,ToFixedPoint(x));
                }
            }
            else
            {
                if (data.High==data.Low)
                {
                    this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                    this.Canvas.lineTo(ToFixedPoint(x),yLow+1);
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                    this.Canvas.lineTo(ToFixedPoint(x),yLow);
                }
            }
            this.Canvas.strokeStyle=unchagneColor;
            this.Canvas.stroke();
        }
    }

    //是否是一字板
    this.IsOneLimitBar=function(kItem)
    {
        if (kItem.Open==kItem.Close && kItem.High==kItem.Low && kItem.Open==kItem.High) return true;
        return false;
    }

    //一字板颜色 和昨收比较
    this.GetOneLimitBarColor=function(kItem)
    {
        if (!kItem || !IFrameSplitOperator.IsNumber(kItem.YClose)) return this.UnchagneColor;

        if (kItem.Close>kItem.YClose) return this.UpColor;
        else if (kItem.Close<kItem.YClose) return this.DownColor;
        else return this.UnchagneColor;
    }

    this.DrawKBar_Custom=function(data, dataWidth, barColor, drawType, option, x, y, left, right, yLow, yHigh, yOpen, yClose, border, isHScreen)
    {
        if (option.BGColor) //画背景色
        {
            this.Canvas.fillStyle=option.BGColor;
            var distanceWidth=this.ChartFrame.DistanceWidth;
            if (isHScreen)
            {
                var yLeft=left-(distanceWidth/2);
                var yRight=right+(distanceWidth/2);
                var xTop=border.RightEx;
                var xBottom=border.LeftEx;

                this.Canvas.fillRect(ToFixedRect(xBottom),ToFixedRect(yLeft),ToFixedRect(xTop-xBottom),ToFixedRect(yRight-yLeft));
            }
            else
            {
                var xLeft=left-(distanceWidth/2);
                var xRight=right+(distanceWidth/2);
                var yTop=border.TopEx;
                var yBottom=border.BottomEx;
                
                this.Canvas.fillRect(ToFixedRect(xLeft),ToFixedRect(yTop),ToFixedRect(xRight-xLeft),ToFixedRect(yBottom-yTop));
            }
        }

        if (dataWidth>=4)
        {
            this.Canvas.strokeStyle=barColor;
            if (data.High>data.Close)   //上影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(drawType==3?Math.max(yClose,yOpen):yClose),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(drawType==3?Math.min(yClose,yOpen):yClose));
                }
                this.Canvas.stroke();
                y=yClose;
            }
            else
            {
                y=yClose;
            }

            this.Canvas.fillStyle=barColor;
            if (isHScreen)
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (drawType==3) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(y),ToFixedPoint(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                    }
                }
            }
            else
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (drawType==3) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(y),ToFixedRect(dataWidth),ToFixedRect(yOpen-y));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,yOpen)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yOpen-y)));
                    }
                }
            }

            if (data.Open>data.Low) //下影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(drawType==3?Math.min(yClose,yOpen):y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(drawType==3?Math.max(yClose,yOpen):y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.strokeStyle=barColor;
            this.Canvas.stroke();
        }
    }

    //绘制自定义K线
    this.DrawColorKBar=function(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (Math.abs(yClose-yOpen)<1)
            this.DrawColorKBar_Line(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
        else if (colorData.Border || colorData.Type===0) 
            this.DrawColorKBar_Border(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
        else 
            this.DrawColorKBar_NoBorder(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
    }

    //带边框柱子
    this.DrawColorKBar_Border=function(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (dataWidth>=4)
        {
            if ((dataWidth%2)!=0) dataWidth-=1;
            var topPrice=Math.max(data.Close,data.Open);
            var bottomPrice=Math.min(data.Close,data.Open);
            if (isHScreen)
            {
                var yBarTop=Math.max(yClose,yOpen);
                var yBarBottom=Math.min(yClose,yOpen);
            }
            else
            {
                var yBarTop=Math.min(yClose,yOpen);
                var yBarBottom=Math.max(yClose,yOpen);
            }
            var yBarHeight=Math.abs(yClose-yOpen);

            //上影线
            if (data.High>topPrice && colorData.Line)   
            {
                this.Canvas.strokeStyle=colorData.Line.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yHigh),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yBarTop),ToFixedPoint(x));
                }
                else
                {
                    var xFixed=left+dataWidth/2;
                    this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(yHigh));
                    this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yBarTop));
                }
                this.Canvas.stroke();
            }

            //下影线
            if (bottomPrice>data.Low && colorData.Line) 
            {
                this.Canvas.strokeStyle=colorData.Line.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yBarBottom),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    var xFixed=left+dataWidth/2;
                    this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(yBarBottom));
                    this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
            }

            //中心柱子
            if (isHScreen)
            {
                var pathBar=new Path2D();
                pathBar.rect(ToFixedPoint(yBarBottom),ToFixedPoint(left),ToFixedRect(yBarHeight),ToFixedRect(dataWidth)); 
            }
            else
            {
                var pathBar=new Path2D();
                pathBar.rect(ToFixedPoint(left),ToFixedPoint(yBarTop),ToFixedRect(dataWidth),ToFixedRect(yBarHeight));
            }

            if (colorData.Type==0) //空心柱子
            {
                if (colorData.BarColor) //边框
                {
                    this.Canvas.strokeStyle=colorData.BarColor;
                    this.Canvas.stroke(pathBar);
                }

                if (colorData.Border)
                {
                    this.Canvas.strokeStyle=colorData.Border.Color;
                    this.Canvas.stroke(pathBar);
                }
            }
            else if (colorData.Type==1) //实心
            {
                if (colorData.BarColor) //内部填充
                {
                    this.Canvas.fillStyle=colorData.BarColor;
                    this.Canvas.fill(pathBar);
                }

                if (colorData.Border)   //边框
                {
                    this.Canvas.strokeStyle=colorData.Border.Color;
                    this.Canvas.stroke(pathBar);
                }
            }
            
        }
        else
        {
            this.DrawColorKBar_MinBar(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
        }
    }

    //不带边框柱子
    this.DrawColorKBar_NoBorder=function(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (dataWidth>=4)
        {
            var topPrice=Math.max(data.Close,data.Open);
            var bottomPrice=Math.min(data.Close,data.Open);
            if (isHScreen)
            {
                var yBarTop=Math.max(yClose,yOpen);
                var yBarBottom=Math.min(yClose,yOpen);
            }
            else
            {
                var yBarTop=Math.min(yClose,yOpen);
                var yBarBottom=Math.max(yClose,yOpen);
            }
            var yBarHeight=Math.abs(yClose-yOpen);

            //上影线
            if (data.High>topPrice && colorData.Line)   
            {
                this.Canvas.strokeStyle=colorData.Line.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yHigh),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yBarTop),ToFixedPoint(x));
                }
                else
                {
                    var xFixed=left+dataWidth/2;
                    this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(yHigh));
                    this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yBarTop));
                }
                this.Canvas.stroke();
            }

            //下影线
            if (bottomPrice>data.Low && colorData.Line) 
            {
                this.Canvas.strokeStyle=colorData.Line.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yBarBottom),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    var xFixed=left+dataWidth/2;
                    this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(yBarBottom));
                    this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
            }

            //中心柱子
            if (isHScreen)
            {
                var pathBar=new Path2D();
                pathBar.rect(ToFixedRect(yBarBottom),ToFixedRect(left),ToFixedRect(yBarHeight),ToFixedRect(dataWidth));
            }
            else
            {
                var pathBar=new Path2D();
                pathBar.rect(ToFixedRect(left),ToFixedRect(yBarTop),ToFixedRect(dataWidth),ToFixedRect(yBarHeight));
            }

            if (colorData.Type==1) //实心
            {
                if (colorData.BarColor) //内部填充
                {
                    this.Canvas.fillStyle=colorData.BarColor;
                    this.Canvas.fill(pathBar);
                }
            }
        }
        else
        {
            this.DrawColorKBar_MinBar(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
        }
    }

    this.DrawColorKBar_MinBar=function(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (colorData.Line)
        {
            this.Canvas.strokeStyle=colorData.Line.Color;
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(yHigh),ToFixedPoint(x));
                this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(yHigh));
                this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
            }
            this.Canvas.stroke();
        }

        /*
        var barColor;
        if (colorData.Type==0) //空心柱子
        {
            if (colorData.Border) barColor=colorData.Border.Color; 
            else if (colorData.BarColor) barColor=colorData.BarColor; 
        }
        else if (colorData.Type==1) //实心
        {
            if (colorData.Border) barColor=colorData.Border.Color; 
            else if (colorData.BarColor) barColor=colorData.BarColor; 
        }

        if (barColor)
        {
            this.Canvas.strokeStyle=barColor;
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(yOpen),ToFixedPoint(x));
                this.Canvas.lineTo(ToFixedPoint(yClose),ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(yOpen));
                this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yClose));
            }
            this.Canvas.stroke();
        }
        */
    }

    //十字线
    this.DrawColorKBar_Line=function(data, colorData, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (dataWidth>=4)
        {
            
            if (colorData.Line)
            {
                this.Canvas.strokeStyle=colorData.Line.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yHigh),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(yHigh));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                }
                
                this.Canvas.stroke();
            }

            var barColor;
            if (colorData.Type==0) //空心柱子
            {
                if (colorData.Border) barColor=colorData.Border.Color; 
                else if (colorData.BarColor) barColor=colorData.BarColor; 
            }
            else if (colorData.Type==1) //实心
            {
                if (colorData.Border) barColor=colorData.Border.Color; 
                else if (colorData.BarColor) barColor=colorData.BarColor; 
            }

            if (barColor)
            {
                this.Canvas.strokeStyle=barColor;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yOpen),ToFixedPoint(left));
                    this.Canvas.lineTo(ToFixedPoint(yOpen),ToFixedPoint(right));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(left),ToFixedPoint(yOpen));
                    this.Canvas.lineTo(ToFixedPoint(right),ToFixedPoint(yOpen));
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            if (colorData.Line)
            {
                var xFixed=left+dataWidth/2;
                this.Canvas.strokeStyle=colorData.Line.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yHigh),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(yHigh));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
            }
        }
    }

    
    this.DrawVirtualBar=function(data, dataWidth, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        var yTop=Math.min(yHigh,yLow), yBottom=Math.max(yHigh,yLow);
        this.Canvas.strokeStyle=this.VirtualBarConfig.Color;
        this.Canvas.setLineDash(this.VirtualBarConfig.LineDash);

        if (isHScreen)
        {
            if (dataWidth>=4)
            {
                this.Canvas.strokeRect(ToFixedPoint(yTop),ToFixedPoint(left),ToFixedRect(yBottom-yTop),ToFixedRect(dataWidth));
            }
            else
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(yTop,ToFixedPoint(x));
                this.Canvas.lineTo(yBottom,ToFixedPoint(x));
                this.Canvas.stroke();
            }
           
        }
        else
        {
            if (dataWidth>=4)
            {
                //this.Canvas.beginPath();
                this.Canvas.strokeRect(ToFixedPoint(left),ToFixedPoint(yTop),ToFixedRect(dataWidth),ToFixedRect(yBottom-yTop));
                //this.Canvas.stroke();
            }
            else
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(ToFixedPoint(x),yTop);
                this.Canvas.lineTo(ToFixedPoint(x),yBottom);
                this.Canvas.stroke();
            }
        }

        this.Canvas.setLineDash([]);
    }

    this.DrawRenkoCandle=function() //砖型K线
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var ptMax={X:null,Y:null,Value:null,Align:'left'};
        var ptMin={X:null,Y:null,Value:null,Align:'left'};
        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            this.DrawKRange.End=i;

            if (ptMax.Value==null || ptMax.Value<data.High)     //求最大值
            {
                ptMax.X=x;
                ptMax.Y=yHigh;
                ptMax.Value=data.High;
                ptMax.Align=j<xPointCount/2?'left':'right';
            }

            if (ptMin.Value==null || ptMin.Value>data.Low)      //求最小值
            {
                ptMin.X=x;
                ptMin.Y=yLow;
                ptMin.Value=data.Low;
                ptMin.Align=j<xPointCount/2?'left':'right';
            }

            if (data.YClose<data.Close) 
            {
                this.Canvas.strokeStyle=this.UpColor; //阳线
                this.Canvas.fillStyle=this.UpColor;
            }
            else if (data.YClose>data.Close) 
            {
                this.Canvas.strokeStyle=this.DownColor; //阴线
                this.Canvas.fillStyle=this.DownColor;
            }

            if (dataWidth>=4)
            {
                if (isHScreen)
                {
                    this.Canvas.fillRect(ToFixedRect(yLow),ToFixedRect(left),ToFixedRect(Math.abs(yLow-yHigh)),ToFixedRect(dataWidth));
                }
                else
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(yHigh),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yLow-yHigh)));
                }
            }
            else
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                    this.Canvas.lineTo(yLow,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                    this.Canvas.lineTo(ToFixedPoint(x),yLow);
                }
                this.Canvas.stroke();
            }
        }

        this.PtMax=ptMax;
        this.PtMin=ptMin;
    }

    this.DrawLineBreak=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var halfDistanceWidth=distanceWidth/2;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin-halfDistanceWidth;
            var chartright=border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin-halfDistanceWidth;
            var chartright=border.RightEx;
        }

        var ptMax={X:null,Y:null,Value:null,Align:'left'};
        var ptMin={X:null,Y:null,Value:null,Align:'left'};
        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth+distanceWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            this.DrawKRange.End=i;

            if (ptMax.Value==null || ptMax.Value<data.High)     //求最大值
            {
                ptMax.X=x;
                ptMax.Y=yHigh;
                ptMax.Value=data.High;
                ptMax.Align=j<xPointCount/2?'left':'right';
            }

            if (ptMin.Value==null || ptMin.Value>data.Low)      //求最小值
            {
                ptMin.X=x;
                ptMin.Y=yLow;
                ptMin.Value=data.Low;
                ptMin.Align=j<xPointCount/2?'left':'right';
            }

            if (data.YClose<data.Close) 
            {
                this.Canvas.strokeStyle=this.UpColor; //阳线
                this.Canvas.fillStyle=this.UpColor;
            }
            else if (data.YClose>data.Close) 
            {
                this.Canvas.strokeStyle=this.DownColor; //阴线
                this.Canvas.fillStyle=this.DownColor;
            }

            if (dataWidth>=4)
            {
                if (isHScreen)
                {
                    this.Canvas.fillRect(ToFixedRect(yLow),ToFixedRect(left),ToFixedRect(Math.abs(yLow-yHigh)),ToFixedRect(dataWidth+distanceWidth));
                }
                else
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(yHigh),ToFixedRect(dataWidth+distanceWidth),ToFixedRect(Math.abs(yLow-yHigh)));
                }
            }
            else
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                    this.Canvas.lineTo(yLow,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                    this.Canvas.lineTo(ToFixedPoint(x),yLow);
                }
                this.Canvas.stroke();
            }
        }

        this.PtMax=ptMax;
        this.PtMin=ptMin;
    }

    this.DrawKagi=function()    //卡吉图
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            var left=border.TopEx+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var left=border.Left+g_JSChartResource.FrameLeftMargin;
        }

        var ptMax={X:null,Y:null,Value:null,Align:'left'};
        var ptMin={X:null,Y:null,Value:null,Align:'left'};
        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        var lineWidth=2*GetDevicePixelRatio();
        this.Canvas.lineWidth=lineWidth;
        var preItem={ Item:null, X:left, Y:null };
        var index=this.Data.DataOffset-1;
        if (index>=0 && index<this.Data.Data.length)
        {
            var item=this.Data.Data[index];
            preItem.Item=item;
            if (item.Direction==1)  //上
            {
                preItem.Y=this.GetYFromData(item.High,false);
            }
            else if (item.Direction==2)
            {
                preItem.Y=this.GetYFromData(item.Low,false);
            }
        } 


        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            this.DrawKRange.End=i;

            if (ptMax.Value==null || ptMax.Value<data.High)     //求最大值
            {
                ptMax.X=x;
                ptMax.Y=yHigh;
                ptMax.Value=data.High;
                ptMax.Align=j<xPointCount/2?'left':'right';
            }

            if (ptMin.Value==null || ptMin.Value>data.Low)      //求最小值
            {
                ptMin.X=x;
                ptMin.Y=yLow;
                ptMin.Value=data.Low;
                ptMin.Align=j<xPointCount/2?'left':'right';
            }

            var xFixed=ToFixedPoint2(lineWidth,x);

            if (preItem.Item)
            {
                this.Canvas.beginPath();
                var yFixed=ToFixedPoint2(lineWidth,preItem.Y);

                this.Canvas.moveTo(preItem.X, yFixed);
                this.Canvas.lineTo(xFixed, yFixed);
                var prePrice=null;
                if (preItem.Item.Direction==1) prePrice=preItem.Item.Low;
                else if (preItem.Item.Direction==2) prePrice=preItem.Item.High;

                if (data.Direction==1)
                {
                    if (data.High<prePrice)
                    {
                        this.Canvas.lineTo(xFixed, yHigh);
                        this.Canvas.strokeStyle=this.DownColor; 
                        this.Canvas.stroke();
                    }
                    else
                    {
                        var yPrePrice=this.GetYFromData(prePrice,false);
                        this.Canvas.lineTo(xFixed, yPrePrice);
                        this.Canvas.strokeStyle=this.DownColor; 
                        this.Canvas.stroke();

                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed, yPrePrice);
                        this.Canvas.lineTo(xFixed, yHigh);
                        this.Canvas.strokeStyle=this.UpColor; 
                        this.Canvas.stroke();
                    }
                        
                }
                else if (data.Direction==2)
                {
                    if (data.Low>prePrice)
                    {
                        this.Canvas.lineTo(xFixed, yLow);
                        this.Canvas.strokeStyle=this.DownColor; //阳线
                        this.Canvas.stroke();
                    }
                    else
                    {
                        var yPrePrice=this.GetYFromData(prePrice,false);
                        this.Canvas.lineTo(xFixed, yPrePrice);
                        this.Canvas.strokeStyle=this.DownColor; //阳线
                        this.Canvas.stroke();

                        this.Canvas.beginPath();
                        this.Canvas.moveTo(xFixed, yPrePrice);
                        this.Canvas.lineTo(xFixed, yLow);
                        this.Canvas.strokeStyle=this.UpColor; 
                        this.Canvas.stroke();
                    }
                }
                
            }
            else
            {
                this.Canvas.beginPath();
                if (data.Direction==1)
                {
                    this.Canvas.moveTo(xFixed, yLow);
                    this.Canvas.lineTo(xFixed, yHigh);
                }
                else if (data.Direction==2)
                {
                    this.Canvas.moveTo(xFixed, yHigh);
                    this.Canvas.lineTo(xFixed, yLow);
                }
                this.Canvas.stroke();
            }

            /*
            if (data.YClose<data.Close) 
            {
                this.Canvas.strokeStyle=this.UpColor; //阳线
                this.Canvas.fillStyle=this.UpColor;
            }
            else if (data.YClose>data.Close) 
            {
                this.Canvas.strokeStyle=this.DownColor; //阴线
                this.Canvas.fillStyle=this.DownColor;
            }
            
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint2(lineWidth,x),yHigh);
                this.Canvas.lineTo(ToFixedPoint2(lineWidth,x),yLow);
            }
            this.Canvas.stroke();
            */

            preItem.Item=data;
            preItem.X=x;

            if (data.Direction==1)  preItem.Y=yHigh;    //上
            else if (data.Direction==2) preItem.Y=yLow  //下
        }

        this.PtMax=ptMax;
        this.PtMin=ptMin;
    }

    this.DrawTrade=function()       //交易系统
    {
        if (!this.TradeData) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen) 
        {
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
            chartright=this.ChartBorder.GetBottom();
        }

        var sellData=this.TradeData.Sell;
        var buyData=this.TradeData.Buy;
        var arrowWidth=dataWidth;
        if (arrowWidth>10) arrowWidth=10;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var buy=false,sell=false;
            if (sellData && i<sellData.length) sell=sellData[i]>0;
            if (buyData && i<buyData.length) buy=buyData[i]>0;
            if (!sell && !buy) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            var yOpen=this.GetYFromData(data.Open,false);
            var yClose=this.GetYFromData(data.Close,false);
            var y=yHigh;

            if (buy)
            {
                this.Canvas.fillStyle=this.UpColor;
                this.Canvas.strokeStyle=this.UnchagneColor;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(yLow-1,x);
                    this.Canvas.lineTo(yLow-arrowWidth-1,x-arrowWidth/2);
                    this.Canvas.lineTo(yLow-arrowWidth-1,x+arrowWidth/2);
                }
                else
                {
                    this.Canvas.moveTo(x,yLow+1);
                    this.Canvas.lineTo(x-arrowWidth/2,yLow+arrowWidth+1);
                    this.Canvas.lineTo(x+arrowWidth/2,yLow+arrowWidth+1);
                }
                this.Canvas.closePath();
                this.Canvas.fill();
                this.Canvas.stroke();
            }

            if (sell)
            {
                this.Canvas.fillStyle=this.DownColor;
                this.Canvas.strokeStyle=this.UnchagneColor;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(yHigh+1,x);
                    this.Canvas.lineTo(yHigh+arrowWidth+1,x-arrowWidth/2);
                    this.Canvas.lineTo(yHigh+arrowWidth+1,x+arrowWidth/2);
                }
                else
                {
                    this.Canvas.moveTo(x,yHigh-1);
                    this.Canvas.lineTo(x-arrowWidth/2,yHigh-arrowWidth-1);
                    this.Canvas.lineTo(x+arrowWidth/2,yHigh-arrowWidth-1);
                }
                this.Canvas.closePath();
                this.Canvas.fill();
                this.Canvas.stroke();
            }
        }
    }

    this.DrawTick=function()        //分笔图
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        if (isHScreen) xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        var fontSize=parseInt(dataWidth);
        if (fontSize<=1) fontSize=2;
        else if (fontSize>=18) fontSize=18;
        var bFirstPoint=true;
        var pixelRatio=GetDevicePixelRatio();
        var textSize=fontSize*pixelRatio;
        this.Canvas.beginPath();
        this.Canvas.font=fontSize*pixelRatio+'px '+this.TickFontName;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yClose=this.ChartFrame.GetYFromData(data.Close,false);
            this.DrawKRange.End=i;

            if (data.Flag===0) this.Canvas.fillStyle=this.UpColor;
            else if (data.Flag==1) this.Canvas.fillStyle=this.DownColor;
            else this.Canvas.fillStyle=this.UnchagneColor;

            this.Canvas.textAlign='center'
            this.Canvas.textBaseline='middle';
            if (isHScreen)  this.Canvas.fillText(this.TickSymbol,yClose,x);
            else this.Canvas.fillText(this.TickSymbol,x,yClose);

            if (this.IsShowKTooltip && !isHScreen)    //添加tooltip区域
            {
                var rect=new Rect(x-textSize/2,yClose-textSize/2,textSize,textSize);
                //this.Canvas.fillStyle="rgb(0,0,100)";
                //this.Canvas.fillRect(rect.X,rect.Y,rect.Width,rect.Height);
                this.TooltipRect.push([i,rect]);    //[0]数据索引 [1]数据区域
            }
        }
    }

    this.DrawHLCArea=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            var borderLeft=border.TopEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var borderLeft=border.LeftEx;
        }

        var lowPath=new Path2D();
        var highPath=new Path2D();
        var closePath=new Path2D();

        var upArea=new Path2D();
        var downArea=new Path2D();

        var aryHighPoint=[];
        var aryLowPoint=[];
        var aryClosePoint=[];

        var bFirstPoint=true;

        if (this.Data.DataOffset>0) //把最左边的一个点连上
        {
            var data=this.Data.Data[this.Data.DataOffset-1];
            if (data && IFrameSplitOperator.IsNumber(data.Close) && IFrameSplitOperator.IsNumber(data.High) && IFrameSplitOperator.IsNumber(data.Low))
            {
                var x=borderLeft;
                var yClose=this.GetYFromData(data.Close,false);
                var yHigh=this.GetYFromData(data.High,false);
                var yLow=this.GetYFromData(data.Low,false);
                if (isHScreen) 
                {
                    closePath.moveTo(yClose,x);
                    highPath.moveTo(yHigh,x);
                    lowPath.moveTo(yLow,x);

                    upArea.moveTo(yHigh,x);
                    downArea.moveTo(yLow,x);

                    aryClosePoint.push({ X:yClose, Y:x });
                    aryHighPoint.push({ X:yHigh, Y:x });
                    aryLowPoint.push({ X:yLow, Y:x });
                }
                else 
                {
                    closePath.moveTo(x,yClose);
                    highPath.moveTo(x,yHigh);
                    lowPath.moveTo(x,yLow);

                    upArea.moveTo(x,yHigh);
                    downArea.moveTo(x,yLow);

                    aryClosePoint.push({ X:x, Y:yClose });
                    aryHighPoint.push({ X:x, Y:yHigh });
                    aryLowPoint.push({ X:x, Y:yLow });
                }

                bFirstPoint=false;
            }
        }
        

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (!data || !IFrameSplitOperator.IsNumber(data.Close) || !IFrameSplitOperator.IsNumber(data.High) || !IFrameSplitOperator.IsNumber(data.Low)) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;

            var x=left+(right-left)/2;
            var yClose=this.GetYFromData(data.Close,false);
            var yHigh=this.GetYFromData(data.High,false);
            var yLow=this.GetYFromData(data.Low,false);
            this.DrawKRange.End=i;

            if (bFirstPoint)
            {
                if (isHScreen) 
                {
                    closePath.moveTo(yClose,x);
                    highPath.moveTo(yHigh,x);
                    lowPath.moveTo(yLow,x);

                    upArea.moveTo(yHigh,x);
                    downArea.moveTo(yLow,x);
                }
                else 
                {
                    closePath.moveTo(x,yClose);
                    highPath.moveTo(x,yHigh);
                    lowPath.moveTo(x,yLow);

                    upArea.moveTo(x,yHigh);
                    downArea.moveTo(x,yLow);
                }
                bFirstPoint=false;
            }
            else
            {
                if (isHScreen) 
                {
                    closePath.lineTo(yClose,x);
                    highPath.lineTo(yHigh,x);
                    lowPath.lineTo(yLow,x);

                    upArea.lineTo(yHigh,x);
                    downArea.lineTo(yLow,x);
                }
                else 
                {
                    closePath.lineTo(x,yClose);
                    highPath.lineTo(x,yHigh);
                    lowPath.lineTo(x,yLow);

                    upArea.lineTo(x,yHigh);
                    downArea.lineTo(x,yLow);
                }
            }

            if (isHScreen) 
            {
                aryClosePoint.push({ X:yClose, Y:x });
                aryHighPoint.push({ X:yHigh, Y:x });
                aryLowPoint.push({ X:yLow, Y:x });
            }
            else
            {
                aryClosePoint.push({ X:x, Y:yClose });
                aryHighPoint.push({ X:x, Y:yHigh });
                aryLowPoint.push({ X:x, Y:yLow });
            }
        }

        if (bFirstPoint) return;

        for(var i=aryClosePoint.length-1; i>=0;--i)
        {
            var item=aryClosePoint[i];
            upArea.lineTo(item.X, item.Y);
            downArea.lineTo(item.X, item.Y);
        }

        upArea.closePath();
        downArea.closePath();

        this.Canvas.fillStyle=this.HLCAreaConfig.UpAreaColor;
        this.Canvas.fill(upArea);

        this.Canvas.fillStyle=this.HLCAreaConfig.DownAreaColor;
        this.Canvas.fill(downArea);

        if (IFrameSplitOperator.IsNumber(this.HLCAreaConfig.LineWidth)) this.Canvas.lineWidth=this.HLCAreaConfig.LineWidth;
        this.Canvas.strokeStyle=this.HLCAreaConfig.CloseLineColor;
        this.Canvas.stroke(closePath);

        this.Canvas.strokeStyle=this.HLCAreaConfig.HighLineColor;
        this.Canvas.stroke(highPath);

        this.Canvas.strokeStyle=this.HLCAreaConfig.LowLineColor;
        this.Canvas.stroke(lowPath);
    }

    this.ClipTickClient=function(isHScreen)
    {
        var border=this.GetBorder();
        if (isHScreen==true)
        {
            var left=this.ChartBorder.GetLeftEx();
            var right=this.ChartBorder.GetRightEx();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }
        else
        {
            var left=border.Left;
            var right=border.Right;
            var top=border.TopTitle;
            var bottom=border.Bottom;
        }

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        this.Canvas.clip();
    }

    this.ClipWindow=function(isHScreen)
    {
        if (isHScreen==true)
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRightEx();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=this.ChartBorder.GetTopEx();
            var bottom=this.ChartBorder.GetBottom();
        }

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        //this.Canvas.stroke(); //调试用
        this.Canvas.clip();
    }

    
    this.ClipClient=function(isHScreen)          //裁剪客户端
    {
        if (isHScreen==true)
        {
            var left=this.ChartBorder.GetLeftEx();
            var right=this.ChartBorder.GetRightEx();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=this.ChartBorder.GetTopEx();
            var bottom=this.ChartBorder.GetBottomEx();
            if (this.ChartBorder.BottomSpace>0) bottom+=1;

            if (this.DrawType==13)  //需要显示文字,裁剪要大点
            {
                top=this.ChartBorder.GetTopTitle();
                bottom=this.ChartBorder.GetBottom();
            }
        }

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        //this.Canvas.stroke(); //调试用
        this.Canvas.clip();
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        this.IsShowOrderText=false;
        this.TooltipRect=[];
        this.InfoTooltipRect=[];
        this.TradeIconTooltipRect=[];
        this.PtMax={X:null,Y:null,Value:null,Align:'left'}; //清空最大
        this.PtMin={X:null,Y:null,Value:null,Align:'left'}; //清空最小
        this.DrawKRange={ Start:null, End:null }; 
        this.AryPriceGapCache=[];

        this.ChartFrame.ChartKLine={Max:null, Min:null };   //保存K线上 显示最大最小值坐标

        this.DrawHeatMap();

        if (!this.IsShow) return;
        if (this.ChartFrame.IsMinSize && this.Name=="Self Kline") return;

        if (ChartData.IsTickPeriod(this.Period))    //分笔图
        {
            this.Canvas.save();
            
            if (this.DrawType==1)
            {
                this.ClipClient(this.ChartFrame.IsHScreen);
                this.DrawCloseLine();
            }
            else if (this.DrawType==4)
            {
                this.ClipClient(this.ChartFrame.IsHScreen);
                this.DrawCloseArea();
            }
            else
            {
                this.ClipTickClient(this.ChartFrame.IsHScreen);
                this.DrawTick();
            }
                

            this.Canvas.restore();
            return;
        }

        this.Canvas.save();
        this.ClipClient(this.ChartFrame.IsHScreen);

        if (this.DrawType==1) 
        {
            this.DrawCloseLine();
            this.Canvas.restore();
            if (this.PriceGap.Enable) this.DrawPriceGap();
            return;
        }
        else if (this.DrawType==2)
        {
            this.DrawAKLine();
        }
        else if (this.DrawType==4)
        {
            this.DrawCloseArea();
        }
        else if (this.DrawType==5)
        {
            this.DrawOrderFlow();
        }
        else if (this.DrawType==7)
        {
            this.DrawOrderFlow_Style2();
        }
        else if (this.DrawType==8)
        {
            this.DrawOrderFlow_Style3();
        }
        else if (this.DrawType==9)
        {
            this.DrawKBar();
        }
        else if (this.DrawType==10)
        {
            this.DrawRenkoCandle();
        }
        else if (this.DrawType==12)
        {
            this.DrawLineBreak();
        }
        else if (this.DrawType==13)
        {
            this.DrawHighLow();
        }
        else if (this.DrawType==14)
        {
            if (this.FFKChart && this.FFKChart.Draw)
            {
                this.FFKChart.Draw(this);
            }
        }
        else if (this.DrawType==15)
        {
            this.DrawHLCArea();
        }
        else if (this.DrawType==16)
        {
            this.DrawKagi();
        }
        else if (this.DrawType==17)
        {
            this.DrawOrderFlow_Style4();
        }
        else if (this.DrawType==18)
        {
            this.DrawOrderFlow_Style5();
        }
        else
        {
            this.DrawKBar();
        }

        if (this.TradeIcon) this.DrawTradeIcon()
        else this.DrawTrade();

        this.Canvas.restore();

        if (this.PriceGap.Enable) this.DrawPriceGap();

        if (this.IsShowMaxMinPrice)     //标注最大值最小值
        {
            if (this.ChartFrame.IsHScreen===true) this.HScreenDrawMaxMinPrice(this.PtMax,this.PtMin);
            else this.DrawMaxMinPrice(this.PtMax,this.PtMin);
        }

        if (this.DrawType==14)      //自定义图形 标注最大最小值
        {
            if (this.FFKChart && this.FFKChart.DrawMaxMinPrice)
            {
                this.FFKChart.DrawMaxMinPrice();
            }
        }
    }

    this.OnFormatHighLowTitle=function(ptMax, ptMin)
    {
        if (!ptMax || !ptMin) return null;
        if (!IFrameSplitOperator.IsNumber(ptMax.Value) || !IFrameSplitOperator.IsNumber(ptMin.Value)) return null;

        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);   //小数位数
        var title=
        { 
            High:ptMax.Value.toFixed(defaultfloatPrecision), 
            Low:ptMin.Value.toFixed(defaultfloatPrecision) 
        };
       
        if (!this.GetEventCallback) return title;
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_KLINE_HIGH_LOW_TITLE);
        if (!event || !event.Callback) return title;

        var data={ Max:ptMax, Min:ptMin, Symbol:this.Symbol, Title:{ High:title.High, Low:title.Low }, Decimal:defaultfloatPrecision, PreventDefault:false };
        event.Callback(event, data, this);
        if (data.PreventDefault) return data.Title;    //使用外部回调的数值

        return title;
    }

    this.DrawMaxMinPrice=function(ptMax,ptMin)
    {
        if (ptMax.X==null || ptMax.Y==null || ptMax.Value==null) return;
        if (ptMin.X==null || ptMin.Y==null || ptMin.Value==null) return;

        var title=this.OnFormatHighLowTitle(ptMax,ptMin);
        if (!title) return;

        var leftArrow=g_JSChartResource.KLine.MaxMin.LeftArrow;
        var rightArrow=g_JSChartResource.KLine.MaxMin.RightArrow;
        var highYOffset=g_JSChartResource.KLine.MaxMin.HighYOffset;
        var lowYOffset=g_JSChartResource.KLine.MaxMin.LowYOffset;

        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        this.Canvas.font=this.TextFont;
       
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();

        var ptTop=ptMax;
        var text=title.High;
        var textColor=this.TextColor;
        if (this.ChartFrame.CoordinateType==1)  //反转坐标
        {
            if (ptMax.Y<ptMin.Y) ptTop=ptMin;
            this.Canvas.textBaseline='top';
            var text=title.Low;
            if (title.LowColor) textColor=title.LowColor;
        }
        else
        {
            if (ptMax.Y>ptMin.Y) ptTop=ptMin;
            this.Canvas.textBaseline='bottom';
            if (title.HighColor) textColor=title.HighColor;
        }

        this.Canvas.fillStyle=textColor;
        this.Canvas.textAlign=ptTop.Align;
        var left=ptTop.Align=='left'?ptTop.X:ptTop.X;
        if (IFrameSplitOperator.IsNumber(highYOffset)) ptTop.Y+=highYOffset;
        //var text=ptTop.Value.toFixed(defaultfloatPrecision);
        if (ptTop.Align=='left') text=leftArrow+text;
        else text=text+rightArrow;
        if (ptTop.Y>(top-2))
        {
            this.Canvas.fillText(text,left,ptTop.Y);
            this.ChartFrame.ChartKLine.Max={X:left, Y:ptTop.Y, Text: { BaseLine:'bottom'}};
        }
        
        var ptBottom=ptMin;
        var text=title.Low;
        var textColor=this.TextColor;
        if (this.ChartFrame.CoordinateType==1)
        {
            if (ptMin.Y>ptMax.Y) ptBottom=ptMax;
            this.Canvas.textBaseline='bottom';
            var text=title.High;
            if (title.HighColor) textColor=title.HighColor;
        }
        else
        {
            if (ptMax.Y>ptMin.Y) ptTop=ptMin;
            this.Canvas.textBaseline='top';
            if (title.LowColor) textColor=title.LowColor;
        }

        this.Canvas.fillStyle=textColor;
        this.Canvas.textAlign=ptBottom.Align;
        var left=ptBottom.Align=='left'?ptBottom.X:ptBottom.X;
        if (IFrameSplitOperator.IsNumber(lowYOffset)) ptBottom.Y+=lowYOffset;
        //var text=ptMin.Value.toFixed(defaultfloatPrecision);
        if (ptBottom.Align=='left') text=leftArrow+text;
        else  text=text+rightArrow;
        if (ptBottom.Y<(bottom+1))
        {
            this.Canvas.fillText(text,left,ptBottom.Y);
            this.ChartFrame.ChartKLine.Min={X:left, Y:ptBottom.Y, Text:{ BaseLine:'top'}};
        }
    }

    this.HScreenDrawMaxMinPrice=function(ptMax,ptMin)   //横屏模式下显示最大最小值
    {
        if (ptMax.X==null || ptMax.Y==null || ptMax.Value==null) return;
        if (ptMin.X==null || ptMin.Y==null || ptMin.Value==null) return;
        var title=this.OnFormatHighLowTitle(ptMax,ptMin);
        if (!title) return;

        var leftArrow=g_JSChartResource.KLine.MaxMin.LeftArrow;
        var rightArrow=g_JSChartResource.KLine.MaxMin.RightArrow;
        var highYOffset=g_JSChartResource.KLine.MaxMin.HighYOffset;
        var lowYOffset=g_JSChartResource.KLine.MaxMin.LowYOffset;

        //var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        var xText=ptMax.Y;
        var yText=ptMax.X;
        if (IFrameSplitOperator.IsNumber(highYOffset)) xText+=highYOffset;
        this.Canvas.save(); 
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);

        var text=title.High;
        this.Canvas.font=this.TextFont;
        if (title.HighColor) this.Canvas.fillStyle=title.HighColor;
        else this.Canvas.fillStyle=this.TextColor;
        this.Canvas.textAlign=ptMax.Align;
        this.Canvas.textBaseline='bottom';
        //var text=ptMax.Value.toFixed(defaultfloatPrecision);
        if (ptMax.Align=='left') text=leftArrow+text;
        else  text=text+rightArrow;
        this.Canvas.fillText(text,0,0);
        this.Canvas.restore();

        
        var xText=ptMin.Y;
        var yText=ptMin.X;
        if (IFrameSplitOperator.IsNumber(lowYOffset)) xText+=lowYOffset;
        this.Canvas.save(); 
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);

        var text=title.Low;
        this.Canvas.font=this.TextFont;
        if (title.LowColor) this.Canvas.fillStyle=title.LowColor;
        else this.Canvas.fillStyle=this.TextColor;
        this.Canvas.textAlign=ptMin.Align;
        this.Canvas.textBaseline='top';
        //var text=ptMin.Value.toFixed(defaultfloatPrecision);
        if (ptMin.Align=='left') text=leftArrow+text;
        else text=text+rightArrow;
        this.Canvas.fillText(text,0,0);
        this.Canvas.restore();
    }

    //画某一天的信息地雷
    this.DrawInfo=function(item)
    {
        if (!this.InfoData || this.InfoData.size<=0) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var bottom=this.ChartBorder.GetBottom();
        var top=this.ChartBorder.GetTop();

        var key=`${item.DayData.Date}`;
        if (this.Data.DataType==1) key=`${item.DayData.Date}-${item.DayData.Time}`;
        if (!this.InfoData.has(key)) return;

        var infoData=this.InfoData.get(key);
        if (!infoData || infoData.Data.length<=0) return;

        this.Canvas.restore();
        this.Canvas.save();
        this.ClipWindow(isHScreen);

        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        var iconSize=dataWidth+distanceWidth;
        var minIconSize=18*pixelTatio;
        var bShowNum=true;
        if (iconSize<=15) bShowNum=false;
        if (iconSize<minIconSize) iconSize=minIconSize;
        
        var text='', title='';
        var mapImage=new Map();
        var iconTop=item.YMax+1*pixelTatio;
        var iconBottom=item.YMin+1*pixelTatio+iconSize;
        var drawTop=true;
        var yOffset=0;
        for(var i in infoData.Data)
        {
            var infoItem=infoData.Data[i];
            var imageInfo=mapImage.get(infoItem.InfoType);
            if (!imageInfo)
            {
                var icon=JSKLineInfoMap.GetIconFont(infoItem.InfoType);
                this.Canvas.fillStyle=icon.Color;
                this.Canvas.font=iconSize+'px '+icon.Family;

                if (isHScreen)
                {
                    this.Canvas.textBaseline="middle";
                    this.Canvas.textAlign="left";
                    this.Canvas.fillText(icon.HScreenText,iconTop,item.XCenter,iconSize);

                    var iconRect=new Rect(item.XCenter-iconSize/2,iconTop-iconSize,iconSize,iconSize);
                    var infoCache={ Data:new Array(infoItem), Rect:iconRect, Type:infoItem.InfoType, TextRect:{X:iconTop, Y:item.XCenter} };
                    mapImage.set(infoItem.InfoType,infoCache);

                    iconTop+=iconSize;
                }
                else
                {
                    this.Canvas.textBaseline="bottom";
                    this.Canvas.textAlign="center";
                    if (this.InfoPosition===1) 
                    {
                        var yBottom=bottom+yOffset;
                        this.Canvas.fillText(icon.Text,item.XCenter,yBottom,iconSize);
                        var iconRect=new Rect(item.XCenter-iconSize/2,yBottom-iconSize,iconSize,iconSize);
                        var infoCache={ Data:new Array(infoItem), Rect:iconRect, Type:infoItem.InfoType, TextRect:{X:item.XCenter, Y:yBottom} };
                        mapImage.set(infoItem.InfoType,infoCache);
                        yOffset-=iconSize;
                    }
                    else
                    {
                        if (drawTop)
                        {
                            this.Canvas.fillText(icon.Text,item.XCenter,iconTop,iconSize);
                            var iconRect=new Rect(item.XCenter-iconSize/2,iconTop-iconSize,iconSize,iconSize);
                            var infoCache={ Data:new Array(infoItem), Rect:iconRect, Type:infoItem.InfoType, TextRect:{X:item.XCenter, Y:iconTop} };
                            mapImage.set(infoItem.InfoType,infoCache);
                            iconTop-=iconSize;
                            if (iconTop-iconSize<top ) drawTop=false;
                        }
                        else    //上面显示不下,就显示在下面
                        {
                            this.Canvas.fillText(icon.Text,item.XCenter,iconBottom,iconSize);
                            var iconRect=new Rect(item.XCenter-iconSize/2,iconBottom-iconSize,iconSize,iconSize);
                            var infoCache={ Data:new Array(infoItem), Rect:iconRect, Type:infoItem.InfoType, TextRect:{X:item.XCenter, Y:iconBottom} };
                            mapImage.set(infoItem.InfoType,infoCache);
                            iconBottom+=iconSize;
                        }
                    }
                }
            }
            else
            {
                imageInfo.Data.push(infoItem);
            }
        }

        var numText;
        if (g_JSChartResource.KLine.NumIcon) 
        {
            if (isHScreen) numText=g_JSChartResource.KLine.NumIcon.HScreenText;
            else numText=g_JSChartResource.KLine.NumIcon.Text;
        }
        for(var item of mapImage)
        {
            var value=item[1];
            if (value.Data.length>=2 && numText && bShowNum) //太小了 就不显示了
            {
                var iconID=value.Data.length;
                if (iconID>=numText.length) iconID=0;
                this.Canvas.fillStyle=g_JSChartResource.KLine.NumIcon.Color;
                var text=numText[iconID];
                this.Canvas.fillText(text,value.TextRect.X,value.TextRect.Y,iconSize);
            }

            if (!isHScreen) this.InfoTooltipRect.push(value);   //横屏没有tooltip
        }

        this.Canvas.restore();
        this.Canvas.save();
        this.ClipClient(isHScreen);
    }

    //画交易图标
    this.DrawTradeIcon=function()
    {
        if (!this.TradeData) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen) 
        {
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
            chartright=this.ChartBorder.GetBottom();
        }

        var sellData=this.TradeData.Sell;
        var buyData=this.TradeData.Buy;
        var iconSize=dataWidth+distanceWidth;
        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        var iconSizeMax=24*pixelTatio,iconSizeMin=12*pixelTatio;
        if (iconSize<iconSizeMin) iconSize=iconSizeMin;
        else if (iconSize>iconSizeMax) iconSize=iconSizeMax;
        this.Canvas.font=iconSize+'px '+this.TradeIcon.Family;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var buy=false,sell=false;
            if (sellData && i<sellData.length) sell=sellData[i]>0;
            if (buyData && i<buyData.length) buy=buyData[i]>0;
            if (!sell && !buy) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            var yOpen=this.GetYFromData(data.Open,false);
            var yClose=this.GetYFromData(data.Close,false);
            var y=yHigh;

            if (buy)
            {
                this.Canvas.fillStyle=this.TradeIcon.Buy.Color;
                
                if (isHScreen)
                {
                    this.Canvas.textAlign='right';
                    this.Canvas.textBaseline='middle';
                    this.Canvas.fillText(this.TradeIcon.Buy.HScreenText,yLow,x);
                }
                else
                {
                    this.Canvas.textAlign='center';
                    this.Canvas.textBaseline='top';
                    this.Canvas.fillText(this.TradeIcon.Buy.Text,x,yLow);

                    var iconRect=new Rect(x-iconSize/2,yLow,iconSize,iconSize);
                    var iconData={ Data:{ Type:1, KData:data, Name:this.TradeData.Name, Param:this.TradeData.Param }, Rect:iconRect, TextRect:{X:x, Y:yLow} };
                    this.TradeIconTooltipRect.push(iconData); 
                }
            }

            if (sell)
            {
                this.Canvas.fillStyle=this.TradeIcon.Sell.Color;
                if (isHScreen)
                {
                    this.Canvas.textAlign='left';
                    this.Canvas.textBaseline='middle';
                    this.Canvas.fillText(this.TradeIcon.Sell.HScreenText,yHigh,x);
                }
                else
                {
                    this.Canvas.textAlign='center';
                    this.Canvas.textBaseline='bottom';
                    this.Canvas.fillText(this.TradeIcon.Sell.Text,x,yHigh);

                    var iconRect=new Rect(x-iconSize/2,yHigh-iconSize,iconSize,iconSize);
                    var iconData={ Data:{ Type:2, KData:data, Name:this.TradeData.Name,Param:this.TradeData.Param }, Rect:iconRect, TextRect:{X:x, Y:yHigh} };
                    this.TradeIconTooltipRect.push(iconData); 
                }
            }
        }
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        if (!this.IsShow) return false;

        for(var i in this.TradeIconTooltipRect)
        {
            var item=this.TradeIconTooltipRect[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                JSConsole.Chart.Log('[ChartKLine::GetTooltipData] trade icon ', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=2; //指标
                return true;
            }
        }

        for(var i in this.InfoTooltipRect)
        {
            var item=this.InfoTooltipRect[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                //JSConsole.Chart.Log('[ChartKLine::GetTooltipData] info ', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=1; //信息地雷
                return true;
            }
        }

        for(var i in this.TooltipRect)
        {
            var rect=this.TooltipRect[i][1];
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                var index=this.TooltipRect[i][0];
                tooltip.Data=this.Data.Data[index];
                tooltip.ChartPaint=this;
                tooltip.Type=0; //K线信息
                return true;
            }
        }

        return false;
    }

    //计算当天显示数据的最大最小值
    this.GetMaxMin=function()
    {
        if (this.DrawType==14)
        {
            if (this.FFKChart && this.FFKChart.GetMaxMin)
            {
                return this.FFKChart.GetMaxMin(this);
            }
        }

        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        if (this.ChartFrame.GlobalOption && this.ChartFrame.GlobalOption.IsValueFullRange)
        {
            start=0;
            xPointCount=this.Data.Data.length;
        }

        var range={ Max:null, Min:null };
       
        if (this.DrawType==1 || this.DrawType==4 )    // 1=收盘价线 4=收盘价面积图
        {
            for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
            {
                var data=this.Data.Data[i];
                if (!IFrameSplitOperator.IsNumber(data.Close)) continue;

                if (range.Max==null) range.Max=data.Close;
                if (range.Min==null) range.Min=data.Close;

                if (range.Max<data.Close) range.Max=data.Close;
                if (range.Min>data.Close) range.Min=data.Close;
            }
        }
        else
        {
            for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
            {
                var data=this.Data.Data[i];
                if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

                if (this.DrawType==5 && data.OrderFlow && IFrameSplitOperator.IsNumber(data.OrderFlow.PriceOffset))
                {
                    var high=data.High;
                    var low=data.Low;

                    if (IFrameSplitOperator.IsNonEmptyArray(data.OrderFlow.High))
                    {
                        for(var k=0;k<data.OrderFlow.High.length;++k)
                        {
                            var item=data.OrderFlow.High[k];
                            if (high<item.Price) high=item.Price;
                        }
                    }

                    if (IFrameSplitOperator.IsNonEmptyArray(data.OrderFlow.Low))
                    {
                        for(var k=0;k<data.OrderFlow.Low.length;++k)
                        {
                            var item=data.OrderFlow.Low[k];
                            if (low>item.Price) low=item.Price;
                        }
                    }

                    high+=data.OrderFlow.PriceOffset;
                    low-=data.OrderFlow.PriceOffset;

                    if (range.Max==null) range.Max=high;
                    if (range.Min==null) range.Min=low;
    
                    if (range.Max<high) range.Max=high;
                    if (range.Min>low) range.Min=low;
                }
                else
                {
                    if (range.Max==null) range.Max=data.High;
                    if (range.Min==null) range.Min=data.Low;
    
                    if (range.Max<data.High) range.Max=data.High;
                    if (range.Min>data.Low) range.Min=data.Low;
                }
            }
        }

        return range;
    }

    //获取所有的价格
    this.GetAllPrice=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var setPrice=new Set();
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var value=data.Close;
            setPrice.add(value);
        }

        var aryPrice=[];
        for(var item of setPrice) 
        {
            aryPrice.push(item);
        }

        aryPrice.sort(function(a,b) { return a-b; });   //排序 升序

        return aryPrice;
    }

    this.DrawLastPointEvent=function(ptLast)
    {
        if (!this.GetEventCallback)  return;
        
        //通知外部绘制最后一个点
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAW_KLINE_LAST_POINT);
        if (event)
        {
            var kWidth={ Data: this.ChartFrame.DataWidth, Distance:this.ChartFrame.DistanceWidth };
            if (ptLast) var data={ LastPoint:{ X:ptLast.X, Y:ptLast.Y, XLeft:ptLast.XLeft, XRight:ptLast.XRight }, KItem:ptLast.KItem, DrawType:this.DrawType, KWidth:kWidth, ChartRight:ptLast.ChartRight };
            else var data={ LastPoint:null, KItem:null, KWidth:kWidth };
            event.Callback(event,data,this);
        }
    }

    this.DrawOrderFlow=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }
        
        var upColor=this.UpColor;
        var downColor=this.DownColor;
        var unchagneColor=this.UnchagneColor; 

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;
        var ptLast=null;

        this.DrawOrderFlowHBar();   //横向柱子

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            this.DrawKRange.End=i;

            var yKline={ Low:yLow, High:yHigh, Open:yOpen, Close:yClose };
            var xKLine={ Left:left, Center:x, Right:right, DataWidth:dataWidth };

            this.DrawOrderFlowBar(data.OrderFlow, data, xKLine, yKline, isHScreen);
            
            if (this.IsShowKTooltip && !isHScreen)    //添加tooltip区域
            {
                var yTop=Math.min(yOpen,yClose);
                var yBottom=Math.max(yOpen,yClose);
                if (Math.abs(yOpen-yClose)<5)   //高度太小了, 上下各+5px
                {
                    yTop=Math.min(yHigh,yTop-5);
                    yBottom=Math.max(yLow,yBottom+5);
                }
                var rect=new Rect(left,yTop,dataWidth,yBottom-yTop);
                //this.Canvas.fillStyle="rgb(0,0,100)";
                //this.Canvas.fillRect(rect.X,rect.Y,rect.Width,rect.Height);
                this.TooltipRect.push([i,rect]);    //[0]数据索引 [1]数据区域
            }

            if(this.Data.DataType==0)
            {
                var infoItem={Xleft:left,XRight:right, XCenter:x, YMax:yHigh, YMin:yLow, DayData:data, Index:j};
                this.DrawInfo(infoItem);
            }

            if (i==this.Data.Data.length-1)
            {
                ptLast={ X:x, Y:yClose, XLeft:left, XRight:right, KItem:data, ChartRight:chartright };
            }
        }
    }

    this.DrawOrderFlowBar=function(orderFlow, kItem, xKLine, yKline, isHScreen)
    {
        var top=Math.min(yKline.Open, yKline.Close)
        var bottom=Math.max(yKline.Open, yKline.Close);
        var barHeight=Math.abs(yKline.Open-yKline.Close);
        var cellHeight=0;
        if (orderFlow && IFrameSplitOperator.IsNumber(orderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(orderFlow.PriceOffset);
        var textFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2);
        this.IsShowOrderText=(cellHeight>5 && xKLine.DataWidth>10);
        if (this.OrderFlow.AlwaysShowOrderText) this.IsShowOrderText=true;

        var kColor;
        if (kItem.Open<kItem.Close) kColor=this.OrderFlow.UpColor;
        else if (kItem.Open>kItem.Close) kColor=this.OrderFlow.DownColor;
        else kColor=this.OrderFlow.UnchagneColor;

        var isSmallKLine=(xKLine.DataWidth<4);

        if (isSmallKLine)
        {
            this.Canvas.strokeStyle=kColor.Border;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(xKLine.Center),top-cellHeight/2);
            this.Canvas.lineTo(ToFixedPoint(xKLine.Center),bottom+cellHeight/2);
            this.Canvas.stroke();
        }
        else
        {
            this.Canvas.fillStyle=kColor.BG;
            this.Canvas.fillRect(ToFixedRect(xKLine.Left),ToFixedRect(top-cellHeight/2),ToFixedRect(xKLine.DataWidth),ToFixedRect(barHeight+cellHeight));
        }

        
        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='center';
        this.Canvas.font=textFont;
        var textWidth=xKLine.DataWidth/2;
        var textXOffset=textWidth/2;
        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.Order))
        {
            var totalAsk=0, totalBid=0, maxTotalIndex=null;
            if (this.OrderFlow.IsShowAskBar || this.OrderFlow.IsShowBidBar || this.OrderFlow.IsShowPOCBG)
            {
                var maxTotal=0, value=0;
                for(var i=0;i<orderFlow.Order.length;++i)
                {
                    var item=orderFlow.Order[i];

                    value=0;
                    if (item.Ask && IFrameSplitOperator.IsNumber(item.Ask.Value)) 
                    {
                        totalAsk+=item.Ask.Value;
                        value+=item.Ask.Value;
                    }

                    if (item.Bid && IFrameSplitOperator.IsNumber(item.Bid.Value)) 
                    {
                        totalBid+=item.Bid.Value;
                        value+=item.Bid.Value;
                    }

                    if (maxTotal<value)
                    {
                        maxTotal=value;
                        maxTotalIndex=i;
                    }
                }
            }

            for(var i=0;i<orderFlow.Order.length;++i)
            {
                var item=orderFlow.Order[i];
                var yPrice=this.GetYFromData(item.Price, false);
    
                var rect={ Left:xKLine.Left, Right:xKLine.Center, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (item.Ask.BG)
                {
                    this.Canvas.fillStyle=item.Ask.BG;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }

                if (this.OrderFlow.IsShowPOCBG && maxTotalIndex==i)
                {
                    this.Canvas.fillStyle=this.OrderFlow.POCGBColor;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }

                if (this.OrderFlow.IsShowAskBar && IFrameSplitOperator.IsNumber(item.Ask.Value) && totalAsk>0)
                {
                    var barWidh=rect.Width*(item.Ask.Value/totalAsk);
                    if (barWidh<1) barWidh=1;
                    this.Canvas.fillStyle=this.OrderFlow.AskBarColor;
                    this.Canvas.fillRect(ToFixedRect(rect.Right),ToFixedRect(rect.Top),ToFixedRect(-barWidh),ToFixedRect(rect.Height));
                }
    
                var text=null;
                if (IFrameSplitOperator.IsString(item.Ask.Text)) text=item.Ask.Text;
                else if (IFrameSplitOperator.IsNumber(item.Ask.Value)) text=item.Ask.Value.toString();
                if (text && this.IsShowOrderText && this.OrderFlow.IsShowAskText)
                {
                    if (item.Ask.Color) this.Canvas.fillStyle=item.Ask.Color;
                    else this.Canvas.fillStyle=this.OrderFlow.Text.Color;

                    if (item.Ask.Font)
                    {
                        var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2, item.Ask.Font);
                        this.Canvas.font=itemFont;
                        this.Canvas.fillText(text,xKLine.Left+textXOffset,yPrice);
                        this.Canvas.font=textFont;
                    }
                    else
                    {
                        this.Canvas.fillText(text,xKLine.Left+textXOffset,yPrice);
                    }
                }
    
                
                var rect={ Left:xKLine.Center, Right:xKLine.Right, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (item.Bid.BG)
                {
                    this.Canvas.fillStyle=item.Bid.BG;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }
                

                if (this.OrderFlow.IsShowPOCBG && maxTotalIndex==i)
                {
                    this.Canvas.fillStyle=this.OrderFlow.POCGBColor;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }

                if (this.OrderFlow.IsShowBidBar && IFrameSplitOperator.IsNumber(item.Bid.Value) && totalBid>0)
                {
                    var barWidh=rect.Width*(item.Bid.Value/totalBid);
                    if (barWidh<1) barWidh=1;
                    this.Canvas.fillStyle=this.OrderFlow.BidBarColor;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(barWidh),ToFixedRect(rect.Height));
                }

    
                var text=null;
                if (IFrameSplitOperator.IsString(item.Bid.Text)) text=item.Bid.Text;
                else if (IFrameSplitOperator.IsNumber(item.Bid.Value)) text=item.Bid.Value.toString();
                if (text && this.IsShowOrderText && this.OrderFlow.IsShowBidText)
                {
                    if (item.Bid.Color) this.Canvas.fillStyle=item.Bid.Color;
                    else this.Canvas.fillStyle=this.OrderFlow.Text.Color;
    
                    if (item.Bid.Font)
                    {
                        var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2, item.Bid.Font);
                        this.Canvas.font=itemFont;
                        this.Canvas.fillText(text,xKLine.Center+textXOffset,yPrice);
                        this.Canvas.font=textFont;
                    }
                    else
                    {
                        this.Canvas.fillText(text,xKLine.Center+textXOffset,yPrice);
                    }
                    
                }
            }
        }
        
        if (yKline.High<top || yKline.Low>bottom)
        {
            this.Canvas.strokeStyle=this.OrderFlow.Line.UpDownColor;
            if (yKline.High<top)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(ToFixedPoint(xKLine.Center),yKline.High-cellHeight/2);
                this.Canvas.lineTo(ToFixedPoint(xKLine.Center),top-cellHeight/2);
                this.Canvas.stroke();
            }

            if (yKline.Low>bottom)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(ToFixedPoint(xKLine.Center),yKline.Low+cellHeight/2);
                this.Canvas.lineTo(ToFixedPoint(xKLine.Center),bottom+cellHeight/2);
                this.Canvas.stroke();
            }
        }

        if (!isSmallKLine && Math.abs(yKline.Open-yKline.Close)>1)  //K线中间竖线
        {
            this.Canvas.strokeStyle=this.OrderFlow.Line.MiddleColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(xKLine.Center),top-cellHeight/2);
            this.Canvas.lineTo(ToFixedPoint(xKLine.Center),bottom+cellHeight/2);
            this.Canvas.stroke();
        }

        //K线边框
        if (!isSmallKLine)
        {
            this.Canvas.beginPath();
            this.Canvas.strokeStyle=kColor.Border;
            this.Canvas.rect(ToFixedPoint(xKLine.Left),ToFixedPoint(top-cellHeight/2),ToFixedRect(xKLine.DataWidth),ToFixedRect(barHeight+cellHeight));
            this.Canvas.stroke();
        }
        

        //var fontHeight=this.Canvas.measureText("擎").width+2;
        var textFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth);
        //上下文字
        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.High) && this.IsShowOrderText)
        {
            for(var i=0;i<orderFlow.High.length;++i)
            {
                var item=orderFlow.High[i];
                var text;
                if (IFrameSplitOperator.IsString(item.Text)) text=item.Text;
                else if (IFrameSplitOperator.IsNumber(item.Value)) text=item.Value.toString();
                if (!text) continue;

                if (item.Color) this.Canvas.fillStyle=item.Color;
                else this.Canvas.fillStyle=this.OrderFlow.Text.Color;

                var yPrice=this.GetYFromData(item.Price, false);

                if (item.Font)
                {
                    var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth, item.Font);
                    this.Canvas.font=itemFont;
                    this.Canvas.fillText(text,xKLine.Center,yPrice);
                    this.Canvas.font=textFont;
                } 
                else
                {
                    this.Canvas.fillText(text,xKLine.Center,yPrice);
                }
                
            }
        }

        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.Low) && this.IsShowOrderText)
        {
            for(var i=0;i<orderFlow.Low.length;++i)
            {
                var item=orderFlow.Low[i];
                var text;
                if (IFrameSplitOperator.IsString(item.Text)) text=item.Text;
                else if (IFrameSplitOperator.IsNumber(item.Value)) text=item.Value.toString();
                if (!text) continue;

                if (item.Color) this.Canvas.fillStyle=item.Color;
                else this.Canvas.fillStyle=this.OrderFlow.Text.Color;

                var yPrice=this.GetYFromData(item.Price, false);

                if (item.Font)
                {
                    var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth, item.Font);
                    this.Canvas.font=itemFont;
                    this.Canvas.fillText(text,xKLine.Center,yPrice);
                    this.Canvas.font=textFont;
                } 
                else
                {
                    this.Canvas.fillText(text,xKLine.Center,yPrice);
                }
            }
        }
    }

    this.GetPriceYOffset=function(value)
    {
        var frame=this.ChartFrame;
        var y=frame.ChartBorder.GetHeightEx()*(value)/(frame.HorizontalMax-frame.HorizontalMin);
        return y;
    }

    this.GetDynamicOrderFlowFont=function(cellHeight, width, fontOption)
    {
        var fontSize=parseInt(cellHeight)-2;
        if (cellHeight<5) fontSize=parseInt(cellHeight);    //高度太小了就不要上下间距了
        if (fontSize>this.OrderFlow.Text.FontMaxSize) fontSize=this.OrderFlow.Text.FontMaxSize;
        else if (fontSize<=0) fontSize=1;
        var font=this.FormatFontString(fontSize, this.OrderFlow.Text.Family, fontOption);

        for(var i=fontSize; i>0; i-=2)
        {
            var font=this.FormatFontString(i, this.OrderFlow.Text.Family, fontOption);
            this.Canvas.font=font;
            var textWidth=this.Canvas.measureText(this.OrderFlow.Text.MaxValue).width+2;
            if (textWidth<width) break;
        }

        return font;
    }

    this.FormatFontString=function(fontSize, family, option)
    {
        var font;
        if (!option) 
        {
            font=`${fontSize}px ${family}`;
        }
        else
        {
            if (option.Weight) font=`${option.Weight} ${fontSize}px ${family}`;
        }

        return font;
    }

    this.DrawOrderFlowHBar=function()
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        var horizontalMax=this.ChartFrame.HorizontalMax, horizontalMin=this.ChartFrame.HorizontalMin;
        var startOffset=this.Data.DataOffset, endOffset=this.Data.DataOffset+xPointCount
        for(var i=0; i<this.Data.Data.length;++i)   //绘制横线柱子
        {
            var kItem=this.Data.Data[i];
            if (!kItem || !kItem.OrderFlow) continue;
            if (!IFrameSplitOperator.IsNonEmptyArray(kItem.OrderFlow.Order)) continue;

            for(var j=0;j<kItem.OrderFlow.Order.length;++j)
            {
                var orderItem=kItem.OrderFlow.Order[j];
                if (!orderItem.HBar) continue;
                if (!IFrameSplitOperator.IsNumber(orderItem.HBar.Width)) continue;
                if (!IFrameSplitOperator.IsNumber(orderItem.Price)) continue;
                if (orderItem.Price>horizontalMax || orderItem.Price<horizontalMin) continue;
                var value=Math.ceil((i+orderItem.HBar.Width));
                var start=Math.min(i,value);
                var end=Math.max(i,value);
                if (end<startOffset || start>endOffset) continue;
                
                this.DrawOrderFlowHBarItem(i, kItem.OrderFlow, orderItem, dataWidth, distanceWidth);
            }

        }
    }

    this.DrawOrderFlowHBarItem=function(index, orderFlow, orderItem, dataWidth, distanceWidth)
    {
        var offset=this.ShowRange.Start;
        var endOffset=this.ShowRange.Start+this.ShowRange.ShowCount;
        var yPrice=this.GetYFromData(orderItem.Price, false);
        var value=parseInt(index+orderItem.HBar.Width);
        var start=index-offset;
        var end=value-offset;
        if (start<0) start=0;
        if (end<0) end=0;

        if (start<=end)
        {
            var chartright=this.ChartBorder.GetRight();
            var xPointCount=this.ChartFrame.XPointCount;
            var dataOffset=offset;

            var cellHeight=this.GetPriceYOffset(orderFlow.PriceOffset);
            var xStart=this.ChartFrame.GetXFromIndex(start)-dataWidth/2;
            
            if (orderItem.HBar.Type==1)
            {
                for(var i=0, j=index+1; i<orderItem.HBar.Width && j<this.Data.Data.length ; ++i, ++j)
                {
                    var data=this.Data.Data[j];
                    if (data.Close<orderItem.Price)
                    {
                        end=(j-1)-dataOffset;
                        break;
                    }
                    
                }
            }
            else if (orderItem.HBar.Type==2)
            {
                for(var i=0, j=index+1; i<orderItem.HBar.Width && j<this.Data.Data.length ; ++i, ++j)
                {
                    var data=this.Data.Data[j];
                    if (data.Close>orderItem.Price)
                    {
                        end=(j-1)-dataOffset;
                        break;
                    }
                        
                }
            }

            if (end<0) return;

            var xEnd=this.ChartFrame.GetXFromIndex(end)+dataWidth/2;
            var yTop=yPrice-cellHeight/2;
            var yHeight=cellHeight+0.5
            if (IFrameSplitOperator.IsNumber(orderItem.HBar.Height)) 
                yHeight=orderItem.HBar.Height*cellHeight+0.1;

            var fValue=orderItem.HBar.Width-parseInt(orderItem.HBar.Width);
            if (fValue>0.000001) xEnd+=(dataWidth+distanceWidth)*fValue;
    
            this.Canvas.fillStyle=orderItem.HBar.Color;
            this.Canvas.fillRect(ToFixedRect(xStart),ToFixedRect(yTop),ToFixedRect(xEnd-xStart),ToFixedRect(yHeight)); //高度适当加上,否则行间有空隙
        }
        
    }

    this.PtInChart=function(x,y)
    {
        if (this.DrawType==1 || this.DrawType==4)
        {
            return this.PtInLine(x,y, {KLineClose:true});
        }

        return this.PtInKBar(x,y);
    }

    this.DrawSelectedStatus=function()
    {
        this.DrawLinePoint({KLineClose:true});
    }

    //////////////////////////////////////////////////////////////
    //订单流样式2
    this.DrawOrderFlow_Style2=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;
        this.AryOrderFlowBorder=[];

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }
        
        var upColor=this.OrderFlow_Style2.UpColor;
        var downColor=this.OrderFlow_Style2.DownColor;
        var unchagneColor=this.OrderFlow_Style2.UnchagneColor; 
        var barWidth=ToFixedRect(this.OrderFlow_Style2.BarWidth);
        var textWidth=dataWidth-barWidth;
        if (textWidth/7<barWidth) barWidth=textWidth/7;
        if (barWidth<=1) barWidth=2;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.DrawOrderFlowHBar();   //横向柱子
        
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            this.DrawKRange.End=i;

            var barTop=Math.min(yOpen,yClose);
            var barBottom=Math.max(yOpen,yClose);
            var barLeft=ToFixedRect(left);
            var barRight=barLeft+barWidth
            if (data.Open<data.Close) this.Canvas.fillStyle=upColor;
            else if (data.Open>data.Close) this.Canvas.fillStyle=downColor;
            else this.Canvas.fillStyle=unchagneColor;

            var cellHeight=0;
            if (data.OrderFlow && IFrameSplitOperator.IsNumber(data.OrderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(data.OrderFlow.PriceOffset);
            
            this.Canvas.fillRect(barLeft,ToFixedRect(barTop-cellHeight/2),barWidth,ToFixedRect(barBottom-barTop+cellHeight));
            var yKline={ Low:yLow, High:yHigh, Open:yOpen, Close:yClose };
            var xKLine={ Left:barRight, Center:x, Right:right, DataWidth:(right-barRight) };
            xKLine.Center=xKLine.Left+xKLine.DataWidth/2;
            this.DrawOrderFlowBar_Style2(data.OrderFlow, data, xKLine, yKline, isHScreen);
        }

        //最后绘制边框
        if (dataWidth-barWidth>5)
        {
            for(var i=0;i<this.AryOrderFlowBorder.length;++i)
            {
                var item=this.AryOrderFlowBorder[i];
                if (!item || !item.Rect || !item.Color) continue;
                var rect=item.Rect;
    
                this.Canvas.strokeStyle=item.Color;
                this.Canvas.beginPath();
                this.Canvas.rect(ToFixedPoint(rect.Left),ToFixedPoint(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                this.Canvas.stroke();
            }
        }

        this.AryOrderFlowBorder=[];
    }

    /////////////////////////////////////////////////////////////
    //订单流样式3
    this.DrawOrderFlow_Style3=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;
        this.AryOrderFlowBorder=[];

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }
        
        var upColor=this.OrderFlow_Style3.UpColor;
        var downColor=this.OrderFlow_Style3.DownColor;
        var unchagneColor=this.OrderFlow_Style3.UnchagneColor; 
        var barWidth=ToFixedRect(this.OrderFlow_Style3.BarWidth);
        if (dataWidth/4<barWidth) barWidth=dataWidth/4;
        if (barWidth<=1) barWidth=2;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.DrawOrderFlowHBar();   //横向柱子
        
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            this.DrawKRange.End=i;

            var barTop=Math.min(yOpen,yClose);
            var barBottom=Math.max(yOpen,yClose);
            var barLeft=ToFixedRect(left);
            var barRight=barLeft+barWidth
            if (data.Open<data.Close) this.Canvas.fillStyle=upColor;
            else if (data.Open>data.Close) this.Canvas.fillStyle=downColor;
            else this.Canvas.fillStyle=unchagneColor;

            var cellHeight=0;
            if (data.OrderFlow && IFrameSplitOperator.IsNumber(data.OrderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(data.OrderFlow.PriceOffset);
            
            this.Canvas.fillRect(barLeft,ToFixedRect(barTop-cellHeight/2),barWidth,ToFixedRect(barBottom-barTop+cellHeight));
            var yKline={ Low:yLow, High:yHigh, Open:yOpen, Close:yClose };
            var xKLine={ Left:barRight, Right:right, DataWidth:(right-barRight) };
            this.DrawOrderFlowBar_Style3(data.OrderFlow, data, xKLine, yKline, isHScreen);
        }

        //最后绘制边框
        if (dataWidth-barWidth>5)
        {
            for(var i=0;i<this.AryOrderFlowBorder.length;++i)
            {
                var item=this.AryOrderFlowBorder[i];
                if (!item || !item.Rect || !item.Color) continue;
                var rect=item.Rect;
    
                this.Canvas.strokeStyle=item.Color;
                this.Canvas.beginPath();
                this.Canvas.rect(ToFixedPoint(rect.Left),ToFixedPoint(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                this.Canvas.stroke();
            }
        }

        this.AryOrderFlowBorder=[];
    }

    this.DrawOrderFlowBar_Style2=function(orderFlow, kItem, xKLine, yKline, isHScreen)
    {
        var top=Math.min(yKline.Open, yKline.Close)
        var bottom=Math.max(yKline.Open, yKline.Close);
        var barHeight=Math.abs(yKline.Open-yKline.Close);
        var cellHeight=0;
        if (orderFlow && IFrameSplitOperator.IsNumber(orderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(orderFlow.PriceOffset);
        var textFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2);
        this.IsShowOrderText=(cellHeight>5 && xKLine.DataWidth>10);
        if (this.OrderFlow.AlwaysShowOrderText) this.IsShowOrderText=true;

        /* 背景暂时不用
        var kColor;
        if (kItem.Open<kItem.Close) kColor=this.OrderFlow.UpColor;
        else if (kItem.Open>kItem.Close) kColor=this.OrderFlow.DownColor;
        else kColor=this.OrderFlow.UnchagneColor;

        var isSmallKLine=(xKLine.DataWidth<4);

        if (isSmallKLine)
        {
            this.Canvas.strokeStyle=kColor.Border;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(xKLine.Center),top-cellHeight/2);
            this.Canvas.lineTo(ToFixedPoint(xKLine.Center),bottom+cellHeight/2);
            this.Canvas.stroke();
        }
        else
        {
            this.Canvas.fillStyle=kColor.BG;
            this.Canvas.fillRect(ToFixedRect(xKLine.Left),ToFixedRect(top-cellHeight/2),ToFixedRect(xKLine.DataWidth),ToFixedRect(barHeight+cellHeight));
        }
        */
        
        
        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        this.Canvas.font=textFont;
        var textWidth=xKLine.DataWidth/2;
        var textXOffset=2;
        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.Order))
        {
            for(var i=0;i<orderFlow.Order.length;++i)
            {
                var item=orderFlow.Order[i];
                var yPrice=this.GetYFromData(item.Price, false);
    
                var rect={ Left:xKLine.Left, Right:xKLine.Center, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (item.Ask.BG)
                {
                    this.Canvas.fillStyle=item.Ask.BG;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }

                if (item.Ask.BorderColor)
                {
                    var borderItem={Rect:rect, Color:item.Ask.BorderColor};
                    this.AryOrderFlowBorder.push(borderItem);
                }
    
                var text=null;
                if (IFrameSplitOperator.IsString(item.Ask.Text)) text=item.Ask.Text;
                else if (IFrameSplitOperator.IsNumber(item.Ask.Value)) text=item.Ask.Value.toString();
                if (text && this.IsShowOrderText)
                {
                    if (item.Ask.Color) this.Canvas.fillStyle=item.Ask.Color;
                    else this.Canvas.fillStyle=this.OrderFlow.Text.Color;

                    if (item.Ask.Font)
                    {
                        var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2, item.Ask.Font);
                        this.Canvas.font=itemFont;
                        this.Canvas.fillText(text,xKLine.Left+textXOffset,yPrice);
                        this.Canvas.font=textFont;
                    }
                    else
                    {
                        this.Canvas.fillText(text,xKLine.Left+textXOffset,yPrice);
                    }
                }

    
                var rect={ Left:xKLine.Center, Right:xKLine.Right, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (item.Bid.BG)
                {
                    this.Canvas.fillStyle=item.Bid.BG;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }

                if (item.Bid.BorderColor)
                {
                    var borderItem={Rect:rect, Color:item.Bid.BorderColor};
                    this.AryOrderFlowBorder.push(borderItem);
                }
    
                var text=null;
                if (IFrameSplitOperator.IsString(item.Bid.Text)) text=item.Bid.Text;
                else if (IFrameSplitOperator.IsNumber(item.Bid.Value)) text=item.Bid.Value.toString();
                if (text && this.IsShowOrderText)
                {
                    if (item.Bid.Color) this.Canvas.fillStyle=item.Bid.Color;
                    else this.Canvas.fillStyle=this.OrderFlow.Text.Color;
    
                    if (item.Bid.Font)
                    {
                        var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2, item.Bid.Font);
                        this.Canvas.font=itemFont;
                        this.Canvas.fillText(text,xKLine.Center+textXOffset,yPrice);
                        this.Canvas.font=textFont;
                    }
                    else
                    {
                        this.Canvas.fillText(text,xKLine.Center+textXOffset,yPrice);
                    }
                    
                }
            }
        }
    }

    this.DrawOrderFlowBar_Style3=function(orderFlow, kItem, xKLine, yKline, isHScreen)
    {
        var top=Math.min(yKline.Open, yKline.Close)
        var bottom=Math.max(yKline.Open, yKline.Close);
        var barHeight=Math.abs(yKline.Open-yKline.Close);
        var itemWidth=xKLine.DataWidth-4;
        var cellHeight=0;
        if (orderFlow && IFrameSplitOperator.IsNumber(orderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(orderFlow.PriceOffset);
        var textFont=this.GetDynamicOrderFlowFont(cellHeight, itemWidth);
        this.IsShowOrderText=(cellHeight>5 && xKLine.DataWidth>10);
        if (this.OrderFlow.AlwaysShowOrderText) this.IsShowOrderText=true;

        /* 背景暂时不用
        var kColor;
        if (kItem.Open<kItem.Close) kColor=this.OrderFlow.UpColor;
        else if (kItem.Open>kItem.Close) kColor=this.OrderFlow.DownColor;
        else kColor=this.OrderFlow.UnchagneColor;

        var isSmallKLine=(xKLine.DataWidth<4);

        if (isSmallKLine)
        {
            this.Canvas.strokeStyle=kColor.Border;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(xKLine.Center),top-cellHeight/2);
            this.Canvas.lineTo(ToFixedPoint(xKLine.Center),bottom+cellHeight/2);
            this.Canvas.stroke();
        }
        else
        {
            this.Canvas.fillStyle=kColor.BG;
            this.Canvas.fillRect(ToFixedRect(xKLine.Left),ToFixedRect(top-cellHeight/2),ToFixedRect(xKLine.DataWidth),ToFixedRect(barHeight+cellHeight));
        }
        */
        
        
        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        this.Canvas.font=textFont;
        var textXOffset=2;
       
        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.Order))
        {
            for(var i=0;i<orderFlow.Order.length;++i)
            {
                var item=orderFlow.Order[i];
                var yPrice=this.GetYFromData(item.Price, false);
    
                var rect={ Left:xKLine.Left, Right:xKLine.Right, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (item.Item.BG)
                {
                    this.Canvas.fillStyle=item.Item.BG;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(rect.Width),ToFixedRect(rect.Height));
                }

                if (item.Item.BorderColor)
                {
                    var borderItem={Rect:rect, Color:item.Item.BorderColor};
                    this.AryOrderFlowBorder.push(borderItem);
                }
    
                var text=null;
                if (IFrameSplitOperator.IsString(item.Item.Text)) text=item.Item.Text;
                else if (IFrameSplitOperator.IsNumber(item.Item.Value)) text=item.Item.Value.toString();
                if (text && this.IsShowOrderText)
                {
                    if (item.Item.Color) this.Canvas.fillStyle=item.Item.Color;
                    else this.Canvas.fillStyle=this.OrderFlow.Text.Color;

                    if (item.Item.Font)
                    {
                        var itemFont=this.GetDynamicOrderFlowFont(cellHeight, itemWidth, item.Item.Font);
                        this.Canvas.font=itemFont;
                        this.Canvas.fillText(text,xKLine.Left+textXOffset,yPrice);
                        this.Canvas.font=textFont;
                    }
                    else
                    {
                        this.Canvas.fillText(text,xKLine.Left+textXOffset,yPrice);
                    }
                }
            }
        }
    }


    //////////////////////////////////////////////////////////////////////////////
    //订单流样式4
    this.DrawOrderFlow_Style4=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;
        this.AryOrderFlowBorder=[];

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }
        
        var upColor=this.OrderFlow_Style4.UpColor;
        var downColor=this.OrderFlow_Style4.DownColor;
        var unchagneColor=this.OrderFlow_Style4.UnchagneColor; 

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.DrawOrderFlowHBar();   //横向柱子

        var kBarWidth=this.OrderFlow_Style4.KBarWidth;
        if (dataWidth+distanceWidth<kBarWidth*3) kBarWidth=1;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            this.DrawKRange.End=i;

            var barLeft=left+this.OrderFlow_Style4.LeftMargin;
            var barRight=right+distanceWidth-this.OrderFlow_Style4.RightMargin;

            if (this.OrderFlow_Style4.KBarType==1)
            {
                var kbarTop=Math.min(yOpen,yClose);
                var kbarBottom=Math.max(yOpen,yClose);
                var kbarLeft=ToFixedRect(left)+this.OrderFlow_Style4.LeftMargin;
                var kbarRight=barLeft+kBarWidth;
                if (data.Open<data.Close) this.Canvas.fillStyle=upColor;
                else if (data.Open>data.Close) this.Canvas.fillStyle=downColor;
                else this.Canvas.fillStyle=unchagneColor;
    
                var cellHeight=0;
                if (data.OrderFlow && IFrameSplitOperator.IsNumber(data.OrderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(data.OrderFlow.PriceOffset);
                
                this.Canvas.fillRect(kbarLeft,ToFixedRect(kbarTop-cellHeight/2),kBarWidth,ToFixedRect(kbarBottom-kbarTop+cellHeight));

                barLeft=kbarRight+1;
            }

            var yKline={ Low:yLow, High:yHigh, Open:yOpen, Close:yClose };
            var xKLine={ Left:barLeft, Center:x, Right:barRight, DataWidth:(barRight-barLeft) };

            xKLine.Center=xKLine.Left+xKLine.DataWidth/2;
            this.DrawOrderFlowBar_Style4(data.OrderFlow, data, xKLine, yKline, isHScreen);
        } 
    }

    this.DrawOrderFlowBar_Style4=function(orderFlow, kItem, xKLine, yKline, isHScreen)
    {
        var top=Math.min(yKline.Open, yKline.Close)
        var bottom=Math.max(yKline.Open, yKline.Close);
        var barHeight=Math.abs(yKline.Open-yKline.Close);
        var cellHeight=0;
        if (orderFlow && IFrameSplitOperator.IsNumber(orderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(orderFlow.PriceOffset);
        var textFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2);
        this.IsShowOrderText=(cellHeight>5 && xKLine.DataWidth>10);
        if (this.OrderFlow.AlwaysShowOrderText) this.IsShowOrderText=true;

        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        this.Canvas.font=textFont;
        var volBarSpace=this.OrderFlow_Style4.VolBarSpace;
        if (cellHeight<=4) volBarSpace=0;   //太细了 间距就不要了
        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.Order))
        {
            if (!orderFlow.Summary) orderFlow.Summary={ };
            if (!orderFlow.Summary.VolMaxMin) //计算最大最小值
            {
                var volMaxMin={  Max:null, Min:null };
                for(var i=0;i<orderFlow.Order.length;++i)
                {
                    var item=orderFlow.Order.length[i];
                    if (volMaxMin.Max==null || volMaxMin.Max<item.Vol.Value) volMaxMin.Max=item.Vol.Value;
                    if (volMaxMin.Min==null || volMaxMin.Min>item.Vol.Value) volMaxMin.Min=item.Vol.Value;
                }

                orderFlow.Summary.VolMaxMin=volMaxMin;
            }

            var preItem=null;   //上一个矩形框
            var max=orderFlow.Summary.VolMaxMin.Max, min=orderFlow.Summary.VolMaxMin.Min;
            for(var i=0;i<orderFlow.Order.length;++i)
            {
                var item=orderFlow.Order[i];
                var yPrice=this.GetYFromData(item.Price, false);
                if (!item.Vol) continue;

                if (IFrameSplitOperator.IsNonEmptyArray(item.AryVol))
                {
                    var barWidth=xKLine.Right-xKLine.Left;

                    var xVolLeft=xKLine.Left;
                    var xVolRight=xVolLeft;
                    var totalVol=0;
                    var rtDraw={ Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                    for(var j=0;j<item.AryVol.length;++j)
                    {
                        var itemVol=item.AryVol[j];
                        if (!IFrameSplitOperator.IsNumber(itemVol.Value)) continue;
                        totalVol+=itemVol.Value;
                        xVolRight=barWidth*(totalVol-min)/(max-min)+xKLine.Left;
                        var rtBar={ Left:xVolLeft, Right:xVolRight, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                        if (preItem && item.Price>preItem.Price)
                        {
                            rtBar.Bottom=preItem.Rect.Top-volBarSpace;
                        }
                        rtBar.Width=rtBar.Right-rtBar.Left;
                        rtBar.Height=rtBar.Bottom-rtBar.Top;

                        rtDraw={ Left:ToFixedRect(rtBar.Left), Top:ToFixedRect(rtBar.Top), Width:ToFixedRect(rtBar.Width), Height:ToFixedRect(rtBar.Height) };
                        rtDraw.Bottom=rtDraw.Top+rtDraw.Height;
                        rtDraw.Right=rtDraw.Left+rtDraw.Width;
                        if (rtDraw.Width<1) rtDraw.Width=1;

                        if (itemVol.BG)    //背景色
                        {
                            this.Canvas.fillStyle=itemVol.BG;
                            this.Canvas.fillRect(rtDraw.Left, rtDraw.Top, rtDraw.Width, rtDraw.Height);
                        }

                        xVolLeft=rtDraw.Right;
                    }

                    rtDraw.Left=xKLine.Left;
                    rtDraw.Width=rtDraw.Right-rtDraw.Left;
                    if (item.Vol.Text &&  this.IsShowOrderText) //文字
                    {
                        this.Canvas.fillStyle=item.Vol.Color;
    
                        if (item.Vol.Font)
                        {
                            var itemFont=this.GetDynamicOrderFlowFont(cellHeight, barWidth/2, item.Vol.Font);
                            this.Canvas.font=itemFont;
                            this.Canvas.fillText(text,xKLine.Center+textXOffset,yPrice);
                            this.Canvas.font=textFont;
                        }
                        else
                        {
                            this.Canvas.fillText(item.Vol.Text,rtDraw.Left+2,yPrice);
                        }
                    }

                    preItem={ Price: item.Price, Rect:rtDraw };
                }
                else if (IFrameSplitOperator.IsNumber(item.Vol.Value)) 
                {
                    var barWidth=xKLine.Right-xKLine.Left;
                    var volWidth=barWidth*(item.Vol.Value-min)/(max-min);
                    var rect={ Left:xKLine.Left, Right:xKLine.Right, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                    rect.Right=rect.Left+volWidth;
    
                    if (preItem && item.Price>preItem.Price)
                    {
                        rect.Bottom=preItem.Rect.Top-volBarSpace;
                    }
    
                    rect.Width=rect.Right-rect.Left;
                    rect.Height=rect.Bottom-rect.Top;
                    
                    
                    var rtDraw={ Left:ToFixedRect(rect.Left), Top:ToFixedRect(rect.Top), Width:ToFixedRect(rect.Width), Height:ToFixedRect(rect.Height) };
                    rtDraw.Bottom=rtDraw.Top+rtDraw.Height;
                    rtDraw.Right=rtDraw.Left+rtDraw.Width;
                    if (rtDraw.Width<1) rtDraw.Width=1;
    
                    if (item.Vol.BG)    //背景色
                    {
                        this.Canvas.fillStyle=item.Vol.BG;
                        this.Canvas.fillRect(rtDraw.Left, rtDraw.Top, rtDraw.Width, rtDraw.Height);
                    }
    
                    if (item.Vol.BorderColor)   //边框
                    {
                        this.Canvas.strokeStyle = item.Vol.BorderColor;
                        this.Canvas.strokeRect(ToFixedPoint(rtDraw.Left), ToFixedPoint(rtDraw.Top), rtDraw.Width, rtDraw.Height);
                    }
    
                    if (item.Vol.Text &&  this.IsShowOrderText) //文字
                    {
                        this.Canvas.fillStyle=item.Vol.Color;
    
                        if (item.Vol.Font)
                        {
                            var itemFont=this.GetDynamicOrderFlowFont(cellHeight, barWidth/2, item.Vol.Font);
                            this.Canvas.font=itemFont;
                            this.Canvas.fillText(text,xKLine.Center+textXOffset,yPrice);
                            this.Canvas.font=textFont;
                        }
                        else
                        {
                            this.Canvas.fillText(item.Vol.Text,rtDraw.Left+2,yPrice);
                        }
                    }
    
                    preItem={ Price: item.Price, Rect:rtDraw };
                }
                else
                {
                    continue;
                }
    
                
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////
    //订单流样式5
    this.DrawOrderFlow_Style5=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;
        this.AryOrderFlowBorder=[];

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }
        
        var upColor=this.OrderFlow_Style2.UpColor;
        var downColor=this.OrderFlow_Style2.DownColor;
        var unchagneColor=this.OrderFlow_Style2.UnchagneColor; 
        var barWidth=ToFixedRect(this.OrderFlow_Style2.BarWidth);
        var textWidth=dataWidth-barWidth;
        if (textWidth/7<barWidth) barWidth=textWidth/7;
        if (barWidth<=1) barWidth=2;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.DrawOrderFlowHBar();   //横向柱子

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            this.DrawKRange.End=i;

            var barTop=Math.min(yOpen,yClose);
            var barBottom=Math.max(yOpen,yClose);
            var barLeft=ToFixedRect(left);
            var barRight=barLeft+barWidth
            if (data.Open<data.Close) this.Canvas.fillStyle=upColor;
            else if (data.Open>data.Close) this.Canvas.fillStyle=downColor;
            else this.Canvas.fillStyle=unchagneColor;

            var cellHeight=0;
            if (data.OrderFlow && IFrameSplitOperator.IsNumber(data.OrderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(data.OrderFlow.PriceOffset);
            
            this.Canvas.fillRect(barLeft,ToFixedRect(barTop-cellHeight/2),barWidth,ToFixedRect(barBottom-barTop+cellHeight));
            var yKline={ Low:yLow, High:yHigh, Open:yOpen, Close:yClose };
            var xKLine={ Left:barRight, Center:x, Right:right, DataWidth:(right-barRight) };
            xKLine.Center=xKLine.Left+xKLine.DataWidth/2;
            this.DrawOrderFlowBar_Style5(data.OrderFlow, data, xKLine, yKline, isHScreen);
        }
    }

    this.DrawOrderFlowBar_Style5=function(orderFlow, kItem, xKLine, yKline, isHScreen)
    {
        var top=Math.min(yKline.Open, yKline.Close)
        var bottom=Math.max(yKline.Open, yKline.Close);
        var barHeight=Math.abs(yKline.Open-yKline.Close);
        var cellHeight=0;
        if (orderFlow && IFrameSplitOperator.IsNumber(orderFlow.PriceOffset)) cellHeight=this.GetPriceYOffset(orderFlow.PriceOffset);
        var textFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2);
        this.IsShowOrderText=(cellHeight>5 && xKLine.DataWidth>10);
        if (this.OrderFlow.AlwaysShowOrderText) this.IsShowOrderText=true;

        this.Canvas.textBaseline='middle';
        
        this.Canvas.font=textFont;
        var textWidth=xKLine.DataWidth/2;
        if (orderFlow && IFrameSplitOperator.IsNonEmptyArray(orderFlow.Order))
        {
            var maxValue=orderFlow.MaxValue;
            for(var i=0;i<orderFlow.Order.length;++i)
            {
                var item=orderFlow.Order[i];
                var yPrice=this.GetYFromData(item.Price, false);
    
                var rect={ Left:xKLine.Left, Right:xKLine.Center, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (IFrameSplitOperator.IsNumber(item.Ask.Value))
                {
                    var color=this.OrderFlow_Style5.AskBarColor;
                    if (item.Ask.BG) color=item.Ask.BG;
                    this.Canvas.fillStyle=color;
                    var barWidth=rect.Width*item.Ask.Value/maxValue;
                    this.Canvas.fillRect(ToFixedRect(rect.Right),ToFixedRect(rect.Top),ToFixedRect(-barWidth),ToFixedRect(rect.Height));
                
                    var text=null;
                    if (IFrameSplitOperator.IsString(item.Ask.Text)) text=item.Ask.Text;
                    else text=item.Ask.Value.toString();
                    if (text && this.IsShowOrderText)
                    {
                        var textColor=this.OrderFlow.Text.Color;
                        if (item.Ask.Color) textColor=item.Ask.Color;

                        this.Canvas.fillStyle=textColor;
                        this.Canvas.textAlign='right';
                        var xText=rect.Right-this.OrderFlow_Style5.LeftMargin;
                        if (item.Ask.Font)
                        {
                            var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2, item.Ask.Font);
                            this.Canvas.font=itemFont;
                            this.Canvas.fillText(text,xText,yPrice);
                            this.Canvas.font=textFont;
                        }
                        else
                        {
                            this.Canvas.fillText(text,xText,yPrice);
                        }
                    }
                }

    
                var rect={ Left:xKLine.Center, Right:xKLine.Right, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
                rect.Width=rect.Right-rect.Left;
                rect.Height=rect.Bottom-rect.Top;
    
                if (IFrameSplitOperator.IsNumber(item.Bid.Value))
                {
                    var color=this.OrderFlow_Style5.BidBarColor;
                    if (item.Bid.BG) color=item.Bid.BG;
                    this.Canvas.fillStyle=color;
                    var barWidth=rect.Width*item.Bid.Value/maxValue;
                    this.Canvas.fillRect(ToFixedRect(rect.Left),ToFixedRect(rect.Top),ToFixedRect(barWidth),ToFixedRect(rect.Height));

                    var text=null;
                    if (IFrameSplitOperator.IsString(item.Bid.Text)) text=item.Bid.Text;
                    else text=item.Bid.Value.toString();
                    if (text && this.IsShowOrderText)
                    {
                        var textColor=this.OrderFlow.Text.Color;
                        if (item.Bid.Color)textColor=item.Bid.Color;

                        this.Canvas.fillStyle=textColor;
                        this.Canvas.textAlign='left';
                        var xText=rect.Left+this.OrderFlow_Style5.RightMargin
                        if (item.Bid.Font)
                        {
                            var itemFont=this.GetDynamicOrderFlowFont(cellHeight, xKLine.DataWidth/2, item.Bid.Font);
                            this.Canvas.font=itemFont;
                            this.Canvas.fillText(text,xText,yPrice);
                            this.Canvas.font=textFont;
                        }
                        else
                        {
                            this.Canvas.fillText(text,xText,yPrice);
                        }
                        
                    }
                }
            }
        }
    }

    //////////////////////////////////////////////////////////////
    // high low bar
    //
    ///////////////////////////////////////////////////////////////
    this.DrawHighLow=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.Canvas.fillStyle=this.HighLowBarColor;
        this.Canvas.strokeStyle=this.HighLowBarColor;
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        var font=this.GetHighLowTextFont(dataWidth,distanceWidth);
        var bShowText=false;
        if (font)
        {
            bShowText=true;
            this.Canvas.font=font;
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            this.ShowRange.End=i;
            if (data.Open==null || data.High==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low,false);
            var yHigh=this.GetYFromData(data.High,false);
            this.DrawKRange.End=i;

            var yBarTop=yLow;
            var barHeight=yHigh-yLow;
            if (Math.abs(barHeight)<1) barHeight=1; //高度小于1,统一使用高度1
            if (dataWidth>=4)
            {
                if (isHScreen)
                {
                    this.Canvas.fillRect(ToFixedRect(yBarTop),ToFixedRect(left),ToFixedRect(barHeight),ToFixedRect(dataWidth));   
                }
                else
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(yBarTop),ToFixedRect(dataWidth),ToFixedRect(barHeight));   
                    if (bShowText) this.DrawHighLowText(yHigh, yLow, x, data, defaultfloatPrecision);
                    //TODO:文字输出 
                }
            }
            else    //竖线
            {
                var x=left+(right-left)/2;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yLow),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yHigh),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(yLow));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yHigh));
                }
                
                this.Canvas.stroke();
            }

            if (this.IsShowKTooltip && !isHScreen)    //添加tooltip区域
            {
                var yTop=Math.min(yLow,yHigh);
                var yBottom=Math.max(yLow,yHigh);
                if (Math.abs(yTop-yBottom)<5)   //高度太小了, 上下各+5px
                {
                    yTop=Math.min(yHigh,yTop-5);
                    yBottom=Math.max(yLow,yBottom+5);
                }
                var rect=new Rect(left,yTop,dataWidth,yBottom-yTop);
                //this.Canvas.fillStyle="rgb(0,0,100)";
                //this.Canvas.fillRect(rect.X,rect.Y,rect.Width,rect.Height);
                this.TooltipRect.push([i,rect]);    //[0]数据索引 [1]数据区域
            }

        }
    }

    this.DrawHighLowText=function(yHigh, yLow, x, kItem, floatPrecision)
    {
        this.Canvas.textAlign="center";

        var text=kItem.High.toFixed(floatPrecision);
        this.Canvas.textBaseline="bottom";
        this.Canvas.fillText(text,x,yHigh-2);

        var text=kItem.Low.toFixed(floatPrecision);
        this.Canvas.textBaseline="top";
        this.Canvas.fillText(text,x,yLow+3);
    }

    this.GetHighLowTextFont=function(dataWidth, distanceWidth)
    {
        var barWidth=dataWidth+distanceWidth;
        var text=this.HighLowTextConfig.MaxText;
        var min=Math.min(this.HighLowTextConfig.MaxSize,this.HighLowTextConfig.MinSize);
        var max=Math.max(this.HighLowTextConfig.MaxSize,this.HighLowTextConfig.MinSize);

        for(var i=max; i>=min; --i)
        {
            var font=`${i*GetDevicePixelRatio()}px ${this.HighLowTextConfig.FontName}`;
            this.Canvas.font=font;
            var textWidth=this.Canvas.measureText(text).width;
            if (textWidth<=barWidth)
                return font;
        }

        return null;
    }

    //////////////////////////////////////////////////////////////
    //标识缺口
    //
    /////////////////////////////////////////////////////////////
    this.DrawPriceGap=function()
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryPriceGapCache)) return;
        if (this.PriceGap.Count<=0) return;

        var index=this.AryPriceGapCache.length-this.PriceGap.Count;
        if (index<0) index=0;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var border=null;
        
        if (isHScreen) border=this.ChartBorder.GetHScreenBorder();
        else border=this.ChartBorder.GetBorder();

        this.Canvas.font=this.PriceGapStyple.Text.Font;
        this.Canvas.textAlign = 'left';
        this.Canvas.textBaseline = 'bottom';
        var textHeight=this.Canvas.measureText("擎").width;
        var decNum=GetfloatPrecision(this.Symbol);

        for(var i=index;i<this.AryPriceGapCache.length;++i)
        {
            var item=this.AryPriceGapCache[i];
            var start=item.Data[0];
            var end=item.Data[1];
            var rect=null, rtText=null, text=null;
            if (item.Type==1)   //上缺口
            {
                if (isHScreen)
                {
                    rect={ Left:start.Coordinate.High, Right:end.Coordinate.Low, Top:start.Coordinate.X, Bottom: border.Bottom };
                    rect.Width=rect.Right-rect.Left;
                    rect.Height=rect.Bottom-rect.Top;

                    rtText={ Left:start.Coordinate.High-textHeight-2, Top:start.Coordinate.Right+2, Height:textHeight };
                    rtText.Bottom=rtText.Top+rtText.Height;
                }
                else
                {
                    rect={ Left:start.Coordinate.X, Right:border.Right, Top:end.Coordinate.Low, Bottom:start.Coordinate.High };
                    rect.Width=rect.Right-rect.Left;
                    rect.Height=rect.Bottom-rect.Top;
    
                    rtText={ Left:start.Coordinate.Right+2, Top:rect.Bottom+2, Right:rect.Right, Height:textHeight };
                    rtText.Bottom=rtText.Top+rtText.Height;
                }

                text=`${start.Data.High.toFixed(decNum)}-${end.Data.Low.toFixed(decNum)}`;
                
            }
            else if (item.Type==2)  //下缺口 
            {
                if (isHScreen)
                {
                    rect={ Left:start.Coordinate.Low, Right:end.Coordinate.High, Top:start.Coordinate.X, Bottom: border.Bottom };
                    rect.Width=rect.Right-rect.Left;
                    rect.Height=rect.Bottom-rect.Top;

                    rtText={ Left:start.Coordinate.Low+2, Top:start.Coordinate.Right+2, Height:textHeight };
                    rtText.Bottom=rtText.Top+rtText.Height;
                }
                else
                {
                    rect={ Left:start.Coordinate.X, Right:border.Right, Top:start.Coordinate.Low, Bottom:end.Coordinate.High };
                    rect.Width=rect.Right-rect.Left;
                    rect.Height=rect.Bottom-rect.Top;
    
                    rtText={ Left:start.Coordinate.Right+2, Bottom:rect.Top, Right:rect.Right, Height:textHeight };
                    rtText.Top=rtText.Bottom-rtText.Height;
                }

                text=`${start.Data.Low.toFixed(decNum)}-${end.Data.High.toFixed(decNum)}`;
            }
            else
            {
                continue;
            }

            if (!rect) return;

            this.Canvas.fillStyle=this.PriceGapStyple.Line.Color;
            this.Canvas.fillRect(rect.Left, rect.Top,rect.Width, rect.Height);
           
            if (rtText)
            {
                var textWidth=this.Canvas.measureText(text).width;
                rtText.Width=textWidth;
                rtText.Right=rtText.Left+rtText.Width;

                this.Canvas.fillStyle=this.PriceGapStyple.Text.Color;

                if (isHScreen)
                {
                    this.Canvas.save(); 
                    this.Canvas.translate(rtText.Left, rtText.Top);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(text,0,0);
                    this.Canvas.restore();
                }
                else
                {
                    if (rtText.Right>rect.Right)
                    {
                        rtText.Right=rect.Right;
                        rtText.Left=rtText.Right-rtText.Width;
                    }

                    this.Canvas.fillStyle=this.PriceGapStyple.Text.Color;
                    this.Canvas.fillText(text,rtText.Left,rtText.Bottom);
                }
    
                //this.Canvas.fillStyle="rgb(250,250,250)"
                //this.Canvas.fillRect(rtText.Left, rtText.Top, rtText.Width, rtText.Height);
    
                
            }
        }
        
    }

    //是否有缺口
    this.IsPriceGap=function(item, preItem)
    {
        if (!preItem || !item) return 0;

        if (preItem.Data.Low>item.Data.High) return 2;    //下缺口 

        if (preItem.Data.High<item.Data.Low) return 1;  //上缺口

        return -1;
    }

     //检测缺口是不回补了
    this.CheckPriceGap=function(kItemInfo)
    {
        var kItem=kItemInfo.Data;
        for(var i=0;i<this.AryPriceGapCache.length;++i)
        {
            var item=this.AryPriceGapCache[i];
            var start=item.Data[0];
            var end=item.Data[1];
            if (item.Type==1) //上缺口
            {
                if (kItem.Low<=start.Data.High)
                {
                    this.AryPriceGapCache.splice(i,1);
                    --i;
                    continue;
                }

                if (kItem.Low<end.Data.Low) item.Data[1]=kItemInfo;
            }
            else if (item.Type==2)  //下缺口 
            {
                if (kItem.High>=start.Data.Low)
                {
                    this.AryPriceGapCache.splice(i,1);
                    --i;
                    continue;
                }

                if (kItem.High>end.Data.High) item.Data[1]=kItemInfo;
            }
        }
    }
    
}

function ChartColorKline()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartColorKline';    //类名
    this.Symbol;        //股票代码
    this.Color='rgb(0,255,44)';
    this.IsEmptyBar=false;
    this.DrawType=0;    //0=实心K线柱子  3=空心K线柱子 
    this.KLineColor;    //Map key=K线索引 value=设置
    this.DrawName;

    this.Draw=function()
    {
        if (!this.IsShow) return;

        if (this.DrawName=="DRAWCOLORKLINE")
        {
            this.DrawColorBar();
        }
        else
        {
            if (!this.KLineColor) return;
            this.DrawBar();
        }
    }

    this.DrawUpBarItem=function(data, xOffset, dataWidth, option)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var left=xOffset;
        var right=xOffset+dataWidth;
        var x=left+(right-left)/2;

        var yLow=this.ChartFrame.GetYFromData(data.Low);
        var yHigh=this.ChartFrame.GetYFromData(data.High);
        var yOpen=this.ChartFrame.GetYFromData(data.Open);
        var yClose=this.ChartFrame.GetYFromData(data.Close);
        var y=yHigh;

        if (dataWidth>=4)
        {
            if (data.High>data.Close)   //上影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(this.DrawType==3?Math.max(yClose,yOpen):yClose),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(this.DrawType==3?Math.min(yClose,yOpen):yClose));
                }
                this.Canvas.stroke();
                y=yClose;
            }
            else
            {
                y=yClose;
            }

            if (isHScreen)
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (this.DrawType==3) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(y),ToFixedPoint(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                    }
                }
            }
            else
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (this.DrawType==3) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(y),ToFixedRect(dataWidth),ToFixedRect(yOpen-y));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,yOpen)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yOpen-y)));
                    }
                }
            }

            if (data.Open>data.Low) //下影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(this.DrawType==3?Math.min(yClose,yOpen):y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(this.DrawType==3?Math.max(yClose,yOpen):y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.stroke();
        }
    }

    this.DrawDownBarItem=function(data, xOffset, dataWidth, option)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var left=xOffset;
        var right=xOffset+dataWidth;
        var x=left+(right-left)/2;

        var yLow=this.ChartFrame.GetYFromData(data.Low);
        var yHigh=this.ChartFrame.GetYFromData(data.High);
        var yOpen=this.ChartFrame.GetYFromData(data.Open);
        var yClose=this.ChartFrame.GetYFromData(data.Close);
        var y=yHigh;

        if (dataWidth>=4)
        {
            if (data.High>data.Close)   //上影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yOpen),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yOpen));
                }
                this.Canvas.stroke();
                y=yOpen;
            }
            else
            {
                y=yOpen
            }

            if (isHScreen)
            {
                if (Math.abs(yClose-y)<1) this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                else this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yClose-y),ToFixedRect(dataWidth));
            }
            else
            {
                if (Math.abs(yClose-y)<1) this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                else this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,yClose)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yClose-y)));
            }

            if (data.Open>data.Low) //下影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.stroke();
        }
    }

    this.DrawUnChangeBarItem=function(data, xOffset, dataWidth, option)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var left=xOffset;
        var right=xOffset+dataWidth;
        var x=left+(right-left)/2;

        var yLow=this.ChartFrame.GetYFromData(data.Low);
        var yHigh=this.ChartFrame.GetYFromData(data.High);
        var yOpen=this.ChartFrame.GetYFromData(data.Open);
        var yClose=this.ChartFrame.GetYFromData(data.Close);
        var y=yHigh;

        if (dataWidth>=4)
        {
            this.Canvas.beginPath();
            if (data.High>data.Close)   //上影线
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(y,ToFixedPoint(x));
                    this.Canvas.lineTo(yOpen,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),y);
                    this.Canvas.lineTo(ToFixedPoint(x),yOpen);
                }
                y=yOpen;
            }
            else
            {
                y=yOpen;
            }

            if (isHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(left));
                this.Canvas.lineTo(ToFixedPoint(y),ToFixedPoint(right));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(left),ToFixedPoint(y));
                this.Canvas.lineTo(ToFixedPoint(right),ToFixedPoint(y));
            }

            if (data.Open>data.Low) //下影线
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                }
            }

            this.Canvas.stroke();
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.stroke();
        }
    }

    this.DrawBar=function()
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;

        if (this.IsHScreen) 
        {
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
            chartright=this.ChartBorder.GetBottom();
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;
            if (!this.KLineColor.has(i)) continue;
            var itemOption=this.KLineColor.get(i);

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;

            if (itemOption.Color)
            {
                this.Canvas.strokeStyle=itemOption.Color;
                this.Canvas.fillStyle=itemOption.Color;
            }
            else
            {
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.fillStyle=this.Color;
            }

            if (data.Open<data.Close)   //阳线
            {
                this.DrawUpBarItem(data,xOffset,dataWidth,itemOption);
            }
            else if (data.Open>data.Close)  //阴线
            {
                this.DrawDownBarItem(data,xOffset,dataWidth,itemOption);
            }
            else    //平线
            {
                this.DrawUnChangeBarItem(data,xOffset,dataWidth,itemOption);
            }
        }
    }

    this.DrawColorBar=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            if (!data) continue;
            if (!IFrameSplitOperator.IsNumber(data.Open) || !IFrameSplitOperator.IsNumber(data.High) || 
                !IFrameSplitOperator.IsNumber(data.Low) || !IFrameSplitOperator.IsNumber(data.Close)) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low, false);
            var yHigh=this.GetYFromData(data.High, false);
            var yOpen=this.GetYFromData(data.Open, false);
            var yClose=this.GetYFromData(data.Close, false);
            var y=yHigh;

            if (data.Open==data.Close) 
                this.DrawKBar_Unchagne(data, dataWidth, this.Color, this.IsEmptyBar, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
            else 
                this.DrawKBar_Custom(data, dataWidth, this.Color, this.IsEmptyBar, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen);
        }
    }

    this.DrawKBar_Unchagne=function(data, dataWidth, unchagneColor, drawType, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (dataWidth>=4)
        {
            if ((dataWidth%2)!=0) dataWidth-=1;
            this.Canvas.strokeStyle=unchagneColor;
            this.Canvas.beginPath();
            if (data.High>data.Close)   //上影线
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(y,ToFixedPoint(x));
                    this.Canvas.lineTo(yOpen,ToFixedPoint(x));
                }
                else
                {
                    var xFixed=ToFixedPoint(left+dataWidth/2);
                    this.Canvas.moveTo(xFixed,y);
                    this.Canvas.lineTo(xFixed,yOpen);
                }
                y=yOpen;
            }
            else
            {
                y=yOpen;
            }

            if (isHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(left));
                this.Canvas.lineTo(ToFixedPoint(y),ToFixedPoint(right));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(left),ToFixedPoint(y));
                this.Canvas.lineTo(ToFixedPoint(left+dataWidth),ToFixedPoint(y));
            }

            if (data.Open>data.Low) //下影线
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    var xFixed=ToFixedPoint(left+dataWidth/2);
                    this.Canvas.moveTo(xFixed,ToFixedPoint(y));
                    this.Canvas.lineTo(xFixed,ToFixedPoint(yLow));
                }
            }

            this.Canvas.stroke();
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.strokeStyle=unchagneColor;
            this.Canvas.stroke();
        }
    }

    this.DrawKBar_Custom=function(data, dataWidth, barColor, isEmptyBar, x, y, left, right, yLow, yHigh, yOpen, yClose, isHScreen)
    {
        if (isEmptyBar)
        {
            if ((dataWidth%2)!=0) dataWidth-=1;
        }

        if (dataWidth>=4)
        {
            this.Canvas.strokeStyle=barColor;
            if (data.High>data.Close)   //上影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(isEmptyBar?Math.max(yClose,yOpen):yClose),ToFixedPoint(x));
                }
                else
                {
                    if (isEmptyBar)
                    {
                        var xFixed=left+dataWidth/2;
                        this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(Math.min(yClose,yOpen)));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yClose));
                    }
                    
                }
                this.Canvas.stroke();
                y=yClose;
            }
            else
            {
                y=yClose;
            }

            
            this.Canvas.fillStyle=barColor;
            if (isHScreen)
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (isEmptyBar) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(y),ToFixedPoint(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                    }
                }
            }
            else
            {
                if (Math.abs(yOpen-y)<1)  
                {
                    this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                }
                else 
                {
                    if (isEmptyBar) //空心柱
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(y),ToFixedRect(dataWidth),ToFixedRect(yOpen-y));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,yOpen)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(yOpen-y)));
                    }
                }
            }
            
            if (data.Open>data.Low) //下影线
            {
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(isEmptyBar?Math.min(yClose,yOpen):y),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                }
                else
                {
                    if (isEmptyBar)
                    {
                        var xFixed=left+dataWidth/2;
                        this.Canvas.moveTo(ToFixedPoint(xFixed),ToFixedPoint(Math.max(yClose,yOpen)));
                        this.Canvas.lineTo(ToFixedPoint(xFixed),ToFixedPoint(yLow));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                    }
                    
                }
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            this.Canvas.strokeStyle=barColor;
            this.Canvas.stroke();
        }
    }

    this.GetMaxMin=function()
    {
        var range={Max:null,Min:null };

        if (this.DrawName=="DRAWCOLORKLINE")
        {
            var xPointCount=this.ChartFrame.XPointCount;
        
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
            {
                var data=this.Data.Data[i];
                if (!data) continue;
                if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;
               
                if (range.Max==null) range.Max=data.High;
                if (range.Min==null) range.Min=data.Low;

                if (range.Max<data.High) range.Max=data.High;
                if (range.Min>data.Low) range.Min=data.Low;
            }
        }

        return range;
    }
}

function ChartHeatMap()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartHeatMap';    //类名

    this.Draw=function()
    {
        if (!this.IsShow) return;
        if (this.ChartFrame.IsMinSize) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.Data.Data[i];
            if (!data.HeatMap) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var xCenter=left+(right-left)/2;

            this.DrawHeatMap(left, right+distanceWidth, data.HeatMap);
        }
    }

    this.DrawHeatMap=function(left, right, heatMap)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(heatMap.Order)) return;

        var max=this.ChartFrame.HorizontalMax;
        var min=this.ChartFrame.HorizontalMin;
        var cellHeight=0;
        if (IFrameSplitOperator.IsNumber(heatMap.PriceOffset)) cellHeight=this.GetPriceYOffset(heatMap.PriceOffset);

        for(var i=0;i<heatMap.Order.length;++i)
        {
            var item=heatMap.Order[i];
            if (!IFrameSplitOperator.IsNumber(item.Price)) continue;
            if (!item.Color) continue;
            if (item.Price>max || item.Price<min) continue;

            var yPrice=this.GetYFromData(item.Price, false);

            var rect={ Left:left, Right:right, Bottom:yPrice+cellHeight/2, Top:yPrice-cellHeight/2 };
            rect.Width=rect.Right-rect.Left;
            rect.Height=rect.Bottom-rect.Top;

            this.Canvas.fillStyle=item.Color;
            this.Canvas.fillRect(rect.Left,rect.Top,rect.Width,rect.Height);
        }
    }

    this.GetPriceYOffset=function(value)
    {
        var frame=this.ChartFrame;
        var y=frame.ChartBorder.GetHeightEx()*(value)/(frame.HorizontalMax-frame.HorizontalMin);
        return y;
    }
}

//K线叠加 支持横屏
var OVERLAY_STATUS_ID=
{
    STATUS_NONE_ID:0,           //空闲状态
    STATUS_REQUESTDATA_ID:1,    //请求数据
    STATUS_RECVDATA_ID:2,       //接收到数据
    STATUS_FINISHED_ID:3,       //数据下载完成
};

function ChartOverlayKLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartOverlayKLine';    //类名
    this.Color="rgb(65,105,225)";
    this.MainData;                  //主图K线数据
    this.SourceData;                //叠加的原始数据
    this.Title;
    this.DrawType=0;
    this.CustomDrawType=null;       //图形类型
    this.Status=OVERLAY_STATUS_ID.STATUS_NONE_ID;
    this.IsDelete=false;            //是否已经删除
    this.CloseLineWidth=g_JSChartResource.CloseLineWidth;
    this.ShowRange={ };     //K线显示范围 { Start:, End:,  DataCount:, ShowCount: }
    this.DrawKRange={ Start:null, End:null };       //当前屏K线的索引{ Start: , End:}
    this.YInfoType=4;

    this.SetOption=function(option)
    {
        if (!option) return;
        if (IFrameSplitOperator.IsNumber(option.DrawType)) this.CustomDrawType=option.DrawType;
        if (IFrameSplitOperator.IsNumber(option.YInfoType)) this.YInfoType=option.YInfoType;
    }

    this.DrawKBar=function(firstOpen)   //firstOpen 当前屏第1个显示数据
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        if (isHScreen) xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        var drawType=this.DrawType;
        if (this.CustomDrawType!=null) drawType=this.CustomDrawType;

        var isFristDraw=true;
        var firstOverlayOpen=null;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.ShowRange.FirstOpen=firstOpen;
        this.DrawKRange.Start=this.Data.DataOffset;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            if (!data || data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            if (firstOverlayOpen==null) 
            {
                firstOverlayOpen=data.Open;
                this.ShowRange.FirstOverlayOpen=data.Open;
            }

            if (isFristDraw)
            {
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.fillStyle=this.Color;
                this.Canvas.beginPath();
                isFristDraw=false;
            }

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low/firstOverlayOpen*firstOpen,false);
            var yHigh=this.GetYFromData(data.High/firstOverlayOpen*firstOpen,false);
            var yOpen=this.GetYFromData(data.Open/firstOverlayOpen*firstOpen,false);
            var yClose=this.GetYFromData(data.Close/firstOverlayOpen*firstOpen,false);
            var y=yHigh;
            this.DrawKRange.End=i;

            if (data.Open<data.Close)       //阳线
            {
                if (dataWidth>=4)
                {
                    if (data.High>data.Close)   //上影线
                    {
                        if (isHScreen)
                        {
                            this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                            this.Canvas.lineTo(ToFixedPoint(this.DrawType==3?Math.max(yClose,yOpen):yClose),ToFixedPoint(x));
                        }
                        else
                        {
                            this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                            this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(this.DrawType==3?Math.min(yClose,yOpen):yClose));
                        }
                        y=yClose;
                    }
                    else
                    {
                        y=yClose;
                    }

                    if (isHScreen)
                    {
                        if (Math.abs(yOpen-y)<1)  
                        {
                            this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                        }
                        else 
                        {
                            if (drawType==3) this.Canvas.rect(ToFixedPoint(y),ToFixedPoint(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));   //空心柱
                            else this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yOpen-y),ToFixedRect(dataWidth));
                        }
                    }
                    else
                    {
                        if (Math.abs(yOpen-y)<1)  
                        {
                            this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                        }
                        else 
                        {
                            if (drawType==3) this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(y),ToFixedRect(dataWidth),ToFixedRect(yOpen-y));   //空心柱
                            else this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),ToFixedRect(yOpen-y));
                        }
                    }

                    if (data.Open>data.Low)
                    {
                        if (isHScreen)
                        {
                            this.Canvas.moveTo(ToFixedPoint(this.DrawType==3?Math.min(yClose,yOpen):y),ToFixedPoint(x));
                            this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                        }
                        else
                        {
                            this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(this.DrawType==3?Math.max(yClose,yOpen):y));
                            this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                        }
                    }
                }
                else
                {
                    if (isHScreen)
                    {
                        this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                        this.Canvas.lineTo(yLow,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                        this.Canvas.lineTo(ToFixedPoint(x),yLow);
                    }
                }
            }
            else if (data.Open>data.Close)  //阴线
            {
                if (dataWidth>=4)
                {
                    if (data.High>data.Close)   //上影线
                    {
                        if (isHScreen)
                        {
                            this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                            this.Canvas.lineTo(ToFixedPoint(yOpen),ToFixedPoint(x));
                        }
                        else
                        {
                            this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                            this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yOpen));
                        }
                        y=yOpen;
                    }
                    else
                    {
                        y=yOpen
                    }

                    if (isHScreen)
                    {
                        if (Math.abs(yClose-y)<1) this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),1,ToFixedRect(dataWidth));    //高度小于1,统一使用高度1
                        else this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(left),ToFixedRect(yClose-y),ToFixedRect(dataWidth));
                    }
                    else
                    {
                        if (Math.abs(yClose-y)<1) this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),1);    //高度小于1,统一使用高度1
                        else this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(y),ToFixedRect(dataWidth),ToFixedRect(yClose-y));
                    }

                    if (data.Open>data.Low) //下影线
                    {
                        if (isHScreen)
                        {
                            this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                            this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                        }
                        else
                        {
                            this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                            this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                        }
                    }
                }
                else
                {
                    if (isHScreen)
                    {
                        this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                        this.Canvas.lineTo(yLow,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                        this.Canvas.lineTo(ToFixedPoint(x),yLow);
                    } 
                }
            }
            else // 平线
            {
                if (dataWidth>=4)
                {
                    if (data.High>data.Close)   //上影线
                    {
                        if (isHScreen)
                        {
                            this.Canvas.moveTo(y,ToFixedPoint(x));
                            this.Canvas.lineTo(yOpen,ToFixedPoint(x));
                        }
                        else
                        {
                            this.Canvas.moveTo(ToFixedPoint(x),y);
                            this.Canvas.lineTo(ToFixedPoint(x),yOpen);
                        }

                        y=yOpen;
                    }
                    else
                    {
                        y=yOpen;
                    }

                    if (isHScreen)
                    {
                        this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(left));
                        this.Canvas.lineTo(ToFixedPoint(y),ToFixedPoint(right));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(left),ToFixedPoint(y));
                        this.Canvas.lineTo(ToFixedPoint(right),ToFixedPoint(y));
                    }

                    if (data.Open>data.Low) //下影线
                    {
                        if (isHScreen)
                        {
                            this.Canvas.moveTo(ToFixedPoint(y),ToFixedPoint(x));
                            this.Canvas.lineTo(ToFixedPoint(yLow),ToFixedPoint(x));
                        }
                        else
                        {
                            this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(y));
                            this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(yLow));
                        }
                    }
                }
                else
                {
                    if (isHScreen)
                    {
                        this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                        this.Canvas.lineTo(yLow,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                        this.Canvas.lineTo(ToFixedPoint(x),yLow);
                    }
                }
            }

            //添加tooltip区域
            {
                var yTop=Math.min(yLow,yHigh,yOpen,yClose);
                var yBottom=Math.max(yLow,yHigh,yOpen,yClose);
                var rect=new Rect(left,yTop,dataWidth,yBottom-yTop);
                //this.Canvas.fillStyle="rgb(0,0,100)";
                //this.Canvas.fillRect(rect.X,rect.Y,rect.Width,rect.Height);
                this.TooltipRect.push([i,rect]);    //[0]数据索引 [1]数据区域
            }
        }

        if (isFristDraw==false) this.Canvas.stroke();
    }

    this.DrawAKLine=function(firstOpen) //美国线
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        if (isHScreen) xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        var firstOverlayOpen=null;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.ShowRange.FirstOpen=firstOpen;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.Canvas.strokeStyle=this.Color;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            if (firstOverlayOpen==null) 
            {
                firstOverlayOpen=data.Open;
                this.ShowRange.FirstOverlayOpen=data.Open;
            }
            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yLow=this.GetYFromData(data.Low/firstOverlayOpen*firstOpen,false);
            var yHigh=this.GetYFromData(data.High/firstOverlayOpen*firstOpen,false);
            var yOpen=this.GetYFromData(data.Open/firstOverlayOpen*firstOpen,false);
            var yClose=this.GetYFromData(data.Close/firstOverlayOpen*firstOpen,false);
            this.DrawKRange.End=i;

            this.Canvas.beginPath();   //最高-最低
            if (isHScreen)
            {
                this.Canvas.moveTo(yHigh,ToFixedPoint(x));
                this.Canvas.lineTo(yLow,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),yHigh);
                this.Canvas.lineTo(ToFixedPoint(x),yLow);
            }
            
            this.Canvas.stroke();

            if (dataWidth>=4)
            {
                this.Canvas.beginPath();    //开盘
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yOpen),left);
                    this.Canvas.lineTo(ToFixedPoint(yOpen),x);
                }
                else
                {
                    this.Canvas.moveTo(left,ToFixedPoint(yOpen));
                    this.Canvas.lineTo(x,ToFixedPoint(yOpen));
                }
                this.Canvas.stroke();

                this.Canvas.beginPath();    //收盘
                if (isHScreen)
                {
                    this.Canvas.moveTo(ToFixedPoint(yClose),right);
                    this.Canvas.lineTo(ToFixedPoint(yClose),x);
                }
                else
                {
                    this.Canvas.moveTo(right,ToFixedPoint(yClose));
                    this.Canvas.lineTo(x,ToFixedPoint(yClose));
                }
                this.Canvas.stroke();
            }
        }

    }

    this.DrawCloseLine=function(firstOpen)  //收盘价线
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        if (isHScreen) xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        var firstOverlayOpen=null;
        var bFirstPoint=true;
        this.Canvas.strokeStyle=this.Color;
        if (IFrameSplitOperator.IsNumber(this.CloseLineWidth)) this.Canvas.lineWidth=this.CloseLineWidth;

        this.ShowRange.Start=this.Data.DataOffset;
        this.ShowRange.End=this.ShowRange.Start;
        this.ShowRange.DataCount=0;
        this.ShowRange.ShowCount=xPointCount;
        this.ShowRange.FirstOpen=firstOpen;
        this.DrawKRange.Start=this.Data.DataOffset;

        this.Canvas.beginPath();
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth),++this.ShowRange.DataCount)
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            if (firstOverlayOpen==null) 
            {
                firstOverlayOpen=data.Open;
                this.ShowRange.FirstOverlayOpen=data.Open;
            }
            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            var yClose=this.GetYFromData(data.Close/firstOverlayOpen*firstOpen,false);
            this.DrawKRange.End=i;

            if (bFirstPoint)
            {
                if (isHScreen) this.Canvas.moveTo(yClose,x);
                else this.Canvas.moveTo(x,yClose);
                bFirstPoint=false;
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(yClose,x);
                else this.Canvas.lineTo(x,yClose);
            }
        }

        if (bFirstPoint==false) this.Canvas.stroke();
    }

    this.GetFirstOpen=function()
    {
        if (!this.MainData || !this.Data) return null;

        var xPointCount=this.ChartFrame.XPointCount;
        for(var i=this.Data.DataOffset,j=0;i<this.MainData.Data.length && j<xPointCount;++i,++j)
        {
            var data=this.MainData.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;
            return data.Open;
        }

        return null;
    }

    this.Draw=function()
    {
        this.TooltipRect=[];
        this.InfoTooltipRect=[];
        this.DrawKRange={ Start:null, End:null }; 
        if (!this.MainData || !this.Data) return;

        var xPointCount=this.ChartFrame.XPointCount;
        var firstOpen=this.GetFirstOpen(); //主线数据第1个开盘价
        if (firstOpen==null) return;

        var drawType=this.DrawType;
        if (this.CustomDrawType!=null) drawType=this.CustomDrawType;

        this.Canvas.save();
        this.ClipClient(this.ChartFrame.IsHScreen);

        if (drawType==1) this.DrawCloseLine(firstOpen);
        else if (drawType==2) this.DrawAKLine(firstOpen);
        else this.DrawKBar(firstOpen);

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Max=null;
        range.Min=null;

        if (!this.MainData || !this.Data) return range;

        var firstOpen=null; //主线数据第1个收盘价
        for(var i=this.Data.DataOffset,j=0;i<this.MainData.Data.length && j<xPointCount;++i,++j)
        {
            var data=this.MainData.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;
            firstOpen=data.Close;
            break;
        }

        if (firstOpen==null) return range;

        var firstOverlayOpen=null;
        var high,low;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var data=this.Data.Data[i];
            if (!data || data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;
            if (firstOverlayOpen==null) firstOverlayOpen=data.Open;

            high=data.High/firstOverlayOpen*firstOpen;
            low=data.Low/firstOverlayOpen*firstOpen;
            if (range.Max==null) range.Max=high;
            if (range.Min==null) range.Min=low;

            if (range.Max<high) range.Max=high;
            if (range.Min>low) range.Min=low;
        }

        return range;
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        for(var i in this.TooltipRect)
        {
            var rect=this.TooltipRect[i][1];
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                var index=this.TooltipRect[i][0];
                tooltip.Data=this.Data.Data[index];
                tooltip.ChartPaint=this;
                return true;
            }
        }
        return false;
    }

    this.PtInChart=function(x,y)
    {
        var drawType=this.DrawType;
        if (IFrameSplitOperator.IsNumber(this.CustomDrawType)) drawType=this.CustomDrawType;

        if (drawType==1 || drawType==4) //线段，面积不支持选中
        {
            return null;
            //return this.PtInLine(x,y, {KLineClose:true});
        }

        return this.PtInKBar(x,y, {OverlayKLine:true});
    }

    this.DrawSelectedStatus=function()
    {
        this.DrawLinePoint({OverlayKLine:true});
    }
}

//K线表格
function ChartKLineTable()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartKlineTable';    //类名
    this.Data;
    this.RowName;
    this.IsShowRowName=false;
    this.BGColor;       //背景色

    this.RowCount=5;                    //行数
    this.RowHeight=10;                  //行高
    this.TextFontConfig=CloneData(g_JSChartResource.ChartKLineTable.TextFont);
    this.ItemMergin=CloneData(g_JSChartResource.ChartKLineTable.ItemMergin);

    this.TextFont;
    this.TextColor='rgb(0,0,0)';
    this.NameColor="rgb(0,0,0)";

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        if (isHScreen) return;
        if (this.RowCount<=0) return;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var border=this.ChartFrame.GetBorder();
        var height=border.Bottom-border.TopTitle;
        this.RowHeight=height/this.RowCount;
        var xOffset=border.LeftEx+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var top=border.TopTitle;
        var bottom=border.Bottom;

        if (this.BGColor)
        {
            this.Canvas.fillStyle=this.BGColor;
            var left=border.LeftEx;
            var width=border.RightEx-border.LeftEx;
            var height=bottom-top;
            this.Canvas.fillRect(left, top, width, height);
        }

        var itemHeight=this.RowHeight;
        var itemWidth=dataWidth+distanceWidth;
        if (itemHeight-this.ItemMergin.Top-this.ItemMergin.Bottom>0) itemHeight=itemHeight-this.ItemMergin.Left-this.ItemMergin.Right;
        if (itemWidth-this.ItemMergin.Left-this.ItemMergin.Right>0) itemWidth=itemWidth-this.ItemMergin.Left-this.ItemMergin.Right;

        var font=this.GetDynamicTextFont(itemHeight, itemWidth);
        this.TextFont=font;
        this.Canvas.font=this.TextFont;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (!item) continue;

            var left=xOffset;
            var right=xOffset+dataWidth+distanceWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;
            if (x>chartright) break;

            if (j==0 && this.IsShowRowName)
            {
                this.DrawRowName(top, bottom, left, right);
            }
            else
            {
                this.DrawRow(item, top, bottom, left, right);    //绘制一列
            }            
        }
    }

    this.DrawRowName=function(top, bottom, left, right)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.RowName)) return;

        var x=left,y=top, width=right-left;
        for(var i=0;i<this.RowName.length;++i)
        {
            var item=this.RowName[i];

            var rtBG={Left:x, Top:y, Right:right, Height:this.RowHeight, Width:width };
            rtBG.Bottom=rtBG.Top+this.RowHeight;

            if (item.Name && rtBG.Width>10)
            {
                this.Canvas.fillStyle=item.Color?item.Color:this.TextColor;
                this.Canvas.textBaseline='middle';

                if (item.TextAlign=='right')
                {
                    this.Canvas.textAlign='right';
                    this.Canvas.fillText(item.Name,rtBG.Right-2,rtBG.Top+this.RowHeight/2, width-4);
                }
                else if (item.TextAlign=='center')
                {
                    this.Canvas.textAlign='center';
                    this.Canvas.fillText(item.Name,rtBG.Left+rtBG.Width/2,rtBG.Top+this.RowHeight/2, width-4);
                }
                else
                {
                    this.Canvas.textAlign='left';
                    this.Canvas.fillText(item.Name,rtBG.Left+2,rtBG.Top+this.RowHeight/2, width-4);
                }
            }

            y+=this.RowHeight;
        }
    }

    this.DrawRow=function(data, top, bottom, left, right)
    {
        var x=left,y=top, width=right-left;
        for(var i=0;i<data.length;++i)
        {
            var item=data[i];
            var rtBG={Left:x, Top:y, Right:right, Height:this.RowHeight, Width:width };
            rtBG.Bottom=rtBG.Top+this.RowHeight;

            if (item.BGColor)
            {
                this.Canvas.fillStyle=item.BGColor;
                this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
            }

            if (item.Color && rtBG.Width>10)
            {
                this.Canvas.fillStyle=item.Color;
                this.Canvas.textBaseline='middle';

                if (item.TextAlign=='right')
                {
                    this.Canvas.textAlign='right';
                    this.Canvas.fillText(item.Text,rtBG.Right-2,rtBG.Top+this.RowHeight/2, width-4);
                }
                else if (item.TextAlign=='center')
                {
                    this.Canvas.textAlign='center';
                    this.Canvas.fillText(item.Text,rtBG.Left+rtBG.Width/2,rtBG.Top+this.RowHeight/2, width-4);
                }
                else
                {
                    this.Canvas.textAlign='left';
                    this.Canvas.fillText(item.Text,rtBG.Left+2,rtBG.Top+this.RowHeight/2, width-4);
                }
            }

            y+=this.RowHeight;
        }
    }

    this.GetDynamicTextFont=function(cellHeight, width, fontOption)
    {
        var fontSize=parseInt(cellHeight)-2;
        if (cellHeight<5) fontSize=parseInt(cellHeight);    //高度太小了就不要上下间距了
        if (fontSize>this.TextFontConfig.FontMaxSize) fontSize=this.TextFontConfig.FontMaxSize;
        else if (fontSize<=0) fontSize=1;
        var font=this.FormatFontString(fontSize, this.TextFontConfig.Family, fontOption);

        return font;
    }

    this.FormatFontString=function(fontSize, family, option)
    {
        var font;
        if (!option) 
        {
            font=`${fontSize}px ${family}`;
        }
        else
        {
            if (option.Weight) font=`${option.Weight} ${fontSize}px ${family}`;
        }

        return font;
    }

    this.GetMaxMin=function()
    {
        return {Min:0, Max:this.RowCount};
    }
}

//分钟成交量 支持横屏
function ChartMinuteVolumBar()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartMinuteVolumBar';    //类名

    this.UpColor = g_JSChartResource.UpBarColor;            //上涨
    this.DownColor = g_JSChartResource.DownBarColor;        //下跌
    this.UnchangeColor=g_JSChartResource.UnchagneBarColor;  //平盘

    this.BarColorType=1;   //柱子颜色显示类型 0=红绿 1=红绿白

    this.CustomColor=g_JSChartResource.Minute.VolBarColor;   //自定义颜色

    this.YClose;    //前收盘
    this.Symbol;
    this.BeforeOpenData;    //盘前数据
    this.AfterCloseData;    //盘后数据  
    this.BeforeVolColor=g_JSChartResource.Minute.Before.VolColor;
    this.ShareAfterVol=0;

    this.MultiDayBeforeOpenData;    //多日分时图 盘前数据 数组 1天一个
    this.MultiDayAfterCloseData;    //多日分时图 盘后数据 数组 1天一个

    this.PtInChart=function(x,y)
    {
        var option={ MinuteVolBar:true };
        return this.PtInBar(x,y,option);
    }

    this.DrawSelectedStatus=function()
    {
        return this.DrawLinePoint({ MinuteVolBar:true });
    }

    this.Draw=function()
    {
        var isHScreen = (this.ChartFrame.IsHScreen === true);
        
        if (isHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright = border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var chartright=border.RightEx;
        }

        this.DrawBeforeOpen();
        this.DrawMultiDayBeforeOpen();

        var xPointCount=this.ChartFrame.XPointCount;
        var yBottom=this.ChartFrame.GetYFromData(0);
        var yPrice=this.YClose; //上一分钟的价格
        var data=this.Data;
        var bShowColorBar=MARKET_SUFFIX_NAME.IsShowMinuteColorVolBar(this.Symbol);

        if (bShowColorBar) this.Canvas.strokeStyle=this.CustomColor;
        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var item = data.Data[i];
            var vol=null;
            if (!item) continue;
            var price=null;

            vol=item.Vol;
            price=item.Close;
            
            if (!vol) continue;

            var y=this.ChartFrame.GetYFromData(vol);
            var x=this.ChartFrame.GetXFromIndex(j);
            if (x>chartright) break;

            //价格>=上一分钟价格 红色 否则绿色
            if (!bShowColorBar) this.Canvas.strokeStyle = this.GetMinuteBarColor(price, yPrice);

            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(y,ToFixedPoint(x));
                this.Canvas.lineTo(yBottom,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(x),y);
                this.Canvas.lineTo(ToFixedPoint(x),yBottom);
            }
            this.Canvas.stroke();
            if (price) yPrice=price;
        }

        this.DrawAfterClose();
        this.DrawMultiDayAfterClose();
    }

    //连续交易成交量柱子颜色
    this.GetMinuteBarColor=function(price, yPrice)
    {
        if (this.BarColorType==1)   //通达信模式
        {
            if (price>yPrice) return this.UpColor;
            else if (price<yPrice) return this.DownColor;
            else return this.UnchangeColor;
        }
        else    //东方财富模式
        {
            return price >= yPrice ? this.UpColor:this.DownColor;
        }
    }

    this.DrawBeforeOpen=function()
    {
        if (this.ChartBorder.LeftExtendWidth<10) return;
        if (!this.BeforeOpenData) return;

        this.DrawCallAuction(-1,this.BeforeOpenData,true);
    }

    this.DrawAfterClose=function()
    {
        if (this.ChartBorder.RightExtendWidth<10) return;
        if (!this.AfterCloseData) return;

        this.DrawCallAuction(-1,this.AfterCloseData,false);
    }

    this.DrawMultiDayBeforeOpen=function()
    {
        if (this.ChartBorder.MultiDayMinute.Count<=1 || this.ChartBorder.MultiDayMinute.Left<=0) return;
        if (!this.MultiDayBeforeOpenData) return;

        var offset=0,showDayCount=this.MultiDayBeforeOpenData.length;
        if (this.DayOffset)
        {
            if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
            if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
        }
        for(var i=offset,j=0; i<this.MultiDayBeforeOpenData.length && j<showDayCount; ++i,++j)
        {
            var dayItem=this.MultiDayBeforeOpenData[i];
            this.DrawCallAuction(j, dayItem, true);
        }
    }

    this.DrawMultiDayAfterClose=function()
    {
        if (this.ChartBorder.MultiDayMinute.Count<=1 || this.ChartBorder.MultiDayMinute.Right<=0) return;
        if (!this.MultiDayAfterCloseData) return;

        var offset=0,showDayCount=this.MultiDayAfterCloseData.length;
        if (this.DayOffset)
        {
            if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
            if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
        }
        for(var i=offset,j=0;i<this.MultiDayAfterCloseData.length && j<showDayCount; ++i,++j)
        {
            var dayItem=this.MultiDayAfterCloseData[i];
            this.DrawCallAuction(j, dayItem, false);
        }
    }

    this.DrawCallAuction=function(indexDay, callAutionData, isBeforeOpen)
    {
        if (!callAutionData) return;

        callAutionData.Index=indexDay;
        var border=this.GetBorder();
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var yPrice=this.YClose;             //上一分钟的价格
        var yBottom=this.ChartFrame.GetYFromData(0);
        if (callAutionData.Ver==1.0)
        {
            for(var i in callAutionData.Data)
            {
                var item=callAutionData.Data[i];
                if (!item || !IFrameSplitOperator.IsNumber(item.Vol[0])) continue;

                if (isBeforeOpen)
                {
                    var x=this.ChartFrame.GetLeftExtendXFromIndex(i,callAutionData);
                    var y=this.ChartFrame.GetLeftExtendYFromData(item.Vol[0]);
                }
                else
                {
                    var x=this.ChartFrame.GetRightExtendXFromIndex(i,callAutionData);
                    var y=this.ChartFrame.GetRightExtendYFromData(item.Vol[0]);
                }
                

                this.Canvas.strokeStyle = item.Price >= yPrice ? this.UpColor:this.DownColor;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    this.Canvas.moveTo(y,ToFixedPoint(x));
                    this.Canvas.lineTo(yBottom,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),y);
                    this.Canvas.lineTo(ToFixedPoint(x),yBottom);
                }
                this.Canvas.stroke();
                if (item.Price) yPrice=item.Price;
            }
        }
        else if (callAutionData.Ver==2.0 || callAutionData.Ver==3.0)
        {
            var range={ Max: callAutionData.VolMax, Min:callAutionData.VolMin }
            
            for(var i in callAutionData.Data)
            {
                var item=callAutionData.Data[i];
                if (!item) continue;
                if (IFrameSplitOperator.IsPlusNumber(item.Vol[0])) 
                {
                    if (isBeforeOpen)
                    {
                        var x=this.ChartFrame.GetLeftExtendXFromIndex(i,callAutionData);
                        var y=this.ChartFrame.GetLeftExtendYFromData(item.Vol[0],false, { Range:range });
                    }
                    else
                    {
                        var x=this.ChartFrame.GetRightExtendXFromIndex(i,callAutionData);
                        if (this.ShareAfterVol==1) var y=this.ChartFrame.GetYFromData(item.Vol[0]);
                        else var y=this.ChartFrame.GetRightExtendYFromData(item.Vol[0],false, { Range:range });
                    }
                    
                    this.Canvas.strokeStyle = this.GetBarColor(item.ColorID);

                    this.Canvas.beginPath();
                    if (isHScreen)
                    {
                        this.Canvas.moveTo(y,ToFixedPoint(x));
                        this.Canvas.lineTo(yBottom,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),y);
                        this.Canvas.lineTo(ToFixedPoint(x),yBottom);
                    }
                    this.Canvas.stroke();
                }

                if (IFrameSplitOperator.IsPlusNumber(item.Vol[1])) 
                {
                    if (isBeforeOpen)
                    {
                        var x=this.ChartFrame.GetLeftExtendXFromIndex(i,callAutionData);
                        var y=this.ChartFrame.GetLeftExtendYFromData(item.Vol[1],false, { Range:range });
                    }
                    else
                    {
                        var x=this.ChartFrame.GetRightExtendXFromIndex(i,callAutionData);
                        if (this.ShareAfterVol==1) var y=this.ChartFrame.GetYFromData(item.Vol[1]);
                        else var y=this.ChartFrame.GetRightExtendYFromData(item.Vol[1],false, { Range:range });
                    }
                    
                    this.Canvas.strokeStyle = this.GetBarColor(item.ColorID);
                    this.Canvas.beginPath();
                    if (isHScreen)
                    {
                        y-=yBottom;
                        y=border.RightEx-y;
                        this.Canvas.moveTo(y,ToFixedPoint(x));
                        this.Canvas.lineTo(border.RightEx,ToFixedPoint(x));
                    }
                    else
                    {
                        y-=yBottom;
                        y=border.TopEx-y;
                        this.Canvas.moveTo(ToFixedPoint(x),y);
                        this.Canvas.lineTo(ToFixedPoint(x),border.TopEx);
                    }
                    this.Canvas.stroke();
                }
            }
        }
    }

    this.GetBarColor=function(id)
    {
        switch(id)
        {
            case 0:
                return this.UnchangeColor;
            case 1:
                return this.UpColor;
            case 2:
                return this.DownColor;
        }

        if (this.BeforeVolColor && Array.isArray(this.BeforeVolColor))
        {
            var index=id-3;
            if (index>=0 && index<this.BeforeVolColor.length)
                return this.BeforeVolColor[index];
        }

        return this.UnchangeColor;
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        if (this.ChartFrame.GlobalOption && this.ChartFrame.GlobalOption.IsValueFullRange===true) 
        {
            xPointCount=this.Data.Data.length;
            start=0;
        }

        var range={};
        range.Min=0;
        range.Max=null;
        
        for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var item = this.Data.Data[i];
            if (!item || !item.Vol) continue;
            if (range.Max == null) range.Max = item.Vol;
            if (range.Max < item.Vol) range.Max = item.Vol;
        }
        

        if (this.ShareAfterVol==1)
        {
            this.GetAfterCloseMaxMin(range);
            this.GetMultiDayAfterCloseMaxMin(range);
        }

        return range;
    }

    this.GetAfterCloseMaxMin=function(range)
    {
        if (this.ChartBorder.RightExtendWidth<10) return;
        if (!this.AfterCloseData) return;

        var callAutionData=this.AfterCloseData;
        if (range.Max == null || range.Max < callAutionData.VolMax) range.Max=callAutionData.VolMax;
    }

    this.GetMultiDayAfterCloseMaxMin=function(range)
    {
        if (this.ChartBorder.MultiDayMinute.Count<=1 || this.ChartBorder.MultiDayMinute.Right<=0) return;
        if (!this.MultiDayAfterCloseData) return;

        for(var i=0;i<this.MultiDayAfterCloseData.length; ++i)
        {
            var callAutionData=this.MultiDayAfterCloseData[i];
            if (callAutionData.Ver==2.0 || callAutionData.Ver==3.0)
            {
                if (range.Max == null || range.Max < callAutionData.VolMax) range.Max=callAutionData.VolMax;
            }
        }
    }

}

function ChartErrorMessage()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartErrorMessage';    //类名

    this.Draw=function()
    {
        if (!this.IsShow) return;
        if (this.NotSupportMessage) this.DrawNotSupportmessage();
    }
}

//线段 支持横屏
function ChartLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartLine';    //类名
    this.Color="rgb(255,193,37)";   //线段颜色
    this.LineWidth;                 //线段宽度
    this.DrawType=0;                //画图方式  0=无效数平滑  1=无效数不画断开
    this.IsDotLine=false;           //虚线
    this.BreakPoint;                //断开的点索引 Set();


    this.DrawSelectedStatus=this.DrawLinePoint;
    this.PtInChart=this.PtInLine;

    this.ExportData=this.ExportArrayData;
    this.GetItemData=this.GetArrayItemData;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        switch(this.DrawType)
        {
            case 0:
                return this.DrawLine();
            case 1: 
                return this.DrawStraightLine();
            case 2:
                return this.DrawSectionLine();  //分段线
        }
    }

    this.DrawLine=function()
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (bHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        
        this.Canvas.save();
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        if (this.IsDotLine) this.Canvas.setLineDash(g_JSChartResource.DOTLINE.LineDash); //画虚线
        var bFirstPoint=true;
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.GetYFromData(value);

            if (x>chartright) break;

            if (bFirstPoint)
            {
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.beginPath();
                if (bHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
            }
            else
            {
                if (bHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();
        this.Canvas.restore();
    }

    //无效数不画
    this.DrawStraightLine=function()
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        this.Canvas.save();
        this.ClipClient(bHScreen);
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        this.Canvas.strokeStyle=this.Color;
        if (this.IsDotLine) this.Canvas.setLineDash(g_JSChartResource.DOTLINE.LineDash); //画虚线

        var bFirstPoint=true;
        var ptFirst=null;;    //第1个点
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        //for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) 
            {
                if (drawCount>0) this.Canvas.stroke();
                bFirstPoint=true;
                drawCount=0;
                ptFirst=null;
                continue;
            }

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }
            
            var y=this.GetYFromData(value,false);

            if (x>chartright) break;

            if (bFirstPoint)
            {
                this.Canvas.beginPath();
                if (bHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
                ptFirst={ X:x, Y:y };
            }
            else
            {
                if (bHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ++drawCount;
        }

        if (drawCount>0) 
        {
            if (drawCount==1 && ptFirst)    //如果只有1个点, 画一个像素的横线
            {
                if (bHScreen) this.Canvas.lineTo(ptFirst.Y,ptFirst.X+1*GetDevicePixelRatio());
                else this.Canvas.lineTo(ptFirst.X+1*GetDevicePixelRatio(),ptFirst.Y);
            }
           
            this.Canvas.stroke();
        }
        this.Canvas.restore();
    }

    //分段线
    this.DrawSectionLine=function()
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        this.Canvas.save();
        this.ClipClient(bHScreen);
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        this.Canvas.strokeStyle=this.Color;
        if (this.IsDotLine) this.Canvas.setLineDash(g_JSChartResource.DOTLINE.LineDash); //画虚线

        var bFirstPoint=true;
        var ptFirst=null;;    //第1个点
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        //for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) 
            {
                if (drawCount>0) this.Canvas.stroke();
                bFirstPoint=true;
                drawCount=0;
                ptFirst=null;
                continue;
            }

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }
            
            var y=this.GetYFromData(value,false);

            if (x>chartright) break;

            //断开
            if (this.BreakPoint && this.BreakPoint.has(i))
            {
                if (drawCount>0)  this.Canvas.stroke();
                bFirstPoint=true;
                drawCount=0;
                ptFirst=null;
            }

            if (bFirstPoint)
            {
                this.Canvas.beginPath();
                if (bHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
                ptFirst={ X:x, Y:y };
            }
            else
            {
                if (bHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ++drawCount;
        }

        if (drawCount>0) 
        {
            if (drawCount==1 && ptFirst)    //如果只有1个点, 画一个像素的横线
            {
                if (bHScreen) this.Canvas.lineTo(ptFirst.Y,ptFirst.X+1*GetDevicePixelRatio());
                else this.Canvas.lineTo(ptFirst.X+1*GetDevicePixelRatio(),ptFirst.Y);
            }
           
            this.Canvas.stroke();
        }
        this.Canvas.restore();
    }
}

//面积图 支持横屏
function ChartArea()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartArea';    //类名
    this.Color="rgb(255,193,37)";   //线段颜色
    this.AreaColor;                 //面积颜色
    this.LineWidth;                 //线段宽度
    this.LineDash;                  //虚线
    this.AreaDirection=0            //0=向下 1=向上

    this.DrawSelectedStatus=this.DrawLinePoint;
    this.PtInChart=this.PtInLine;

    this.ExportData=this.ExportArrayData;
    this.GetItemData=this.GetArrayItemData;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        this.DrawArea();
    }

    //无效数不画
    this.DrawArea=function()
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        this.Canvas.save();
        this.ClipClient(bHScreen);
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        this.Canvas.strokeStyle=this.Color;
        if (this.AreaColor) this.Canvas.fillStyle=this.AreaColor;
        else this.Canvas.fillStyle=IChartDrawPicture.ColorToRGBA(this.Color,0.6);
        if (IFrameSplitOperator.IsNonEmptyArray(this.LineDash)) this.Canvas.setLineDash(this.LineDas); //画虚线

        var bFirstPoint=true;
        var ptFirst=null, ptEnd=null   //起始结束点
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) 
            {
                if (drawCount>0) this.Canvas.stroke();
                if (ptFirst && ptEnd)
                {
                    if (bHScreen)
                    {
                        if (this.AreaDirection==1)
                        {
                            this.Canvas.lineTo(border.RightEx,ptEnd.X);
                            this.Canvas.lineTo(border.RightEx,ptFirst.X);
                        }
                        else
                        {
                            this.Canvas.lineTo(border.LeftEx,ptEnd.X);
                            this.Canvas.lineTo(border.LeftEx,ptFirst.X);
                        }
                        
                        this.Canvas.closePath();
                        this.Canvas.fill();
                    }
                    else
                    {
                        if (this.AreaDirection==1)
                        {
                            this.Canvas.lineTo(ptEnd.X, border.TopEx);
                            this.Canvas.lineTo(ptFirst.X, border.TopEx);
                        }
                        else
                        {
                            this.Canvas.lineTo(ptEnd.X, border.BottomEx);
                            this.Canvas.lineTo(ptFirst.X, border.BottomEx);
                        }
                        
                        this.Canvas.closePath();
                        this.Canvas.fill();
                    }
                }

                bFirstPoint=true;
                drawCount=0;
                ptFirst=null;
                ptEnd=null;
                continue;
            }

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }
            
            var y=this.GetYFromData(value,false);

            if (x>chartright) break;

            if (bFirstPoint)
            {
                this.Canvas.beginPath();
                if (bHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
                ptFirst={ X:x, Y:y };
            }
            else
            {
                if (bHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
                ptEnd={ X:x, Y:y };
            }

            ++drawCount;
        }

        if (drawCount>0) 
        {
            if (drawCount==1 && ptFirst)    //如果只有1个点, 画一个像素的横线
            {
                if (bHScreen) this.Canvas.lineTo(ptFirst.Y,ptFirst.X+1*GetDevicePixelRatio());
                else this.Canvas.lineTo(ptFirst.X+1*GetDevicePixelRatio(),ptFirst.Y);
            }
           
            this.Canvas.stroke();

            if (ptFirst && ptEnd)
            {
                if (bHScreen)
                {
                    if (this.AreaDirection==1)
                    {
                        this.Canvas.lineTo(border.RightEx,ptEnd.X);
                        this.Canvas.lineTo(border.RightEx,ptFirst.X);
                    }
                    else
                    {
                        this.Canvas.lineTo(border.LeftEx,ptEnd.X);
                        this.Canvas.lineTo(border.LeftEx,ptFirst.X);
                    }
                   
                    this.Canvas.closePath();
                    this.Canvas.fill();
                }
                else
                {
                    if (this.AreaDirection==1)
                    {
                        this.Canvas.lineTo(ptEnd.X, border.TopEx);
                        this.Canvas.lineTo(ptFirst.X, border.TopEx);
                    }
                    else
                    {
                        this.Canvas.lineTo(ptEnd.X, border.BottomEx);
                        this.Canvas.lineTo(ptFirst.X, border.BottomEx);
                    }
                    
                    this.Canvas.closePath();
                    this.Canvas.fill();
                }
            }
        }
        this.Canvas.restore();
    }
}

//散点图
function ChartScatterPlot()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartScatterPlot';      //类名
    //默认点配置
    this.Color="rgb(255,193,37)";           //点颜色
    this.Radius=3;                          //半径
    //this.Data.Data [ {Value:, Radius:半径(可选), Color:颜色(可选), ColorBorder:边框颜色(可选)}, .....]
    this.TooltipData=[];

    this.Draw=function()
    {
        this.TooltipData=[];
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        this.DrawScatterPlot();
    }

    this.DrawScatterPlot=function()
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        this.Canvas.save();
        this.ClipClient(bHScreen);

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (!item) continue;

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            if (x>chartright) break;

            if (Array.isArray(item))
            {
                for(var j=0;j<item.length;++j)
                {
                    this.DrawItem(item[j], x);
                }
            }
            else
            {
                this.DrawItem(item, x);
            }
           
        }

        this.Canvas.restore();
    }

    this.DrawItem=function(item, x)
    {
        if (!item) return;
        if (!IFrameSplitOperator.IsNumber(item.Value)) return;

        var y=this.GetYFromData(item.Value,false);

        var radius=this.Radius;
        if (item.Radius) radius=item.Radius;
        if (!IFrameSplitOperator.IsNumber(radius)) return;

        this.Canvas.beginPath();
        this.Canvas.arc(x, y, radius, 0, 2 * Math.PI);

        var color=this.Color;
        if (item.Color) color=item.Color;
        if (color)
        {
            this.Canvas.fillStyle=color;
            this.Canvas.fill();
        }

        if (item.ColorBorder) 
        {
            this.Canvas.strokeStyle=item.ColorBorder;
            this.Canvas.stroke()
        }

        var itemTooltip={ X:x, Y:y, Radius:radius, Data:item };
        this.TooltipData.push(itemTooltip);
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        if (this.ChartFrame.GlobalOption && this.ChartFrame.GlobalOption.IsValueFullRange)
        {
            start=0;
            xPointCount=this.Data.Data.length;
        }
        
        var range={};
        range.Min=null;
        range.Max=null;

        if(!this.Data || !this.Data.Data) return range;

        for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var point=this.Data.Data[i];
            if (!point) continue;

            if (Array.isArray(point))
            {
                for(var k=0;k<point.length;++k)
                {
                    var item=point[k];
                    if (!IFrameSplitOperator.IsNumber(item.Value)) continue;

                    if (range.Max==null) range.Max=item.Value;
                    if (range.Min==null) range.Min=item.Value;
        
                    if (range.Max<item.Value) range.Max=item.Value;
                    if (range.Min>item.Value) range.Min=item.Value;
                }
            }
            else
            {
                if (!IFrameSplitOperator.IsNumber(point.Value)) continue;
                if (range.Max==null) range.Max=point.Value;
                if (range.Min==null) range.Min=point.Value;
    
                if (range.Max<point.Value) range.Max=point.Value;
                if (range.Min>point.Value) range.Min=point.Value;
            }
        }

        return range;
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        if (!this.IsShow) return false;

        if (!IFrameSplitOperator.IsNonEmptyArray(this.TooltipData)) return false;
        
        for(var i=this.TooltipData.length-1; i>=0; --i)
        {
            var item=this.TooltipData[i];
            
            this.Canvas.beginPath();
            this.Canvas.arc(item.X, item.Y, item.Radius, 0, 2 * Math.PI);
            if (this.Canvas.isPointInPath(x,y))
            {
                JSConsole.Chart.Log('[ChartScatterPlot::GetTooltipData] point', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=6; //散点图
                return true;
            }
        }
    }
   
}

//子线段
function ChartSubLine()
{
    this.newMethod=ChartLine;       //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartSubLine';     //类名
    this.Color="rgb(255,193,37)";   //线段颜色
    this.LineWidth;                 //线段宽度
    this.DrawType=0;                //画图方式  0=无效数平滑  1=无效数不画断开
    this.IsDotLine=false;           //虚线

    this.SubFrame={ Max:null,Min:null };

    this.Draw=function()
    {
        if (!this.IsShow) return;
        if (!this.Data || !this.Data.Data) return;

        this.CalculateDataMaxMin();

        switch(this.DrawType)
        {
            case 0:
                return this.DrawLine();
            case 1: 
                return this.DrawStraightLine();
        }
    }

    this.GetYFromData=function(value)
    {
        var bHScreen = (this.ChartFrame.IsHScreen === true);

        if (bHScreen)
        {
            if (value <= this.SubFrame.Min) return this.ChartBorder.GetLeftEx();
            if (value >= this.SubFrame.Max) return this.ChartBorder.GetRightEx();

            var width = this.ChartBorder.GetWidthEx() * (value - this.SubFrame.Min) / (this.SubFrame.Max - this.SubFrame.Min);
            return this.ChartBorder.GetLeftEx() + width;
        }
        else
        {
            if(value<=this.SubFrame.Min) return this.ChartBorder.GetBottomEx();
            if(value>=this.SubFrame.Max) return this.ChartBorder.GetTopEx();
    
            var height=this.ChartBorder.GetHeightEx()*(value-this.SubFrame.Min)/(this.SubFrame.Max-this.SubFrame.Min);
            return this.ChartBorder.GetBottomEx()-height;
        }
    }

    this.CalculateDataMaxMin=function()
    {
        this.SubFrame={ Max:null,Min:null };

        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var chartright=this.ChartBorder.GetRight();
        if (bHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            if (x>chartright) break;

            if (this.SubFrame.Min==null || this.SubFrame.Min>value) this.SubFrame.Min=value;
            if (this.SubFrame.Max==null || this.SubFrame.Max<value) this.SubFrame.Max=value;
        }
    }

    this.GetMaxMin=function()   //数据不参与坐标轴最大最小值计算
    {
        var range={Min:null, Max:null};
        return range;
    }
}

//叠加线段
function ChartOverlayLine()
{
    this.newMethod=ChartLine;   //派生
    this.newMethod();
    delete this.newMethod;

    this.MainData=new ChartData();  //主数据

    this.Draw=function()
    {
        if (!this.Data || !this.Data.Data) return;
        if (!this.MainData || !this.MainData.Data) return;

        switch(this.DrawType)
        {
            case 0:
                return this.DrawLine();
            case 1: 
                return this.DrawStraightLine();
        }
    }

    //获取第1个有效数据
    this.GetFirstVaildIndex=function()
    {
        var startIndex=this.Data.DataOffset;
        for(var i=startIndex, j=0 ; i<this.MainData.Data.length && i<this.Data.Data.length; ++i,++j )
        {
            var value=this.MainData.Data[i];
            var overlayValue=this.Data.Data[i];
            if (IFrameSplitOperator.IsNumber(value) && IFrameSplitOperator.IsNumber(overlayValue)) 
                return { Index:j, DataOffset:i, OverlayValue:overlayValue, MainValue:value };
        }

        return null;
    }

    //无效数不画
    this.DrawStraightLine=function()
    {
        var firstData=this.GetFirstVaildIndex();
        if (!firstData) return;

        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (bHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        var lockRect=this.GetLockRect();
        if (lockRect)
        {
            if (bHScreen) chartright=lockRect.Top;
            else chartright=lockRect.Left;
        }

        this.Canvas.save();
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        this.Canvas.strokeStyle=this.Color;
        if (this.IsDotLine) this.Canvas.setLineDash([3,5]); //画虚线

        var bFirstPoint=true;
        var drawCount=0,rate=0;
        for(var i=firstData.DataOffset,j=firstData.Index;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) 
            {
                if (drawCount>0) this.Canvas.stroke();
                bFirstPoint=true;
                drawCount=0;
                continue;
            }

            var x=this.ChartFrame.GetXFromIndex(j);
            var diff=value-firstData.OverlayValue;
            if (firstData.OverlayValue!=0) rate= 1+ diff/Math.abs(firstData.OverlayValue);
            else rate=1+diff;
            var fixedValue=firstData.MainValue*rate;
            //var fixedValue=value/firstData.OverlayValue*firstData.MainValue;
            var y=this.GetYFromData(fixedValue);

            if (x>chartright) break;

            if (bFirstPoint)
            {
                this.Canvas.beginPath();
                if (bHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
            }
            else
            {
                if (bHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();
        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        var firstData=this.GetFirstVaildIndex();
        if (!firstData) return range;

        for(var i=firstData.DataOffset,j=firstData.Index; i<this.Data.Data.length && j<xPointCount; ++i,++j)
        {
            var overlayValue=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(overlayValue)) continue;

            var diff=overlayValue-firstData.OverlayValue;
            if (firstData.OverlayValue!=0) rate= 1+ diff/Math.abs(firstData.OverlayValue);
            else rate=1+diff;
            var value=firstData.MainValue*rate;
            //var value=overlayValue/firstData.OverlayValue*firstData.MainValue;

            if (range.Max==null) range.Max=value;
            if (range.Min==null) range.Min=value;

            if (range.Max<value) range.Max=value;
            if (range.Min>value) range.Min=value;
        }

        return range;
    }
}

//独立线段
function ChartSingleLine()
{
    this.newMethod=ChartLine;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartSingleLine';     //类名
    this.MaxMin=null;    //当前的显示范围

    this.Draw=function()
    {
        this.MaxMin=null;
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (!this.Data || !this.Data.Data) return;

        this.MaxMin=this.GetCurrentMaxMin();
        if (!this.MaxMin) return;
        if (!IFrameSplitOperator.IsNumber(this.MaxMin.Max) || !IFrameSplitOperator.IsNumber(this.MaxMin.Min)) return;

        switch(this.DrawType)
        {
            
            default: 
                return this.DrawStraightLine();
        }
    }

    //获取当前页的最大最小值
    this.GetCurrentMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={ Max:null, Min:null };

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            if (range.Max==null) range.Max=value;
            if (range.Min==null) range.Min=value;

            if (range.Max<value) range.Max=value;
            if (range.Min>value) range.Min=value;
        }

        return range;
    }

    this.GetMaxMin=function()
    {
        return { Max:null, Min:null };
    }

    this.GetYFromData=function(value)
    {
        var bHScreen = (this.ChartFrame.IsHScreen === true);

        if (bHScreen)
        {
            if (value <= this.MaxMin.Min) return this.ChartBorder.GetLeftEx();
            if (value >= this.MaxMin.Max) return this.ChartBorder.GetRightEx();

            var width = this.ChartBorder.GetWidthEx() * (value - this.MaxMin.Min) / (this.MaxMin.Max - this.MaxMin.Min);
            return this.ChartBorder.GetLeftEx() + width;
        }
        else
        {
            if(value<=this.MaxMin.Min) return this.ChartBorder.GetBottomEx();
            if(value>=this.MaxMin.Max) return this.ChartBorder.GetTopEx();
    
            var height=this.ChartBorder.GetHeightEx()*(value-this.MaxMin.Min)/(this.MaxMin.Max-this.MaxMin.Min);
            return this.ChartBorder.GetBottomEx()-height;
        }
    }
}

//彩色线段
function ChartPartLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartPartLine';     //类名
    this.LineWidth;                     //线段宽度            

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        this.DrawLine();
    }

    this.DrawLine=function()
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var xPointCount=this.ChartFrame.XPointCount;
        var isMinute=this.IsMinuteFrame();

        this.Canvas.save();
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        var bFirstPoint=true;
        var drawCount=0;
        var lastColor;
        var lastPoint={X:null,Y:null};
        var isPerNull=false;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (item==null || item.Value==null) 
            {
                lastPoint.X=null;
                lastPoint.Y=null;
                isPerNull=true;
                continue;
            }

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            var value=item.Value;
            var color=item.RGB;
            var y=this.ChartFrame.GetYFromData(value);

            if (x>chartright) break;

            if (color!=lastColor || isPerNull==true)
            {
                if (lastColor && drawCount>0) this.Canvas.stroke();

                drawCount=0;
                lastColor=color;
                this.Canvas.strokeStyle=color;
                this.Canvas.beginPath();

                if (lastPoint.X!=null && lastPoint.Y!=null) //接着上一个点连线
                {
                    if (bHScreen) this.Canvas.moveTo(lastPoint.Y,lastPoint.X);  //横屏坐标轴对调
                    else this.Canvas.moveTo(lastPoint.X,lastPoint.Y);

                    if (bHScreen) this.Canvas.lineTo(y,x);
                    else this.Canvas.lineTo(x,y);

                    ++drawCount;
                }
                else
                {
                    if (bHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                    else this.Canvas.moveTo(x,y);
                }
            }
            else
            {
                if (bHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
                ++drawCount;
            }

            lastPoint.X=x;
            lastPoint.Y=y;
            isPerNull=false;
        }

        if (drawCount>0) this.Canvas.stroke();
        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var item = this.Data.Data[i];
            if (!item || !item.Value) continue;
            if (range.Max == null || range.Max<item.Value) range.Max = item.Value;
            if (range.Min == null || range.Min>item.Value) range.Min = item.Value;
        }

        return range;
    }

    this.ExportData=function(aryKData, option)
    {
        var aryValue=[], aryColor=[];
        if (IFrameSplitOperator.IsNonEmptyArray(this.Data.Data))
        {
            var start=0, end=this.Data.length-1;
            //限制范围
            if (option && option.Start && option.End && IFrameSplitOperator.IsNumber(option.Start.Index) && IFrameSplitOperator.IsNumber(option.End.Index))
            {
                start=option.Start.Index;
                end=option.End.Index;
            }

            for(var i=start ;i<=end && i<this.Data.Data.length; ++i)
            {
                var item = this.Data.Data[i];
                aryValue[i]=null;
                aryColor[i]=null;

                if (item && IFrameSplitOperator.IsNumber(item.Value))
                {
                    aryValue[i]=item.Value;
                    aryColor[i]=item.RGB;
                } 
            }
        }

        return [{ Name: `${this.Name}-Value`, Data:aryValue }, { Name: `${this.Name}-Color`, Data:aryColor }] ;
    }
}

//阶梯折线图
function ChartStepLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartStepLine';     //类名
    this.LineWidth=1;                    //线段宽度  
    this.DotLine;
    this.IsHScreen;
    this.IsDotLine=false;           //虚线


    this.PtInChart=function(x,y)
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        if (bHScreen) return;

        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var lockRect=this.GetLockRect();
        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            if (lockRect) chartright=lockRect.Top;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            if (lockRect) chartright=lockRect.Left;
        }

        if (x<xOffset || x>chartright) return null;
        if (y>border.BottomEx || y<border.TopEx) return null;

        var ptStart={}, ptEnd={};
        for(var i=this.Data.DataOffset; i>=0; --i)
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            var yPt=this.GetYFromData(value,false);
            var xPt=null;
            
            if (isMinute) xPt=this.ChartFrame.GetXFromIndex(0);
            else xPt=xOffset;

            ptStart.Y=yPt;
            ptStart.X=xPt;
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            if (isMinute)
            {
                var xLine=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var xLine=left+(right-left)/2;
            }

            var yLine=this.GetYFromData(value,false);

            if (xLine<x)
            {
                ptStart.X=xLine;
                ptStart.Y=yLine;
            }
            else if (xLine==x)
            {
                ptStart.X=ptEnd.X=xLine;
                ptStart.Y=ptEnd.Y=yLine;
                break;
            }
            else
            {
                ptEnd.X=xLine;
                ptEnd.Y=yLine;
                break;
            }
            
            if (x>chartright) break;
        }

        if (!IFrameSplitOperator.IsNumber(ptStart.X) || !IFrameSplitOperator.IsNumber(ptStart.Y)) return null;
        if (!IFrameSplitOperator.IsNumber(ptEnd.X) || !IFrameSplitOperator.IsNumber(ptEnd.Y)) return null;

        if (x==ptStart.X || y==ptStart.Y) 
            return { Identify:this.Identify, Chart:this };
        if (x==ptEnd.X || y==ptEnd.Y) 
            return { Identify:this.Identify, Chart:this };

        if (x>=ptStart.X && x<=ptEnd.X && y>=ptStart.Y-3 && y<=ptStart.Y+3)
            return { Identify:this.Identify, Chart:this };
       
        if (x>=ptEnd.X-3 && x<=ptEnd.X+3 && y>=Math.min(ptStart.Y,ptEnd.Y) && y<Math.max(ptStart.Y,ptEnd.Y)) 
            return { Identify:this.Identify, Chart:this };

        return null;
    }
    
    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;
        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        this.Canvas.save();
        this.ClipClient(this.IsHScreen);

        this.DrawLine();

        this.Canvas.restore();
    }

    this.DrawLine=function()
    {
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var lockRect=this.GetLockRect();

        if (this.IsHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            if (lockRect) chartright=lockRect.Top;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            if (lockRect) chartright=lockRect.Left;
        }

        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        if (this.IsDotLine) this.Canvas.setLineDash(g_JSChartResource.DOTLINE.LineDash); //画虚线
        if (this.DotLine) this.Canvas.setLineDash(this.DotLine); //画虚线
        this.Canvas.strokeStyle=this.Color;
        var bFirstPoint=true;
        var drawCount=0;
        var prePoint={ X:null, Y:null };

        for(var i=this.Data.DataOffset; i>=0; --i)
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            var y=this.GetYFromData(value,false);
            var x=null;
            
            if (isMinute) x=this.ChartFrame.GetXFromIndex(0);
            else x=xOffset;

            this.Canvas.beginPath();
            if (this.IsHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
            else this.Canvas.moveTo(x,y);
            bFirstPoint=false;

            prePoint.Y=y;
            prePoint.X=x;
        }


        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            if (x>chartright) break;

            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            var y=this.GetYFromData(value,false);

            if (bFirstPoint)
            {
                this.Canvas.beginPath();
                if (this.IsHScreen) this.Canvas.moveTo(y,x);  //横屏坐标轴对调
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;

                prePoint.X=x;
                prePoint.Y=y;
            }
            else
            {
                if (this.IsHScreen) 
                {
                    this.Canvas.lineTo(prePoint.Y,x)
                    this.Canvas.lineTo(y,x);
                }
                else 
                {
                    this.Canvas.lineTo(x,prePoint.Y)
                    this.Canvas.lineTo(x,y);
                }

                prePoint.X=x;
                prePoint.Y=y;
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();
    }

    this.DrawSelectedStatus=function()
    {
        this.DrawLinePoint();
    }
}

//斜率线 DRAWSL()
function ChartSlopeLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartSlopeLine';     //类名
    this.Color="rgb(255,193,37)";        //线段颜色
    this.IsDotLine=false;
    this.LineWidth;
    this.Option;    //[ { Slope:slope, Length:len, Direct:direct } ]

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        this.Canvas.save();
        this.Canvas.strokeStyle=this.Color;
        if (this.IsDotLine) this.Canvas.setLineDash(g_JSChartResource.DOTLINE.LineDash); //画虚线
        
        var left=this.ChartBorder.GetLeft();
        var top=this.ChartBorder.GetTopEx();
        var right=this.ChartBorder.GetRight();
        var bottom=this.ChartBorder.GetBottom();

        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        this.Canvas.clip();

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue; 
            var option=this.Option[i];
            if (!option) continue;
           
            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value);
            var z=option.Length*g_JSChartResource.DRAWSL.PixelWidth;
            if (x>chartright) break;

            var x2=Math.sqrt((z*z)/(1+option.Slope*option.Slope));
            var y2=x2*option.Slope;

            this.Canvas.beginPath();
            if (option.Direct==2)
            {
                this.Canvas.moveTo(x-x2,y+y2);
                this.Canvas.lineTo(x+x2,y-y2);
            }
            else if (option.Direct==1)
            {
                this.Canvas.moveTo(x,y);
                this.Canvas.lineTo(x-x2,y+y2);
            }
            else
            {
                this.Canvas.moveTo(x,y);
                this.Canvas.lineTo(x+x2,y-y2);
            }
            
            this.Canvas.stroke();
        }

        this.Canvas.restore();
    }
}


//POINTDOT 圆点 支持横屏
/*
SAR的圈圈分成两种颜色，当股价朝向上的方向前进时，SAR位于收盘价线的下方，并且呈现红色的圈圈，
当股价朝下跌的方向前进时，SAR位于收盘价的上方，并且呈现绿色的圈圈。
我们最需要注意的是，股价向上或向下穿越SAR圈圈的讯号，而且是以收盘价的穿越有效。
当价格由下往上穿越今天绿色的SAR时，画面上立即在明天的价格位置显示一个红色的圈圈，
代表股价已经翻红，又代表明天开始，必须从事多头交易，当价格由上往下跌破今天红色的SAR时，画面上立即在明天的价格位置，
显示一个绿色的圈圈，代表股价已经翻绿，又代表明天开始必须从事空头交易。
*/
function ChartPointDot()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartPointDot';    //类名
    this.Color="rgb(255,193,37)";   //线段颜色
    this.Radius=1;                  //点半径
    this.EnableUpDownColor=false;   //是否是红绿点
    this.HistoryData;

    this.ExportData=this.ExportArrayData;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (bHScreen===true) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        this.Canvas.save();
        this.ClipClient(bHScreen);
        this.Canvas.fillStyle=this.Color;
        var colorDot;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value, false);

            if (x>chartright) break;

            if (this.EnableUpDownColor)
            {
                var kItem=this.HistoryData.Data[i];

                if (kItem.Close>value) colorDot="rgb(255,61,61)";
                else colorDot='rgb(0,199,65)';

                this.Canvas.fillStyle=colorDot;
            }

            this.Canvas.beginPath();
            if (bHScreen) this.Canvas.arc(y, x, this.Radius, 0, Math.PI*2, true);
            else this.Canvas.arc(x, y, this.Radius, 0, Math.PI*2, true);
            this.Canvas.closePath();
            this.Canvas.fill();
        }

        this.Canvas.restore();
    }
}

//通达信语法  STICK 支持横屏
function ChartStick()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Color="rgb(255,193,37)";   //线段颜色
    this.LineWidth;                 //线段宽度
    this.ClassName='ChartStick';

    this.ExportData=this.ExportArrayData;

    this.DrawLine=function()
    {
        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen===true) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        this.Canvas.save();
        if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        var bFirstPoint=true;
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value);

            if (x>chartright) break;

            if (bFirstPoint)
            {
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(y,x);
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();
        this.Canvas.restore();
    }

    this.DrawStick=function()
    {
        if (!this.Data || !this.Data.Data) return;
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var chartright=this.ChartBorder.GetRight();
        if (bHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        var yBottom=this.ChartBorder.GetBottom();
        var xLeft=this.ChartBorder.GetLeft();

        this.Canvas.save();
        this.Canvas.strokeStyle=this.Color;
        if (this.LineWidth) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        var lineWidth=this.Canvas.lineWidth;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value);

            if (x>chartright) break;

            this.Canvas.beginPath();
            if (bHScreen)
            {
                this.Canvas.moveTo(xLeft,x);  
                this.Canvas.lineTo(y,x);
                this.Canvas.stroke();
            }
            else
            {
                var xFix=ToFixedPoint2(lineWidth, x);
                this.Canvas.moveTo(xFix,y);  
                this.Canvas.lineTo(xFix,yBottom);
            }
            this.Canvas.stroke();
        }

        this.Canvas.restore();
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        this.DrawStick();
    }
}

//通达信语法 LINESTICK 支持横屏
function ChartLineStick()
{
    this.newMethod=ChartStick;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartLineStick';

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        this.DrawStick();
        this.DrawLine();
    }
}

//通达信语法 VOLSTICK 支持横屏
function ChartVolStick()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.UpColor=g_JSChartResource.UpBarColor;
    this.DownColor=g_JSChartResource.DownBarColor;
    this.HistoryData;               //历史数据
    this.KLineDrawType=0;
    
    this.ClassName='ChartVolStick';

    this.BarWidth;                  //固定宽度 目前只支持宽度为1
    this.BarType;                   //柱子状态 1=实心 0=空心 2=涨实跌空 如果设置了这个属性， 属性KLineDrawType无效
    this.PtInChart=this.PtInBar;
    this.DrawSelectedStatus=this.DrawLinePoint;

    this.ExportData=this.ExportArrayData;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.ChartFrame.IsHScreen===true) 
        {
            this.HScreenDraw();
            return;
        }

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        var xPointCount=this.ChartFrame.XPointCount;
        var lockRect=this.GetLockRect();
        if (lockRect) chartright=lockRect.Left;
        var isMinute=this.IsMinuteFrame();

        var yBottom=this.ChartFrame.GetYFromData(0);

        this.Canvas.save();

        if (dataWidth>=4 && !(this.BarWidth===1))
        {
            yBottom=ToFixedRect(yBottom);
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                var kItem=this.HistoryData.Data[i];
                if (value==null || kItem==null) continue;
                if (value==0) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;

                var y=this.ChartFrame.GetYFromData(value);
                var barColor=this.GetBarColor(kItem);
                var bUp=barColor.IsUp;
                
                   
                var height=ToFixedRect(Math.abs(yBottom-y)>=1?yBottom-y:1);//高度调整为整数, 如果小于1, 统一使用1
                y=yBottom-height;
                var bSolidBar=this.IsSolidBar(bUp); //实心柱子

                if (bSolidBar)
                {
                    this.Canvas.fillStyle=barColor.Color;
                    this.Canvas.fillRect(ToFixedRect(left),y,ToFixedRect(dataWidth),height);
                }
                else
                {
                    this.Canvas.strokeStyle=barColor.Color;
                    this.Canvas.beginPath();
                    this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(y),ToFixedRect(dataWidth),height);
                    this.Canvas.stroke();
                }
            }
        }
        else    //太细了直接话线
        {
            var preKItem=null;
            var barColor=null;
            this.Canvas.linewidth=1*GetDevicePixelRatio();
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                var kItem=this.HistoryData.Data[i];
                if (value==null || kItem==null) continue;

                var y=this.ChartFrame.GetYFromData(value);
                if (isMinute)
                {
                    var x=this.ChartFrame.GetXFromIndex(j);
                }
                else
                {
                    var left=xOffset;
                    var right=xOffset+dataWidth;
                    var x=left+(right-left)/2;
                }

                if (x>chartright) break;

                if (isMinute) barColor=this.GetMinuteBarColor(kItem,preKItem);    //分时图颜色单独计算
                else barColor=this.GetBarColor(kItem);
                
                this.Canvas.strokeStyle=barColor.Color;
                
                //var x=this.ChartFrame.GetXFromIndex(j);
                this.Canvas.beginPath();
                this.Canvas.moveTo(ToFixedPoint(x),y);
                this.Canvas.lineTo(ToFixedPoint(x),yBottom);
                this.Canvas.stroke();

                preKItem=kItem;
            }
        }

        this.Canvas.restore();
    }

    this.HScreenDraw=function() //横屏画法
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.ChartBorder.GetHScreenBorder();
        var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartBottom=border.BottomEx;
        var xPointCount=this.ChartFrame.XPointCount;
        var lockRect=this.GetLockRect();
        if (lockRect) chartBottom=lockRect.Top;

        var isMinute=this.IsMinuteFrame();
        var yBottom=this.ChartFrame.GetYFromData(0);

        if (dataWidth>=4)
        {
            yBottom=ToFixedRect(yBottom);
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                var kItem=this.HistoryData.Data[i];
                if (value==null || kItem==null) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartBottom) break;

                var y=this.ChartFrame.GetYFromData(value);
                var barColor=this.GetBarColor(kItem);
                var bUp=barColor.IsUp;
                
                var height=ToFixedRect(y-yBottom);  //高度调整为整数
                var bSolidBar=this.IsSolidBar(bUp); //实心柱子

                if (bSolidBar)
                {
                    this.Canvas.fillStyle=barColor.Color;
                    this.Canvas.fillRect(yBottom,ToFixedRect(left),height,ToFixedRect(dataWidth));
                }
                else
                {
                    this.Canvas.strokeStyle=barColor.Color;
                    this.Canvas.beginPath();
                    this.Canvas.rect(ToFixedPoint(yBottom),ToFixedPoint(left),height,ToFixedRect(dataWidth));
                    this.Canvas.stroke();
                }
            }
        }
        else    //太细了直接话线
        {
            var preKItem=null;
            var barColor=null;
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                var kItem=this.HistoryData.Data[i];
                if (value==null || kItem==null) continue;

                var y=this.ChartFrame.GetYFromData(value);

                if (isMinute)
                {
                    var x=this.ChartFrame.GetXFromIndex(j);
                }
                else
                {
                    var left=xOffset;
                    var right=xOffset+dataWidth;
                    var x=left+(right-left)/2;
                }

                if (x>chartBottom) break;

                if (isMinute) barColor=this.GetMinuteBarColor(kItem,preKItem);    //分时图颜色单独计算
                else barColor=this.GetBarColor(kItem);

                var bUp=barColor.IsUp;
                this.Canvas.strokeStyle=barColor.Color;

                //var x=this.ChartFrame.GetXFromIndex(j);
                this.Canvas.beginPath();
                this.Canvas.moveTo(y,ToFixedPoint(x));
                this.Canvas.lineTo(yBottom,ToFixedPoint(x));
                this.Canvas.stroke();

                preKItem=kItem;
            }
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        if (this.ChartFrame.GlobalOption && this.ChartFrame.GlobalOption.IsValueFullRange)
        {
            start=0;
            xPointCount=this.Data.Data.length;
        }

        var range={ Min:null, Max:null };
        for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(range.Max) || range.Max<value) range.Max=value;
            if (!IFrameSplitOperator.IsNumber(range.Min) || range.Min>value) range.Min=value
        }

        if (range.Max>0 && range.Min>0) range.Min=0;
        else if (range.Max<0 && range.Min<0) range.Max=0;

        return range;
    }

    this.GetBarColor=function(kItem)
    {
        if (kItem.Close>=kItem.Open) return { Color:this.UpColor, IsUp:true };  //颜色, 是否是上涨
        else return { Color:this.DownColor, IsUp:false };
    }

    //true=实心 false=空心
    this.IsSolidBar=function(bUp)
    {
        var bSolidBar=true; //实心柱子

        if (this.BarType===0 || this.BarType===1 || this.BarType===2)
        {
            if (this.BarType===0)   //空心
                bSolidBar=false;
            else if (this.BarType===2)  //涨实跌空
                bSolidBar=bUp;
        }
        else
        {
            if (this.KLineDrawType==6) //完全空心柱
                bSolidBar=false;    
            else if (bUp && (this.KLineDrawType==1 || this.KLineDrawType==2 || this.KLineDrawType==3)) //空心柱子
                bSolidBar=false;
        }

        return bSolidBar;
    }

    this.GetMinuteBarColor=function(kItem, preItem)
    {
        var prePrice=kItem.YClose;
        if (preItem) prePrice=preItem.Close;

        if (kItem.Close>=prePrice) return { Color:this.UpColor, IsUp:true };  //颜色, 是否是上涨
        else return { Color:this.DownColor, IsUp:false };
    }

    this.GetItemData=function(indexData)
    {
        if (!indexData) return null;
        if (!IFrameSplitOperator.IsNumber(indexData.Index)) return null;
        if (!this.HistoryData || !IFrameSplitOperator.IsNonEmptyArray(this.HistoryData.Data)) return null;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return null;
        var index=indexData.Index;
        if (index<0 || index>=this.Data.Data.length || index>=this.HistoryData.Data.length) return null;

        var item=this.Data.Data[index];
        var kItem=this.HistoryData.Data[index];

        return [ { Value:item, Color:this.GetBarColor(kItem).Color, Name: this.Name } ];
    }
}

// VERTLINE(HIGH>=HHV(HIGH,20),1)表示在创20天新高画垂直虚线。
// 支持横屏
function ChartVericaltLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartVericaltLine';    //类名
    this.LineWidth=2;
    this.LineCap;

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        var isHScreen=this.ChartFrame.IsHScreen==true;
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.GetBorder();
        var xPointCount=this.ChartFrame.XPointCount;

        if (isHScreen)
        {
            var top=border.RightEx;
            var bottom=border.LeftEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var top=border.TopEx;
            var bottom=border.BottomEx;
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }

        this.Canvas.save();
        this.Canvas.strokeStyle=this.Color;
        if (this.LineType) this.Canvas.setLineDash(this.LineType);
        if (this.LineCap) this.Canvas.lineCap = this.LineCap;
        
        this.Canvas.beginPath();
        var lineWidth=this.Canvas.lineWidth;
        if (this.LineWidth>0) 
        {
            lineWidth=this.LineWidth * GetDevicePixelRatio();
            this.Canvas.lineWidth=lineWidth;
        }
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (!item) continue;

            var center=xOffset+dataWidth/2;
            center=ToFixedPoint2(lineWidth, center);
            if (isHScreen)
            {
                this.Canvas.moveTo(top,center);
                this.Canvas.lineTo(bottom,center);
            }
            else
            {
                this.Canvas.moveTo(center, top);
                this.Canvas.lineTo(center,bottom);
            }
            
            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        return { Min:null, Max:null };
    }
}

//HORLINE 支持横屏 
function ChartHorizontalLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartHorizontalLine';    //类名
    this.LineWidth=2;
    this.LineCap;
    this.ExtendType=0;   //1=表示向左延长，2=表示向右延长，3=表示左右延长

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        var isHScreen=this.ChartFrame.IsHScreen==true;
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var border=this.GetBorder();
        
        var xPointCount=this.ChartFrame.XPointCount;
        if (isHScreen)
        {
            var left=border.TopEx;
            var right=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var left=border.LeftEx
            var right=border.RightEx;
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        
        this.Canvas.save();
        this.Canvas.strokeStyle=this.Color;
        if (this.LineType) this.Canvas.setLineDash(this.LineType);
        if (this.LineCap) this.Canvas.lineCap = this.LineCap;
        
        this.Canvas.beginPath();
        var lineWidth=this.Canvas.lineWidth;
        if (this.LineWidth>0) 
        {
            lineWidth=this.LineWidth * GetDevicePixelRatio();
            this.Canvas.lineWidth=lineWidth;
        }
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (!item) continue;
            if (!IFrameSplitOperator.IsNumber(item)) continue;

            var y=this.ChartFrame.GetYFromData(item);
            y=ToFixedPoint2(lineWidth, y);
            var center=xOffset+dataWidth/2;
            center=ToFixedPoint2(lineWidth, center);
            if (this.ExtendType==3) //左右延长
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(y, left);
                    this.Canvas.lineTo(y, right);
                }
                else
                {
                    this.Canvas.moveTo(left, y);
                    this.Canvas.lineTo(right, y);
                }
                
            }
            else if (this.ExtendType==1) //左延长
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(y, left);
                    this.Canvas.lineTo(y, center);
                }
                else
                {
                    this.Canvas.moveTo(left, y);
                    this.Canvas.lineTo(center, y);
                }
                
            }
            else    //右延长
            {
                if (isHScreen)
                {
                    this.Canvas.moveTo(y, center);
                    this.Canvas.lineTo(y, right);
                }
                else
                {
                    this.Canvas.moveTo(center, y);
                    this.Canvas.lineTo(right, y);
                }
                
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();

        this.Canvas.restore();
    }
}



//线段 多数据(一个X点有多条Y数据) 支持横屏
function ChartLineMultiData()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartLineMultiData';    //类名
    this.Color="rgb(255,193,37)";           //线段颜色
    
    this.PointColor;        //='rgb(255,193,80)';
    this.PointRadius;       //=2;
    this.LineWidth;

    this.Draw=function()
    {
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        this.Canvas.save();
        if (IFrameSplitOperator.IsPlusNumber(this.LineWidth)) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        var bFirstPoint=true;
        var drawCount=0;
        var aryPoint=[];
        var aryValue;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var lineItem=this.Data.Data[i];
            if (!lineItem) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            if (x>chartright) break;

            if (Array.isArray(lineItem)) aryValue=lineItem;
            else aryValue=[lineItem];

            for(var index=0; index<aryValue.length; ++index)
            {
                var item=aryValue[index];
                if (!item) continue;

                var value =item.Value;
                
                var y=this.ChartFrame.GetYFromData(value);

                if (bFirstPoint)
                {
                    this.Canvas.strokeStyle=this.Color;
                    this.Canvas.beginPath();
                    if (isHScreen) this.Canvas.moveTo(y,x);
                    else this.Canvas.moveTo(x,y);
                    bFirstPoint=false;

                    if (item.Type===1) aryPoint.push({X:x, Y:y});
                }
                else
                {
                    if (isHScreen) this.Canvas.lineTo(y,x);
                    else this.Canvas.lineTo(x,y);

                    if (item.Type===1) aryPoint.push({X:x, Y:y});
                }

                ++drawCount;
            }
        }

        if (drawCount>0) this.Canvas.stroke();

        this.DrawPoint(aryPoint);

        this.Canvas.restore();
    }

    this.DrawPoint=function(aryPoint)
    {
        if (!this.PointColor) return;
        if (!IFrameSplitOperator.IsPlusNumber(this.PointRadius)) return;
        var radius=this.PointRadius*GetDevicePixelRatio();
        for(var i=0;i<aryPoint.length;++i)
        {
            var item=aryPoint[i];

            this.Canvas.beginPath();
            this.Canvas.arc(item.X,item.Y,radius,0,360,false);
            this.Canvas.fillStyle=this.PointColor;      //填充颜色
            this.Canvas.fill();                         //画实心圆
            this.Canvas.closePath();
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        if(!this.Data || !this.Data.Data) return range;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var item=this.Data.Data[i];
            if (!item) continue;

            var aryValue;
            if (Array.isArray(item)) aryValue=item;
            else aryValue=[item];

            for(var j=0; j<aryValue.length; ++j)
            {
                var value=aryValue[j].Value;
                if (!IFrameSplitOperator.IsNumber(value)) continue;
                if (range.Max==null) range.Max=value;
                if (range.Min==null) range.Min=value;

                if (range.Max<value) range.Max=value;
                if (range.Min>value) range.Min=value;
            }
        }

        return range;
    }
}

//柱子 支持横屏
function ChartStickLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartStickLine';    //类名
    this.Color="rgb(255,193,37)";               //线段颜色
    this.BarType=0;                     //柱子类型 0=实心 1=空心 -1=画虚线空心柱
    this.LineDotted=[3,3];              //虚线设置
    this.Width=0;                       //柱子宽度 0=1 3,50=k线宽度 101=K线宽度+间距宽度

    this.SetEmptyBar=function()         //设置空心柱子
    {
        if (this.BarType!=1 && this.BarType!=-1) return false;

        this.Canvas.lineWidth=GetDevicePixelRatio();
        this.Canvas.strokeStyle=this.Color;
        var emptyBGColor=g_JSChartResource.EmptyBarBGColor;
        if (emptyBGColor) this.Canvas.fillStyle=emptyBGColor;
        if (this.BarType==-1)   //虚线
        {
            this.Canvas.setLineDash(this.LineDotted);   //虚线
        }

        return true;
    }

    this.IsEmptyBar=function()
    {
        return (this.BarType==1 || this.BarType==-1);
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        var zoomIndex=this.ChartFrame.ZoomIndex;
        if (isHScreen) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        if (isHScreen) xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;

        var isMinute=this.IsMinuteFrame();
        
        this.Canvas.save();
        var bFillBar=false;
        var bFillKLine=false;
        var emptyBGColor=g_JSChartResource.EmptyBarBGColor;

        if (isMinute)
        {
            if (this.Width>1) this.Canvas.lineWidth=2*GetDevicePixelRatio();
            else this.Canvas.lineWidth=GetDevicePixelRatio();
            this.Canvas.strokeStyle=this.Color;
        }
        else if(this.Width==0)
        {
            this.SetEmptyBar();
        }
        else if (this.Width==3 || this.Width==50)   //3和50 K线宽度
        {
            if (dataWidth>=4)
            {
                bFillKLine=true; 
                this.SetEmptyBar();
                if (!this.IsEmptyBar()) this.Canvas.fillStyle=this.Color; 
                this.Canvas.strokeStyle=this.Color;
            }
            else    //太细了 画竖线
            {
                this.Canvas.lineWidth=GetDevicePixelRatio();
                this.Canvas.strokeStyle=this.Color;
            }  
        }
        else if (this.Width==101)
        {
            var lineWidth=dataWidth+distanceWidth+1*GetDevicePixelRatio();
            this.Canvas.lineWidth=lineWidth;
            this.Canvas.strokeStyle=this.Color;
        }
        else if (this.Width<=3)
        {
            var minWidth=2*GetDevicePixelRatio();
            var barWidth=dataWidth*(this.Width/3);
            if (barWidth<minWidth) barWidth=minWidth;
            this.SetEmptyBar();
            if (!this.IsEmptyBar()) this.Canvas.fillStyle=this.Color;
            bFillBar=true;
        }
        else
        {
            var barWidth=this.Width*GetDevicePixelRatio()+dataWidth;
            this.SetEmptyBar();
            if (!this.IsEmptyBar()) this.Canvas.fillStyle=this.Color;
            bFillBar=true;
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var price=value.Value;
            var price2=value.Value2;
            if (price2==null) price2=0;

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                var x=left+(right-left)/2;
            }

            var y=this.ChartFrame.GetYFromData(price);
            var y2=this.ChartFrame.GetYFromData(price2);

            if (x>chartright) break;

            if (bFillBar)
            {
                if (isHScreen)
                {
                    var left=x-barWidth/2;
                    var width=barWidth;
                    if (this.IsEmptyBar()) //空心
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(Math.min(y,y2)),ToFixedPoint(left),ToFixedRect(Math.abs(y-y2)),ToFixedRect(width));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(Math.min(y,y2)),ToFixedRect(left),ToFixedRect(Math.abs(y-y2)),ToFixedRect(width));
                    }
                }
                else
                {
                    var left=x-barWidth/2;
                    var width=barWidth;
                    if (left+width>chartright) width=chartright-left; //不要超过右边框子
                    if (this.IsEmptyBar()) //空心
                    {
                        if (emptyBGColor)
                            this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,y2)),ToFixedRect(width),ToFixedRect(Math.abs(y-y2)));

                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(left),ToFixedPoint(Math.min(y,y2)),ToFixedRect(width),ToFixedRect(Math.abs(y-y2)));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(Math.min(y,y2)),ToFixedRect(width),ToFixedRect(Math.abs(y-y2)));
                    }
                }
            }
            else if (bFillKLine)
            {
                if (this.IsEmptyBar())    //空心
                {
                    if (isHScreen)
                    {
                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(Math.min(y,y2)),ToFixedPoint(xOffset),ToFixedRect(Math.abs(y-y2)),ToFixedRect(dataWidth));
                        this.Canvas.stroke();
                    }
                    else
                    {
                        if (emptyBGColor)
                            this.Canvas.fillRect(ToFixedRect(xOffset),ToFixedRect(Math.min(y,y2)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(y-y2)));

                        this.Canvas.beginPath();
                        this.Canvas.rect(ToFixedPoint(xOffset),ToFixedPoint(Math.min(y,y2)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(y-y2)));
                        this.Canvas.stroke();
                    }
                }
                else
                {
                    if (isHScreen) 
                        this.Canvas.fillRect(ToFixedRect(Math.min(y,y2)),ToFixedRect(xOffset),ToFixedRect(Math.abs(y-y2)),ToFixedRect(dataWidth));
                    else 
                        this.Canvas.fillRect(ToFixedRect(xOffset),ToFixedRect(Math.min(y,y2)),ToFixedRect(dataWidth),ToFixedRect(Math.abs(y-y2)));
                }
            }
            else
            {
                if (isHScreen)
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(y,ToFixedPoint(x));
                    this.Canvas.lineTo(y2,ToFixedPoint(x));
                    this.Canvas.stroke();
                }
                else
                {
                    var xFix=parseInt(x.toString())+0.5;
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(xFix,y);  
                    this.Canvas.lineTo(xFix,y2);
                    this.Canvas.stroke();
                }
            }
        }

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        if(!this.Data || !this.Data.Data) return range;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var data=this.Data.Data[i];
            if (data == null) continue;
            var value2=data.Value2;
            if (value2==null) value2=0;
            if (data==null || isNaN(data.Value) ||isNaN(value2)) continue;

            var valueMax=Math.max(data.Value,value2);
            var valueMin=Math.min(data.Value,value2);
            
            if (range.Max==null) range.Max=valueMax;
            if (range.Min==null) range.Min=valueMin;

            if (range.Max<valueMax) range.Max=valueMax;
            if (range.Min>valueMin) range.Min=valueMin;
        }

        return range;
    }
}

function ChartText()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartText';    //类名
    this.TextFont="14px 微软雅黑";

    this.Draw=function()
    {
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;

        for(var i in this.Data.Data)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            var price=value.Value;
            var position=value.Position;

            if (position=='Left')
            {
                var x=this.ChartFrame.GetXFromIndex(0);
                var y=this.ChartFrame.GetYFromData(price);

                if (x>chartright) continue;

                this.Canvas.textAlign='left';
                this.Canvas.textBaseline='middle';
                this.Canvas.fillStyle=value.Color;
                this.Canvas.font=this.TextFont;
                this.Canvas.fillText(value.Message,x,y);
            }

        }

    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        if(!this.Data || !this.Data.Data) return range;

        for(var i in this.Data.Data)
        {
            var data=this.Data.Data[i];
            if (data==null || isNaN(data.Value)) continue;

            var value=data.Value;
            
            if (range.Max==null) range.Max=value;
            if (range.Min==null) range.Min=value;

            if (range.Max<value) range.Max=value;
            if (range.Min>value) range.Min=value;
        }

        return range;
    }
}

/*
    文字输出 支持横屏
    数组(Data)不为null的数据中输出 this.Text文本
*/
function ChartSingleText()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartSingleText';    //类名
    this.Color="rgb(255,193,37)";           //线段颜色
    this.TextFont="14px 微软雅黑";           //线段宽度
    this.Text;
    this.TextAlign='left';
    this.TextBG;            //{ Color:"rgb(0,0,92)", Border:"rgb(205,0,92)", Margin:[0,1,1,1],  }   // { Color:背景色, Border:边框颜色, Margin=[上,下,左, 右] }
    this.Direction=0;       //0=middle 1=bottom 2=top
    this.FixedFontSize=-1;  //固定字体大小
    this.YOffset=0;         //连线      
    this.Position;          //指定输出位置
    this.ShowOffset={ X:0, Y:0 };   //显示偏移
    this.IconFont;          //Iconfont
    this.IconSize=
    { 
        Max: g_JSChartResource.DRAWICON.Icon.MaxSize, Min:g_JSChartResource.DRAWICON.Icon.MinSize, //图标的最大最小值
        Zoom:{ Type:g_JSChartResource.DRAWICON.Icon.Zoom.Type , Value:g_JSChartResource.DRAWICON.Icon.Zoom.Value }, //放大倍数
        YOffset:g_JSChartResource.DRAWICON.Icon.YOffset //Direction==2的向下偏移
    };  

    this.TextSize=
    {
        Max: g_JSChartResource.DRAWICON.Text.MaxSize, Min:g_JSChartResource.DRAWICON.Text.MinSize, //字体的最大最小值
        Zoom:{ Type:g_JSChartResource.DRAWICON.Text.Zoom.Type , Value:g_JSChartResource.DRAWICON.Text.Zoom.Value }, //放大倍数
        FontName:g_JSChartResource.DRAWICON.Text.FontName,
        YOffset:g_JSChartResource.DRAWICON.Text.YOffset
    }

    this.Font=
    {
        DRAWTEXT_FIX:g_JSChartResource.DRAWTEXT_FIX.Font,
        DRAWNUMBER_FIX: g_JSChartResource.DRAWNUMBER_FIX.Font
    }

    this.ExportData=this.ExportBoolData;
    

    this.ReloadResource=function(resource)
    {
        if (this.Name=="DRAWTEXT")
        {
            this.TextSize=
            {
                Max: g_JSChartResource.DRAWTEXT.MaxSize, Min:g_JSChartResource.DRAWTEXT.MinSize, //字体的最大最小值
                Zoom:{ Type:g_JSChartResource.DRAWTEXT.Zoom.Type , Value:g_JSChartResource.DRAWTEXT.Zoom.Value }, //放大倍数
                FontName:g_JSChartResource.DRAWTEXT.FontName,
                YOffset:g_JSChartResource.DRAWTEXT.YOffset
            }
        }
        else if (this.Name=="DRAWNUMBER")
        {
            this.TextSize=
            {
                Max: g_JSChartResource.DRAWNUMBER.MaxSize, Min:g_JSChartResource.DRAWNUMBER.MinSize, //字体的最大最小值
                Zoom:{ Type:g_JSChartResource.DRAWNUMBER.Zoom.Type , Value:g_JSChartResource.DRAWNUMBER.Zoom.Value }, //放大倍数
                FontName:g_JSChartResource.DRAWNUMBER.FontName,
                YOffset:g_JSChartResource.DRAWNUMBER.YOffset
            }
        }
        else if (this.Name=="DRAWTEXT_FIX") 
        {
            this.Font.DRAWTEXT_FIX=g_JSChartResource.DRAWTEXT_FIX.Font;
        }
        else if (this.Name=="DRAWNUMBER_FIX") 
        {
            this.Font.DRAWNUMBER_FIX=g_JSChartResource.DRAWNUMBER_FIX.Font;
        }
    }

    this.SuperGetMaxMin=this.GetMaxMin;
    this.GetMaxMin=function()
    {
        if ( this.Name=="DRAWTEXT_FIX" || this.Name=='DRAWNUMBER_FIX')  //固定位置的 没有大小值
        {
            return { Min:null,Max:null };
        }
        else if (this.Name=="DRAWTEXTREL" || this.Name=="DRAWTEXTABS")
        {
            return { Min:null,Max:null };
        }
        else
        {
            return this.SuperGetMaxMin();
        }
    }

    this.DrawRectText=function()
    {
        if (!this.DrawData) return;
        var isHScreen=(this.ChartFrame.IsHScreen===true)
        var border=this.ChartFrame.GetBorder();
        

        if (this.Name=="DRAWTEXTREL")
        {
            if (isHScreen)
            {
                var height=border.RightTitle-border.LeftEx;
                var width=border.BottomEx-border.TopEx;
                var x=this.DrawData.Point.X/1000*width+border.TopEx;
                var y=border.RightTitle-this.DrawData.Point.Y/1000*width;
            }
            else
            {
                var width=border.RightEx-border.LeftEx;
                var height=border.BottomEx-border.TopTitle;
                var x=this.DrawData.Point.X/1000*width+border.LeftEx;
                var y=this.DrawData.Point.Y/1000*height+border.TopTitle;
            }
            
        }
        else if (this.Name=="DRAWTEXTABS")
        {
            if (isHScreen)
            {
                var x=this.DrawData.Point.X+border.TopEx;
                var y=border.RightTitle-this.DrawData.Point.Y;
            }
            else
            {
                var x=this.DrawData.Point.X+border.LeftEx;
                var y=this.DrawData.Point.Y+border.TopTitle;
            }
        }
        else
        {
            return;
        }

        if (this.Direction==1) this.Canvas.textBaseline='bottom';
        else if (this.Direction==2) this.Canvas.textBaseline='top';
        else this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        this.Canvas.font=this.TextFont;
        this.Canvas.fillStyle=this.Color;
        this.DrawText(this.DrawData.Text,x,y,isHScreen);
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;
        
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (this.Name=="DRAWTEXTREL" || this.Name=="DRAWTEXTABS")
        {
            this.DrawRectText();
            return;
        }

        if (this.Position) 
        {
            this.DrawPosition();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true)
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=this.ChartBorder.GetRight();
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();

        this.Canvas.save();
        this.ClipClient(this.ChartFrame.IsHScreen);

        if (isHScreen) 
        {
            chartright=this.ChartBorder.GetBottom();
            top=this.ChartBorder.GetRightEx();
            bottom=this.ChartBorder.GetLeftEx();
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        var xPointCount=this.ChartFrame.XPointCount;

        var isArrayText=Array.isArray(this.Text);
        var pixelTatio = GetDevicePixelRatio();
        
        var drawTextInfo={ Text:{ }, Font:{ } };
        if (this.Direction==1) 
        {
            this.Canvas.textBaseline='bottom';
            drawTextInfo.Text={ Baseline: 'bottom'};
        }
        else if (this.Direction==2) 
        {
            this.Canvas.textBaseline='top';
            drawTextInfo.Text={ Baseline: 'top'};
        }
        else 
        {
            this.Canvas.textBaseline='middle';
            drawTextInfo.Text={ Baseline: 'middle'};
        }

        if (this.IconFont)
        {
            this.Color=this.IconFont.Color;
            this.Text=this.IconFont.Text;

            if (this.FixedFontSize>0) var iconSize=this.FixedFontSize;
            else var iconSize=this.GetDynamicIconSize(dataWidth,distanceWidth,this.IconSize.Max,this.IconSize.Min,this.IconSize.Zoom);
            this.Canvas.font=iconSize+'px '+this.IconFont.Family;
        }
        else
        {
            if (this.FixedFontSize>0) 
                this.TextFont=`${this.FixedFontSize}px ${this.TextSize.FontName}`;
            else 
                this.TextFont=this.GetDynamicFont(dataWidth,distanceWidth,this.TextSize.Max,this.TextSize.Min,this.TextSize.Zoom,this.TextSize.FontName);
            this.Canvas.font=this.TextFont;
        }

        drawTextInfo.Font={ Height:this.GetFontHeight() };
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }
            
            var y=this.ChartFrame.GetYFromData(value,false);

            if (x>chartright) break;

            y+=this.ShowOffset.Y;
            x+=this.ShowOffset.X;

            this.Canvas.textAlign=this.TextAlign;
            this.Canvas.fillStyle=this.Color;

            drawTextInfo.Text.Color=this.Color;
            drawTextInfo.Text.Align=this.TextAlign;
            drawTextInfo.X=x;
            drawTextInfo.Y=y;
            
            if (this.YOffset>0 && this.Direction>0)
            {
                var yPrice=y;

                this.Canvas.setLineDash([5,10]);
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.beginPath();
                if (isHScreen)
                {
                    if (this.Direction==1) 
                    {
                        y=top-this.YOffset*pixelTatio;
                        yPrice+=5*pixelTatio;
                    }
                    else 
                    {
                        y=bottom+this.YOffset*pixelTatio;
                        yPrice-=5*pixelTatio;
                    }
                    this.Canvas.moveTo(ToFixedPoint(yPrice),ToFixedPoint(x));
                    this.Canvas.lineTo(ToFixedPoint(y),ToFixedPoint(x));
                }
                else
                {
                    if (this.Direction==1) 
                    {
                        y=top+this.YOffset*pixelTatio;
                        yPrice+=5*pixelTatio;
                    }
                    else 
                    {
                        y=bottom-this.YOffset*pixelTatio;
                        yPrice-=5*pixelTatio;
                    }

                    this.Canvas.moveTo(ToFixedPoint(x),ToFixedPoint(yPrice));
                    this.Canvas.lineTo(ToFixedPoint(x),ToFixedPoint(y));
                }
                this.Canvas.stroke();
                this.Canvas.setLineDash([]);
            }

            if (isArrayText)
            {
                var text=this.Text[i];
                if (!text) continue;
                if (this.Name=='DRAWNUMBER')
                {
                    if (this.Direction==1) y-=g_JSChartResource.DRAWABOVE.YOffset*pixelTatio;
                    else if (this.Direction==2) y+=this.TextSize.YOffset*pixelTatio;
                }

                if (this.Name=="DRAWTEXT")  
                    this.DrawTextV2(text,drawTextInfo,isHScreen);
                else 
                    this.DrawText(text,x,y,isHScreen);
            }
            else
            {
                if (this.Name=='DRAWICON')
                {
                    if (this.Direction==1) y-=g_JSChartResource.DRAWABOVE.YOffset*pixelTatio;
                    else if (this.Direction==2) 
                    {
                        if (this.IconFont) y+=this.IconSize.YOffset*pixelTatio;
                        else y+=this.TextSize.YOffset*pixelTatio;
                    }
                }
                else if (this.Name=="DRAWTEXT")
                {
                    if (this.Direction==1) y-=g_JSChartResource.DRAWABOVE.YOffset*pixelTatio;
                    else if (this.Direction==2) y+=this.TextSize.YOffset*pixelTatio;
                }

                if (this.Name=="DRAWTEXT")
                {
                    this.DrawTextV2(this.Text,drawTextInfo,isHScreen);
                }
                else
                {
                    this.DrawText(this.Text,x,y,isHScreen);
                }
            }
        }

        this.Canvas.restore();
    }

    this.DrawPosition=function()    //绘制在指定位置上
    {
        if (!this.Text) return;
        var isHScreen=(this.ChartFrame.IsHScreen===true)
        if (isHScreen)
        {
            var y=this.ChartBorder.GetRightEx()-this.ChartBorder.GetWidthEx()*this.Position.Y;
            var x=this.ChartBorder.GetTop()+this.ChartBorder.GetHeight()*this.Position.X;
        }
        else
        {
            var x=this.ChartBorder.GetLeft()+this.ChartBorder.GetWidth()*this.Position.X;
            var y=this.ChartBorder.GetTopEx()+this.ChartBorder.GetHeightEx()*this.Position.Y;
        }

        this.Canvas.fillStyle=this.Color;

        if (this.Name=="DRAWTEXT_FIX") this.Canvas.font=this.Font.DRAWTEXT_FIX;
        else if (this.Name=="DRAWNUMBER_FIX") this.Canvas.font=this.Font.DRAWNUMBER_FIX;

        //TYPE:0为左对齐,1为右对齐.
        if (this.Position.Type==0) this.Canvas.textAlign='left';
        else if (this.Position.Type==1) this.Canvas.textAlign='right';
        else this.Canvas.textAlign='center';

        if (this.Direction==1) this.Canvas.textBaseline='bottom';
        else if (this.Direction==2) this.Canvas.textBaseline='top';
        else this.Canvas.textBaseline='middle';

        if (Array.isArray(this.Text))
        {
            if (!this.Data || !this.Data.Data) return;
            var xPointCount=this.ChartFrame.XPointCount;
            for(var i=this.Data.DataOffset,j=0; i<this.Data.Data.length && j<xPointCount; ++i,++j)
            {
                var text=this.Text[i];
                if (text)
                {
                    this.DrawText(text,x,y,isHScreen);
                    break;
                }
            }
        }
        else
        {
            this.DrawText(this.Text,x,y,isHScreen);
        }
    }

    this.DrawText=function(text,x,y,isHScreen)
    {
        if (isHScreen)
        {
            this.Canvas.save(); 
            this.Canvas.translate(y, x);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(text,0,0);
            this.Canvas.restore();
        }
        else
        {
            this.Canvas.fillText(text,x,y);
        }
    }

    this.DrawTextV2=function(text, drawInfo, isHScreen)
    {
        var textWidth=this.Canvas.measureText(text).width;

        if (isHScreen)
        {
            var x=drawInfo.Y;
            var y=drawInfo.X;

            if (drawInfo.Text.Align=="right") y=y-textWidth;
            else if (drawInfo.Text.Align=="center") y=y-textWidth/2;

            if (drawInfo.Text.Baseline=="top") x-=drawInfo.Font.Height;
            else if (drawInfo.Text.Baseline=="middle") x-=drawInfo.Font.Height/2;

            if (this.TextBG && (this.TextBG.Color || this.TextBG.Border))
            {
                var margin=this.TextBG.Margin;  //0=上 1=下 2=左 3=右
                var xRect=x-margin[0];
                var yRect=y-margin[2];
                var bgWidth=textWidth+margin[2]+margin[3];
                var bgHeight=drawInfo.Font.Height+margin[0]+margin[1];
                if (this.TextBG.Color)
                {
                    this.Canvas.fillStyle=this.TextBG.Color;
                    this.Canvas.fillRect(xRect,yRect,bgHeight,bgWidth);
                }

                if (this.TextBG.Border)
                {
                    this.Canvas.strokeStyle=this.TextBG.Border;
                    this.Canvas.strokeRect(ToFixedPoint(xRect),ToFixedPoint(yRect),ToFixedRect(bgHeight),ToFixedRect(bgWidth));
                }
            }

            this.Canvas.textBaseline="bottom";
            this.Canvas.textAlign="left";
            this.Canvas.fillStyle=drawInfo.Text.Color;

            this.Canvas.save(); 
            this.Canvas.translate(x, y);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(text,0,0);
            this.Canvas.restore();
        }
        else
        {
            var x=drawInfo.X;
            var y=drawInfo.Y;
            if (drawInfo.Text.Align=="right") x=x-textWidth;
            else if (drawInfo.Text.Align=="center") x=x-textWidth/2;

            if (drawInfo.Text.Baseline=="top") y+=drawInfo.Font.Height;
            else if (drawInfo.Text.Baseline=="middle") y+=drawInfo.Font.Height/2;

            if (this.TextBG && (this.TextBG.Color || this.TextBG.Border))
            {
                var margin=this.TextBG.Margin;  //0=上 1=下 2=左 3=右
                var xRect=x-margin[2];
                var yRect=y-drawInfo.Font.Height-margin[1];
                var bgWidth=textWidth+margin[2]+margin[3];
                var bgHeight=drawInfo.Font.Height+margin[0]+margin[1];
                if (this.TextBG.Color)
                {
                   
                    this.Canvas.fillStyle=this.TextBG.Color;
                    this.Canvas.fillRect(xRect,yRect,bgWidth,bgHeight);
                }

                if (this.TextBG.Border)
                {
                    this.Canvas.strokeStyle=this.TextBG.Border;
                    this.Canvas.strokeRect(ToFixedPoint(xRect),ToFixedPoint(yRect),ToFixedRect(bgWidth),ToFixedRect(bgHeight));
                }
            }

            this.Canvas.textBaseline="bottom";
            this.Canvas.textAlign="left";
            this.Canvas.fillStyle=drawInfo.Text.Color;
            this.Canvas.fillText(text,x,y);
        }
    }
}


function ChartTradeIcon()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartTradeIcon';    //类名
    this.TextAlign='center';
    this.TextBaseline='middle';
    this.SVG={ Family:"iconfont", Size:12 };
    this.AryIcon;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if(!this.Data || !this.Data.Data) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryIcon)) return;

        var bHScreen=(this.ChartFrame.IsHScreen===true);
        this.Canvas.font=`${this.SVG.Size}px ${this.SVG.Family}`;
        this.Canvas.textAlign=this.TextAlign;
        this.Canvas.textBaseline='middle';
        var yOffset=0;
        if (this.TradeType=="BUY" || this.TradeType=="BUYSHORT") 
        {
            this.Canvas.textBaseline="top";
            yOffset+=(bHScreen?-2:2);
        }
        else if (this.TradeType=="SELL" || this.TradeType=="SELLSHORT")
        {
            this.Canvas.textBaseline="bottom";
            yOffset=(bHScreen?2:-2);
        }
       
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;
        var border=this.ChartFrame.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        if (bHScreen) 
        {
            chartright=this.ChartBorder.GetBottom();
            //top=this.ChartBorder.GetRightEx();
            //bottom=this.ChartBorder.GetLeftEx();
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;
            if (value<=0) continue;

            var iconItem=this.AryIcon[i];
            if (!IFrameSplitOperator.IsNumber(iconItem.Value) || !iconItem.Icon) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;

            var x=left+(right-left)/2;
            var y=this.GetYFromData(iconItem.Value, false);

            this.Canvas.fillStyle=iconItem.Color;

            if (dataWidth>2) x=ToFixedPoint(x);

            this.DrawTradeIcon(iconItem.Icon,x,y+yOffset, bHScreen);
        }
    }

    this.DrawTradeIcon=function(text,x,y,isHScreen)
    {
        if (isHScreen)
        {
            this.Canvas.save(); 
            this.Canvas.translate(y, x);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(text,0,0);
            this.Canvas.restore();
        }
        else
        {
            this.Canvas.fillText(text,x,y);
        }
    }

    this.GetMaxMin=function()
    {
        var range={Max:null, Min:null };
        if(!this.Data || !this.Data.Data) return range;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryIcon)) return range;

        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        if (this.ChartFrame.GlobalOption && this.ChartFrame.GlobalOption.IsValueFullRange)
        {
            start=0;
            xPointCount=this.Data.Data.length;
        }

        for(var i=start,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;
            if (value<=0) continue;

            var iconItem=this.AryIcon[i];
            if (!IFrameSplitOperator.IsNumber(iconItem.Value) || !iconItem.Icon) continue;

            if (range.Max==null) range.Max=iconItem.Value;
            else if (range.Max<iconItem.Value) range.Max=iconItem.Value;

            if (range.Min==null) range.Min=iconItem.Value;
            else if (range.Min>iconItem.Value) range.Min=iconItem.Value;
        }

        return range;
    }
}


function ChartDrawText()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawText';         //类名
    this.Color="rgb(255,193,37)";           //线段颜色
    this.TextFont="14px 微软雅黑";           //线段宽度
    this.TextBaseline="middle";
    this.TextAlign='left';
    this.Text
    this.TextBG;            //{ Color:"rgb(0,0,92)", Border:"rgb(205,0,92)", Margin:[0,1,1,1],  }   // { Color:背景色, Border:边框颜色, Margin=[上,下,左, 右] }
    this.FixedFontSize=-1;  //固定字体大小
    this.YOffset=0;         //连线  
    this.FixedPosition=-1;  //固定位置输出 1顶部, 2底部    
    this.VerticalLine;      //垂直线
    this.ShowOffset={ X:0, Y:0 };   //显示偏移
    this.ExportData=this.ExportBoolData;

    this.TextSize=
    {
        Max: g_JSChartResource.DRAWICON.Text.MaxSize, Min:g_JSChartResource.DRAWICON.Text.MinSize, //字体的最大最小值
        Zoom:{ Type:g_JSChartResource.DRAWICON.Text.Zoom.Type , Value:g_JSChartResource.DRAWICON.Text.Zoom.Value }, //放大倍数
        FontName:g_JSChartResource.DRAWICON.Text.FontName,
        YOffset:g_JSChartResource.DRAWICON.Text.YOffset
    }

    this.ReloadResource=function(resource)
    {
        this.TextSize=
        {
            Max: g_JSChartResource.DRAWTEXT.MaxSize, Min:g_JSChartResource.DRAWTEXT.MinSize, //字体的最大最小值
            Zoom:{ Type:g_JSChartResource.DRAWTEXT.Zoom.Type , Value:g_JSChartResource.DRAWTEXT.Zoom.Value }, //放大倍数
            FontName:g_JSChartResource.DRAWTEXT.FontName,
            YOffset:g_JSChartResource.DRAWTEXT.YOffset
        }
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true)
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=this.ChartBorder.GetRight();
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();

        this.Canvas.save();
        this.ClipClient(isHScreen);

        if (isHScreen) 
        {
            chartright=this.ChartBorder.GetBottom();
            top=this.ChartBorder.GetRightEx();
            bottom=this.ChartBorder.GetLeftEx();
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        var xPointCount=this.ChartFrame.XPointCount;

        var isArrayText=Array.isArray(this.Text);
        var drawTextInfo={ Text:{ Color:this.Color, Align:this.TextAlign, Baseline:this.TextBaseline }, Font:{ } };
        

        if (this.FixedFontSize>0)  //固定字体大小模式
            this.TextFont=`${this.FixedFontSize}px ${this.TextSize.FontName}`;
        else    //动态字体大小
            this.TextFont=this.GetDynamicFont(dataWidth,distanceWidth,this.TextSize.Max,this.TextSize.Min,this.TextSize.Zoom,this.TextSize.FontName);

        this.Canvas.font=this.TextFont;
        drawTextInfo.Font={ Height:this.GetFontHeight() };
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (value==null) continue;

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }
            
            var y;
            if (this.FixedPosition===1)
            {
                y=top;
            }
            else if (this.FixedPosition===2)
            {
                y=bottom;
            }
            else
            {
                y=this.ChartFrame.GetYFromData(value,false);
            }
                
            if (x>chartright) break;

            y+=this.ShowOffset.Y;
            x+=this.ShowOffset.X;

            drawTextInfo.X=x;
            drawTextInfo.Y=y;
            
            if (isArrayText)
            {
                var text=this.Text[i];
                if (!text) continue;
                this.DrawText(text,drawTextInfo,isHScreen);
            }
            else
            {
                this.DrawText(this.Text,drawTextInfo,isHScreen);
            }

            this.DrawVerticalLine(i, drawTextInfo, isHScreen);
        }

        this.Canvas.restore();
    }

    this.DrawText=function(text, drawInfo, isHScreen)
    {
        var textWidth=this.Canvas.measureText(text).width;

        if (isHScreen)
        {
            var x=drawInfo.Y;
            var y=drawInfo.X;

            if (drawInfo.Text.Align=="right") y=y-textWidth;
            else if (drawInfo.Text.Align=="center") y=y-textWidth/2;

            if (drawInfo.Text.Baseline=="top") x-=drawInfo.Font.Height;
            else if (drawInfo.Text.Baseline=="middle") x-=drawInfo.Font.Height/2;

            if (this.TextBG && (this.TextBG.Color || this.TextBG.Border))
            {
                var margin=this.TextBG.Margin;  //0=上 1=下 2=左 3=右
                var xRect=x-margin[0];
                var yRect=y-margin[2];
                var bgWidth=textWidth+margin[2]+margin[3];
                var bgHeight=drawInfo.Font.Height+margin[0]+margin[1];
                if (this.TextBG.Color)
                {
                    this.Canvas.fillStyle=this.TextBG.Color;
                    this.Canvas.fillRect(xRect,yRect,bgHeight,bgWidth);
                }

                if (this.TextBG.Border)
                {
                    this.Canvas.strokeStyle=this.TextBG.Border;
                    this.Canvas.strokeRect(ToFixedPoint(xRect),ToFixedPoint(yRect),ToFixedRect(bgHeight),ToFixedRect(bgWidth));
                }

                drawInfo.Rect={Bottom:xRect, Top:xRect+bgHeight };
            }
            else
            {
                var xRect=x;
                var bgHeight=drawInfo.Font.Height;
                drawInfo.Rect={Bottom:xRect, Top:xRect+bgHeight };
            }

            this.Canvas.textBaseline="bottom";
            this.Canvas.textAlign="left";
            this.Canvas.fillStyle=drawInfo.Text.Color;

            this.Canvas.save(); 
            this.Canvas.translate(x, y);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(text,0,0);
            this.Canvas.restore();
        }
        else
        {
            var x=drawInfo.X;
            var y=drawInfo.Y;
            if (drawInfo.Text.Align=="right") x=x-textWidth;
            else if (drawInfo.Text.Align=="center") x=x-textWidth/2;

            if (drawInfo.Text.Baseline=="top") y+=drawInfo.Font.Height;
            else if (drawInfo.Text.Baseline=="middle") y+=drawInfo.Font.Height/2;

            if (this.TextBG && (this.TextBG.Color || this.TextBG.Border))
            {
                var margin=this.TextBG.Margin;  //0=上 1=下 2=左 3=右
                var xRect=x-margin[2];
                var yRect=y-drawInfo.Font.Height-margin[1];
                var bgWidth=textWidth+margin[2]+margin[3];
                var bgHeight=drawInfo.Font.Height+margin[0]+margin[1];
                if (this.TextBG.Color)
                {
                   
                    this.Canvas.fillStyle=this.TextBG.Color;
                    this.Canvas.fillRect(xRect,yRect,bgWidth,bgHeight);
                }

                if (this.TextBG.Border)
                {
                    this.Canvas.strokeStyle=this.TextBG.Border;
                    this.Canvas.strokeRect(ToFixedPoint(xRect),ToFixedPoint(yRect),ToFixedRect(bgWidth),ToFixedRect(bgHeight));
                }

                drawInfo.Rect={Top:yRect, Bottom:yRect+bgHeight };
            }
            else
            {
                var yRect=y-drawInfo.Font.Height;
                var bgHeight=drawInfo.Font.Height;
                drawInfo.Rect={Top:yRect, Bottom:yRect+bgHeight };
            }

            this.Canvas.textBaseline="bottom";
            this.Canvas.textAlign="left";
            this.Canvas.fillStyle=drawInfo.Text.Color;
            this.Canvas.fillText(text,x,y);
        }
    }

    //画连线
    this.DrawVerticalLine=function(index, drawTextInfo, isHScreen)
    {
        if (!this.VerticalLine) return;

        var item=this.VerticalLine.Data[index];
        if (!item) return;
        if (!IFrameSplitOperator.IsNumber(item.High)) return;
        if (!IFrameSplitOperator.IsNumber(item.Low)) return;
        var yHigh=this.ChartFrame.GetYFromData(item.High);
        var yLow=this.ChartFrame.GetYFromData(item.Low);

        var yLine, yLine2;
        if (isHScreen)
        {
            if (drawTextInfo.Rect.Bottom>yHigh)
            {
                yLine=drawTextInfo.Rect.Bottom-1;
                yLine2=yHigh+1;
            }
            else if (drawTextInfo.Rect.Top<yLow)
            {
                yLine=drawTextInfo.Rect.Top-1;
                yLine2=yLow-1;
            }
            else
            {
                return;
            }
        }
        else
        { 
            if (drawTextInfo.Rect.Bottom<yHigh)
            {
                yLine=drawTextInfo.Rect.Bottom+1;
                yLine2=yHigh-1;
            }
            else if (drawTextInfo.Rect.Top>yLow)
            {
                yLine=drawTextInfo.Rect.Top-1;
                yLine2=yLow+1;
            }
            else
            {
                return;
            }
        }

        this.Canvas.save(); 
        var pixelTatio = GetDevicePixelRatio();
        var xLine=drawTextInfo.X;
        if (this.VerticalLine.LineType==1)
        {
            if (this.VerticalLine.LineDotted)
                this.Canvas.setLineDash(this.VerticalLine.LineDotted);
            else 
                this.Canvas.setLineDash([5,10]);
        }

        if (IFrameSplitOperator.IsPlusNumber(this.VerticalLine.LineWidth))
        {
            this.Canvas.lineWidth=this.VerticalLine.LineWidth*pixelTatio;
        }
        
        this.Canvas.strokeStyle=this.VerticalLine.Color;
        this.Canvas.beginPath();
        if (isHScreen)
        {
            this.Canvas.moveTo(ToFixedPoint(yLine),ToFixedPoint(xLine));
            this.Canvas.lineTo(ToFixedPoint(yLine2),ToFixedPoint(xLine));
        }
        else
        {
            this.Canvas.moveTo(ToFixedPoint(xLine),ToFixedPoint(yLine));
            this.Canvas.lineTo(ToFixedPoint(xLine),ToFixedPoint(yLine2));
        }
        this.Canvas.stroke();

        this.Canvas.restore();
    }
}

function ChartDrawNumber()
{
    this.newMethod=ChartDrawText;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawNumber';         //类名

    this.ReloadResource=function(resource)
    {
        this.TextSize=
        {
            Max: g_JSChartResource.DRAWNUMBER.MaxSize, Min:g_JSChartResource.DRAWNUMBER.MinSize, //字体的最大最小值
            Zoom:{ Type:g_JSChartResource.DRAWNUMBER.Zoom.Type , Value:g_JSChartResource.DRAWNUMBER.Zoom.Value }, //放大倍数
            FontName:g_JSChartResource.DRAWNUMBER.FontName,
            YOffset:g_JSChartResource.DRAWNUMBER.YOffset
        }
    }
}

//直线 水平直线 只有1个数据
function ChartStraightLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartStraightLine';    //类名
    this.Color="rgb(255,193,37)";   //线段颜色

    this.Draw=function()
    {
        if (!this.Data || !this.Data.Data) return;
        if (this.Data.Data.length!=1) return;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;

        var yValue=this.Data.Data[0];
        var y=this.ChartFrame.GetYFromData(yValue);
        var xLeft=this.ChartFrame.GetXFromIndex(0);
        var xRight=this.ChartFrame.GetXFromIndex(xPointCount-1);

        var yFix=parseInt(y.toString())+0.5;
        this.Canvas.beginPath();
        this.Canvas.moveTo(xLeft,yFix);
        this.Canvas.lineTo(xRight,yFix);
        this.Canvas.strokeStyle=this.Color;
        this.Canvas.stroke();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        if (!this.Data || !this.Data.Data) return range;
        if (this.Data.Data.length!=1) return range;

        range.Min=this.Data.Data[0];
        range.Max=this.Data.Data[0];

        return range;
    }
}

/*  
    水平面积 只有1个数据
    Data 数据结构 
    Value, Value2  区间最大最小值
    Color=面积的颜色
    Title=标题 TitleColor=标题颜色
    支持横屏
*/
function ChartStraightArea() 
{
    this.newMethod = IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartStraightArea';    //类名
    this.Color = "rgb(255,193,37)";   //线段颜色
    this.Font ='11px 微软雅黑';

    this.Draw = function () 
    {
        if (this.ChartFrame.IsMinSize) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        if (this.ChartFrame.IsHScreen===true)
        {
            this.HScreenDraw();
            return;
        }

        var dataWidth = this.ChartFrame.DataWidth;
        var distanceWidth = this.ChartFrame.DistanceWidth;
        var chartright = this.ChartBorder.GetRight();
        var bottom = this.ChartBorder.GetBottom();
        var left = this.ChartBorder.GetLeft();
        var xPointCount = this.ChartFrame.XPointCount;

        var xRight = this.ChartFrame.GetXFromIndex(xPointCount - 1);

        for(let i in this.Data.Data)
        {
            let item=this.Data.Data[i];
            if (item==null || isNaN(item.Value) || isNaN(item.Value2)) continue;
            if (item.Color==null) continue;

            let valueMax=Math.max(item.Value,item.Value2);
            let valueMin=Math.min(item.Value,item.Value2);

            var yTop=this.ChartFrame.GetYFromData(valueMax);
            var yBottom=this.ChartFrame.GetYFromData(valueMin);

            this.Canvas.fillStyle = item.Color;
            this.Canvas.fillRect(ToFixedRect(left), ToFixedRect(yTop), ToFixedRect(xRight - left), ToFixedRect(yBottom - yTop));

            if(item.Title && item.TitleColor)
            {
              this.Canvas.textAlign = 'right';
              this.Canvas.textBaseline = 'middle';
              this.Canvas.fillStyle = item.TitleColor;
              this.Canvas.font = this.Font;
              let y = yTop + (yBottom - yTop)/2;
              this.Canvas.fillText(item.Title, xRight, y);
            }
        }
    }

    this.HScreenDraw=function()
    {
        var bottom = this.ChartBorder.GetBottom();
        var top=this.ChartBorder.GetTop();
        var height=this.ChartBorder.GetHeight();

        for(let i in this.Data.Data)
        {
            let item=this.Data.Data[i];
            if (item==null || isNaN(item.Value) || isNaN(item.Value2)) continue;
            if (item.Color==null) continue;

            let valueMax=Math.max(item.Value,item.Value2);
            let valueMin=Math.min(item.Value,item.Value2);

            var yTop=this.ChartFrame.GetYFromData(valueMax);
            var yBottom=this.ChartFrame.GetYFromData(valueMin);

            this.Canvas.fillStyle = item.Color;
            this.Canvas.fillRect(ToFixedRect(yBottom), ToFixedRect(top), ToFixedRect(yTop-yBottom),ToFixedRect(height));

            if(item.Title && item.TitleColor)
            {
                var xText=yTop + (yBottom - yTop)/2;
                var yText=bottom;
                this.Canvas.save(); 
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180);

                this.Canvas.textAlign = 'right';
                this.Canvas.textBaseline = 'middle';
                this.Canvas.fillStyle = item.TitleColor;
                this.Canvas.font = this.Font;
                this.Canvas.fillText(item.Title, 0, -2);

                this.Canvas.restore();
            }
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        if (!this.Data || !this.Data.Data) return range;
        
        for (let i in this.Data.Data)
        {
          let item = this.Data.Data[i];
            if (item==null || isNaN(item.Value) || isNaN(item.Value2)) continue;

            let valueMax=Math.max(item.Value,item.Value2);
            let valueMin=Math.min(item.Value,item.Value2);

            if (range.Max==null) range.Max=valueMax;
            if (range.Min==null) range.Min=valueMin;

            if (range.Max<valueMax) range.Max=valueMax;
            if (range.Min>valueMin) range.Min=valueMin;
        }

        return range;
    }
}

//分钟线 支持横屏
function ChartMinutePriceLine()
{
    this.newMethod=ChartLine;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartMinutePriceLine';    //类名
    this.YClose;
    this.IsDrawArea=true;    //是否画价格面积图
    this.AreaColor='rgba(0,191,255,0.1)';
    this.IsShowLead=false;
    this.LeadData;
    this.UpColor=g_JSChartResource.UpBarColor;
    this.DownColor=g_JSChartResource.DownBarColor;

    this.BeforeOpenData;    //盘前数据 Data:[] 数据, TotalCount:一共的数据个数
    this.BeforeLineColor=g_JSChartResource.Minute.Before.LineColor;
    this.BeforeAvPriceColor=g_JSChartResource.Minute.Before.AvPriceColor;
    this.BeforePoint=CloneData(g_JSChartResource.Minute.Before.Point);

    this.AfterCloseData;    //盘后数据
    this.AfterLineColor=g_JSChartResource.Minute.After.LineColor;
    this.AfterAvPriceColor=g_JSChartResource.Minute.After.AvPriceColor;
    this.AfterPoint=CloneData(g_JSChartResource.Minute.After.Point);

    this.MultiDayBeforeOpenData;    //多日分时图 盘前数据 数组 1天一个
    this.MultiDayAfterCloseData;    //多日分时图 盘后数据 数组 1天一个

    this.ColorLineData;     //自定义价格线分段颜色
    this.Source;            //原始分钟数据

    this.PtInChart=this.PtInLine;
    this.DrawSelectedStatus=this.DrawLinePoint;

    this.PtInChart=this.PtInLine;
    this.DrawSelectedStatus=this.DrawLinePoint;

    this.DayOffset;

    this.LastPoint={};  //最后一个点的信息 {X, Y, Data:, Value:, DateTime:YYYYMMDDHHMMSS }
    this.FFMChart; //定制图形
    this.DrawType=0;    //0=走势图 14=定制图形


    this.UpdateLastPoint=function(dateTime, x,y, item)
    {
        if (IFrameSplitOperator.IsNumber(this.LastPoint.DateTime) && this.LastPoint.DateTime>dateTime) return;

        this.LastPoint.DateTime=dateTime;
        this.LastPoint.X=x;
        this.LastPoint.Y=y;
        this.LastPoint.Data=item;
        this.LastPoint.Value=item.Value;
    }

    this.Draw=function()
    {
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        this.LastPoint={};
        if (!this.IsShow) return;

        if (this.DrawType==14)
        {
            if (this.FFMChart && this.FFMChart.Draw)
                this.FFMChart.Draw(this);
            return;
        }

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen===true) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        var minuteCount=this.ChartFrame.MinuteCount;
        var bottom=this.ChartBorder.GetBottom();
        var left=this.ChartBorder.GetLeft();
        var data=this.Data;

        this.DrawBeforeOpen();   //盘前
        this.DrawMultiDayBeforeOpen();

        if (this.IsShowLead) this.DrawLead();   //领先指标

        if (!data) return;

        var bFirstPoint=true;
        var ptFirst={}; //第1个点
        var drawCount=0;
        var pointCount=0;
        
        this.Canvas.save();
        if (IFrameSplitOperator.IsPlusNumber(this.LineWidth>0)) this.Canvas.lineWidth=this.LineWidth;
        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var value=null;
            value=data.Data[i];
            ++pointCount;
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value);

            if (bFirstPoint)
            {
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(y,x);
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
                ptFirst={X:x,Y:y};
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            if (this.Source)
            {
                var item=this.Source.Data[i];
                var dateTime=item.Date*1000000+item.Time*100;
                this.UpdateLastPoint(dateTime, x,y, { Value:value, Index:i, Date:item.Date, Time:item.Time, Type:0,  Explain:"盘中"});
            }
          
            ++drawCount;

            if (pointCount>=minuteCount) //上一天的数据和这天地数据线段要断开
            {
                bFirstPoint=true;
                this.Canvas.stroke();
                if (this.IsDrawArea)   //画面积
                {
                    if (isHScreen)
                    {
                        this.Canvas.lineTo(left,x);
                        this.Canvas.lineTo(left,ptFirst.X);
                        this.SetFillStyle(this.AreaColor,this.ChartBorder.GetRightEx(),bottom,this.ChartBorder.GetLeftEx(),bottom);
                    }
                    else
                    {
                        this.Canvas.lineTo(x,bottom);
                        this.Canvas.lineTo(ptFirst.X,bottom);
                        this.SetFillStyle(this.AreaColor, left,this.ChartBorder.GetTopEx(), left,bottom);
                    }
                    
                    this.Canvas.fill();
                }
                pointCount=0;
                drawCount=0;
            }
        }

        if (drawCount>0)
        {
            if (drawCount==1)   //如果线段只有1个点 线段无法画出来 直接画点
            {
                this.Canvas.beginPath();
                if (isHScreen)
                    this.Canvas.arc(ptFirst.Y, ptFirst.X, 1,0,360, false);
                else
                    this.Canvas.arc(ptFirst.X, ptFirst.Y, 1,0,360, false);
                    
                this.Canvas.closePath();
                this.Canvas.fillStyle=this.Color;
                this.Canvas.fill();
            }
            else
            {
                this.Canvas.stroke();
                if (this.IsDrawArea)   //画面积
                {
                    if (isHScreen)
                    {
                        this.Canvas.lineTo(left,x);
                        this.Canvas.lineTo(left,ptFirst.X);
                        this.SetFillStyle(this.AreaColor,this.ChartBorder.GetRightEx(),bottom,this.ChartBorder.GetLeftEx(),bottom);
                    }
                    else
                    {
                        this.Canvas.lineTo(x,bottom);
                        this.Canvas.lineTo(ptFirst.X,bottom);
                        this.SetFillStyle(this.AreaColor,left,this.ChartBorder.GetTopEx(), left,bottom);
                    }

                    this.Canvas.fill();
                }
            }
        }

        this.Canvas.restore();

        this.DrawColorLine();
        this.DrawAfterClose();      //收盘集合竞价
        this.DrawMultiDayAfterClose();

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAW_MINUTE_LAST_POINT);
            if (event)
            {
                var pixelRatio=GetDevicePixelRatio();
                var data=
                { 
                    InterLastPoint:{X:this.LastPoint.X, Y:this.LastPoint.Y},    //内部点 给画布用
                    LastPoint:{X:this.LastPoint.X/pixelRatio, Y:this.LastPoint.Y/pixelRatio},   //外部点 给DOM用
                    Price:this.LastPoint.Price, Data:this.LastPoint.Data,
                    PixelRatio:pixelRatio,
                };
                event.Callback(event,data,this);
            }
        }
    }

    //画领先指标
    this.DrawLead=function()
    {
        if (!this.LeadData) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        //if (isHScreen) return;
        //var dataWidth=this.ChartFrame.DataWidth;
        //var distanceWidth=this.ChartFrame.DistanceWidth;
        //var chartright=this.ChartBorder.GetRight();
       
        var xPointCount=this.ChartFrame.XPointCount;
        var minuteCount=this.ChartFrame.MinuteCount;
        var bottom=this.ChartBorder.GetBottomEx();
        var top=this.ChartBorder.GetTopEx();
        if (isHScreen===true) top=this.ChartBorder.GetRightEx();

        if (xPointCount>minuteCount) return;

        var aryLead=[]; //{X: Value:}
        var max=null, min=null;
        var yCenter=this.ChartFrame.GetYFromData(this.YClose);
        var leadHeight=(yCenter-top)/3;
        var data=this.LeadData;
        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var value=data.Data[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;
            if (value==0) continue;
            var x=this.ChartFrame.GetXFromIndex(j);

            if (max==null || max<value) max=value;
            if (min==null || min>value) min=value;

            aryLead.push({X:x, Value:value})
        }

        if (aryLead.length<=0) return;
        var maxValue=Math.max(Math.abs(max),Math.abs(min));

        for(var i in aryLead)
        {
            var item=aryLead[i];
            if (item.Value>0) this.Canvas.strokeStyle=this.UpColor;
            else this.Canvas.strokeStyle=this.DownColor;

            var y=yCenter-(item.Value*leadHeight/maxValue);
            var x=ToFixedPoint(item.X);
            this.Canvas.beginPath();
            if (isHScreen===true)
            {
                this.Canvas.moveTo(yCenter,x);
                this.Canvas.lineTo(y,x);
            }
            else
            { 
                this.Canvas.moveTo(x,yCenter);
                this.Canvas.lineTo(x,y);
            }
            this.Canvas.stroke();
        }
    }

    this.DrawBeforeOpen=function()
    {
        if (this.ChartBorder.LeftExtendWidth<10) return;
        if (!this.BeforeOpenData) return;

        this.DrawCallAuction(-1, this.BeforeOpenData, true); 
    }

    this.DrawAfterClose=function()
    {
        if (this.ChartBorder.RightExtendWidth<10) return;
        if (!this.AfterCloseData) return;

        this.DrawCallAuction(-1, this.AfterCloseData, false); 
    }

    this.DrawMultiDayBeforeOpen=function()
    {
        if (this.ChartBorder.MultiDayMinute.Count<=1 || this.ChartBorder.MultiDayMinute.Left<=0) return;
        if (!this.MultiDayBeforeOpenData) return;

        var offset=0, showDayCount=this.MultiDayBeforeOpenData.length;
        if (this.DayOffset)
        {
            if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
            if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
        }
        
        for(var i=offset,j=0; i<this.MultiDayBeforeOpenData.length && j<showDayCount; ++i,++j)
        {
            var dayItem=this.MultiDayBeforeOpenData[i];
            this.DrawCallAuction(j, dayItem, true);
        }
    }

    this.DrawMultiDayAfterClose=function()
    {
        if (this.ChartBorder.MultiDayMinute.Count<=1 || this.ChartBorder.MultiDayMinute.Right<=0) return;
        if (!this.MultiDayAfterCloseData) return;

        var offset=0,showDayCount=this.MultiDayAfterCloseData.length;
        if (this.DayOffset)
        {
            if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
            if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
        }

        for(var i=offset,j=0; i<this.MultiDayAfterCloseData.length && j<showDayCount; ++i,++j)
        {
            var dayItem=this.MultiDayAfterCloseData[i];
            this.DrawCallAuction(j, dayItem, false);
        }
    }

    this.DrawCallAuction=function(indexDay, callAutionData, isBeforeOpen)
    {
        if (!callAutionData) return;

        callAutionData.Index=indexDay;
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var bFirstPoint=true;
        var drawCount=0;
        var callAutionInfo={ TotalCount:callAutionData.TotalCount };
        if (callAutionData.Ver==3.0)   //均线
        {
            for(var i=0; i<callAutionData.Data.length; ++i)
            {
                var item=callAutionData.Data[i];
                if (!item || !IFrameSplitOperator.IsNumber(item.AvPrice)) continue;
    
                if (isBeforeOpen)
                {
                    var x=this.ChartFrame.GetLeftExtendXFromIndex(i,callAutionData);
                    var y=this.ChartFrame.GetLeftExtendYFromData(item.AvPrice);
                }
                else
                {
                    var x=this.ChartFrame.GetRightExtendXFromIndex(i,callAutionData);
                    var y=this.ChartFrame.GetRightExtendYFromData(item.AvPrice);
                }
                
                if (bFirstPoint)
                {
                    this.Canvas.strokeStyle=this.BeforeAvPriceColor;
                    this.Canvas.beginPath();
                    if (isHScreen) this.Canvas.moveTo(y,x);
                    else this.Canvas.moveTo(x,y);
                    bFirstPoint=false;
                }
                else
                {
                    if (isHScreen) this.Canvas.lineTo(y,x);
                    else this.Canvas.lineTo(x,y);
                }
    
                ++drawCount;
            }
    
            if (drawCount>0)
            {
                this.Canvas.stroke();
            }
        }

        var bFirstPoint=true;
        var drawCount=0;
        var aryPoint=[];
        for(var i=0; i<callAutionData.Data.length; ++i)
        {
            var item=callAutionData.Data[i];
            if (!item || !IFrameSplitOperator.IsNumber(item.Price)) 
            {
                if (i==0 && isBeforeOpen && IFrameSplitOperator.IsNumber(this.YClose))
                {
                    var x=this.ChartFrame.GetLeftExtendXFromIndex(i,callAutionData);
                    var y=this.ChartFrame.GetLeftExtendYFromData(this.YClose);

                    this.Canvas.strokeStyle=this.BeforeLineColor;
                    this.Canvas.beginPath();
                    if (isHScreen) this.Canvas.moveTo(y,x);
                    else this.Canvas.moveTo(x,y);
                    bFirstPoint=false;
                }

                continue;
            }

            if (isBeforeOpen)
            {
                var x=this.ChartFrame.GetLeftExtendXFromIndex(i,callAutionData);
                var y=this.ChartFrame.GetLeftExtendYFromData(item.Price);
            }
            else
            {
                var x=this.ChartFrame.GetRightExtendXFromIndex(i,callAutionData);
                var y=this.ChartFrame.GetRightExtendYFromData(item.Price);
            }

            if (bFirstPoint)
            {
                this.Canvas.strokeStyle=(isBeforeOpen? this.BeforeLineColor:this.AfterLineColor);
                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(y,x);
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;

                aryPoint.push({X:x, Y:y });
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);

                aryPoint.push({X:x, Y:y });
            }

           
            var dateTime=item.Date*1000000+item.Time;
            this.UpdateLastPoint(dateTime, x,y, { Value:item.Price, Index:i, Date:item.Date, Time:item.Time, Type:isBeforeOpen?1:2,  Explain:isBeforeOpen?"盘前":"盘后"});

            ++drawCount;
        }

        if (drawCount>0)
        {
            this.Canvas.stroke();
        }

        if (callAutionData.Ver==2.0 && this.BeforePoint.Radius>0)
        {
            this.Canvas.fillStyle=(isBeforeOpen? this.BeforePoint.Color : this.AfterPoint.Color);
            for(var i in aryPoint)
            {
                var item=aryPoint[i];

                this.Canvas.beginPath();
                if (isHScreen)  this.Canvas.arc(item.Y, item.X, this.BeforePoint.Radius, 0, 2 * Math.PI);
                else  this.Canvas.arc(item.X, item.Y, this.BeforePoint.Radius, 0, 2 * Math.PI);
                this.Canvas.fill();
            }
            
        }
    }

    this.FindColorLineItem=function(minuteItem)
    {
        if (!minuteItem || !this.ColorLineData) return null;

        for(var i in this.ColorLineData)
        {
            var item=this.ColorLineData[i];
            if (item.Date==minuteItem.Date && (minuteItem.Time>=item.Start && minuteItem.Time<=item.End))
            {
                return item;
            }
        }

        return null;
    }

    //TODO:这个函数比较耗时间 后面再优化吧
    this.DrawColorLine=function()
    {
        if (!this.ColorLineData|| !this.Source || !this.Data) return;
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var border=this.ChartBorder.GetBorder();
        var xPointCount=this.ChartFrame.XPointCount;
        var minuteCount=this.ChartFrame.MinuteCount;
        var data=this.Data;

        var bFirstPoint=true;
        var ptLast={};  //最后一个点
        var ptFirst={};
        var drawCount=0;
        var preColor=null;
        this.Canvas.save();

        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var value=null;
            value=data.Data[i];
            var item=this.Source.Data[i];
            if (!value || !item) continue;

            var colorItem=this.FindColorLineItem(item);
            if (!colorItem)
            {
                if (drawCount>0)
                {
                    this.Canvas.stroke();
                    bFirstPoint=true;
                }
                continue;
            }

            if (preColor && preColor!=colorItem.Color)
            {
                this.Canvas.stroke();
                bFirstPoint=true;

                /*
                this.Canvas.strokeStyle=colorItem.Color;
                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(ptLast.Y,ptLast.X);
                else this.Canvas.moveTo(ptLast.X,ptLast.Y);
                bFirstPoint=false;
                preColor=colorItem.Color;
                */
            }

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value);

            if (bFirstPoint)
            {
                this.Canvas.strokeStyle=colorItem.Color;
                if (IFrameSplitOperator.IsNumber(colorItem.LineWidth))
                    this.Canvas.lineWidth=colorItem.LineWidth;

                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(y,x);
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
                ptFirst={X:x,Y:y};
                preColor=colorItem.Color;
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ptLast.X=x;
            ptLast.Y=y;
            ptLast.Price=value;

            ++drawCount;
        }

        if (drawCount>0)
        {
            this.Canvas.stroke();
        }

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        if (this.DrawType==14)
        {
            if (this.FFMChart && this.FFMChart.GetMaxMin)
                return this.FFMChart.GetMaxMin(this);
        }

        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        if (this.YClose==null) return range;
        if (!this.IsShow) return range;

        range.Min=this.YClose;
        range.Max=this.YClose;

        if (this.ChartBorder.LeftExtendWidth>10 && this.BeforeOpenData)
        {
            for(var i in this.BeforeOpenData.Data)
            {
                var item=this.BeforeOpenData.Data[i];
                if (!item) continue;
                if (IFrameSplitOperator.IsNumber(item.Price))
                {
                    if (range.Max==null) range.Max=item.Price;
                    if (range.Min==null) range.Min=item.Price;
    
                    if (range.Max<item.Price) range.Max=item.Price;
                    if (range.Min>item.Price) range.Min=item.Price;
                }
                
                //集合竞价均线统计
                if (this.BeforeOpenData.Ver==3.0 && IFrameSplitOperator.IsNumber(item.AvPrice))
                {
                    if (range.Max==null) range.Max=item.AvPrice;
                    if (range.Min==null) range.Min=item.AvPrice;
    
                    if (range.Max<item.AvPrice) range.Max=item.AvPrice;
                    if (range.Min>item.AvPrice) range.Min=item.AvPrice;
                }
            }
        }
        

        //价格数据
        var data=this.Data;
        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var value=null;
            value=data.Data[i];
            
            if (value==null) continue;

            if (range.Max==null) range.Max=value;
            if (range.Min==null) range.Min=value;

            if (range.Max<value) range.Max=value;
            if (range.Min>value) range.Min=value;
        }

        if (range.Max==this.YClose && range.Min==this.YClose)
        {
            range.Max=this.YClose+this.YClose*0.1;
            range.Min=this.YClose-this.YClose*0.1;
            return range;
        }

        var distance=Math.max(Math.abs(this.YClose-range.Max),Math.abs(this.YClose-range.Min));
        range.Max=this.YClose+distance;
        range.Min=this.YClose-distance;

        return range;
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        if (isHScreen) return false;
        if (!this.IsShow) return false;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return false;
        var position=this.ChartBorder.PtInClient(x,y,this.Canvas,isHScreen);
        if (position!=1) return false;
        
        var data=this.Data;
        var index=this.ChartFrame.GetXData(x);
        var end=Math.ceil(index);
        var start=Math.floor(index);

        if (end>=data.Data.length || start>=data.Data.length) return false;

        var lineWidth=5;
        if (end==start)
        {
            var value=data.Data[start];
        }
        else
        {
            var startValue=data.Data[start];
            var endValue=data.Data[end];
            var ptStart={X:this.ChartFrame.GetXFromIndex(start), Y:this.ChartFrame.GetYFromData(startValue)};
            var ptEnd={X:this.ChartFrame.GetXFromIndex(end), Y:this.ChartFrame.GetYFromData(endValue)};

            this.Canvas.beginPath();
            this.Canvas.moveTo(ptStart.X,ptStart.Y+lineWidth);
            this.Canvas.lineTo(ptStart.X,ptStart.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y+lineWidth);
            this.Canvas.closePath();
            if (this.Canvas.isPointInPath(x,y))
            {
                tooltip.Data={ Index:index, Start:{ Index:start, Item:data.Data[start] }, End:{ Index:end, Value:data.Data[end]} };
                tooltip.ChartPaint=this;
                tooltip.Type=5; //走势图线
                return true;
            }
        }

        return false;
    }
}

//分钟线叠加 支持横屏
function ChartOverlayMinutePriceLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Color="rgb(65,105,225)";
    this.MainData;                  //主图数据
    this.SourceData;                //原始数据

    this.ClassName="ChartOverlayMinutePriceLine";
    this.Title;
    this.Symbol;                    //叠加的股票代码
    this.Status=OVERLAY_STATUS_ID.STATUS_NONE_ID;

    this.OverlayType=0; //叠加方式 0=百分比叠加  1=绝对叠加
    this.IsCalcuateMaxMin=true; //是否参与计算Y轴的最大最小值

    this.SetOption=function(option)
    {
        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.OverlayType)) this.OverlayType=option.OverlayType;
            if (IFrameSplitOperator.IsBool(option.IsCalcuateMaxMin)) this.IsCalcuateMaxMin=option.IsCalcuateMaxMin;
        }
    }

    this.PtInChart=function(x,y)
    {
        var option={ MinuteOverlayPrice:true, OverlayType:this.OverlayType };
        return this.PtInLine(x, y, option);
    }

    this.DrawSelectedStatus=function()
    {
        var option={ MinuteOverlayPrice:true, OverlayType:this.OverlayType };
        this.DrawLinePoint(option);
    }

    this.Draw=function()
    {
        if (!this.Data) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen===true) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        var minuteCount=this.ChartFrame.MinuteCount;

        this.Canvas.save();
        this.ClipClient(isHScreen);

        var bFirstPoint=true;
        var drawCount=0;
        var xOffset=0, showValue=0;
        var yClose=null, mainYClose=null;
        var pointCount=0;
        for(var i=this.Data.DataOffset+xOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var item=this.Data.Data[i];
            if (item && IFrameSplitOperator.IsNumber(item.Close)) 
            {
                if (bFirstPoint)    //百分比使用每天的昨收计算
                {
                    yClose=item.YClose;
                    var minItem=this.MainData.Data[i];
                    mainYClose=minItem.YClose;
                }

                var value=item.Close;
                showValue=value;           //绝对叠加

                if (this.OverlayType==0) 
                    showValue=value/yClose*mainYClose;   //百分比

                var x=this.ChartFrame.GetXFromIndex(j);
                var y=this.ChartFrame.GetYFromData(showValue, false);

                if (bFirstPoint)
                {
                    this.Canvas.strokeStyle=this.Color;
                    this.Canvas.beginPath();
                    if (isHScreen) this.Canvas.moveTo(y,x);
                    else this.Canvas.moveTo(x,y);
                    bFirstPoint=false;
                }
                else
                {
                    if (isHScreen) this.Canvas.lineTo(y,x);
                    else this.Canvas.lineTo(x,y);
                }

                ++drawCount;
            }

            ++pointCount;

            if (pointCount>=minuteCount) //上一天的数据和这天地数据线段要断开
            {
                bFirstPoint=true;
                pointCount=0;
                if (drawCount>0) this.Canvas.stroke();
                drawCount=0;
            }
        }

        if (drawCount>0) this.Canvas.stroke();

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={ Min:null, Max:null };
        if (!this.IsCalcuateMaxMin) return range;

        var minuteCount=this.ChartFrame.MinuteCount;
        var yClose=null, mainYClose=null;
        var bFirstPoint=true;
        var pointCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var item=this.Data.Data[i];
            if (!item || !IFrameSplitOperator.IsNumber(item.Close)) 
            {
                ++pointCount;
                continue;
            }

            if (bFirstPoint)
            {
                yClose=item.YClose;
                var minItem=this.MainData.Data[i];
                mainYClose=minItem.YClose;
                bFirstPoint=false;
            }

            var value=item.Close;
            if (this.OverlayType==0) value=value/yClose*mainYClose;

            if (range.Max==null) range.Max=value;
            if (range.Min==null) range.Min=value;

            if (range.Max<value) range.Max=value;
            if (range.Min>value) range.Min=value;

            ++pointCount;

            if (pointCount>=minuteCount)
            {
                bFirstPoint=true;
                pointCount=0;
            }
        }

        //JSConsole.Chart.Log(`[ChartOverlayMinutePriceLine::GetMaxMin] max=${range.Max} min=${range.Min}`);
        return range;
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        if (isHScreen) return false;
        if (!this.IsShow) return false;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return false;
        if (!IFrameSplitOperator.IsNumber(this.YClose) || !IFrameSplitOperator.IsNumber(this.MainYClose)) return false;

        var position=this.ChartBorder.PtInClient(x,y,this.Canvas,isHScreen);
        if (position!=1) return false;

        var data=this.Data;
        var index=this.ChartFrame.GetXData(x);
        var end=Math.ceil(index);
        var start=Math.floor(index);

        if (end>=data.Data.length || start>=data.Data.length) return false;

        var lineWidth=5;
        if (end==start)
        {
            var value=data.Data[start];
        }
        else
        {
            var startValue=data.Data[start].Close
            startValue=startValue/this.YClose*this.MainYClose;
            var endValue=data.Data[end].Close
            endValue=endValue/this.YClose*this.MainYClose;
            var ptStart={X:this.ChartFrame.GetXFromIndex(start), Y:this.ChartFrame.GetYFromData(startValue)};
            var ptEnd={X:this.ChartFrame.GetXFromIndex(end), Y:this.ChartFrame.GetYFromData(endValue)};

            this.Canvas.beginPath();
            this.Canvas.moveTo(ptStart.X,ptStart.Y+lineWidth);
            this.Canvas.lineTo(ptStart.X,ptStart.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y+lineWidth);
            this.Canvas.closePath();
            if (this.Canvas.isPointInPath(x,y))
            {
                tooltip.Data={ Index:index, Start:{ Index:start, Item:data.Data[start] }, End:{ Index:end, Value:data.Data[end]} };
                tooltip.ChartPaint=this;
                tooltip.Type=6; //走势图线
                //tooltip.Stock={Symbol:this.Symbol, Name:this.Title };
                return true;
            }
        }

        return false;
    }
}


//分钟持仓线
function ChartMinutePositionLine()
{
    this.newMethod=ChartLine;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartMinutePositionLine';    //类名

    this.Draw=function()
    {
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.IsShow) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen===true) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;
        var minuteCount=this.ChartFrame.MinuteCount;
        var bottom=this.ChartBorder.GetBottomEx();
        var left=this.ChartBorder.GetLeftEx();
        var data=this.Data;

        if (!data) return;

        var bFirstPoint=true;
        var ptFirst={}; //第1个点
        var ptLast={};  //最后一个点
        var drawCount=0;
        var pointCount=0;

        this.Canvas.save();

        if (IFrameSplitOperator.IsPlusNumber(this.LineWidth>0)) this.Canvas.lineWidth=this.LineWidth;
        if (this.IsDotLine) this.Canvas.setLineDash(g_JSChartResource.DOTLINE.LineDash); //画虚线

        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var value=null;
            value=data.Data[i];
            ++pointCount;
            if (value==null) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value);

            if (bFirstPoint)
            {
                this.Canvas.strokeStyle=this.Color;
                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(y,x);
                else this.Canvas.moveTo(x,y);
                bFirstPoint=false;
                ptFirst={X:x,Y:y};
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(y,x);
                else this.Canvas.lineTo(x,y);
            }

            ptLast.X=x;
            ptLast.Y=y;
            ptLast.Price=value;

            ++drawCount;

            if (pointCount>=minuteCount) //上一天的数据和这天地数据线段要断开
            {
                bFirstPoint=true;
                this.Canvas.stroke();
                pointCount=0;
                drawCount=0;
            }
        }

        if (drawCount>0) 
        {
            if (drawCount==1)   //如果线段只有1个点 线段无法画出来 直接画点
            {
                this.Canvas.beginPath();
                if (isHScreen)
                    this.Canvas.arc(ptFirst.Y, ptFirst.X, 1,0,360, false);
                else
                    this.Canvas.arc(ptFirst.X, ptFirst.Y, 1,0,360, false);
                    
                this.Canvas.closePath();
                this.Canvas.fillStyle=this.Color;
                this.Canvas.fill();
            }
            else
            {
                this.Canvas.stroke();
            }
        }

        this.Canvas.restore();
    }
}

//分钟信息地雷 支持横屏
function ChartMinuteInfo()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartMinuteInfo";
    this.Data=new Map()  //Map key=date-time, value=[{Date, Time, Title, Type, ID:}]
    this.SourceData;
    this.ChartMinutePrice;
    this.YClose;
    this.HQChartBorder;

    this.TextColor=g_JSChartResource.MinuteInfo.TextColor;
    this.Font=g_JSChartResource.MinuteInfo.Font;
    this.PointColor=g_JSChartResource.MinuteInfo.PointColor;
    this.PointRadius=g_JSChartResource.MinuteInfo.PointRadius;
    this.LineColor=g_JSChartResource.MinuteInfo.LineColor;
    this.TextBGColor=g_JSChartResource.MinuteInfo.TextBGColor;
    this.PixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
    this.TextHeight=20;

    this.TextRectCache=[];
    this.InfoDrawCache=[];
    this.FrameBottom;
    this.FrameTop;
    this.FrameLeft;
    this.FrameRight;
    this.YOffset=5;
    this.IsHScreen=false;
    this.IsDrawFull=false;   //是否全屏画

    this.TooltipRect=[];    //Rect 

    this.SetOption=function(option)
    {
        if (option.TextColor) this.TextColor=option.TextColor;
        if (option.TextBGColor) this.TextBGColor=option.TextBGColor;
        if (option.Font) this.Font=option.Font;
        if (option.PointColor) this.PointColor=option.PointColor;
        if (option.LineColor) this.LineColor=option.LineColor;
        if (option.TextHeight>0) this.TextHeight=option.TextHeight;
        if (option.IsDrawFull==true) this.IsDrawFull=true;
    }

    this.Draw=function()
    {
        this.TooltipRect=[];
        if (!this.ChartMinutePrice) return;
        if (!this.Data || this.Data.size<=0) return;

        this.TextRectCache=[];
        this.InfoDrawCache=[];
        this.PixelTatio=GetDevicePixelRatio();
        this.YOffset=5*this.PixelTatio;
        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        
        var xPointCount=this.ChartFrame.XPointCount;
        var minuteCount=this.ChartFrame.MinuteCount;

        this.FrameBottom=this.ChartBorder.GetBottom();
        if (this.IsDrawFull && this.HQChartBorder) this.FrameBottom=this.HQChartBorder.GetBottom();
        this.FrameTop=this.ChartBorder.GetTop();
        this.FrameLeft=this.ChartBorder.GetLeft();
        this.FrameRight=this.ChartBorder.GetRight();
        if (this.IsHScreen)
        {
            this.FrameRight=this.ChartBorder.GetBottom();
            this.FrameLeft=this.ChartBorder.GetTop();
            this.FrameBottom=this.ChartBorder.GetLeft();
            this.FrameTop=this.ChartBorder.GetRight();
        }

        this.YClose=this.ChartMinutePrice.YClose;

        var data=this.ChartMinutePrice.Source;

        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j)
        {
            var item=data.Data[i];
            if (!item) continue;

            var dateTime=item.DateTime;
            if (!this.Data.has(dateTime)) continue;
            if (this.IsHScreen) 
                this.CalcuateInfoHScreenPosition(this.Data.get(dateTime), j, item);
            else 
                this.CalcuateInfoPosition(this.Data.get(dateTime), j, item);
        }

        for(var i in this.InfoDrawCache)
        {
            var item=this.InfoDrawCache[i];
            this.DrawInfoLines(item);
        }

        for(var i in this.InfoDrawCache)
        {
            var item=this.InfoDrawCache[i];
            this.DrawInfoText(item);
            if (!this.IsHScreen) 
            {
                var rtBorder=item.Border;
                var textRect=new Rect(rtBorder.X,rtBorder.Y,rtBorder.Width,rtBorder.Height);
                var tooltipData={ Data:{ Item:item }, Rect:textRect };
                this.TooltipRect.push(tooltipData);
            }
        }

        this.TextRectCache=[];
        this.InfoDrawCache=[];
    }

    this.CalcuateInfoPosition=function(infoItem, index, minuteItem)
    {
        if (!infoItem  || !infoItem.Data || infoItem.Data.length<=0) return;

        var showItem=infoItem.Data[0];
        this.Canvas.font = this.Font;
        var textWidth=this.Canvas.measureText(showItem.Title).width+4*this.PixelTatio;
        var textHeight=this.TextHeight*this.PixelTatio;

        var x=this.ChartFrame.GetXFromIndex(index);
        var y;
        if (IFrameSplitOperator.IsNumber(showItem.Price)) y=this.ChartFrame.GetYFromData(showItem.Price);
        else y=this.ChartFrame.GetYFromData(minuteItem.Close);
        x=ToFixedPoint(x);

        var isDrawLeft=x<(this.FrameLeft+Math.abs(this.FrameLeft-this.FrameRight)/2);

        var ARRAY_OFFSET=[2,4,6,8,3,5,7];
        var offset=textHeight+ARRAY_OFFSET[index%ARRAY_OFFSET.length]*this.PixelTatio;
        var yData= 
        { 
            Y: 
            [
                {Value:y+(textHeight+this.YOffset), Offset: offset},
                {Value:y-(2*textHeight+this.YOffset), Offset:-offset}
            ]
        };

        if (minuteItem.Close<this.YClose) 
            yData.Y=yData.Y.reverse();
        
        var rtBorder={X:x, Y:null, Width:textWidth,Height:textHeight};
        if (!isDrawLeft) rtBorder.X-=rtBorder.Width;

        this.FixTextRect(rtBorder,yData);
        var InfoDrawItem= {  Border:rtBorder, Start:{X:x,Y:y}, IsLeft:isDrawLeft, Title:showItem.Title, Date:showItem.Date, Time:showItem.Time };
        if (showItem.Content) InfoDrawItem.Content=showItem.Content;
        if (showItem.Link) InfoDrawItem.Link=showItem.Link;
        if (showItem.Color) InfoDrawItem.Color=showItem.Color;
        if (showItem.BGColor) InfoDrawItem.BGColor=showItem.BGColor;

        this.InfoDrawCache.push(InfoDrawItem);
        this.TextRectCache.push(rtBorder);
    }

    this.CalcuateInfoHScreenPosition=function(infoItem, index, minuteItem)
    {
        if (!infoItem  || !infoItem.Data || infoItem.Data.length<=0) return;

        var showItem=infoItem.Data[0];
        this.Canvas.font = this.Font;
        var textHeight=this.Canvas.measureText(showItem.Title).width+4*this.PixelTatio;
        var textWidth=this.TextHeight*this.PixelTatio;

        var y=this.ChartFrame.GetXFromIndex(index);
        var x;
        if (IFrameSplitOperator.IsNumber(showItem.Price)) x=this.ChartFrame.GetYFromData(showItem.Price);
        else x=this.ChartFrame.GetYFromData(minuteItem.Close);
        y=ToFixedPoint(y);

        var isDrawLeft=y<(this.FrameLeft+Math.abs(this.FrameLeft-this.FrameRight)/2);

        var ARRAY_OFFSET=[2,4,6,8,3,5,7];
        var offset=textWidth+ARRAY_OFFSET[index%ARRAY_OFFSET.length]*this.PixelTatio;
        var xData= 
        { 
            X: 
            [
                {Value:x+(textWidth+this.YOffset), Offset: offset},
                {Value:x-(2*textWidth+this.YOffset), Offset:-offset}
            ]
        };

        if (minuteItem.Close>this.YClose) 
            xData.X=xData.X.reverse();
        
        var rtBorder={X:null, Y:y, Width:textWidth,Height:textHeight};
        if (!isDrawLeft) rtBorder.Y-=rtBorder.Height;
        
        this.FixHScreenTextRect(rtBorder,xData);
        var InfoDrawItem={ Border:rtBorder, Start:{X:x,Y:y}, IsLeft:isDrawLeft, Title:showItem.Title };
        if (showItem.Content) InfoDrawItem.Content=showItem.Content;
        if (showItem.Link) InfoDrawItem.Link=showItem.Link;
        if (showItem.Color) InfoDrawItem.Color=showItem.Color;
        if (showItem.BGColor) InfoDrawItem.BGColor=showItem.BGColor;

        this.InfoDrawCache.push(InfoDrawItem);
        this.TextRectCache.push(rtBorder);
    }

    this.DrawInfoLines=function(item)
    {
        var rtBorder=item.Border;
        var isDrawLeft=item.IsLeft;
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(item.Start.X),item.Start.Y);
        if (isDrawLeft) 
        {
            this.Canvas.lineTo(ToFixedPoint(item.Start.X),rtBorder.Y);
        }
        else 
        {
            if (this.IsHScreen) this.Canvas.lineTo(rtBorder.X,rtBorder.Y+rtBorder.Height);
            else this.Canvas.lineTo(ToFixedPoint(item.Start.X),rtBorder.Y);
        }
        this.Canvas.stroke();

        this.Canvas.fillStyle = this.PointColor;
        this.Canvas.beginPath();
        this.Canvas.arc(item.Start.X,item.Start.Y, this.PointRadius, 0, 2 * Math.PI);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    this.DrawInfoText=function(item)
    {
        var rtBorder=item.Border;
        var x=rtBorder.X, y=rtBorder.Y;
        if (item.BGColor) this.Canvas.fillStyle=item.BGColor
        else this.Canvas.fillStyle=this.TextBGColor;
        this.Canvas.fillRect(x, y, rtBorder.Width,rtBorder.Height);

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.rect(x,y,rtBorder.Width,rtBorder.Height);
        this.Canvas.stroke();

        if (this.IsHScreen)
        {
            this.Canvas.save(); 
            this.Canvas.translate(rtBorder.X,rtBorder.Y);
            this.Canvas.rotate(90 * Math.PI / 180);
            x=0;y=0;
        }

        this.Canvas.textAlign = 'left'
        this.Canvas.textBaseline = 'middle';
        if (item.Color) this.Canvas.fillStyle=item.Color;
        else this.Canvas.fillStyle = this.TextColor;
        this.Canvas.font = this.Font;
        if (this.IsHScreen) this.Canvas.fillText(item.Title, x+2*this.PixelTatio, y-rtBorder.Width/2);
        else this.Canvas.fillText(item.Title, x+2*this.PixelTatio, y+rtBorder.Height/2);

        if (this.IsHScreen) this.Canvas.restore();
    }

    this.FixTextRect=function(rect,yData) 
    {
        for(var k in yData.Y)
        {
            var yItem=yData.Y[k];
            rect.Y=yItem.Value;

            var y;
            for(var j=0;j<10;++j)
            {
                var isOverlap=false;
                for(var i in this.TextRectCache)
                {
                    var item=this.TextRectCache[i];
                    if (this.IsOverlap(item, rect))
                    {
                        isOverlap=true;
                        break;
                    }
                }

                if (isOverlap==false) return;

                y=rect.Y;
                y+=yItem.Offset;
                if (y+rect.Height>this.FrameBottom || y<this.FrameTop) break;

                rect.Y=y;
            }
        }
    }

    this.FixHScreenTextRect=function(rect,xData) 
    {
        for(var k in xData.X)
        {
            var xItem=xData.X[k];
            rect.X=xItem.Value;

            var x;
            for(var j=0;j<10;++j)
            {
                var isOverlap=false;
                for(var i in this.TextRectCache)
                {
                    var item=this.TextRectCache[i];
                    if (this.IsOverlap(item, rect))
                    {
                        isOverlap=true;
                        break;
                    }
                }

                if (isOverlap==false) return;

                x=rect.X;
                x+=xItem.Offset;
                if (x+rect.Width<this.FrameBottom || x>this.FrameTop) break;

                rect.X=x;
            }
        }
    }

    this.IsOverlap=function(rc1, rc2)
    {
        if (rc1.X + rc1.Width  > rc2.X &&rc2.X + rc2.Width  > rc1.X &&rc1.Y + rc1.Height > rc2.Y &&rc2.Y + rc2.Height > rc1.Y)
            return true;
        else
            return false;
    }

    this.GetMaxMin=function()
    {
        var range={Min:null, Max:null};
        return range;
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        for(var i in this.TooltipRect)
        {
            var item=this.TooltipRect[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                //JSConsole.Chart.Log('[ChartMinuteInfo::GetTooltipData] info ', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=3; //异动信息
                return true;
            }
        }

        return false;
    }
}

//MACD森林线 支持横屏
function ChartMACD()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartMACD";
    this.UpColor=g_JSChartResource.UpBarColor;
    this.DownColor=g_JSChartResource.DownBarColor;
    this.LineWidth=1;

    this.DrawSelectedStatus=this.DrawLinePoint;
    this.ExportData=this.ExportArrayData;
    
    this.PtInChart=function(x,y)
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var barWidth=this.LineWidth*GetDevicePixelRatio();
        if (this.barWidth==50) barWidth=null;
        else if (barWidth>dataWidth) barWidth=dataWidth;

        if (barWidth<4) barWidth=4; //宽度太小了点不到

        return this.PtInBar(x, y, { BarWidth:barWidth })
    }

    this.DrawBars=function(lineWidth, bUpBar)
    {
        var isMinute=this.IsMinuteFrame();
        
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var isHSCreen=this.ChartFrame.IsHScreen===true;

        if (isHSCreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            var lockRect=this.GetLockRect();
            if (lockRect) chartright=lockRect.Top;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;

            var chartright=border.RightEx;
            var lockRect=this.GetLockRect();
            if (lockRect) chartright=lockRect.Left;
        }


        if (bUpBar) this.Canvas.strokeStyle=this.UpColor;
        else this.Canvas.strokeStyle=this.DownColor;

        var yBottom=this.ChartFrame.GetYFromData(0);
        this.Canvas.beginPath();
        var drawCount=0;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            if (value==null) continue;
            if (bUpBar)
            {
                if (value<0) continue;
            }
            else
            {
                if (value>=0) continue;
            }

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            if (x>chartright) break;

            var y=this.ChartFrame.GetYFromData(value);
            var xFix=ToFixedPoint2(lineWidth, x); //毛边修正

            if (isHSCreen)
            {
                this.Canvas.moveTo(yBottom,ToFixedPoint(x));
                this.Canvas.lineTo(y,ToFixedPoint(x));
            }
            else
            {
                this.Canvas.moveTo(xFix,yBottom);
                this.Canvas.lineTo(xFix,y);
            }
            
            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        var dataWidth=this.ChartFrame.DataWidth;
        var lineWidth=this.LineWidth*GetDevicePixelRatio();
        if (this.LineWidth==50) lineWidth=dataWidth;
        else if (lineWidth>dataWidth) lineWidth=dataWidth;
        
        var backupLineWidth=this.Canvas.lineWidth;
        this.Canvas.lineWidth=lineWidth;

         //上下分开画
        this.DrawBars(lineWidth, true);
        this.DrawBars(lineWidth, false);

        this.Canvas.lineWidth=backupLineWidth;
    }

    this.GetItemData=function(indexData)
    {
        if (!indexData) return null;
        if (!IFrameSplitOperator.IsNumber(indexData.Index)) return null;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return null;
        var index=indexData.Index;
        if (index<0 || index>=this.Data.Data.length) return null;

        var item=this.Data.Data[index];
        return [ { Value:item, Color:item>0 ? this.UpColor:this.DownColor, Name: this.Name } ];
    }
}

//柱子
function ChartBar()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartBar";
    this.UpBarColor=g_JSChartResource.UpBarColor;
    this.DownBarColor=g_JSChartResource.DownBarColor;

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;

        var bFirstPoint=true;
        var drawCount=0;
        var yBottom=this.ChartFrame.GetYFromData(0);
        if (dataWidth>=4)
        {
            yBottom=ToFixedRect(yBottom);   //调整为整数
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                if (value==null || value==0) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;

                var x=this.ChartFrame.GetXFromIndex(j);
                var y=this.ChartFrame.GetYFromData(value);


                if (value>0) this.Canvas.fillStyle=this.UpBarColor;
                else this.Canvas.fillStyle=this.DownBarColor;

                //高度调整为整数
                var height=ToFixedRect(Math.abs(yBottom-y));
                if(yBottom-y>0) y=yBottom-height;
                else y=yBottom+height;
                this.Canvas.fillRect(ToFixedRect(left),y,ToFixedRect(dataWidth),height);
            }
        }
        else    //太细了 直接画柱子
        {
            for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                if (value==null || value==0) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;

                var x=this.ChartFrame.GetXFromIndex(j);
                var y=this.ChartFrame.GetYFromData(value);

                if (value>0) this.Canvas.strokeStyle=this.UpBarColor;
                else this.Canvas.strokeStyle=this.DownBarColor;

                this.Canvas.beginPath();
                this.Canvas.moveTo(ToFixedPoint(x),y);
                this.Canvas.lineTo(ToFixedPoint(x),yBottom);
                this.Canvas.stroke();
            }
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=0;
        range.Max=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (range.Max==null) range.Max=value;
            if (range.Max<value) range.Max=value;
        }

        return range;
    }
}


// 面积图 支持横屏
function ChartBand()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    this.IsDrawFirst = true;

    this.ClassName="ChartBand";
    this.FirstColor = g_JSChartResource.Index.LineColor[0];
    this.SecondColor = g_JSChartResource.Index.LineColor[1];

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        var isMinute=this.IsMinuteFrame();
        var isHScreen=this.ChartFrame.IsHScreen;
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
        var x = 0;
        var y = 0;
        var y2 = 0;
        var firstlinePoints = [];
        var secondlinePoints = [];
        for(var i=this.Data.DataOffset,j=0; i<this.Data.Data.length && j<xPointCount;++i, ++j, xOffset+=(dataWidth+distanceWidth))
        {
            firstlinePoints = [];
            secondlinePoints = [];
            for(;i<this.Data.Data.length && j<xPointCount;++i, ++j, xOffset+=(dataWidth+distanceWidth))
            {
                var value=this.Data.Data[i];
                if (value==null || value.Value==null || value.Value2 == null) break;

                if (isMinute)
                {
                    x=this.ChartFrame.GetXFromIndex(j);
                }
                else
                {
                    var left=xOffset;
                    var right=xOffset+dataWidth;
                    x=left+(right-left)/2;
                }

                y=this.ChartFrame.GetYFromData(value.Value);
                y2 = this.ChartFrame.GetYFromData(value.Value2);

                if (isHScreen)
                {
                    firstlinePoints.push({x:y,y:x});
                    secondlinePoints.push({x:y2,y:x});
                }
                else
                {
                    firstlinePoints.push({x:x,y:y});
                    secondlinePoints.push({x:x,y:y2});
                }
                
            }

            if (firstlinePoints.length>1 && secondlinePoints.length>1)
            {
                this.DrawBand(firstlinePoints, secondlinePoints);
            }
        }
    }

    this.ClipTop=function(aryFrist)
    {
        var isHScreen=this.ChartFrame.IsHScreen;
        this.Canvas.beginPath();
        for(var i=0;i<aryFrist.length;++i)
        {
            if (i == 0)
                this.Canvas.moveTo(aryFrist[i].x, aryFrist[i].y);
            else
                this.Canvas.lineTo(aryFrist[i].x, aryFrist[i].y);
        }
        var ptStart=aryFrist[0];
        var ptEnd=aryFrist[aryFrist.length-1];

       
        if (isHScreen)
        {
            var xLeft=this.ChartBorder.GetRightEx();
            this.Canvas.lineTo(xLeft, ptEnd.y);
            this.Canvas.lineTo(xLeft, ptStart.y);
        }
        else
        {
            var yTop=this.ChartBorder.GetTopEx();
            this.Canvas.lineTo(ptEnd.x, yTop);
            this.Canvas.lineTo(ptStart.x, yTop);
        }
       
        this.Canvas.closePath();
        this.Canvas.clip();
    }

    this.ClipBottom=function(aryFrist)
    {
        var isHScreen=this.ChartFrame.IsHScreen;
        this.Canvas.beginPath();
        for(var i=0;i<aryFrist.length;++i)
        {
            if (i == 0)
                this.Canvas.moveTo(aryFrist[i].x, aryFrist[i].y);
            else
                this.Canvas.lineTo(aryFrist[i].x, aryFrist[i].y);
        }
        var ptStart=aryFrist[0];
        var ptEnd=aryFrist[aryFrist.length-1];

        if (isHScreen)
        {
            var xLeft=this.ChartBorder.GetLeftEx();
            this.Canvas.lineTo(xLeft, ptEnd.y);
            this.Canvas.lineTo(xLeft, ptStart.y);
        }
        else
        {
            var yBottom=this.ChartBorder.GetBottomEx();
            this.Canvas.lineTo(ptEnd.x, yBottom);
            this.Canvas.lineTo(ptStart.x, yBottom);
        }
      
        this.Canvas.closePath();
        //this.Canvas.fillStyle = "rgb(255,0,0)";
        //this.Canvas.fill();
        this.Canvas.clip();
    }

    this.DrawArea=function(aryFrist, arySecond, clrArea)
    {
        this.Canvas.beginPath();
        for(var i=0;i<aryFrist.length;++i)
        {
            if (i == 0)
                this.Canvas.moveTo(aryFrist[i].x, aryFrist[i].y);
            else
                this.Canvas.lineTo(aryFrist[i].x, aryFrist[i].y);
        }

        for (var i = arySecond.length-1; i >= 0; --i)
        {
            this.Canvas.lineTo(arySecond[i].x, arySecond[i].y);
        }  
        this.Canvas.closePath();
        this.Canvas.fillStyle = clrArea;
        this.Canvas.fill();
    }

    this.DrawBand=function(aryFrist, arySecond)
    {
        if (this.FirstColor)
        {
            this.Canvas.save();
            this.ClipTop(aryFrist);
            this.DrawArea(aryFrist, arySecond, this.FirstColor);
            this.Canvas.restore();
        }
       
        if (this.SecondColor)
        {
            this.Canvas.save();
            this.ClipBottom(aryFrist);
            this.DrawArea(aryFrist, arySecond, this.SecondColor);
            this.Canvas.restore();
        }
    }


    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null || value.Value==null || value.Value2 == null) continue;
            var maxData = value.Value>value.Value2?value.Value:value.Value2;
            var minData = value.Value<value.Value2?value.Value:value.Value2;
            if (range.Max==null) 
                range.Max = maxData;
            else if (range.Max < maxData)
                range.Max = maxData;
            
            if (range.Min==null)
                range.Min = minData;
            else if (range.Min > minData)
                range.Min = minData; 
        }

        return range;
    }
}

// 线段围成的面积图 支持横屏
function ChartLineArea()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    this.IsDrawFirst = true;    //面积图在K线前面画,否则回挡住K线的

    this.ClassName="ChartLineArea";
    this.Color='rgb(56,67,99)';
    this.IsHScreen=false;

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var x = 0, y = 0, y2 = 0;
        var aryPoint=[];
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            aryPoint[i]=null;
            if (value==null || value.Value==null || value.Value2 == null) continue;
            x=this.ChartFrame.GetXFromIndex(j);
            y=this.ChartFrame.GetYFromData(value.Value);
            y2 = this.ChartFrame.GetYFromData(value.Value2);

            if (this.IsHScreen)
                aryPoint[i]={ Line:{ X:y, Y:x }, Line2:{ X:y2, Y:x }};
            else
                aryPoint[i]={ Line:{ X:x, Y:y }, Line2:{ X:x, Y:y2 }};
        }

        this.Canvas.fillStyle = this.Color;
        var firstPoint=true;
        var pointCount=0;
        var aryLine2=[];
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (!item)
            {
                if (pointCount>0)
                {
                    for(var j=aryLine2.length-1; j>=0; --j)
                    {
                        var item2=aryLine2[j];
                        this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y);
                    }
                    this.Canvas.closePath();
                    this.Canvas.fill();
                }

                firstPoint=true;
                pointCount=0;
                aryLine2=[];
                continue;
            }

            if (firstPoint)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(item.Line.X, item.Line.Y);
                firstPoint=false;
            }
            else
            {
                this.Canvas.lineTo(item.Line.X, item.Line.Y);
            }

            aryLine2.push(item);
            ++pointCount;
        }

        if (pointCount>0)
        {
            for(var j=aryLine2.length-1; j>=0; --j)
            {
                var item2=aryLine2[j];
                this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y);
            }
            this.Canvas.closePath();
            this.Canvas.fill();
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (!value || value.Value==null || value.Value2 == null) continue;

            var maxData = value.Value>value.Value2?value.Value:value.Value2;
            var minData = value.Value<value.Value2?value.Value:value.Value2;

            if (range.Max==null)  range.Max = maxData;
            else if (range.Max < maxData) range.Max = maxData;
            
            if (range.Min==null) range.Min = minData;
            else if (range.Min > minData) range.Min = minData; 
        }

        return range;
    }
}

// 线段围成的面积图 支持横屏
function ChartFillRGN()
{
    this.newMethod=ChartLineArea;   //派生
    this.newMethod();
    delete this.newMethod;
    this.IsDrawFirst = true;    //面积图在K线前面画,否则回挡住K线的
    this.IsHScreen=false;

    this.ClassName="ChartFillRGN";

    this.DrawRGB=function(aryPoint)
    {
        var firstPoint=true;
        var pointCount=0;
        var aryLine2=[];
        var color=null;
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (!item || (color && item.Color!=color) )
            {
                if (pointCount>0)
                {
                    for(var j=aryLine2.length-1; j>=0; --j)
                    {
                        var item2=aryLine2[j];
                        this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y);
                    }
                    this.Canvas.closePath();
                    this.Canvas.fillStyle = color;
                    this.Canvas.fill();
                }

                firstPoint=true;
                pointCount=0;
                aryLine2=[];
                color=null;
            }

            if (!item) continue;

            if (firstPoint)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(item.Line.X, item.Line.Y);
                firstPoint=false;
                color=item.Color;
            }
            else
            {
               this.Canvas.lineTo(item.Line.X, item.Line.Y);
            }

            aryLine2.push(item);
            ++pointCount;
        }

        if (pointCount>0)
        {
            for(var j=aryLine2.length-1; j>=0; --j)
            {
                var item2=aryLine2[j];
                this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y);
            }
            this.Canvas.closePath();
            this.Canvas.fillStyle = color;
            this.Canvas.fill();
        }
    }

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var x = 0, y = 0, y2 = 0;
        var aryPoint=[];    //点坐标
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            aryPoint[i]=null;
            if (value==null || value.Value==null || value.Value2 == null || !value.Color) continue;

            x=this.ChartFrame.GetXFromIndex(j);
            y=this.ChartFrame.GetYFromData(value.Value);
            y2 = this.ChartFrame.GetYFromData(value.Value2);

            if (this.IsHScreen)
                aryPoint[i]={ Line:{ X:y, Y:x }, Line2:{ X:y2, Y:x }, Color:value.Color };
            else
                aryPoint[i]={ Line:{ X:x, Y:y }, Line2:{ X:x, Y:y2 }, Color:value.Color };
        }

        this.DrawRGB(aryPoint);
    }
}

//支持横屏
//用法:FLOATRGN(PRICE,WIDTH,COND1,COLOR1,COND2,COLOR2...),以PRICE为基础填充宽度为WIDTH像素的区域,WIDTH为负则向下填充,当COND1条件满足时,用COLOR1颜色,当COND2条件满足时,用COLOR2颜色,否则不填充,从COND1之后的参数均可以省略,最多可以有10组条件
//例如:FLOATRGN(CLOSE,VOL/HHV(VOL,10)*15,CLOSE>OPEN,RGB(255,0,0),1,RGB(0,255,0)) 表示沿收盘价填充宽度为成交量的区域,区域最大宽度为15像素,阳线时用红色,阴线时用绿色。
function ChartFLOATRGN()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    this.IsDrawFirst = false;    //面积图在K线前面画,否则回挡住K线的

    this.ClassName="ChartFLOATRGN";
    this.Color='rgb(56,67,99)';
    this.IsHScreen=false;

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;

        var x = 0, y = 0, y2 = 0;
        var aryPoint=[];    //点坐标
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            aryPoint[i]=null;
            if (!item || !IFrameSplitOperator.IsNumber(item.Value)|| !IFrameSplitOperator.IsNumber(item.Value2) || !item.Color) continue;

            x=this.ChartFrame.GetXFromIndex(j);
            y=this.ChartFrame.GetYFromData(item.Value);

            if (this.IsHScreen)
                aryPoint[i]={ Line:{ X:y, Y:x }, Line2:{ X:y+item.Value2*GetDevicePixelRatio(), Y:x }, Color:item.Color };
            else
                aryPoint[i]={ Line:{ X:x, Y:y }, Line2:{ X:x, Y:y-item.Value2*GetDevicePixelRatio() }, Color:item.Color };
        }

        //计算左右位置的点
        var preItem=null;
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (preItem && item)
            {
                if (this.IsHScreen)
                {
                    var xWidth=(item.Line.Y-preItem.Line.Y);
                    x=preItem.Line.Y+xWidth/2;
                    y=preItem.Line.X+(item.Line.X-preItem.Line.X)/2;
                    y2=preItem.Line2.X+(item.Line2.X-preItem.Line2.X)/2;

                    preItem.RightLine={X:y, Y:x};
                    preItem.RightLine2={X:y2, Y:x};
                    item.LeftLine={X:y, Y:x};
                    item.LeftLine2={X:y2, Y:x};
                }
                else
                {
                    var xWidth=(item.Line.X-preItem.Line.X);
                    x=preItem.Line.X+xWidth/2;
                    y=preItem.Line.Y+(item.Line.Y-preItem.Line.Y)/2;
                    y2=preItem.Line2.Y+(item.Line2.Y-preItem.Line2.Y)/2;
                    preItem.RightLine={X:x, Y:y};
                    preItem.RightLine2={X:x, Y:y2};
                    item.LeftLine={X:x, Y:y};
                    item.LeftLine2={X:x, Y:y2};
                }
            }

            preItem=item;  //上一个点
        }

        this.DrawRGB(aryPoint);
    }

    this.DrawRGB=function(aryPoint)
    {
        var firstPoint=true;
        var pointCount=0;
        var aryLine2=[];
        var color=null;

        if (this.IsHScreen)
        {
            var left=this.ChartBorder.GetLeftEx();
            var right=this.ChartBorder.GetRightEx();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=this.ChartBorder.GetTopEx();
            var bottom=this.ChartBorder.GetBottomEx();
        }
        

        this.Canvas.save();
        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        this.Canvas.clip();

        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (!item || (color && item.Color!=color) )
            {
                if (pointCount>0)
                {
                    var lastItem=aryLine2[aryLine2.length-1];
                    var firstItem=aryLine2[0];
                    if (lastItem.RightLine)
                    {
                        this.Canvas.lineTo(lastItem.RightLine.X, lastItem.RightLine.Y);
                        this.Canvas.lineTo(lastItem.RightLine2.X, lastItem.RightLine2.Y);
                    }

                    for(var j=aryLine2.length-1; j>=0; --j)
                    {
                        var item2=aryLine2[j];
                        this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y);
                    }

                    if (firstItem.LeftLine2)
                    {
                        this.Canvas.lineTo(firstItem.LeftLine2.X, firstItem.LeftLine2.Y);
                    }
                    
                    this.Canvas.closePath();
                    this.Canvas.fillStyle = color;
                    this.Canvas.fill();
                }

                firstPoint=true;
                pointCount=0;
                aryLine2=[];
                color=null;
            }

            if (!item) continue;

            if (firstPoint)
            {
                this.Canvas.beginPath();
                if (item.LeftLine)
                {
                    this.Canvas.moveTo(item.LeftLine.X, item.LeftLine.Y);
                    this.Canvas.lineTo(item.Line.X, item.Line.Y);
                }
                else 
                {
                    this.Canvas.moveTo(item.Line.X, item.Line.Y);
                }
                firstPoint=false;
                color=item.Color;
            }
            else
            {
                this.Canvas.lineTo(item.Line.X, item.Line.Y);
            }

            aryLine2.push(item);
            ++pointCount;
        }

        if (pointCount>0)
        {
            var lastItem=aryLine2[aryLine2.length-1];
            var firstItem=aryLine2[0];
            if (lastItem.RightLine)
            {
                this.Canvas.lineTo(lastItem.RightLine.X, lastItem.RightLine.Y);
                this.Canvas.lineTo(lastItem.RightLine2.X, lastItem.RightLine2.Y);
            }

            for(var j=aryLine2.length-1; j>=0; --j)
            {
                var item2=aryLine2[j];
                this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y);
            }

            if (firstItem.LeftLine2)
            {
                this.Canvas.lineTo(firstItem.LeftLine2.X, firstItem.LeftLine2.Y);
            }
            
            this.Canvas.closePath();
            this.Canvas.fillStyle = color;
            this.Canvas.fill();
        }

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var item=this.Data.Data[i];
            if (!item || !IFrameSplitOperator.IsNumber(item.Value)) continue;
            var value=item.Value;
            
            if (range.Max==null) range.Max = value;
            else if (range.Max < value) range.Max = value;
            
            if (range.Min==null) range.Min = value;
            else if (range.Min > value) range.Min = value; 
        }

        return range;
    }
}

//线段围城的顶部或底部面积图 TODO:支持横屏
function ChartFillBGRGN()
{
    this.newMethod=ChartFillRGN;   //派生
    this.newMethod();
    delete this.newMethod;
    this.IsDrawFirst = true;    //面积图在K线前面画,否则回挡住K线的
    this.IsHScreen=false;

    this.ClassName="ChartFillBGRGN";


    this.DrawVerticalRGN=function()
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();

        var y=top, y2=bottom;

        var aryPoint=[];    //点坐标
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            aryPoint[i]=null;
            if (!value || !value.Color) continue;

            x=this.ChartFrame.GetXFromIndex(j);

            if (this.IsHScreen)
                aryPoint[i]={ Line:{ X:y, Y:x }, Line2:{ X:y2, Y:x }, Color:value.Color };
            else
                aryPoint[i]={ Line:{ X:x, Y:y }, Line2:{ X:x, Y:y2 }, Color:value.Color };
        }

        this.DrawRGB(aryPoint);
    }

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        if (this.Name=="FILLVERTICALRGN")
        {
            this.DrawVerticalRGN();
            return;
        }

        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();
        var x = 0, y = 0, y2 = top;
        if (this.Name=="FILLBOTTOMRGN")  y2=bottom;

        var aryPoint=[];    //点坐标
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            aryPoint[i]=null;
            if (value==null || value.Value==null || !value.Color) continue;

            x=this.ChartFrame.GetXFromIndex(j);
            y=this.ChartFrame.GetYFromData(value.Value);

            if (this.IsHScreen)
                aryPoint[i]={ Line:{ X:y, Y:x }, Line2:{ X:y2, Y:x }, Color:value.Color };
            else
                aryPoint[i]={ Line:{ X:x, Y:y }, Line2:{ X:x, Y:y2 }, Color:value.Color };
        }

        this.DrawRGB(aryPoint);
    }

    this.DrawRGB=function(aryPoint)
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var halfWidth=(distanceWidth+dataWidth)/2;
        var firstPoint=true;
        var pointCount=0;
        var aryLine2=[];
        var color=null;
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (!item || (color && item.Color!=color) )
            {
                if (pointCount>0)
                {
                    for(var j=aryLine2.length-1; j>=0; --j)
                    {
                        var item2=aryLine2[j];
                        this.Canvas.lineTo(item2.Line2.X+halfWidth, item2.Line2.Y);
                        this.Canvas.lineTo(item2.Line2.X-halfWidth, item2.Line2.Y);
                    }
                    this.Canvas.closePath();
                    this.Canvas.fillStyle = color;
                    this.Canvas.fill();
                }

                firstPoint=true;
                pointCount=0;
                aryLine2=[];
                color=null;
            }

            if (!item) continue;

            if (firstPoint)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(item.Line.X-halfWidth, item.Line.Y);
                this.Canvas.lineTo(item.Line.X+halfWidth, item.Line.Y);
                firstPoint=false;
                color=item.Color;
            }
            else
            {
                this.Canvas.lineTo(item.Line.X-halfWidth, item.Line.Y);
                this.Canvas.lineTo(item.Line.X+halfWidth, item.Line.Y);
            }

            aryLine2.push(item);
            ++pointCount;
        }

        if (pointCount>0)
        {
            for(var j=aryLine2.length-1; j>=0; --j)
            {
                var item2=aryLine2[j];
                this.Canvas.lineTo(item2.Line2.X+halfWidth, item2.Line2.Y);
                this.Canvas.lineTo(item2.Line2.X-halfWidth, item2.Line2.Y);
            }
            this.Canvas.closePath();
            this.Canvas.fillStyle = color;
            this.Canvas.fill();
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (!value || value.Value==null ) continue;

            var value=value.Value;

            if (range.Max==null)  range.Max = value;
            else if (range.Max < value) range.Max = value;
            
            if (range.Min==null) range.Min = value;
            else if (range.Min > value) range.Min = value; 
        }

        return range;
    }
}

// 通道面积图 支持横屏
function ChartChannel()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    this.IsDrawFirst = true;

    this.ClassName="ChartChannel";
    this.IsHScreen=false;   //是否是横屏
    this.PointCount=0;
    this.DataWidth=0;
    this.DistanceWidth=0;
    this.ChartRight=0;      //可以绘制的最右边
    this.LineColor='RGB(255,0,0)';
    this.LineDotted=[3,3];
    this.AreaColor='RGB(255,222,173)';
    this.LineWidth=1;

    this.CalculateData=function()   //把数据通过nul值分割开, 并计算坐标
    {
        var data=[];
        var lineData=[];
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<this.PointCount;++i,++j)
        {
            var item=this.Data.Data[i];
            if (!item || !IFrameSplitOperator.IsNumber(item.Value) || !IFrameSplitOperator.IsNumber(item.Value2))
            {
                if (lineData.length>0) 
                {
                    data.push(lineData);
                    lineData=[];    //创建新的一组数据
                }

                continue;
            }

            var x=this.ChartFrame.GetXFromIndex(j);
            if (x>this.ChartRight) break;
            var y=this.ChartFrame.GetYFromData(item.Value);
            var y2=this.ChartFrame.GetYFromData(item.Value2);

            lineData.push({X:x, Y:y,Y2:y2});
        }
        
        if (lineData.length>0) data.push(lineData);
        return data;
    }

    this.DrawArea=function(lineData)
    {
        if (lineData.length<=0) return;
        this.Canvas.beginPath();

        var drawCount=0;
        var firstItem=lineData[0];
        if (this.IsHScreen) this.Canvas.moveTo(firstItem.Y,firstItem.X);
        else this.Canvas.moveTo(firstItem.X,firstItem.Y);
        for(var i=1;i<lineData.length;++i)
        {
            var item=lineData[i];
            if (this.IsHScreen) this.Canvas.lineTo(item.Y,item.X);
            else this.Canvas.lineTo(item.X,item.Y);
            ++drawCount;
        }

        for(var i=lineData.length-1;i>=0;--i)
        {
            var item=lineData[i];
            if (this.IsHScreen) this.Canvas.lineTo(item.Y2,item.X);
            else this.Canvas.lineTo(item.X,item.Y2);
            ++drawCount;
        }

        this.Canvas.closePath();
        this.Canvas.fillStyle = this.AreaColor;
        this.Canvas.fill();
    }

    this.DrawLine=function(lineData)
    {
        this.Canvas.strokeStyle=this.LineColor;
        for(var k=0;k<2;++k)
        {
            var bFirstPoint=true;
            var drawCount=0;
            for(var i=0;i<lineData.length;++i)
            {
                var item=lineData[i];

                if (bFirstPoint)
                {
                    this.Canvas.beginPath();
                    if (this.IsHScreen) this.Canvas.moveTo(k===0?item.Y:item.Y2,item.X);
                    else this.Canvas.moveTo(item.X, k===0?item.Y:item.Y2 );
                    bFirstPoint=false;
                }
                else
                {
                    if (this.IsHScreen) this.Canvas.lineTo(k===0?item.Y:item.Y2,item.X);
                    else this.Canvas.lineTo(item.X,k===0?item.Y:item.Y2);
                }

                ++drawCount;
            }
            if (drawCount>0) this.Canvas.stroke();
        }
    }

    this.Draw=function()
    {
        if (this.ChartFrame.IsMinSize) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        this.PointCount=this.ChartFrame.XPointCount;
        this.DataWidth=this.ChartFrame.DataWidth;
        this.DistanceWidth=this.ChartFrame.DistanceWidth;
        if (this.IsHScreen) this.ChartRight=this.ChartBorder.GetBottom();
        else this.ChartRight=this.ChartBorder.GetRight();

        var drawData=this.CalculateData();
        if (!drawData || drawData.length<=0) return;

        this.Canvas.save();
        this.Canvas.lineWidth=this.LineWidth*GetDevicePixelRatio();
        this.Canvas.setLineDash(this.LineDotted);   //虚线
        for(var i=0;i<drawData.length;++i)
        {
            var lineData=drawData[i];
            this.DrawArea(lineData);
            this.DrawLine(lineData);
        }
        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={Min:null, Max:null};
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null || value.Value==null || value.Value2 == null) continue;
            var maxData = value.Value>value.Value2?value.Value:value.Value2;
            var minData = value.Value<value.Value2?value.Value:value.Value2;
            if (range.Max==null) 
                range.Max = maxData;
            else if (range.Max < maxData)
                range.Max = maxData;
            
            if (range.Min==null)
                range.Min = minData;
            else if (range.Min > minData)
                range.Min = minData; 
        }

        return range;
    }
}

//填充背景 支持横屏
function ChartBackground()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartBackground";
    this.Color=null;
    this.ColorAngle=0;  //0 竖向 1 横向
    this.IsDrawFirst = true;    //面积图在K线前面画,否则回挡住K线的

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Color) return;
        if (this.Color.length<=0) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        if (this.Color.length==2)
        {
            if (this.IsHScreen)
            {
                if (this.ColorAngle==0)
                {
                    var ptStart={ X:this.ChartBorder.GetRight(), Y:this.ChartBorder.GetTopEx() };
                    var ptEnd={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
                }
                else
                {
                    var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
                    var ptEnd={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetBottomEx() };
                }
            }
            else
            {
                if (this.ColorAngle==0)
                {
                    var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
                    var ptEnd={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetBottomEx() };
                }
                else
                {
                    var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
                    var ptEnd={ X:this.ChartBorder.GetRight(), Y:this.ChartBorder.GetTopEx() };
                }
            }
            
            let gradient = this.Canvas.createLinearGradient(ptStart.X,ptStart.Y, ptEnd.X,ptEnd.Y);
            gradient.addColorStop(0, this.Color[0]);
            gradient.addColorStop(1, this.Color[1]);
            this.Canvas.fillStyle=gradient;
        }
        else if (this.Color.length==1)
        {
            this.Canvas.fillStyle=this.Color[0];
        }
        else
        {
            return;
        }

        if (this.Name=="DRAWGBK2" || this.Name=="KLINE_BG")
        {
            this.DrawRegion();
            return;
        }

        if (this.IsHScreen)
        {
            var left=this.ChartBorder.GetLeftEx();
            var top=this.ChartBorder.GetTop();
            var width=this.ChartBorder.GetWidthEx();
            var height=this.ChartBorder.GetHeight();
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var top=this.ChartBorder.GetTopEx();
            var width=this.ChartBorder.GetWidth();
            var height=this.ChartBorder.GetHeightEx();
        }
        this.Canvas.fillRect(left, top,width, height);
    }

    this.DrawRegion=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();
        if (this.IsHScreen)
        {
            top=this.ChartBorder.GetRightEx();
            bottom=this.ChartBorder.GetLeftEx();
        }

        var aryPoint=[];    //点坐标
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var value=this.Data.Data[i];
            aryPoint[i]=null;
            if (!IFrameSplitOperator.IsNumber(value) || value<=0) continue;

            var x=this.ChartFrame.GetXFromIndex(j);
            var y=this.ChartFrame.GetYFromData(value.Value);

            if (this.IsHScreen)
                aryPoint[i]={ Line:{ X:bottom, Y:x }, Line2:{ X:top, Y:x } };
            else
                aryPoint[i]={ Line:{ X:x, Y:top }, Line2:{ X:x, Y:bottom } };
        }

        this.DrawBG(aryPoint);
    }

    this.DrawBG=function(aryPoint)
    {
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var halfWidth=(distanceWidth+dataWidth)/2;
        var firstPoint=true;
        var pointCount=0;
        var aryLine2=[];
        var color=null;
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (!item || (color && item.Color!=color) )
            {
                if (pointCount>0)
                {
                    for(var j=aryLine2.length-1; j>=0; --j)
                    {
                        var item2=aryLine2[j];
                        if (this.IsHScreen)
                        {
                            this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y+halfWidth);
                            this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y-halfWidth);
                        }
                        else
                        {
                            this.Canvas.lineTo(item2.Line2.X+halfWidth, item2.Line2.Y);
                            this.Canvas.lineTo(item2.Line2.X-halfWidth, item2.Line2.Y);
                        }
                    }
                    this.Canvas.closePath();
                    this.Canvas.fill();
                }

                firstPoint=true;
                pointCount=0;
                aryLine2=[];
                color=null;
            }

            if (!item) continue;

            if (firstPoint)
            {
                this.Canvas.beginPath();
                if (this.IsHScreen)
                {
                    this.Canvas.moveTo(item.Line.X, item.Line.Y-halfWidth);
                    this.Canvas.lineTo(item.Line.X, item.Line.Y+halfWidth);
                }
                else
                {
                    this.Canvas.moveTo(item.Line.X-halfWidth, item.Line.Y);
                    this.Canvas.lineTo(item.Line.X+halfWidth, item.Line.Y);
                }
                firstPoint=false;
                color=item.Color;
            }
            else
            {
                if (this.IsHScreen)
                {
                    this.Canvas.lineTo(item.Line.X, item.Line.Y-halfWidth);
                    this.Canvas.lineTo(item.Line.X, item.Line.Y+halfWidth);
                }
                else
                {
                    this.Canvas.lineTo(item.Line.X-halfWidth, item.Line.Y);
                    this.Canvas.lineTo(item.Line.X+halfWidth, item.Line.Y);
                }
            }

            aryLine2.push(item);
            ++pointCount;
        }

        if (pointCount>0)
        {
            for(var j=aryLine2.length-1; j>=0; --j)
            {
                var item2=aryLine2[j];
                if (this.IsHScreen)
                {
                    this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y+halfWidth);
                    this.Canvas.lineTo(item2.Line2.X, item2.Line2.Y-halfWidth);
                }
                else
                {
                    this.Canvas.lineTo(item2.Line2.X+halfWidth, item2.Line2.Y);
                    this.Canvas.lineTo(item2.Line2.X-halfWidth, item2.Line2.Y);
                }
            }
            this.Canvas.closePath();
            this.Canvas.fill();
        }
    }

    this.GetMaxMin=function()
    {
        return { Min:null, Max:null };
    }
}

//填充部分背景 支持横屏
function ChartBackgroundDiv()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartBackgroundDiv";

    this.AryColor;
    this.ColorType=0;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryColor)) return;

        if (!this.Data || !this.Data.Data) return;

        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;
        var border,xOffset, chartright, yTop, yBottom;

        if (bHScreen) 
        {
            border=this.ChartBorder.GetHScreenBorder();
            xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.BottomEx;
            yTop=border.LeftEx;
            yBottom=border.RightEx;
        }
        else 
        {
            border=this.ChartBorder.GetBorder();
            xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            chartright=border.RightEx;
            yTop=border.TopEx;
            yBottom=border.BottomEx;
        }

        var rtBG=null //{ Left:null, Top:null, Right:null, Bottom:null };
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;

            if (!item)
            {
                if (rtBG) this.DrawDiv(rtBG,bHScreen);

                rtBG=null;
            }
            else
            {
                var y=yTop;
                var y2=yBottom;
                if (IFrameSplitOperator.IsNonEmptyArray(item.AryValue))
                {
                    var value=this.ChartFrame.GetYFromData(item.AryValue[0]);
                    var value2=this.ChartFrame.GetYFromData(item.AryValue[1]);
                    y=Math.min(value, value2);
                    y2=Math.max(value, value2);
                }

                if (bHScreen)
                {
                    if (!rtBG)
                    {
                        rtBG={ Left:y, Right:y2, Top:left, Bottom:right };
                    }
                    else
                    {
                        rtBG.Bottom=right;
                        if (rtBG.Left>y) rtBG.Left=y;
                        if (rtBG.Right<y2) rtBG.Right=y2;
                    }
                }
                else
                {
                    if (!rtBG)
                    {
                        rtBG={ Left:left, Right:right, Top:y, Bottom:y2 };
                    }
                    else
                    {
                        rtBG.Right=right;
                        if (rtBG.Top>y) rtBG.Top=y;
                        if (rtBG.Bottom<y2) rtBG.Bottom=y2;
                    }
                }
            }
        }
    }

    this.DrawDiv=function(rtBG, bHScreen)
    {
        if (this.ColorType==2)          //2=用COLOR1画框线
        {
            this.Canvas.strokeStyle = this.AryColor[0];
            this.Canvas.strokeRect(ToFixedPoint(rtBG.Left),ToFixedPoint(rtBG.Top),ToFixedRect(rtBG.Right-rtBG.Left),ToFixedRect(rtBG.Bottom-rtBG.Top));
        }
        else if (this.ColorType==3)     //3=用COLOR1画框线,用COLOR2填充
        {
            this.Canvas.fillStyle=this.AryColor[1];
            this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top),ToFixedRect(rtBG.Right-rtBG.Left),ToFixedRect(rtBG.Bottom-rtBG.Top));

            this.Canvas.strokeStyle = this.AryColor[0];
            this.Canvas.strokeRect(ToFixedPoint(rtBG.Left),ToFixedPoint(rtBG.Top),ToFixedRect(rtBG.Right-rtBG.Left),ToFixedRect(rtBG.Bottom-rtBG.Top));
        }
        else if (this.ColorType==0 || this.ColorType==1)      //0=上下渐进 1=左右渐进
        {
            var gradient=null;
            if (bHScreen)
            {
                if (this.ColorType==0)
                    gradient = this.Canvas.createLinearGradient(rtBG.Left,rtBG.Top, rtBG.Right,rtBG.Top);
                else 
                    gradient = this.Canvas.createLinearGradient(rtBG.Left,rtBG.Top, rtBG.Left,rtBG.Bottom); 
            }
            else
            {
                if (this.ColorType==0)
                    gradient = this.Canvas.createLinearGradient(rtBG.Left,rtBG.Top, rtBG.Left,rtBG.Bottom);
                else 
                    gradient = this.Canvas.createLinearGradient(rtBG.Left,rtBG.Top, rtBG.Right,rtBG.Top);
            }
    
            gradient.addColorStop(0.5, this.AryColor[0]);
            gradient.addColorStop(1, this.AryColor[1]);
    
            this.Canvas.fillStyle=gradient;
            this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top),ToFixedRect(rtBG.Right-rtBG.Left),ToFixedRect(rtBG.Bottom-rtBG.Top));
        }
        else
        {
            return;
        }
    }
}

//画矩形
function ChartRectangle()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartRectangle";

    this.Color=[];
    this.Rect;
    this.BorderColor=g_JSChartResource.FrameBorderPen;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Color || !this.Rect) return;
        if (this.Color.length<=0) return;

        this.Canvas.strokeStyle=this.BorderColor;
        var bFill=false;
        if (this.Color.length==2)
        {
            /*  TODO 渐变下次做吧
            if (this.ColorAngle==0)
            {
                var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
                var ptEnd={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetBottomEx() };
            }
            else
            {
                var ptStart={ X:this.ChartBorder.GetLeft(), Y:this.ChartBorder.GetTopEx() };
                var ptEnd={ X:this.ChartBorder.GetRight(), Y:this.ChartBorder.GetTopEx() };
            }

            let gradient = this.Canvas.createLinearGradient(ptStart.X,ptStart.Y, ptEnd.X,ptEnd.Y);
            gradient.addColorStop(0, this.Color[0]);
            gradient.addColorStop(1, this.Color[1]);
            this.Canvas.fillStyle=gradient;
            */

            this.Canvas.fillStyle=this.Color[0];
            bFill=true;
        }
        else if (this.Color.length==1)
        {
            if (this.Color[0])
            {
                this.Canvas.fillStyle=this.Color[0];
                bFill=true;
            }
        }
        else
        {
            return;
        }

        var chartWidth=this.ChartBorder.GetWidth();
        var chartHeight=this.ChartBorder.GetHeightEx();
        var left=this.Rect.Left/1000*chartWidth;
        var top=this.Rect.Top/1000*chartHeight;
        var right=this.Rect.Right/1000*chartWidth;
        var bottom=this.Rect.Bottom/1000*chartHeight;

        left=this.ChartBorder.GetLeft()+left
        top=this.ChartBorder.GetTopEx()+top;
        right=this.ChartBorder.GetLeft()+right;
        bottom=this.ChartBorder.GetTopEx()+bottom;
        var width=Math.abs(left-right);
        var height=Math.abs(top-bottom);
        if (bFill) this.Canvas.fillRect(left, top,width, height);
        this.Canvas.beginPath();
        this.Canvas.rect(ToFixedPoint(left), ToFixedPoint(top),ToFixedRect(width), ToFixedRect(height));
        this.Canvas.stroke();
    }
}

// 文字+线段输出
function ChartTextLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartTextLine";

    this.Text;  //Text=内容 Color
    this.Line;  //Type=线段类型 0=不画 1=直线 2=虚线, Color
    this.Price;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Text || !this.Line || !IFrameSplitOperator.IsNumber(this.Price)) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var bottom=this.ChartBorder.GetBottomEx();
        var top=this.ChartBorder.GetTopEx();
        var y=this.ChartFrame.GetYFromData(this.Price);
        var textWidth=0;
        if (this.Text.Title)
        {
            var x=left+2*GetDevicePixelRatio();
            var yText=y;
            this.Canvas.textAlign = 'left';
            this.Canvas.textBaseline = 'middle';
            var offsetY=8*GetDevicePixelRatio();
            if (y-offsetY<top) 
            {
                this.Canvas.textBaseline='top';
                yText=top;
            }
            else if (y+offsetY>bottom) 
            {
                this.Canvas.textBaseline='bottom';
                yText=bottom;
            }
            
            this.Canvas.fillStyle = this.Text.Color;
            this.Canvas.font = this.Text.Font;
            this.Canvas.fillText(this.Text.Title, x, yText);
            textWidth=this.Canvas.measureText(this.Text.Title).width+4*GetDevicePixelRatio();
        }

        if (this.Line.Type>0)
        {
            if (this.Line.Type==2)  //虚线
            {
                this.Canvas.save();
                this.Canvas.setLineDash([3,5]);   //虚线
            }

            var x=left+textWidth;
            this.Canvas.strokeStyle=this.Line.Color;
            this.Canvas.beginPath();
            this.Canvas.moveTo(x,ToFixedPoint(y));
            this.Canvas.lineTo(right,ToFixedPoint(y));
            this.Canvas.stroke();

            if (this.Line.Type==2)
            {
                this.Canvas.restore();
            }
        }

    }

    this.GetMaxMin=function()
    {
        var range={Min:null, Max:null};
        if (IFrameSplitOperator.IsNumber(this.Price))
        {
            range.Min=this.Price;
            range.Max=this.Price;
        }
        
        return range;
    }
}

// 柱子集合  支持横屏
function ChartMultiBar()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    
    this.ClassName="ChartMultiBar";
    this.Bars=[];   // [ {Point:[ {Index, Value, Value2 }, ], Color:, Width: , Type: 0 实心 1 空心 }, ] 
    this.IsHScreen=false;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;
        if (!this.Data || this.Data.length<=0) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;
        var dataWidth=this.ChartFrame.DataWidth;
        var pixelRatio=GetDevicePixelRatio();

        var drawBars=[];
        for(var i in this.Bars)
        {
            var item=this.Bars[i];
            var drawPoints={ Point:[], Color:item.Color, Width:dataWidth, Type:0 };
            if (item.Type>0) drawPoints.Type=item.Type;
            if (item.Width>0) 
            {
                drawPoints.Width=item.Width*pixelRatio;
                if (drawPoints.Width>dataWidth) drawPoints.Width=dataWidth;
            }
            else
            {
                if(drawPoints.Width<4) drawPoints.Width=1*pixelRatio;
            }

            for(var j in item.Point)
            {
                var point=item.Point[j];
                if (!IFrameSplitOperator.IsNumber(point.Index)) continue;

                var index=point.Index-offset;
                if (index>=0 && index<xPointCount)
                {
                    var x=this.ChartFrame.GetXFromIndex(index);
                    var y=this.ChartFrame.GetYFromData(point.Value);
                    var y2=this.ChartFrame.GetYFromData(point.Value2);
                    drawPoints.Point.push({X:x, Y:y, Y2:y2});
                }
            }

            if (drawPoints.Point.length>0) drawBars.push(drawPoints)
        }

        for(var i in drawBars)
        {
            var item=drawBars[i];
            if (item.Width>=4) 
            {
                if (item.Type==1) this.DrawHollowBar(item);
                else this.DrawFillBar(item);
            }
            else 
            {
                this.DrawLineBar(item);
            }
        }
    }

    this.DrawLineBar=function(bar)
    {
        this.Canvas.strokeStyle=bar.Color;
        var backupLineWidth=this.Canvas.lineWidth;
        this.Canvas.lineWidth=bar.Width;
        for(var i in bar.Point)
        {
            var item=bar.Point[i];

            this.Canvas.beginPath();
            if (this.IsHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(item.Y),ToFixedPoint(item.X));
                this.Canvas.lineTo(ToFixedPoint(item.Y2),ToFixedPoint(item.X));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(item.X),ToFixedPoint(item.Y));
                this.Canvas.lineTo(ToFixedPoint(item.X),ToFixedPoint(item.Y2));
            }
            
            this.Canvas.stroke();
        }

        this.Canvas.lineWidth=backupLineWidth;
    }

    this.DrawFillBar=function(bar)
    {
        this.Canvas.fillStyle=bar.Color;
        for(var i in bar.Point)
        {
            var item=bar.Point[i];
            var x=item.X-(bar.Width/2);
            var y=Math.min(item.Y,item.Y2);
            var barWidth=bar.Width;
            var barHeight=Math.abs(item.Y-item.Y2);
            if (this.IsHScreen)
                this.Canvas.fillRect(ToFixedRect(y),ToFixedRect(x),ToFixedRect(barHeight),ToFixedRect(barWidth));
            else 
                this.Canvas.fillRect(ToFixedRect(x),ToFixedRect(y),ToFixedRect(barWidth),ToFixedRect(barHeight));
        }
    }

    this.DrawHollowBar=function(bar)    //空心柱子
    {
        this.Canvas.strokeStyle=bar.Color;
        var backupLineWidth=1;
        for(var i in bar.Point)
        {
            var item=bar.Point[i];
            var x=item.X-(bar.Width/2);
            var y=Math.min(item.Y,item.Y2);
            var barWidth=bar.Width;
            var barHeight=Math.abs(item.Y-item.Y2);
            this.Canvas.beginPath();
            if (this.IsHScreen)
                this.Canvas.rect(ToFixedPoint(y),ToFixedPoint(x),ToFixedRect(barHeight),ToFixedRect(barWidth));
            else
                this.Canvas.rect(ToFixedPoint(x),ToFixedPoint(y),ToFixedRect(barWidth),ToFixedRect(barHeight));

            this.Canvas.stroke();
        }

        this.Canvas.lineWidth=backupLineWidth;
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;
        for(var i in this.Bars)
        {
            var item=this.Bars[i];
            for(var j in item.Point)
            {
                var point=item.Point[j];
                if (point.Index>=start && point.Index<end)
                {
                    var minValue=Math.min(point.Value,point.Value2);
                    var maxValue=Math.max(point.Value,point.Value2);
                    if (range.Max==null) range.Max=maxValue;
                    else if (range.Max<maxValue) range.Max=maxValue;
                    if (range.Min==null) range.Min=minValue;
                    else if (range.Min>minValue) range.Min=minValue;
                }
            }
        }

        return range;
    }
}

// 线段集合 支持横屏
function ChartMultiLine()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    
    this.ClassName="ChartMultiLine";
    this.Lines=[];   // [ {Point:[ {Index, Value }, ], Color:  }, ] 
    this.LineDash;
    this.LineWidth=1;
    this.IsHScreen=false;

    //箭头配置
    this.ArrawAngle=35;     //三角斜边一直线夹角
    this.ArrawLength=10;    //三角斜边长度
    this.ArrawLineWidth=5;  //箭头粗细
    this.Arrow={ Start:false, End:false };  //Start=是否绘制开始箭头 <-   End=是否绘制结束箭头 ->

    this.IsFullRangeMaxMin=false;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;
        if (!this.Data || this.Data.length<=0) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Lines)) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;

        var drawLines=[];
        var arrowLines=[];
        for(var i=0; i<this.Lines.length; ++i)
        {
            var line=this.Lines[i];
            var drawPoints={ Point:[], Color:line.Color, AryCircle:null };
            var drawArrowPoints={ Start:[], End:[] };
            if (line.BGColor) drawPoints.BGColor=line.BGColor;
            if (IFrameSplitOperator.IsNonEmptyArray(line.Circle)) drawPoints.AryCircle=line.Circle;

            var isExtendLine=false;
            if (IFrameSplitOperator.IsBool(line.IsExtendLine)) isExtendLine=line.IsExtendLine;
           
            if (isExtendLine)   //左右延申
            {
                var prePoint=null;
                var bFirstPoint=true;
                for(var j=0; j<line.Point.length; ++j)
                {
                    var point=line.Point[j];
                    if (!IFrameSplitOperator.IsNumber(point.Index)) continue;

                    var index=point.Index-offset;
                    if (index>0 && index<xPointCount)
                    {
                        if (bFirstPoint)
                        {
                            if (prePoint)
                            {
                                var preIndex=prePoint.Index-offset;

                                var x=this.ChartFrame.GetXFromIndex(preIndex, false);
                                var y=this.ChartFrame.GetYFromData(prePoint.Value, false);

                                var pointItem={X:x, Y:y, End:false};
                                drawPoints.Point.push(pointItem);
                            }

                            bFirstPoint=false;
                        }

                        var x=this.ChartFrame.GetXFromIndex(index, false);
                        var y=this.ChartFrame.GetYFromData(point.Value, false);

                        var pointItem={X:x, Y:y, End:false};
                        drawPoints.Point.push(pointItem);
                    }
                    else 
                    {
                        if (drawPoints.Point.length>0)
                        {
                            var x=this.ChartFrame.GetXFromIndex(index, false);
                            var y=this.ChartFrame.GetYFromData(point.Value, false);
    
                            var pointItem={X:x, Y:y, End:true};
                            drawPoints.Point.push(pointItem);

                            bFirstPoint=true;
                            prePoint=null;
                        }
                    }

                    prePoint=point;
                }

                if (drawPoints.Point.length>=2) 
                {
                    drawLines.push(drawPoints);
                    arrowLines.push(drawArrowPoints);
                }
            }
            else
            {
                for(var j=0; j<line.Point.length; ++j)
                {
                    var point=line.Point[j];
                    if (!IFrameSplitOperator.IsNumber(point.Index)) continue;
    
                    var index=point.Index-offset;
                    if (index>=0 && index<xPointCount)
                    {
                        var x=this.ChartFrame.GetXFromIndex(index);
                        var y=this.ChartFrame.GetYFromData(point.Value, false);
                        var pointItem={X:x, Y:y, End:false};

                        drawPoints.Point.push(pointItem);
    
                        if (j==0 || j==1) drawArrowPoints.Start.push(pointItem);    //起始点
                        if (j==line.Point.length-1 || j==line.Point.length-2) drawArrowPoints.End.push(pointItem);  //结束点
                    }
                    else
                    {
                        if (drawPoints.Point.length>0) drawPoints.Point[drawPoints.Point.length-1].End=true;  //点断开
                    }
                }
    
                if (drawPoints.Point.length>=2) 
                {
                    drawLines.push(drawPoints);
                    arrowLines.push(drawArrowPoints);
                }
            }
        }

        var pixelRatio=GetDevicePixelRatio();
        this.Canvas.save();
        this.ClipClient(this.IsHScreen);
        //绘制线段
        for(var i=0; i<drawLines.length; ++i)
        {
            if (this.LineDash) this.Canvas.setLineDash(this.LineDash);
            if (IFrameSplitOperator.IsPlusNumber(this.LineWidth)) this.Canvas.lineWidth=this.LineWidth*pixelRatio;
            else this.Canvas.lineWidth=1*pixelRatio;
            var item=drawLines[i];
            this.DrawLine(item, arrowLines[i]);

            //绘制圆点
            if (item.AryCircle) this.DrawCircle(item)
        }

        this.Canvas.restore();
    }

    this.DrawCircle=function(line)
    {
        var pixelRatio=GetDevicePixelRatio();
        
        for(var i=0; i<line.Point.length; ++i)
        {
            var item=line.Point[i];

            for(var j=0;j<line.AryCircle.length;++j)
            {
                var circleItem=line.AryCircle[j];
                
                var type=0;
                if (IFrameSplitOperator.IsNumber(circleItem.Type)) type=circleItem.Type;
                
                this.Canvas.beginPath();
                this.Canvas.arc(item.X, item.Y, circleItem.Radius, 0, 2 * Math.PI);

                if (type==1)
                {
                    if (IFrameSplitOperator.IsPlusNumber(circleItem.LineWidth)) this.Canvas.lineWidth=circleItem.LineWidth*pixelRatio;
                    this.Canvas.strokeStyle=circleItem.Color;
                    this.Canvas.stroke();
                }
                else
                {
                    this.Canvas.fillStyle=circleItem.Color;
                    this.Canvas.fill()
                }
                
            }
        }
    }

    this.DrawLine=function(line, arrow)
    {
        if (line.BGColor)   //背景色
        {
            this.Canvas.fillStyle=line.BGColor;
            for(var i=0; i<line.Point.length; ++i)
            {
                var item=line.Point[i];
                if (i==0)
                {
                    this.Canvas.beginPath();
                    if (this.IsHScreen) this.Canvas.moveTo(item.Y,item.X);
                    else this.Canvas.moveTo(item.X,item.Y);
                }
                else
                {
                    if (this.IsHScreen) this.Canvas.lineTo(item.Y,item.X);
                    else this.Canvas.lineTo(item.X,item.Y);
                }
            }
            this.Canvas.closePath();
            this.Canvas.fill();
        }

        this.Canvas.strokeStyle=line.Color;
        var drawCount=0;
        for(var i=0; i<line.Point.length; ++i)
        {
            var item=line.Point[i];
            if (drawCount==0)
            {
                this.Canvas.beginPath();
                if (this.IsHScreen) this.Canvas.moveTo(item.Y,item.X);
                else this.Canvas.moveTo(item.X,item.Y);
                ++drawCount;
            }
            else
            {
                if (this.IsHScreen) this.Canvas.lineTo(item.Y,item.X);
                else this.Canvas.lineTo(item.X,item.Y);
                ++drawCount;
            }

            if (item.End==true) //点断了 要重新画
            {
                if (drawCount>0) this.Canvas.stroke();
                drawCount=0;
            }
        }

        if (drawCount>0) this.Canvas.stroke();

        //绘制箭头
        if (arrow.End.length==2 && this.Arrow.End==true)    
            this.DrawArrow(arrow.End[0],arrow.End[1]);

        if (arrow.Start.length==2 && this.Arrow.Start==true)
            this.DrawArrow(arrow.Start[1],arrow.Start[0]);
       
    }

    this.DrawArrow=function(ptStart,ptEnd)
    {
        //计算箭头
        var theta=this.ArrawAngle;       //三角斜边一直线夹角
        var headlen=this.ArrawLength;    //三角斜边长度
        var angle = Math.atan2(ptStart.Y - ptEnd.Y, ptStart.X - ptEnd.X) * 180 / Math.PI,
        angle1 = (angle + theta) * Math.PI / 180,
        angle2 = (angle - theta) * Math.PI / 180,
        topX = headlen * Math.cos(angle1),
        topY = headlen * Math.sin(angle1),
        botX = headlen * Math.cos(angle2),
        botY = headlen * Math.sin(angle2);

        this.Canvas.beginPath();
        var arrowX = ptEnd.X + topX;
        var arrowY = ptEnd.Y + topY;
        this.Canvas.moveTo(arrowX,arrowY);

        this.Canvas.lineTo(ptEnd.X, ptEnd.Y);

        arrowX = ptEnd.X + botX;
        arrowY = ptEnd.Y + botY;
        this.Canvas.lineTo(arrowX,arrowY);

        this.Canvas.setLineDash([]);
        this.Canvas.lineWidth=this.ArrawLineWidth*GetDevicePixelRatio();
        this.Canvas.stroke();
    }

    this.GetMaxMin=function()
    {
        if (this.IsFullRangeMaxMin) return this.GetFullRangeMaxMin();

        var range={ Min:null, Max:null };
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;

        for(var i in this.Lines)
        {
            var line=this.Lines[i];
            for(var j in line.Point)
            {
                var point=line.Point[j];
                if (point.Index>=start && point.Index<end)
                {
                    if (range.Max==null) range.Max=point.Value;
                    else if (range.Max<point.Value) range.Max=point.Value;
                    if (range.Min==null) range.Min=point.Value;
                    else if (range.Min>point.Value) range.Min=point.Value;
                }
            }
        }

        return range;
    }

    //全部数据的最大最小值
    this.GetFullRangeMaxMin=function()
    {
        var range={ Min:null, Max:null };
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Lines)) return range;

        for(var i=0; i<this.Lines.length; ++i)
        {
            var line=this.Lines[i];
            if (!IFrameSplitOperator.IsNonEmptyArray(line.Point)) continue;

            for(var j=0; j<line.Point.length; ++j)
            {
                var point=line.Point[j];
                
                if (range.Max==null) range.Max=point.Value;
                else if (range.Max<point.Value) range.Max=point.Value;
                if (range.Min==null) range.Min=point.Value;
                else if (range.Min>point.Value) range.Min=point.Value;
            }
        }

        return range;
    }
}

// 线段集合 支持横屏
function ChartMultiPoint()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;
    
    this.ClassName="ChartMultiPoint";
    this.PointGroup=[];   // [ {Point:[ {Index, Value }, ], Color:  }, ] 


    this.IsHScreen=false;
    this.LineWidth=1;
    this.PointRadius=5;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Data || this.Data.length<=0) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.PointGroup)) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;
        var pixel=GetDevicePixelRatio();

        this.Canvas.save();
        this.ClipClient(this.IsHScreen);
        
        for(var i=0; i<this.PointGroup.length; ++i)
        {
            var item=this.PointGroup[i];
            var color=item.Color;
            var bgColor=item.BGColor;
            var lineWidth=this.LineWidth;
            var radius=this.PointRadius;
            if (IFrameSplitOperator.IsNumber(item.LineWidth)) lineWidth=item.LineWidth;
            if (IFrameSplitOperator.IsNumber(item.PointRadius)) radius=item.PointRadius;
            var path=new Path2D();
            var count=0;

            for(var j=0; j<item.Point.length; ++j)
            {
                var point=item.Point[j];
                if (!IFrameSplitOperator.IsNumber(point.Index)) continue;

                var index=point.Index-offset;
                if (index>=0 && index<xPointCount)
                {
                    var x=this.ChartFrame.GetXFromIndex(index);
                    var y=this.ChartFrame.GetYFromData(point.Value, false);

                    var pointPath = new Path2D();
                    if (this.IsHScreen) 
                        pointPath.arc(y,x,radius*pixel,0,360,false);
                    else
                        pointPath.arc(x,y,radius*pixel,0,360,false);

                    path.addPath(pointPath);
                    ++count;
                }
            }

            if (count>0 && (bgColor || color))
            {
                this.Canvas.lineWidth=lineWidth*pixel;
                this.Canvas.fillStyle=bgColor;      //背景填充颜色
                this.Canvas.strokeStyle=color;

                if (bgColor) this.Canvas.fill(path);
                if (color) this.Canvas.stroke(path);
            }
                
        }

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;

        for(var i=0; i<this.PointGroup.length; ++i)
        {
            var item=this.PointGroup[i];
            if (!IFrameSplitOperator.IsNonEmptyArray(item.Point)) continue;

            for(var j=0; j<item.Point.length; ++j)
            {
                var point=item.Point[j];
                if (point.Index>=start && point.Index<end)
                {
                    if (range.Max==null) range.Max=point.Value;
                    else if (range.Max<point.Value) range.Max=point.Value;
                    if (range.Min==null) range.Min=point.Value;
                    else if (range.Min>point.Value) range.Min=point.Value;
                }
            }
        }

        return range;
    }
}

// 多文本集合 支持横屏
function ChartMultiText()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartMultiText";
    this.Texts=[];  //[ {Index:, Value:, Text:, Color:, Font: , Baseline:, Line:{ Color:, Dash:[虚线点], KData:"H/L", Offset:[5,10], Width:线粗细 }} ]
    this.Font=g_JSChartResource.DefaultTextFont;
    this.Color=g_JSChartResource.DefaultTextColor;
    this.IsHScreen=false;   //是否横屏

    this.BuildKey=function(item)
    {
        if (IFrameSplitOperator.IsNumber(item.Time))
        {
            var key=`${item.Date}-${item.Time}`;
        }
        else
        {
            var key=`${item.Date}`;
        }
        
        return key;
    }

    this.GetShowTextData=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;

        var mapText=new Map();  //key='date-time' value={ Data:[] }
        for(var i=0; i<this.Texts.length; ++i)
        {
            var item=this.Texts[i];
            if (!item.Text) continue;
            if (!IFrameSplitOperator.IsNumber(item.Index)) continue;

            var index=item.Index-offset;
            if (index>=0 && index<xPointCount)
            {
                var key=this.BuildKey(item);
                if (mapText.has(key))
                {
                    var textItem=mapText.get(key);
                    textItem.Data.push(item);
                }
                else
                {
                    var textItem={ Data:[item] };
                    mapText.set(key, textItem);
                }
            }
        }

        return mapText;
    }

    this.DrawAllText=function(mapText)
    {
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var isMinute=this.IsMinuteFrame();
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var chartleft=border.TopEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var left=this.ChartBorder.GetTop();
            var right=this.ChartBorder.GetBottom();
            var top=border.RightEx;
            var bottom=border.LeftEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var chartleft=border.LeftEx;
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=border.TopEx;
            var bottom=border.BottomEx;
        }

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var kItem=this.Data.Data[i];
            if (!kItem) continue;

            var key=this.BuildKey(kItem);
            if (!mapText.has(key)) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;

            var textItem=mapText.get(key);
            for(var k=0;k<textItem.Data.length;++k)
            {
                var item=textItem.Data[k];
                var y=top;
                if (item.Value=="TOP") y=top;
                else if (item.Value=="BOTTOM") y=bottom;
                else y=this.ChartFrame.GetYFromData(item.Value, false);

                if (item.Color)  this.Canvas.fillStyle = item.Color;
                else this.Canvas.fillStyle = this.Color;
                if (item.Font) this.Canvas.font = item.Font;
                else this.Canvas.font=this.Font;

                var textWidth=this.Canvas.measureText(item.Text).width;
                this.Canvas.textAlign='center';
                if (x+textWidth/2>=chartright) 
                {
                    this.Canvas.textAlign='right';
                    x=chartright;
                }
                else if (x-textWidth/2<chartleft)
                {
                    this.Canvas.textAlign = 'left';
                    x=chartleft;
                }
                
                if (item.Baseline==1) this.Canvas.textBaseline='top';
                else if (item.Baseline==2) this.Canvas.textBaseline='bottom';
                else this.Canvas.textBaseline = 'middle';

                if (this.IsHScreen)
                {
                    this.Canvas.save(); 
                    this.Canvas.translate(y, x);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(item.Text,0,0);
                    this.Canvas.restore();
                }
                else
                {
                    if (IFrameSplitOperator.IsNumber(item.YMove)) y+=item.YMove;
                    this.Canvas.fillText(item.Text, x, y);
                }

                if (item.Line)
                {
                    var kItem=this.Data.Data[item.Index];
                    var price=item.Line.KData=="H"? kItem.High:kItem.Low;
                    var yPrice=this.ChartFrame.GetYFromData(price, false);
                    var yText=y;
                    if (Array.isArray(item.Line.Offset) && item.Line.Offset.length==2)
                    {
                        if (yText>yPrice) //文字在下方
                        {
                            yText-=item.Line.Offset[1];
                            yPrice+=item.Line.Offset[0]
                        }
                        else if (yText<yPrice)
                        {
                            yText+=item.Line.Offset[1];
                            yPrice-=item.Line.Offset[0]
                        }
                    }
                    this.Canvas.save();
                    if (item.Line.Dash) this.Canvas.setLineDash(item.Line.Dash);    //虚线
                    if (item.Line.Width>0) this.Canvas.lineWidth=item.Line.Width;   //线宽
                    this.Canvas.strokeStyle = item.Line.Color;
                    this.Canvas.beginPath();
                    if (this.IsHScreen)
                    {
                        this.Canvas.moveTo(yText, ToFixedPoint(x));
                        this.Canvas.lineTo(yPrice,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yText);
                        this.Canvas.lineTo(ToFixedPoint(x),yPrice);
                    }
                    
                    this.Canvas.stroke();
                    this.Canvas.restore();
                }
            }
        }
    }

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;
        if (!this.Data || this.Data.length<=0) return;
        if (!this.Texts) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        var mapText=this.GetShowTextData();
        if (mapText.size<=0) return;

        this.Canvas.save();
        this.ClipClient(this.IsHScreen);

        this.DrawAllText(mapText);

        this.Canvas.restore();
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        if (!this.Texts) return range;

        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;

        for(var i in this.Texts)
        {
            var item=this.Texts[i];
            if (!IFrameSplitOperator.IsNumber(item.Value)) continue;

            if (item.Index>=start && item.Index<end)
            {
                if (range.Max==null) range.Max=item.Value;
                else if (range.Max<item.Value) range.Max=item.Value;
                if (range.Min==null) range.Min=item.Value;
                else if (range.Min>item.Value) range.Min=item.Value;
            }
        }

        return range;
    }
}

// 图标集合 支持横屏
function ChartMultiSVGIcon()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartMultiSVGIcon";
    this.Icon;  //[ {Index:, Value:, Symbol:, Color:, Baseline:, Line:{ Color:, Dash:[虚线点], KData:"H/L", Offset:[5,10], Width:线粗细 } } ]
    this.IconSize={ Max: g_JSChartResource.DRAWICON.Icon.MaxSize, Min:g_JSChartResource.DRAWICON.Icon.MinSize ,    //图标的最大最小值
        Zoom:{ Type:g_JSChartResource.DRAWICON.Icon.Zoom.Type , Value:g_JSChartResource.DRAWICON.Icon.Zoom.Value } //放大倍数
    }; 
    this.Family;
    this.Color=g_JSChartResource.DefaultTextColor;
    this.IsHScreen=false;
    this.IconRect=[];   //0=序号,1=区域

    this.Draw=function()
    {
        this.IconRect=[];
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;
        if (!this.Data || this.Data.length<=0) return;
        if (!this.Family || !this.Icon) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Icon)) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;
        this.DataWidth=this.ChartFrame.DataWidth;
        this.DistanceWidth=this.ChartFrame.DistanceWidth;

        var border=this.GetBorder();
        if (this.IsHScreen)
        {
            var left=border.TopEx;
            var right=border.BottomEx;
        }
        else
        {
            var left=border.LeftEx;
            var right=border.RightEx;
        }

        var fontSize=this.GetDynamicIconSize(this.DataWidth,this.DistanceWidth,this.IconSize.Max,this.IconSize.Min,this.IconSize.Zoom);
        this.Canvas.font=fontSize+'px '+this.Family;

        for(var i=0; i<this.Icon.length; ++i)
        {
            var item=this.Icon[i];
            if (!IFrameSplitOperator.IsNumber(item.Index)) continue;

            var index=item.Index-offset;
            if (index>=0 && index<xPointCount)
            {
                var x=this.ChartFrame.GetXFromIndex(index);
                var y=this.ChartFrame.GetYFromData(item.Value);

                if (item.Color)  this.Canvas.fillStyle = item.Color;
                else this.Canvas.fillStyle = this.Color;

                var textWidth=this.Canvas.measureText(item.Symbol).width;
                this.Canvas.textAlign='center';
                var rtIcon=new Rect(x-fontSize/2,y-fontSize/2,fontSize,fontSize);
                if (x+textWidth/2>=right) 
                {
                    this.Canvas.textAlign='right';
                    x+=this.DataWidth/2;
                    rtIcon.X=x-fontSize;
                }
                else if (x-textWidth/2<left)
                {
                    this.Canvas.textAlign = 'left';
                    x-=this.DataWidth/2;
                    rtIcon.X=x;
                }

                if (item.Baseline==1) 
                {
                    this.Canvas.textBaseline='top';
                    rtIcon.Y=y;
                }
                else if (item.Baseline==2) 
                {
                    this.Canvas.textBaseline='bottom';
                    rtIcon.Y=y-fontSize;
                }
                else 
                {
                    this.Canvas.textBaseline = 'middle';
                    rtIcon.Y=y-fontSize/2;
                }

                if (this.IsHScreen)
                {
                    this.Canvas.save(); 
                    this.Canvas.translate(y, x);
                    this.Canvas.rotate(90 * Math.PI / 180);
                    this.Canvas.fillText(item.Symbol,0,0);
                    this.Canvas.restore();
                }
                else
                {
                    if (IFrameSplitOperator.IsNumber(item.YMove)) y+=item.YMove;
                    this.Canvas.fillText(item.Symbol, x, y);
                    if (item.Text) this.IconRect.push({ Index:i, Rect:rtIcon , Item:item });
                }

                if (item.Line)
                {
                    var kItem=this.Data.Data[item.Index];
                    var price=item.Line.KData=="H"? kItem.High:kItem.Low;
                    var yPrice=this.ChartFrame.GetYFromData(price);
                    var yText=y;
                    if (Array.isArray(item.Line.Offset) && item.Line.Offset.length==2)
                    {
                        if (yText>yPrice) //文字在下方
                        {
                            yText-=item.Line.Offset[1];
                            yPrice+=item.Line.Offset[0]
                        }
                        else if (yText<yPrice)
                        {
                            yText+=item.Line.Offset[1];
                            yPrice-=item.Line.Offset[0]
                        }
                    }
                    this.Canvas.save();
                    if (item.Line.Dash) this.Canvas.setLineDash(item.Line.Dash);    //虚线
                    if (item.Line.Width>0) this.Canvas.lineWidth=item.Line.Width;   //线宽
                    this.Canvas.strokeStyle = item.Line.Color;
                    this.Canvas.beginPath();
                    if (this.IsHScreen)
                    {
                        this.Canvas.moveTo(yText, ToFixedPoint(x));
                        this.Canvas.lineTo(yPrice,ToFixedPoint(x));
                    }
                    else
                    {
                        this.Canvas.moveTo(ToFixedPoint(x),yText);
                        this.Canvas.lineTo(ToFixedPoint(x),yPrice);
                    }
                    
                    this.Canvas.stroke();
                    this.Canvas.restore();
                }
            }
        }
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.IconRect)) return false;
        for(var i=0; i<this.IconRect.length; ++i)
        {
            var item=this.IconRect[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                JSConsole.Chart.Log('[ChartMultiSVGIcon::GetTooltipData] icon ', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=4; //指标
                return true;
            }
        }

        return false;
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;

        for(var i in this.Icon)
        {
            var item=this.Icon[i];
            if (item.Index>=start && item.Index<end)
            {
                if (range.Max==null) range.Max=item.Value;
                else if (range.Max<item.Value) range.Max=item.Value;
                if (range.Min==null) range.Min=item.Value;
                else if (range.Min>item.Value) range.Min=item.Value;
            }
        }

        return range;
    }
}


//图标集合(2.0) 支持横屏
function ChartMultiSVGIconV2()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartMultiSVGIconV2";
    this.AryIcon;  //[ {Index:, Value:, Symbol:, Color:, Baseline:, Line:{ Color:, Dash:[虚线点], KData:"H/L", Offset:[5,10], Width:线粗细 } } ]
    this.IconSize=
    { 
        Max: g_JSChartResource.DRAWICON.Icon.MaxSize, Min:g_JSChartResource.DRAWICON.Icon.MinSize ,    //图标的最大最小值
        Zoom:{ Type:g_JSChartResource.DRAWICON.Icon.Zoom.Type , Value:g_JSChartResource.DRAWICON.Icon.Zoom.Value } //放大倍数
    }; 
    this.Family;
    this.Color=g_JSChartResource.DefaultTextColor;
    this.IsHScreen=false;
    this.IconRect=[];   //0=序号,1=区域

    this.MapCache=null; //key=date/date-time  value={ Data:[] }

    this.BuildKey=function(item)
    {
        if (IFrameSplitOperator.IsNumber(item.Time)) return `${item.Date}-${item.Time}`;
        else return item.Date;
    }

    this.BuildCacheData=function()
    {
        var mapData=new Map();
        this.MapCache=mapData;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryIcon)) return;

        for(var i=0;i<this.AryIcon.length;++i)
        {
            var item=this.AryIcon[i];
            var key=this.BuildKey(item);
            if (mapData.has(key))
            {
                var mapItem=mapData.get(key);
                mapItem.Data.push(item);
            }
            else
            {
                mapData.set(key,{ Data:[item] });
            }
        }
    }

    this.ClipClient=function(isHScreen)          //裁剪客户端
    {
        if (isHScreen==true)
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var top=this.ChartBorder.GetTop();
            var bottom=this.ChartBorder.GetBottom();
        }

        this.Canvas.beginPath();
        this.Canvas.rect(left,top,(right-left),(bottom-top));
        //this.Canvas.stroke(); //调试用
        this.Canvas.clip();
    }

    this.Draw=function()
    {
        this.IconRect=[];
        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return; //k线数据
        if (!this.Family) return;
        if (!this.MapCache || this.MapCache.size<=0) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var isMinute=this.IsMinuteFrame();

        var border=this.GetBorder();
        if (this.IsHScreen)
        {
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            var chartLeft=border.TopEx;
        }
        else
        {
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var chartLeft=border.LeftEx;
        }

        this.Canvas.save();
        this.ClipClient(this.ChartFrame.IsHScreen);

        var fontSize=this.GetDynamicIconSize(dataWidth,distanceWidth,this.IconSize.Max,this.IconSize.Min,this.IconSize.Zoom);
        this.Canvas.font=fontSize+'px '+this.Family;

        var drawInfo={ Left:chartLeft, Right:chartright, FontSize:fontSize, DataWidth:dataWidth, DistanceWidth:distanceWidth };

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var kItem=this.Data.Data[i];
            var key=this.BuildKey(kItem);
            if (!this.MapCache.has(key)) continue;
            var mapItem=this.MapCache.get(key);

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            this.DrawItem(mapItem, kItem, x, drawInfo);
        }

        this.Canvas.restore();
    }

    this.GetKValue=function(kItem, valueName)
    {
        switch(valueName)
        {
            case "HIGH":
            case "H":
                return kItem.High;
            case "L":
            case "LOW":
                return kItem.Low;
            case "C":
            case "CLOSE":
                return kItem.Close;
            case "O":
            case "OPEN":
                return KItem.Open;
            default:
                return null;
        }
    }

    this.DrawItem=function(groupItem, kItem, x, drawInfo)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(groupItem.Data)) return;

        var fontSize=drawInfo.FontSize;
        var left=drawInfo.Left, right=drawInfo.Right;
        var dataWidth=drawInfo.DataWidth;
        //var distanceWidth=drawInfo.DistanceWidth;

        for(var i=0;i<groupItem.Data.length;++i)
        {
            var item=groupItem.Data[i]; 
            var value=item.Value;
            if (IFrameSplitOperator.IsString(item.Value)) value=this.GetKValue(kItem,item.Value);
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            var y=this.ChartFrame.GetYFromData(item.Value,false);

            if (item.Color)  this.Canvas.fillStyle = item.Color;
            else this.Canvas.fillStyle = this.Color;

            var textWidth=this.Canvas.measureText(item.Symbol).width;
            this.Canvas.textAlign='center';
            var rtIcon=new Rect(x-fontSize/2,y-fontSize/2,fontSize,fontSize);
             
            if (item.Baseline==1) 
            {
                this.Canvas.textBaseline='top';
                rtIcon.Y=y;
            }
            else if (item.Baseline==2) 
            {
                this.Canvas.textBaseline='bottom';
                rtIcon.Y=y-fontSize;
            }
            else 
            {
                this.Canvas.textBaseline = 'middle';
                rtIcon.Y=y-fontSize/2;
            } 

            if (this.IsHScreen)
            {
                this.Canvas.save(); 
                this.Canvas.translate(y, x);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(item.Symbol,0,0);
                this.Canvas.restore();
            }
            else
            {
                if (IFrameSplitOperator.IsNumber(item.YMove)) y+=item.YMove;
                this.Canvas.fillText(item.Symbol, x, y);
                if (item.Text) this.IconRect.push({ Rect:rtIcon , Item:item, KItem:kItem });
            }

            if (item.Line)
            {
                var price=item.Line.KData=="H"? kItem.High:kItem.Low;
                var yPrice=this.ChartFrame.GetYFromData(price, false);
                var yText=y;
                if (Array.isArray(item.Line.Offset) && item.Line.Offset.length==2)
                {
                    if (yText>yPrice) //文字在下方
                    {
                        yText-=item.Line.Offset[1];
                        yPrice+=item.Line.Offset[0]
                    }
                    else if (yText<yPrice)
                    {
                        yText+=item.Line.Offset[1];
                        yPrice-=item.Line.Offset[0]
                    }
                }
                this.Canvas.save();
                if (item.Line.Dash) this.Canvas.setLineDash(item.Line.Dash);    //虚线
                if (item.Line.Width>0) this.Canvas.lineWidth=item.Line.Width;   //线宽
                this.Canvas.strokeStyle = item.Line.Color;
                this.Canvas.beginPath();
                if (this.IsHScreen)
                {
                    this.Canvas.moveTo(yText, ToFixedPoint(x));
                    this.Canvas.lineTo(yPrice,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),yText);
                    this.Canvas.lineTo(ToFixedPoint(x),yPrice);
                }
                
                this.Canvas.stroke();
                this.Canvas.restore();
            }
        }
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.IconRect)) return false;
        for(var i=0; i<this.IconRect.length; ++i)
        {
            var item=this.IconRect[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                JSConsole.Chart.Log('[ChartMultiSVGIconV2::GetTooltipData] icon ', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=4; //指标
                return true;
            }
        }

        return false;
    }

    this.GetMaxMin=function()
    {
        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var range={ Min:null, Max:null };
        if(!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return range;
        if (!this.MapCache || this.MapCache.size<=0) return;
        var xPointCount=this.ChartFrame.XPointCount;

        for(var i=this.Data.DataOffset,j=0, k=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var kItem=this.Data.Data[i];
            var key=this.BuildKey(kItem);
            if (!this.MapCache.has(key)) continue;
            var mapItem=this.MapCache.get(key);
            if (!IFrameSplitOperator.IsNonEmptyArray(mapItem.Data)) continue;

            for(k=0;k<mapItem.Data.length;++k)
            {
                var item=mapItem.Data[k];
                var value=item.Value;
                if (IFrameSplitOperator.IsString(item.Value)) value=this.GetKValue(kItem,item.Value);
                if (!IFrameSplitOperator.IsNumber(value)) continue;

                if (range.Max==null) range.Max=value;
                else if (range.Max<value) range.Max=value;
                if (range.Min==null) range.Min=value;
                else if (range.Min>value) range.Min=value;
            }
        }

        return range;
    }
}

// 多dom节点
function ChartMultiHtmlDom()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartMultiHtmlDom";
    this.Texts=[];  //[ {Index:, Value:, Text: ] Text=dom内容
    this.IsHScreen=false;   //是否横屏
    this.DrawCallback;  //function(op, obj)  op:1=开始 2=结束 3=绘制单个数据 4=销毁
    this.DrawItem=[];
    this.EnableDraw=true;   //是否允许绘制
    this.HQChart;
    this.IsDestroy=false;   //是否已销毁

    this.Draw=function()
    {
        if (!this.EnableDraw) return;
        if (this.IsDestroy) return;

        this.DrawItem=[];
        if (this.DrawCallback) this.DrawCallback(1, {Self:this} );

        this.DrawDom();

        if (this.DrawCallback) this.DrawCallback(2, { Self:this, DrawItem:this.DrawItem } );
    }

    this.OnDestroy=function()
    {
        this.IsDestroy=true;
        if (this.DrawCallback) this.DrawCallback(4, { Self:this } );
    }

    this.DrawDom=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Data || this.Data.length<=0) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();
        var pixelTatio = GetDevicePixelRatio();
        if (this.HQChart)
        {
            var elementLeft=this.HQChart.UIElement.getBoundingClientRect().left;
            var elementTop=this.HQChart.UIElement.getBoundingClientRect().top;
        }
        else
        {
            var elementLeft=null,elementTop=null;
        }
        

        for(var i in this.Texts)
        {
            var item=this.Texts[i];

            if (!item.Text) continue;
            if (!IFrameSplitOperator.IsNumber(item.Index)) continue;

            var isMinuteFrame=this.IsMinuteFrame();

            var index=item.Index-offset;
            var kItem=this.Data.Data[item.Index];   //K线数据
            var obj={ KData:kItem, Item:item, IsShow:false, Self:this };
            if (index>=0 && index<xPointCount)
            {
                var x=this.ChartFrame.GetXFromIndex(index);
                if (item.Value=="Top")
                {
                    var y=top;
                }
                else if (item.Value=="Bottom")
                {
                    var y=bottom;
                }
                else
                {
                    var y=this.ChartFrame.GetYFromData(item.Value);
                }

                obj.X=x/pixelTatio;
                obj.Y=y/pixelTatio;
                obj.UIElement={Left:elementLeft, Top:elementTop};
                obj.IsShow=true;
            }

            this.DrawItem.push(obj);
            if (this.DrawCallback) this.DrawCallback(3, obj);

            if (item.Line)
            {
                if (isMinuteFrame)
                {
                    var price=this.Data.Data[item.Index];
                }
                else
                {
                    var kItem=this.Data.Data[item.Index];
                    var price=item.Line.KData=="H"? kItem.High:kItem.Low;
                }
                
                var yPrice=this.ChartFrame.GetYFromData(price);
                var yText=y;
                if (Array.isArray(item.Line.Offset) && item.Line.Offset.length==2)
                {
                    if (yText>yPrice) //文字在下方
                    {
                        yText-=item.Line.Offset[1];
                        yPrice+=item.Line.Offset[0]
                    }
                    else if (yText<yPrice)
                    {
                        yText+=item.Line.Offset[1];
                        yPrice-=item.Line.Offset[0]
                    }
                }
                this.Canvas.save();
                if (item.Line.Dash) this.Canvas.setLineDash(item.Line.Dash);    //虚线
                var pixelRatio=GetDevicePixelRatio();
                var lineWidth=1*pixelRatio;
                if (item.Line.Width>0) lineWidth=item.Line.Width*pixelRatio;
                this.Canvas.lineWidth=lineWidth;   //线宽
                this.Canvas.strokeStyle = item.Line.Color;
                this.Canvas.beginPath();
                if (this.IsHScreen)
                {
                    this.Canvas.moveTo(yText, ToFixedPoint(x));
                    this.Canvas.lineTo(yPrice,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint2(lineWidth,x),yText);
                    this.Canvas.lineTo(ToFixedPoint2(lineWidth,x),yPrice);
                }
                
                this.Canvas.stroke();
                this.Canvas.restore();
            }
        }
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;

        for(var i in this.Texts)
        {
            var item=this.Texts[i];
            if (!IFrameSplitOperator.IsNumber(item.Index)) continue;
            if (item.Index>=start && item.Index<end)
            {
                if (range.Max==null) range.Max=item.Value;
                else if (range.Max<item.Value) range.Max=item.Value;
                if (range.Min==null) range.Min=item.Value;
                else if (range.Min>item.Value) range.Min=item.Value;
            }
        }

        return range;
    }
}

//绘制SVG图标
function ChartDrawSVG()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartDrawSVG";
    this.Family;
    this.TextFont;
    this.Texts=[];  //[ { Index:, Value:, Symbol:, Text:, Size: } ] SVG:图标 Text:文字 Size:图标大小
    this.IsHScreen=false;   //是否横屏
    this.IsDestroy=false;   //是否已销毁
    this.EnableTooltip=true;
    this.TooltipRect=[];
    this.ExcludeArea=null;  //排除区域 { Left, Top, Width, Height, Type:0 }
    this.AutoPosition=null; //{ Direction:0, MaxYOffset:40 }    //自动调整Y轴偏移，防止文字重叠

    this.AryDrawRect=[];    //已经绘制的区域
    this.AutoYOffset=0;
    
    //this.Data;  存K线数据

    this.Draw=function()
    {
        this.TooltipRect=[];
        this.AryDrawRect=[];
        this.AutoYOffset=0;

        if (!this.IsShow || this.ChartFrame.IsMinSize || !this.IsVisible) return;
        if (this.IsShowIndexTitleOnly()) return;
        if (this.IsHideScriptIndex()) return;

        this.DrawSVG();
    }

    this.DrawDetail=function(rtSVG, data, svgItem)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Content)) return;
        
        var lefMargin=2;
        var rightMargin=2;
        var itemSpace=2;
        var rtBorder={ Left:rtSVG.Right, Right:rtSVG.Right, Bottom:rtSVG.Bottom };
        var rightBorder=0;  //右边的边界 0=div的宽度 1=图形框架边框
        if (IFrameSplitOperator.IsNumber(data.ItemSpace)) itemSpace=data.ItemSpace;
        if (IFrameSplitOperator.IsNumber(data.YOffset)) rtBorder.Bottom+=data.YOffset;
        if (IFrameSplitOperator.IsNumber(data.XOffset)) rtBorder.Left+=data.XOffset;

        if (IFrameSplitOperator.IsNumber(data.LeftMargin)) lefMargin=data.LeftMargin;
        if (IFrameSplitOperator.IsNumber(data.RightMargin)) rightMargin=data.RightMargin;

        if (IFrameSplitOperator.IsNumber(data.RightBorder)) rightBorder=data.RightBorder;

        if (data.Font)  this.Canvas.font=data.Font;
        else  this.Canvas.font=this.TextFont;
        this.Canvas.textBaseline='bottom';
        this.Canvas.textAlign='left';

        var textHeight=this.Canvas.measureText("擎").width+2;
        rtBorder.Height=textHeight+5;
        var yText=rtBorder.Bottom-(rtBorder.Height-textHeight)/2;
        var xText=rtBorder.Left+lefMargin;

        var aryText=[];
        for(var i=0;i<data.Content.length;++i)
        {
            if (aryText.length>0) xText+=itemSpace;

            var item=data.Content[i];
            if (!item.Text) continue;
            var textWidth=this.Canvas.measureText(item.Text).width+2;
            aryText.push({ X:xText, Y:yText, Width:textWidth, Data:item });
            xText+=textWidth;

            rtBorder.Right=xText;
        }

        rtBorder.Right+=rightMargin;
        rtBorder.Width=rtBorder.Right-rtBorder.Left;
        rtBorder.Top=rtBorder.Bottom-rtBorder.Height;

        var right=this.ChartBorder.GetChartWidth()-1;
        if (rightBorder==1) right=this.ChartBorder.GetRight();
        if (rtBorder.Right>right)   //右边显示不下,显示在左边
        {
            rtBorder.Right=rtSVG.Left;
            if (IFrameSplitOperator.IsNumber(data.XOffset)) rtBorder.Right-=data.XOffset;
            rtBorder.Left=rtBorder.Right-rtBorder.Width;
            var xText=rtBorder.Left+lefMargin;
            for(var i=0;i<aryText.length;++i)
            {
                if (i>0) xText+=itemSpace;

                var item=aryText[i];
                item.X=xText;
                xText+=item.Width;
            }
        }

        if (data.BGColor)
        {
            this.Canvas.fillStyle=data.BGColor;
            this.Canvas.fillRect(rtBorder.Left,rtBorder.Top,rtBorder.Width,rtBorder.Height);
        }

        if (data.BorderColor)
        {
            this.Canvas.strokeStyle=data.BorderColor;
            this.Canvas.strokeRect(ToFixedPoint(rtBorder.Left),ToFixedPoint(rtBorder.Top),ToFixedRect(rtBorder.Width),ToFixedRect(rtBorder.Height));
        }


        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
           
            this.Canvas.fillStyle = item.Data.Color;
            this.Canvas.fillText(item.Data.Text, item.X, item.Y);
        }

        this.AryDrawRect.push( {Left:rtBorder.Left, Top:rtBorder.Top, Right:rtBorder.Right, Bottom:rtBorder.Bottom, Type:"Detail", Data:svgItem } );
    }

    this.GetDetailPosition=function(rtSVG, data)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Content)) return null;
        
        var lefMargin=2;
        var rightMargin=2;
        var itemSpace=2;
        var rtBorder={ Left:rtSVG.Right, Right:rtSVG.Right, Bottom:rtSVG.Bottom };
        var rightBorder=0;  //右边的边界 0=div的宽度 1=图形框架边框
        if (IFrameSplitOperator.IsNumber(data.ItemSpace)) itemSpace=data.ItemSpace;
        if (IFrameSplitOperator.IsNumber(data.YOffset)) rtBorder.Bottom+=data.YOffset;
        if (IFrameSplitOperator.IsNumber(data.XOffset)) rtBorder.Left+=data.XOffset;

        if (IFrameSplitOperator.IsNumber(data.LeftMargin)) lefMargin=data.LeftMargin;
        if (IFrameSplitOperator.IsNumber(data.RightMargin)) rightMargin=data.RightMargin;

        if (IFrameSplitOperator.IsNumber(data.RightBorder)) rightBorder=data.RightBorder;

        if (data.Font)  this.Canvas.font=data.Font;
        else  this.Canvas.font=this.TextFont;

        var textHeight=this.Canvas.measureText("擎").width+2;
        rtBorder.Height=textHeight+5;
        var yText=rtBorder.Bottom-(rtBorder.Height-textHeight)/2;
        var xText=rtBorder.Left+lefMargin;

        var bFrist=true;
        for(var i=0;i<data.Content.length;++i)
        {
            if (!bFrist) xText+=itemSpace;

            var item=data.Content[i];
            if (!item.Text) continue;

            var textWidth=this.Canvas.measureText(item.Text).width+2;
            
            xText+=textWidth;
            rtBorder.Right=xText;
            bFrist=false;
        }

        rtBorder.Right+=rightMargin;
        rtBorder.Width=rtBorder.Right-rtBorder.Left;
        rtBorder.Top=rtBorder.Bottom-rtBorder.Height;

        var right=this.ChartBorder.GetChartWidth()-1;
        if (rightBorder==1) right=this.ChartBorder.GetRight();
        if (rtBorder.Right>right)   //右边显示不下,显示在左边
        {
            rtBorder.Right=rtSVG.Left;
            if (IFrameSplitOperator.IsNumber(data.XOffset)) rtBorder.Right-=data.XOffset;
            rtBorder.Left=rtBorder.Right-rtBorder.Width;
        }

        return rtBorder;
    }

    this.CalculateShowPosition=function(item, pt)
    {
        var x=pt.X, y=pt.Y;
        var svgItem=item.SVG;
        if (IFrameSplitOperator.IsNumber(svgItem.YOffset)) y+=svgItem.YOffset;
        var fontSVG=`${svgItem.Size}px ${this.Family}`;
        this.Canvas.font=fontSVG;
        var halfSize=svgItem.Size/2;
        var rtSVG={ Left:x-halfSize, Right:x+halfSize, Top:y-svgItem.Size, Bottom:y, Height:svgItem.Size, Width:svgItem.Size };

        if (svgItem.VAlign===0) //top
        {
            rtSVG.Top=y;
            rtSVG.Bottom=rtSVG.Top+svgItem.Size;
        }
        else if (svgItem.VAlign===1) //middle
        {
            rtSVG.Top=y-svgItem.Size/2;
            rtSVG.Bottom=rtSVG.Top+svgItem.Size;
        }

        if (rtSVG.Top<0) 
        {
            rtSVG.Top=0;
            rtSVG.Bottom=svgItem.Size;
            y=rtSVG.Bottom;
        }

        var rtContent=null;
        if (item.Detail)
            rtContent=this.GetDetailPosition(rtSVG,item.Detail);
        

        var yOffset=0, yMoveStep=-5;
        if (IFrameSplitOperator.IsNumber(this.AutoPosition.MoveYStep)) yMoveStep=-(Math.abs(this.AutoPosition.MoveYStep))
        for(var i=0;i<20;++i)
        {
            if (rtSVG && !rtContent)
            {
                if (!this.IsRectOverlap(rtSVG))
                    break;
            }
            else if (rtSVG && rtContent)
            {
                if (!this.IsRectOverlap(rtSVG) && !this.IsRectOverlap(rtContent))
                break;
            }

            yOffset+=yMoveStep;

            if (Math.abs(yOffset)>=this.AutoPosition.MaxYOffset) break;

            rtSVG.Top+=yMoveStep;
            rtSVG.Bottom+=yMoveStep;
            if (rtContent)
            {
                rtContent.Top+=yMoveStep;
                rtContent.Bottom+=yMoveStep;
            }
        }

        pt.X=x;
        pt.Y=y+yOffset;
       
    }

    this.IsRectOverlap=function(rect)
    {
        for(var i=0; i<this.AryDrawRect.length; ++i)
        {
            var item=this.AryDrawRect[i];
            if ( ((rect.Left>=item.Left && rect.Left<=item.Right) || (rect.Right>=item.Left && rect.Right<=item.Right)) &&
                 ((rect.Top>=item.Top && rect.Top<=item.Bottom) || (rect.Bottom>=item.Top && rect.Bottom<=item.Bottom)) )
            {
                return true;
            }
        }

        return false;
    }

    this.DrawSVG=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Texts)) return;
        if (!this.Family) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        var xPointCount=this.ChartFrame.XPointCount;
        var offset=this.Data.DataOffset;
        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();
        var pixelRatio = GetDevicePixelRatio();
        
        var x=0,y=0;
        for(var i=0; i<this.Texts.length; ++i)
        {
            var item=this.Texts[i];

            if (!item.SVG || !item.SVG.Symbol) continue;
            if (!IFrameSplitOperator.IsNumber(item.Index)) continue;

            var isMinuteFrame=this.IsMinuteFrame();
            var index=item.Index-offset;
            var kItem=this.Data.Data[item.Index];
            if (index<0 || index>=xPointCount) continue;
            
            x=this.ChartFrame.GetXFromIndex(index);
            if (item.Value=="Top") y=top;
            else if (item.Value=="Bottom") y=bottom;
            else y=this.ChartFrame.GetYFromData(item.Value, false);
            if (IFrameSplitOperator.IsNumber(item.YOffset)) y+=item.YOffset;    //Y轴偏移

            var svgItem=item.SVG;
            if (IFrameSplitOperator.IsNumber(svgItem.YOffset)) y+=svgItem.YOffset;

            if (this.AutoPosition) 
            {
                var pt={ X:x, Y:y };
                this.CalculateShowPosition(item, pt);   //重新计算位置
                x=pt.X;
                y=pt.Y;
            }


            var fontSVG=`${svgItem.Size}px ${this.Family}`;
            this.Canvas.font=fontSVG;
            var halfSize=svgItem.Size/2;
            var textBaseline='bottom';
            var rtSVG={ Left:x-halfSize, Right:x+halfSize, Top:y-svgItem.Size, Bottom:y, Height:svgItem.Size, Width:svgItem.Size };
            if (svgItem.VAlign===0) 
            {
                textBaseline="top";
                rtSVG.Top=y;
                rtSVG.Bottom=rtSVG.Top+svgItem.Size;
            }
            else if (svgItem.VAlign===1) 
            {
                textBaseline='middle';
                rtSVG.Top=y-svgItem.Size/2;
                rtSVG.Bottom=rtSVG.Top+svgItem.Size;
            }

            if (rtSVG.Top<0) 
            {
                rtSVG.Top=0;
                rtSVG.Bottom=svgItem.Size;
                y=rtSVG.Bottom;
            }

            this.Canvas.textBaseline=textBaseline;
            this.Canvas.textAlign='center';
            this.Canvas.fillStyle = svgItem.Color;
            this.Canvas.fillText(svgItem.Symbol, x, y);

            this.AryDrawRect.push( {Left:rtSVG.Left, Top:rtSVG.Top, Right:rtSVG.Right, Bottom:rtSVG.Bottom, Type:"SVG", Data:item } );

            if (this.EnableTooltip) this.TooltipRect.push({ Rect:rtSVG,Index:i });

            //文字
            if (item.Text && item.Text.Content && this.TextFont)
            {
                var textItem=item.Text;
                this.Canvas.font=this.TextFont;
                this.Canvas.fillStyle=textItem.Color;
                var yText=y;
                if (IFrameSplitOperator.IsNumber(textItem.YOffset)) yText+=textItem.YOffset;
                this.Canvas.fillText(textItem.Content, x, yText);
            }

            if (item.Detail)
            {
                this.DrawDetail(rtSVG,item.Detail, item);
            }
              
            //连线
            if (item.Line)
            {
                var lineItem=item.Line;
                var price=null, yPrice=null;
                var kItem=this.Data.Data[item.Index];
                if (lineItem.Value=="Bottom")
                {
                    yPrice=bottom;
                }
                else if (lineItem.Value=="Top")
                {
                    yPrice=top;
                }
                else
                {
                    switch(lineItem.Value)
                    {
                        case "C":
                            price=kItem.Close;
                            break;
                        case "H":
                            price=kItem.High;
                            break;
                        case "L":
                            price=kItem.Low;
                            break;    
                    }
    
                    if (!IFrameSplitOperator.IsNumber(price)) continue;
                    
                    yPrice=this.ChartFrame.GetYFromData(price);
                }
                
                if (yPrice>=rtSVG.Top && yPrice<=rtSVG.Bottom) continue;

                var yText;
                if (yPrice<rtSVG.Top) 
                {
                    yText=rtSVG.Top;
                    if (IFrameSplitOperator.IsNumber(lineItem.SVGBlank))
                    {
                        //yPrice+=lineItem.Blank;
                        yText-=lineItem.SVGBlank;
                    }
                }
                else
                {
                    yText=rtSVG.Bottom;
                    if (IFrameSplitOperator.IsNumber(lineItem.SVGBlank))
                    {
                        //yPrice-=lineItem.Blank;
                        yText+=lineItem.SVGBlank;
                    }
                }

                if (lineItem.Dash) this.Canvas.setLineDash(lineItem.Dash);    //虚线
                var lineWidth=1*pixelRatio;
                if (lineItem.Width>0) lineWidth=lineItem.Width*pixelRatio;
                this.Canvas.lineWidth=lineWidth;   //线宽
                this.Canvas.strokeStyle = lineItem.Color;
                this.Canvas.beginPath();

                if (this.IsHScreen)
                {
                    this.Canvas.moveTo(yText, ToFixedPoint(x));
                    this.Canvas.lineTo(yPrice,ToFixedPoint(x));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint2(lineWidth,x),yText);
                    this.Canvas.lineTo(ToFixedPoint2(lineWidth,x),yPrice);
                }
                
                this.Canvas.stroke();
                this.Canvas.setLineDash([]);
            }
        }
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        var xPointCount=this.ChartFrame.XPointCount;
        var start=this.Data.DataOffset;
        var end=start+xPointCount;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Texts)) return range;

        for(var i=0; i<this.Texts.length; ++i)
        {
            var item=this.Texts[i];
            if (!IFrameSplitOperator.IsNumber(item.Index)) continue;
            if (item.Index>=start && item.Index<end)
            {
                if(!IFrameSplitOperator.IsNumber(item.Value)) continue;
                if (range.Max==null) range.Max=item.Value;
                else if (range.Max<item.Value) range.Max=item.Value;
                if (range.Min==null) range.Min=item.Value;
                else if (range.Min>item.Value) range.Min=item.Value;
            }
        }

        return range;
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        if (!this.IsShow) return false;

        for(var i=0;i<this.TooltipRect.length;++i)
        {
            var item=this.TooltipRect[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.Left,rect.Top,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                var data=this.Texts[item.Index];
                JSConsole.Chart.Log('[ChartDrawSVG::GetTooltipData] svg icon.', item);
                tooltip.Data={ Rect:item.Rect, Item:data, Index:item.Index };
                tooltip.ChartPaint=this;
                tooltip.Type=7; //drawsvg
                return true;
            }
        }

        return false;
    }
}

// OX图 支持横屏
function ChartOX()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartOX";
    this.Font;
    this.Family=g_JSChartResource.ChartOX.Family;
    this.Color=[g_JSChartResource.ChartOX.Up.Color, g_JSChartResource.ChartOX.Down.Color];
    this.Text=[g_JSChartResource.ChartOX.Up.Text, g_JSChartResource.ChartOX.Down.Text];
    this.IsHScreen=false;   //是否横屏
    this.SquareSize=10;
    this.OXData=null;   //{ Data:[ { Type: 0/1, Data:[ price, price ] } ], Max:, Min: }
    this.SquareLineColor=g_JSChartResource.ChartOX.SquareLineColor;
    this.TooltipData=[]; //{ Rect:, Data }

    //计算每个单元格的大小
    this.CalcualteSquare=function()
    {
        if (this.IsHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var top=border.LeftEx;
            var bottom=border.RightEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var top=border.TopEx;
            var bottom=border.BottomEx;
        }
        

        this.SquareSize=(bottom-top)/(this.OXData.Max-this.OXData.Min)*this.OXData.BlockSize;

        var fontSize=parseInt(this.SquareSize);
        this.Font=`${fontSize}px ${this.Family}`;
    }


    this.DrawSquares=function()
    {
        this.Canvas.beginPath();
        this.Canvas.strokeStyle=this.SquareLineColor;

        if (this.IsHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var left=border.Top;
            var right=border.Bottom;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var left=border.Left;
            var right=border.Right;
            var top=border.TopEx;
            var bottom=border.BottomEx;
        }
        
        for(var price=this.OXData.StartPrice; price<this.OXData.Max; price+=this.OXData.BlockSize)
        {
            var y=this.ChartFrame.GetYFromData(price);

            if (this.IsHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(y),border.Top);
                this.Canvas.lineTo(ToFixedPoint(y), border.Bottom);
            }
            else
            {
                this.Canvas.moveTo(left,ToFixedPoint(y));
                this.Canvas.lineTo(right,ToFixedPoint(y));
            }
        }

        for(var price=this.OXData.StartPrice; price>this.OXData.Min; price-=this.OXData.BlockSize)
        {
            var y=this.ChartFrame.GetYFromData(price);

            if (this.IsHScreen)
            {
                this.Canvas.moveTo(ToFixedPoint(y),border.Top);
                this.Canvas.lineTo(ToFixedPoint(y), border.Bottom);
            }
            else
            {
                this.Canvas.moveTo(left,ToFixedPoint(y));
                this.Canvas.lineTo(right,ToFixedPoint(y));
            }
            
        }

        var xStart=left+g_JSChartResource.FrameLeftMargin;
        for(var i=xStart;i<right; i+=this.SquareSize)
        {
            if (this.IsHScreen)
            {
                this.Canvas.moveTo(border.LeftEx,ToFixedPoint(i));
                this.Canvas.lineTo(border.RightEx,ToFixedPoint(i));
            }
            else
            {
                this.Canvas.moveTo(ToFixedPoint(i),top);
                this.Canvas.lineTo(ToFixedPoint(i),bottom);
            }
        }

        this.Canvas.stroke();
    }

    this.Draw=function()
    {
        this.TooltipData=[];
        if (this.ChartFrame.IsMinSize) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.OXData || !this.OXData.Data) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        this.CalcualteSquare();
        this.DrawSquares();

        if (this.IsHScreen)
        {
            var left=this.ChartBorder.GetTop();
            var right=this.ChartBorder.GetBottom();
            var xOffset=left+g_JSChartResource.FrameLeftMargin;
            this.Canvas.textBaseline='middle';
            this.Canvas.textAlign='center';
            this.Canvas.font=this.Font;

            for(var i=0;i<this.OXData.Data.length;++i, xOffset+=this.SquareSize)
            {
                if (xOffset>right) break;
    
                var item=this.OXData.Data[i];
                this.Canvas.fillStyle=this.Color[item.Type];
                var text=this.Text[item.Type];
                if (!IFrameSplitOperator.IsNonEmptyArray(item.Data)) continue;
                for(var j=0; j<item.Data.length; ++j)
                {
                    var value=item.Data[j];
                    var y=this.ChartFrame.GetYFromData(value+this.OXData.BlockSize/2);
                    this.Canvas.fillText(text,y,xOffset+this.SquareSize/2);
                }
            }
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var xOffset=left+g_JSChartResource.FrameLeftMargin;
    
            this.Canvas.textBaseline='middle';
            this.Canvas.textAlign='center';
            this.Canvas.font=this.Font;
    
            for(var i=0;i<this.OXData.Data.length;++i, xOffset+=this.SquareSize)
            {
                if (xOffset>right) break;
    
                var item=this.OXData.Data[i];
                this.Canvas.fillStyle=this.Color[item.Type];
                var text=this.Text[item.Type];
                var rt={ X:xOffset, Width:this.SquareSize };
                var maxValue=null, minValue=null;
                if (!IFrameSplitOperator.IsNonEmptyArray(item.Data)) continue;
                for(var j=0; j<item.Data.length; ++j)
                {
                    var value=item.Data[j];
                    var y=this.ChartFrame.GetYFromData(value+this.OXData.BlockSize/2);
                    this.Canvas.fillText(text,xOffset+this.SquareSize/2,y);
    
                    if (maxValue==null) maxValue=value;
                    else if (maxValue<value) maxValue=value;
    
                    if (minValue==null) minValue=value;
                    else if (minValue>value) minValue=value;
                }
    
                rt.Y=this.ChartFrame.GetYFromData(maxValue+this.OXData.BlockSize);
                rt.Height=this.ChartFrame.GetYFromData(minValue)-rt.Y;
                var tooltipItem={ Data:item,  Rect:rt };
                this.TooltipData.push(tooltipItem);
            }
        }
    }

    this.GetTooltipData=function(x,y,tooltip)
    {
        for(var i in this.TooltipData)
        {
            var item=this.TooltipData[i];
            if (!item.Rect) continue;
            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.X,rect.Y,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                JSConsole.Chart.Log('[ChartOX::GetTooltipData] item ', item);
                tooltip.Data=item;
                tooltip.ChartPaint=this;
                tooltip.Type=5; //OX指标
                return true;
            }
        }

        return false;
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };

        if (this.OXData)
        {
            if (IFrameSplitOperator.IsNumber(this.OXData.Max)) range.Max=this.OXData.Max;
            if (IFrameSplitOperator.IsNumber(this.OXData.Min)) range.Min=this.OXData.Min;
        }

        return range;
    }
}

//成交量柱子图-可视范围
function ChartVolProfileVisibleRange()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartVolProfileVisibleRange";

    this.IsDrawFirst=true;
    this.IsShowText=true;   //是否显示成交量数据
    this.VolType=0;         //0=up|down bar  1=total bar
    this.BarPosition=1;     //柱子方向 0=左边  1=右边
    this.BarWidthRate=0.3;
    this.VolFont;
    this.HQChart;
    this.IsDestroy=false;

    this.Data=null;
    this.MaxVol;
    this.MaxVolPrice;

    this.VolLineColor=g_JSChartResource.ChartVolProfileVisibleRange.VolLineColor;
    this.VolLineFont=g_JSChartResource.ChartVolProfileVisibleRange.VolLineFont;
    this.VolLineTextColor=g_JSChartResource.ChartVolProfileVisibleRange.VolLineTextColor;

    //value Area
    this.VAHLineColor=g_JSChartResource.ChartVolProfileVisibleRange.VAHLineColor;
    this.VAHTextColor=g_JSChartResource.ChartVolProfileVisibleRange.VAHTextColor;
    this.VALLineColor=g_JSChartResource.ChartVolProfileVisibleRange.VALLineColor;
    this.VALTextColor=g_JSChartResource.ChartVolProfileVisibleRange.VALTextColor;
    this.VAFont=g_JSChartResource.ChartVolProfileVisibleRange.VAFont;
    
    this.TextConfig=
    {
        Color:g_JSChartResource.ChartVolProfileVisibleRange.Text.Color,
        Family:g_JSChartResource.ChartVolProfileVisibleRange.Text.Family,
        FontMaxSize:g_JSChartResource.ChartVolProfileVisibleRange.Text.FontMaxSize,
        FontMinSize:g_JSChartResource.ChartVolProfileVisibleRange.Text.FontMinSize,
        Color:g_JSChartResource.ChartVolProfileVisibleRange.Text.Color,
    }

    this.BarColor=
    [
        g_JSChartResource.ChartVolProfileVisibleRange.UpVolColor,
        g_JSChartResource.ChartVolProfileVisibleRange.DownVolColor,
        g_JSChartResource.ChartVolProfileVisibleRange.AreaUpColor,
        g_JSChartResource.ChartVolProfileVisibleRange.AreaDonwColor
    ]

    this.MaxVolLine;

    this.OnDestroy=function()
    {
        this.IsDestroy=true;
    }

    this.SetOption=function(option)
    {
        if (!option) return;

        if (IFrameSplitOperator.IsBool(option.IsShowText)) this.IsShowText=option.IsShowText;
        if (IFrameSplitOperator.IsNumber(option.VolType)) this.IsShowText=option.VolType;
        if (IFrameSplitOperator.IsNumber(option.BarPosition)) this.BarPosition=option.BarPosition;
        if (IFrameSplitOperator.IsNumber(option.BarWidthRate)) this.IsShowText=option.BarWidthRate;
    }

    this.PtInChart=function(x,y)
    {
        if (this.MaxVolLine)
        {
            if (x>=this.MaxVolLine.Start.X && x<=this.MaxVolLine.End.X && y>=this.MaxVolLine.Start.Y-5 && y<this.MaxVolLine.Start.Y+5)
                return { Identify:this.Identify, Chart:this };
        }


        return null;
    }

    this.SetSelectedStatus=function(status)
    {
        if (status==0)  this.IsDrawFirst=true;
        else this.IsDrawFirst=false;
    }

    this.DrawSelectedStatus=function()
    {
        var radius=this.SelectedRadius;
        var pixelRatio=GetDevicePixelRatio();
        this.Canvas.save();

        if (this.MaxVolLine)
        {
            this.Canvas.lineWidth=this.SelectedLineWidth*pixelRatio;
            this.Canvas.strokeStyle=this.SelectedLineColor;
            if (this.SelectedBGColor) this.Canvas.fillStyle=this.SelectedBGColor;

            var space=(this.MaxVolLine.End.X-this.MaxVolLine.Start.X)/6;
            var aryPoint=[];
            for(var x=this.MaxVolLine.Start.X+space; x<this.MaxVolLine.End.X; x+=space)
            {
                aryPoint.push({X:x, Y:this.MaxVolLine.Start.Y});
            }
            
            for(var i=0;i<aryPoint.length;++i)
            {
                var item=aryPoint[i];
                this.Canvas.beginPath();
                this.Canvas.arc(item.X,item.Y,radius,0,360,false);
                this.Canvas.closePath();
                if (this.SelectedBGColor)  this.Canvas.fill();
                this.Canvas.stroke();
            }
            
        }

        this.Canvas.restore();
    }

    this.Draw=function()
    {
        this.VolFont=null;
        this.MaxVolLine=null;
        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        if (this.ChartFrame.IsMinSize) return;

        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (!this.Data || !this.Data.Data) return;

        this.Canvas.save();

        this.DrawVolBar();

        this.Canvas.restore();
    }

    this.DrawPriceLine=function()
    {
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var pixelTatio = GetDevicePixelRatio();

        var aryPrice=[];
        var maxVolPrice=this.MaxVolPrice;
        if (IFrameSplitOperator.IsNumber(this.Data.MaxVolPrice)) maxVolPrice=this.Data.MaxVolPrice;
        if (maxVolPrice>=this.ChartFrame.HorizontalMin && maxVolPrice<=this.ChartFrame.HorizontalMax)
            aryPrice.push({Price:maxVolPrice, Font:this.VolLineFont, LineColor:this.VolLineColor, LineWidth:2, TextColor:this.VolLineTextColor, Type:1});

        if (IFrameSplitOperator.IsNumber(this.Data.VAHPrice) && this.Data.VAHPrice>=this.ChartFrame.HorizontalMin && this.Data.VAHPrice<=this.ChartFrame.HorizontalMax)
            aryPrice.push({Price:this.Data.VAHPrice, Font:this.VAFont, LineColor:this.VAHLineColor, LineWidth:2, TextColor:this.VAHTextColor, Type:2});

        if (IFrameSplitOperator.IsNumber(this.Data.VALPrice) && this.Data.VALPrice>=this.ChartFrame.HorizontalMin && this.Data.VALPrice<=this.ChartFrame.HorizontalMax)
            aryPrice.push({Price:this.Data.VALPrice, Font:this.VAFont, LineColor:this.VALLineColor, LineWidth:2, TextColor:this.VALTextColor, Type:3});

        for(var i=0;i<aryPrice.length;++i)
        {
            var item=aryPrice[i];
            var yLine=ToFixedPoint2(item.LineWidth,this.ChartFrame.GetYFromData(item.Price,false));
            this.Canvas.lineWidth=item.LineWidth;
            this.Canvas.strokeStyle=item.LineColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(left,yLine);
            this.Canvas.lineTo(right,yLine);
            this.Canvas.stroke();
            if (item.Type==1) this.MaxVolLine= { Start:{X:left,Y:yLine}, End:{X:right,Y:yLine} };

            if (this.ChartBorder.Right>10)  //刻度文字
            {
                var defaultfloatPrecision=GetfloatPrecision(this.HQChart.Symbol);//价格小数位数
                var text=item.Price.toFixed(defaultfloatPrecision);
                this.Canvas.font=item.Font;
                this.Canvas.textAlign = "left";
                this.Canvas.textBaseline = "middle";
                var fontHeight=this.GetFontHeight();
                var textWidth=this.Canvas.measureText(text).width+2*pixelTatio;

                this.Canvas.fillStyle=item.LineColor;
                this.Canvas.fillRect(right,yLine-fontHeight/2,textWidth,fontHeight);

                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.fillText(text,right+1*pixelTatio, yLine);
            }
        }
    }

    this.DrawVolBar=function()
    {
        var cellHeight=this.GetPriceYOffset(this.Data.PriceOffset);
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var top=this.ChartFrame.GetYFromData(this.Data.MaxPrice)-cellHeight/2;
        var bottom=this.ChartFrame.GetYFromData(this.Data.MinPrice)+cellHeight/2;
        var width=right-left;
        var height=bottom-top;
        var maxBarWidth=width*this.BarWidthRate;
       

        if (this.IsShowText)
        {
            this.VolFont=this.GetDynamicVolTextFont(cellHeight, maxBarWidth);
            if (this.VolFont) this.Canvas.font=this.VolFont;
        }
        
        for(var i=0,j=0;i<this.Data.Data.length;++i)
        {
            var item=this.Data.Data[i];
            if (item.Price<this.ChartFrame.HorizontalMin || item.Price>this.ChartFrame.HorizontalMax) continue;

            this.DrawVolBarItem(item, left, right, maxBarWidth, cellHeight);
        }

        this.DrawPriceLine();
    }

    this.DrawVolBarItem=function(item, left, right, maxBarWidth, cellHeight)
    {
        var barLeft=left;
        var barRight=right;
        var barTop=this.ChartFrame.GetYFromData(item.Price)-cellHeight/2;
        var barHeight=cellHeight-1;
        if (barHeight<1) barHeight=1;

        if (this.VolType==1)
        {
            if (!item.TotalVol) return;
            if (!IFrameSplitOperator.IsNumber(item.TotalVol.Value)) return;
            var barWidth=item.TotalVol.Value*maxBarWidth/this.MaxVol;

            var color;
            if (IFrameSplitOperator.IsNumber(item.TotalVol.ColorID)) color=this.BarColor[item.TotalVol.ColorID];
            else if (item.TotalVol.Color) color=item.TotalVol.Color;

            this.Canvas.fillStyle=color;
            if (this.BarPosition==1)
            {
                this.Canvas.fillRect(barRight,ToFixedRect(barTop),-barWidth,ToFixedRect(barHeight));
            }
            else
            {
                this.Canvas.fillRect(barLeft,ToFixedRect(barTop),barWidth,ToFixedRect(barHeight));
            }
            
            if (this.IsShowText && this.VolFont)
            {
                var text=IFrameSplitOperator.FormatVolString(item.TotalVol.Value, this.HQChart.LanguageID);
                this.Canvas.textBaseline = 'middle';
                this.Canvas.fillStyle=this.TextConfig.Color;
                if (this.BarPosition==1)
                {
                    this.Canvas.textAlign = 'right';
                    this.Canvas.fillText(text,right-5,barTop+cellHeight/2);
                }
                else
                {
                    this.Canvas.textAlign = 'left';
                    this.Canvas.fillText(text,left+5,barTop+cellHeight/2);
                }
                
            }
        }
        else
        {
            var text="";
            for(var i=0;i<item.Vol.length;++i)
            {
                var volItem=item.Vol[i];
    
                if (!IFrameSplitOperator.IsNumber(volItem.Value)) continue;
                
                var color;
                if (IFrameSplitOperator.IsNumber(volItem.ColorID)) color=this.BarColor[volItem.ColorID];
                else if (volItem.Color) color=volItem.Color;
    
                if (!color) continue;
                
                var barWidth=volItem.Value*maxBarWidth/this.MaxVol;
                this.Canvas.fillStyle=color;
                if (this.BarPosition==1)
                {
                    this.Canvas.fillRect(barRight,ToFixedRect(barTop),-barWidth,ToFixedRect(barHeight));
                    barRight-=barWidth;
                }
                else
                {
                    this.Canvas.fillRect(barLeft,ToFixedRect(barTop),barWidth,ToFixedRect(barHeight));
                    barLeft+=barWidth;
                }
                
                var volText=IFrameSplitOperator.FormatVolString(volItem.Value, this.HQChart.LanguageID);
                if (text.length>0) text+="x";
                text+=volText;
            }

            if (this.IsShowText && this.VolFont)
            {
                
                this.Canvas.textBaseline = 'middle';
                this.Canvas.fillStyle=this.TextConfig.Color;
                if (this.BarPosition==1)
                {
                    this.Canvas.textAlign = 'right';
                    this.Canvas.fillText(text,right-5,barTop+cellHeight/2);
                }
                else
                {
                    this.Canvas.textAlign = 'left';
                    this.Canvas.fillText(text,left+5,barTop+cellHeight/2);
                }
                
            }
        }
    }

    this.GetPriceYOffset=function(value)
    {
        var frame=this.ChartFrame;
        var y=frame.ChartBorder.GetHeightEx()*(value)/(frame.HorizontalMax-frame.HorizontalMin);
        return y;
    }

    this.GetDynamicVolTextFont=function(cellHeight, width, fontOption)
    {
        var fontSize=parseInt(cellHeight)-2;
        if (cellHeight<5) fontSize=parseInt(cellHeight);    //高度太小了就不要上下间距了
        if (fontSize>this.TextConfig.FontMaxSize) fontSize=this.TextConfig.FontMaxSize;
        else if (fontSize<=0) fontSize=1;

        if (fontSize<this.TextConfig.FontMinSize) return null;

        var font=this.FormatFontString(fontSize, this.TextConfig.Family, fontOption);

        return font;
    }

    this.FormatFontString=function(fontSize, family, option)
    {
        var font;
        if (!option) 
        {
            font=`${fontSize}px ${family}`;
        }
        else
        {
            if (option.Weight) font=`${option.Weight} ${fontSize}px ${family}`;
        }

        return font;
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null };
        return range;
    }
}

//堆积柱状图
function ChartStackedBar()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartStackedBar";
    this.Data;      //{ Data:[ [bar1, bar2], [bar1,bar2 ] ] };
    this.BarName=[];
    this.BarColor=['rgb(255,165,0)',"rgb(95,158,160)"];
    this.LineWidth=1;
    this.BarType=0; //0=线段    1=K线宽度一致
    this.IsHScreen;

    this.Draw=function()
    {
        if (!this.IsShow || this.ChartFrame.IsMinSize) return;
        if (!this.Data || !IFrameSplitOperator.IsNonEmptyArray(this.Data.Data)) return;

        this.IsHScreen=(this.ChartFrame.IsHScreen===true);
        
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var xPointCount=this.ChartFrame.XPointCount;

        if (this.IsHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            var top=border.RightEx;
            var bottom=border.LeftEx;
        }
        else
        {
            var border=this.ChartFrame.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var top=border.TopEx;
            var bottom=border.BottomEx;

            var lockRect=this.GetLockRect();
            if (lockRect) chartright=lockRect.Left;
        }

        var isMinute=this.IsMinuteFrame();
       
        this.Canvas.save();
        if (this.BarType==1)
        {
           
        }
        else
        {
            if (this.LineWidth>0) this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
            var lineWidth=this.Canvas.lineWidth;
        }
       
        var yZero=this.ChartFrame.GetYFromData(0);
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var bars=this.Data.Data[i];
            if (!IFrameSplitOperator.IsNonEmptyArray(bars)) continue;

            if (isMinute)
            {
                var x=this.ChartFrame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            if (x>chartright) break;

            if (this.BarType==1)
            {
                if (dataWidth>=4)   //柱子太细就直接画竖线
                    this.DrawKBarItem(bars, x, left, right, top, bottom, yZero, dataWidth);
                else
                    this.DrawBarItem(bars, x, top, bottom, yZero, lineWidth);
            }  
            else
            {
                this.DrawBarItem(bars, x, top, bottom, yZero, lineWidth);
            }
                

        }
      
        this.Canvas.restore();
    }

    this.DrawKBarItem=function(aryBar, x, left, right, top, bottom, yZero, barWidth)
    {
        var plusValue=0, yPlus=yZero;               //正数
        var negativeValue=0, yNegative= yZero;      //负数
        for(var i=0;i<aryBar.length;++i)
        {
            var item=aryBar[i];
            if (!IFrameSplitOperator.IsNumber(item)) continue;
            if(item==0) continue;

            this.Canvas.fillStyle=this.BarColor[i];
            if (item>0) 
            {
                plusValue+=item;
                var y=this.ChartFrame.GetYFromData(plusValue);
                var rtBar={Left: left, Top:y, Width:barWidth, Height:(yPlus-y)};
                yPlus=y;
            }
            else
            {
                negativeValue+=item;
                var y=this.ChartFrame.GetYFromData(negativeValue);
                var rtBar={Left:left, Top:y, Width:barWidth, Height:(yNegative-y)};
                yNegative=y;
            }


            if (this.IsHScreen)
                this.Canvas.fillRect(rtBar.Top,rtBar.Left, rtBar.Height, rtBar.Width);
            else 
                this.Canvas.fillRect(rtBar.Left, rtBar.Top, rtBar.Width, rtBar.Height);
        }
    }

    this.DrawBarItem=function(aryBar,x, top, bottom, yZero, lineWidth)
    {
        var x=ToFixedPoint2(lineWidth, x);
        var plusValue=0, yPlus=yZero;               //正数
        var negativeValue=0, yNegative=yZero;      //负数

        for(var i=0;i<aryBar.length;++i)
        {
            var item=aryBar[i];
            if (!IFrameSplitOperator.IsNumber(item)) continue;
            if(item==0) continue;

            var line={};
            if (item>0) 
            {
                plusValue+=item;
                var y=this.ChartFrame.GetYFromData(plusValue);
                var line={X:x, Y:yPlus, X2:x, Y2:y};

                yPlus=y;
            }
            else
            {
                negativeValue+=item;
                var y=this.ChartFrame.GetYFromData(negativeValue);
                var line={X:x, Y:yNegative, X2:x, Y2:y};
                yNegative=y;
            }

            this.Canvas.beginPath();
            if (this.IsHScreen)
            {
                this.Canvas.moveTo(line.Y,line.X);
                this.Canvas.lineTo(line.Y2,line.X2);
            }
            else
            {
                this.Canvas.moveTo(line.X,line.Y);
                this.Canvas.lineTo(line.X2,line.Y2);
            }
            
            this.Canvas.strokeStyle=this.BarColor[i];
            this.Canvas.stroke();
        }
    }

    this.GetMaxMin=function()
    {
        var xPointCount=this.ChartFrame.XPointCount;
        var range={};
        range.Min=null;
        range.Max=null;

        if(!this.Data || !this.Data.Data) return range;

        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var bars=this.Data.Data[i];
            if (!bars || !IFrameSplitOperator.IsNonEmptyArray(bars)) continue;

            var plusValue=0;          //正数
            var negativeValue=0;      //负数
            for(var k=0;k<bars.length;++k)
            {
                var barValue=bars[k];
                if (!IFrameSplitOperator.IsNumber(barValue)) continue;
                if (barValue==0) continue;

                if (barValue>0) plusValue+=barValue;
                else if (barValue<0) negativeValue+=barValue;
            }

            if (range.Max==null) 
            {
                range.Max=plusValue;
                range.Min=negativeValue;
            }

            if (range.Max<plusValue) range.Max=plusValue;
            if (range.Min>negativeValue) range.Min=negativeValue;
        }

        return range;
    }

    this.PtInChart=function(x,y)
    {
        var option={ StackedBar:true };
        if (this.BarType==0) option.BarWidth=4;
        return this.PtInBar(x,y, option );
    }

    this.DrawSelectedStatus=function()
    {
        this.DrawLinePoint({ StackedBar:true });
    }
    
}

//锁  支持横屏
function ChartLock()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartLock";
    this.WidthDiv = 0.2;  // 框子宽度占比
    this.LockCount = 20; // 锁最新的几个数据
    this.BGColor = g_JSChartResource.LockBGColor;
    this.TextColor = g_JSChartResource.LockTextColor;
    this.Font = g_JSChartResource.DefaultTextFont;
    this.Title = '🔒开通权限';
    this.LockRect=null; //上锁区域
    this.LockID;        //锁ID
    this.Callback;      //回调
    this.IndexName;     //指标名字
    this.MinWidth=null;  //最小宽度

    this.Draw=function(isDraw)
    {
        this.LockRect=null;
        if (this.NotSupportMessage)
        {
            this.DrawNotSupportmessage();
            return;
        }

        if (this.ChartFrame.IsHScreen===true)
        {
            this.HScreenDraw(isDraw);
            return;
        }

        var xOffset = this.ChartBorder.GetRight();
        var lOffsetWidth = 0;
        if (this.ChartFrame.Data != null)
        {
            var dataWidth=this.ChartFrame.DataWidth;
            var distanceWidth=this.ChartFrame.DistanceWidth;
            xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+2.0;
            var chartright=this.ChartBorder.GetRight();
            var xPointCount=this.ChartFrame.XPointCount;
            for(var i=this.ChartFrame.Data.DataOffset,j=0;i<this.ChartFrame.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var data=this.ChartFrame.Data.Data[i];
                if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
            }
            lOffsetWidth = (dataWidth + distanceWidth) * this.LockCount;    
        }
        if (lOffsetWidth == 0)
        {
            lOffsetWidth = (xOffset - this.ChartBorder.GetLeft()) * this.WidthDiv;
        }
        var lLeft = xOffset - lOffsetWidth;
        if (lLeft < this.ChartBorder.GetLeft())
            lLeft = this.ChartBorder.GetLeft();
        var lHeight = this.ChartBorder.GetBottom() - this.ChartBorder.GetTop();
        var lWidth = this.ChartBorder.GetRight() - lLeft;

        if (this.MinWidth>10 && lWidth<this.MinWidth) 
        {
            lWidth=this.MinWidth;
            lLeft=this.ChartBorder.GetRight()-lWidth;
            if (lLeft < this.ChartBorder.GetLeft()) lLeft = this.ChartBorder.GetLeft();
        }

        if (isDraw)
        {
            this.Canvas.fillStyle = this.BGColor;
            this.Canvas.fillRect(lLeft, this.ChartBorder.GetTop(), lWidth, lHeight);
            var xCenter = lLeft + lWidth / 2;
            var yCenter = this.ChartBorder.GetTop() + lHeight / 2;
            this.Canvas.textAlign = 'center';
            this.Canvas.textBaseline = 'middle';
            this.Canvas.fillStyle = this.TextColor;
            this.Canvas.font = this.Font;
            this.Canvas.fillText(this.Title, xCenter, yCenter);
        }

        this.LockRect={Left:lLeft,Top:this.ChartBorder.GetTop(),Width:lWidth,Heigh:lHeight};    //保存上锁区域
    }

    this.HScreenDraw=function(isDraw)
    {
        var xOffset = this.ChartBorder.GetBottom();

        var lOffsetWidth = 0;
        if (this.ChartFrame.Data != null)
        {
            var dataWidth=this.ChartFrame.DataWidth;
            var distanceWidth=this.ChartFrame.DistanceWidth;
            xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+2.0;
            var chartright=this.ChartBorder.GetBottom();
            var xPointCount=this.ChartFrame.XPointCount;
            //求最后1个数据的位置
            for(var i=this.ChartFrame.Data.DataOffset,j=0;i<this.ChartFrame.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
            {
                var data=this.ChartFrame.Data.Data[i];
                if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
            }
            lOffsetWidth = (dataWidth + distanceWidth) * this.LockCount;    
        }
        if (lOffsetWidth == 0)
        {
            lOffsetWidth = (xOffset - this.ChartBorder.GetTop()) * this.WidthDiv;
        }

        var lLeft = xOffset - lOffsetWidth;
        if (lLeft < this.ChartBorder.GetTop()) lLeft = this.ChartBorder.GetTop();
        var lHeight =  this.ChartBorder.GetRight()-this.ChartBorder.GetLeft();
        var lWidth = this.ChartBorder.GetBottom() - lLeft;
        this.Canvas.fillStyle = this.BGColor;
        this.Canvas.fillRect(this.ChartBorder.GetLeft(), lLeft,lHeight,lWidth);

        var xCenter = this.ChartBorder.GetLeft() + lHeight / 2;
        var yCenter = lLeft + lWidth / 2;
        this.Canvas.save(); 
        this.Canvas.translate(xCenter, yCenter);
        this.Canvas.rotate(90 * Math.PI / 180);
        this.Canvas.textAlign = 'center';
        this.Canvas.textBaseline = 'middle';
        this.Canvas.fillStyle = this.TextColor;
        this.Canvas.font = this.Font;
        this.Canvas.fillText(this.Title, 0, 0);
        this.Canvas.restore();

        this.LockRect={Left:this.ChartBorder.GetLeft(),Top:lLeft,Width:lHeight,Heigh:lWidth};    //保存上锁区域
    }

    //x,y是否在上锁区域
    this.GetTooltipData=function(x,y,tooltip)
    {
        if (this.LockRect==null) return false;

        this.Canvas.beginPath();
        this.Canvas.rect(this.LockRect.Left,this.LockRect.Top,this.LockRect.Width,this.LockRect.Heigh);
        if (this.Canvas.isPointInPath(x,y))
        {
            tooltip.Data={ ID:this.LockID, Callback:this.Callback, IndexName:this.IndexName };
            tooltip.ChartPaint=this;
            return true;
        }
        
        return false;
    }
}

//买卖盘
function ChartBuySell()
{
    this.newMethod=ChartSingleText;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartBuySell";
    this.TextFont=g_JSChartResource.KLineTrain.Font;                //"bold 14px arial";           //买卖信息字体
    this.LastDataIcon=g_JSChartResource.KLineTrain.LastDataIcon;    //{Color:'rgb(0,0,205)',Text:'↓'};
    this.BuyIcon=g_JSChartResource.KLineTrain.BuyIcon;              //{Color:'rgb(0,0,205)',Text:'B'};
    this.SellIcon=g_JSChartResource.KLineTrain.SellIcon;            //{Color:'rgb(0,0,205)',Text:'S'};
    this.BuySellData=new Map();                                     //Key=数据索引index Value:Data:[ { Op: 买/卖 0=buy 1=sell, Date:, Time, Price: Vol:}, ] 
    this.IconFont=g_JSChartResource.KLineTrain.IconFont;
    this.LastDataDrawType=0;    //0=画在最后一个数据上 1=画在指定索引上
    this.LastDataIndex=-1;

    this.AddTradeItem=function(tradeItem)
    {
        if (this.BuySellData.has(tradeItem.Key))
        {
            var Trade=this.BuySellData.get(tradeItem.Key);
            Trade.Data.push(tradeItem);
        }
        else
        {
            this.BuySellData.set(tradeItem.Key, { Data:[tradeItem] });
        }
    }

    this.ClearTradeData=function()
    {
        this.BuySellData=new Map(); 
    }

    this.Draw=function()
    {
        if (!this.Data || !this.Data.Data) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=this.ChartFrame.DataWidth;
        var distanceWidth=this.ChartFrame.DistanceWidth;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen===true) chartright=this.ChartBorder.GetBottom();
        var xPointCount=this.ChartFrame.XPointCount;

        if (this.IconFont)
        {
            var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
            var iconSize=dataWidth+distanceWidth;
            var minIconSize=18*pixelTatio;
            if (iconSize<minIconSize) iconSize=minIconSize;
            this.Canvas.font=iconSize+'px '+this.IconFont.Family;
        }
        else
        {
            this.Canvas.font=this.TextFont;
        }
        
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var value=this.Data.Data[i];
            if (value==null) continue;
            var x=this.ChartFrame.GetXFromIndex(j);
            if (x>chartright) break;

            var bDrawLastData=false;
            if (this.LastDataDrawType==1)
            {
                if (i==this.LastDataIndex) bDrawLastData=true;
            }
            else
            {
                if (i==this.Data.Data.length-1) bDrawLastData=true;
            }
            
            if (bDrawLastData)
            {
                //最后一个位置 画一个箭头
                var x=this.ChartFrame.GetXFromIndex(j);
                var yHigh=this.ChartFrame.GetYFromData(value.High);
                this.Canvas.textAlign='center';
                this.Canvas.textBaseline='bottom';
                if (this.IconFont)
                {
                    this.Canvas.fillStyle=this.IconFont.Last.Color
                    this.DrawText(this.IconFont.Last.Text,x,yHigh,isHScreen);
                }
                else
                {
                    this.Canvas.fillStyle=this.LastDataIcon.Color;
                    this.Canvas.font=this.TextFont;
                    this.DrawText(this.LastDataIcon.Text,x,yHigh,isHScreen);
                }
            }
            
            var key=i;
            if (!this.BuySellData.has(key)) continue;

            var trade=this.BuySellData.get(key);
            var yHigh=this.ChartFrame.GetYFromData(value.High);
            var yLow=this.ChartFrame.GetYFromData(value.Low);
            var drawInfo=[false, false];    //0=buy 1=sell
            for(var k in trade.Data)
            {
                if (drawInfo[0]==true && drawInfo[1]==true) break;  //买卖图标只画一次

                var bsItem=trade.Data[k];
                if (bsItem.Op==0 && drawInfo[0]==false)   //买 标识在最低价上
                {
                    this.Canvas.textAlign='center';
                    this.Canvas.textBaseline='top';
                    if (this.IconFont)
                    {
                        this.Canvas.fillStyle=this.IconFont.Buy.Color
                        this.DrawText(this.IconFont.Buy.Text,x,yLow,isHScreen);
                    }
                    else
                    {
                        this.Canvas.fillStyle=this.BuyIcon.Color;
                        this.DrawText(this.BuyIcon.Text,x,yLow,isHScreen);
                    }

                    drawInfo[0]=true;
                }
                else if (bsItem.Op==1 && drawInfo[1]==false)   //卖 标识在最高价上
                {
                    this.Canvas.textAlign='center';
                    this.Canvas.textBaseline='bottom';
                    if (this.IconFont)
                    {
                        this.Canvas.fillStyle=this.IconFont.Sell.Color
                        this.DrawText(this.IconFont.Sell.Text,x,yHigh,isHScreen);
                    }
                    else
                    {
                        this.Canvas.fillStyle=this.SellIcon.Color;
                        this.DrawText(this.SellIcon.Text,x,yHigh,isHScreen);
                    }

                    drawInfo[1]=true;
                }
            }
        }   
    }
}

//深度图
function ChartOrderbookDepth()
{
    this.newMethod=IChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="ChartOrderbookDepth";
    this.Data=null;

    this.AskColor={ Line:g_JSChartResource.DepthChart.AskColor.Line, Area:g_JSChartResource.DepthChart.AskColor.Area }      //卖
    this.BidColor={ Line:g_JSChartResource.DepthChart.BidColor.Line, Area:g_JSChartResource.DepthChart.BidColor.Area }      //买
    this.LineWidth=g_JSChartResource.DepthChart.LineWidth;

    this.Draw=function()
    {
        if (!this.Data) return;

        var lineWidthBackup=this.Canvas.lineWidth;
        this.Canvas.lineWidth=this.LineWidth * GetDevicePixelRatio();
        this.DrawArea(this.Data.Bids, this.BidColor.Line, this.BidColor.Area, true);
        this.DrawArea(this.Data.Asks, this.AskColor.Line, this.AskColor.Area, false);
        this.Canvas.lineWidth=lineWidthBackup;
    }

    this.DrawArea=function(aryData, colorLine, colorArea, isLeft)
    {
        var xRange=this.ChartFrame.VerticalRange;
        var aryPoint=[];
        for(var i in aryData)
        {
            var item=aryData[i];
            if (isLeft)
            {
                if (item.Price<xRange.Min) break;
            }
            else
            {
                if (item.Price>xRange.Max) break;
            }

            var x=this.ChartFrame.GetXFromIndex(item.Price);
            var y=this.ChartFrame.GetYFromData(item.Vol);
            aryPoint.push({X:x,Y:y});
        }
        if (aryPoint.length<=1) return;

        var left=this.ChartBorder.GetLeft();
        var bottom=this.ChartBorder.GetBottom();
        var right=this.ChartBorder.GetRight();

        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X, bottom);
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            this.Canvas.lineTo(item.X,item.Y);
        }

        this.Canvas.lineTo(isLeft?left:right,aryPoint[aryPoint.length-1].Y);
        this.Canvas.lineTo(isLeft?left:right,bottom);
        this.Canvas.lineTo(aryPoint[0].X,bottom);
        this.Canvas.closePath();
        this.Canvas.fillStyle = colorArea;
        this.Canvas.fill();

        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X, bottom);
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            this.Canvas.lineTo(item.X,item.Y);
        }
        this.Canvas.lineTo(isLeft?left:right,aryPoint[aryPoint.length-1].Y);
        this.Canvas.strokeStyle=colorLine;
        this.Canvas.stroke();
    }

    this.GetMaxMin=function()
    {
        var range={ Min:null, Max:null, XMin:null, XMax:null };
        var xRange=this.ChartFrame.VerticalRange;

        for(var i in this.Data.Asks)
        {
            var item=this.Data.Asks[i];
            if (item.Price>xRange.Max) break;
            
            if (range.XMin==null || range.XMin>item.Price) range.XMin=item.Price;
            if (range.XMax==null || range.XMax<item.Price) range.XMax=item.Price;
            if (range.Min==null || range.Min>item.Vol) range.Min=item.Vol;
            if (range.Max==null || range.Max<item.Vol) range.Max=item.Vol;
        }

        for(var i in this.Data.Bids)
        {
            var item=this.Data.Bids[i];
            if (item.Price<xRange.Min) break;

            if (range.XMin==null || range.XMin>item.Price) range.XMin=item.Price;
            if (range.XMax==null || range.XMax<item.Price) range.XMax=item.Price;
            if (range.Min==null || range.Min>item.Vol) range.Min=item.Vol;
            if (range.Max==null || range.Max<item.Vol) range.Max=item.Vol;
        }

        return range;
    }
}


/*
    扩展图形
*/

function ExtendChartPaintFactory()
{
    this.DataMap=new Map(
        [
            ["FrameSplitPaint", { Create:function() { return new FrameSplitPaint(); } }],
            ["RectSelectPaint", { Create:function() { return new RectSelectPaint(); } }],
            ["RectDragPaint", { Create:function() { return new RectDragPaint(); } }],
            ["DragMovePaint", { Create:function() { return new DragMovePaint(); } }],
            ["SessionBreaksPaint", { Create:function() { return new SessionBreaksPaint(); }}],
            ["FrameButtomToolbarPaint", {Create:function() { return new FrameButtomToolbarPaint(); }}]
        ]
    );

    this.SetCallbackDraw=new Set();

    this.Create=function(name)
    {
        if (!this.DataMap.has(name)) return null;

        var item=this.DataMap.get(name);
        return item.Create();
    }

    this.Add=function(name, option)
    {
        this.DataMap.set(name, { Create:option.Create } );
    }

    this.AddCallbackDrawClassName=function(className)
    {
        if (!className) return;

        this.SetCallbackDraw.add(className);
    }

    this.IsCallbackDraw=function(className)
    {
        return this.SetCallbackDraw.has(className);
    }
}

var g_ExtendChartPaintFactory=new ExtendChartPaintFactory();

function IExtendChartPainting()
{
    this.Canvas;                        //画布
    this.ChartBorder;                   //边框信息
    this.ChartFrame;                    //框架画法
    this.Name;                          //名称
    this.Data;                          //数据区
    this.IsDynamic=false;
    this.IsAnimation=false;             //是否是动画
    this.ClassName='IExtendChartPainting';
    this.SizeChange=true;               //大小是否改变
    this.IsEraseBG=false;               //是否每次画的时候需要擦除K线图背景
    this.DrawAfterTitle=false;          //是否在动态标题画完以后再画,防止动态标题覆盖
    this.DrawAfterPicture=false;        //是否在画图工具以后绘制
    this.IsCallbackDraw=false;          //在回调函数里绘制, 不在Draw()中绘制
    this.ID=Guid();

    //上下左右间距
    this.Left=5;
    this.Right=5;
    this.Top=5;
    this.Bottom=5;

    this.Draw=function()
    {

    }

    //设置参数接口
    this.SetOption=function(option)
    {

    }

    this.GetFontHeight=function(font)
    {
        return GetFontHeight(this.Canvas, font, "擎");
    }
}

//K线Tooltip, 显示在左边或右边
function KLineTooltipPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.IsDynamic=true;
    this.IsEraseBG=true;
    this.DrawAfterTitle=true;
    this.ClassName='KLineTooltipPaint';
    this.BorderColor=g_JSChartResource.TooltipPaint.BorderColor;    //边框颜色
    this.BGColor=g_JSChartResource.TooltipPaint.BGColor;            //背景色
    this.TitleColor=g_JSChartResource.TooltipPaint.TitleColor;      //标题颜色
    this.DateTimeColor=g_JSChartResource.TooltipPaint.DateTimeColor;      //日期时间颜色
    this.VolColor=g_JSChartResource.TooltipPaint.VolColor;       //标题成交量
    this.AmountColor=g_JSChartResource.TooltipPaint.AmountColor;    //成交金额
    this.LatestPoint;               //手势位置
    this.ShowPosition=0;            //显示位置 0=左 1=右

    this.Left=1*GetDevicePixelRatio();
    this.Top=5*GetDevicePixelRatio();
    
    this.Width=50;
    this.Height=100;
    this.LineHeight=15*GetDevicePixelRatio(); //行高
    this.LineSpace=2;   //行间距
    this.Mergin={ Left:2, Top:3, Bottom:5, Right:5 };
    this.ExtendLineWidth=2;

    this.Font=[g_JSChartResource.TooltipPaint.TitleFont];

    this.HQChart;
    this.KLineTitlePaint;
    this.IsHScreen=false;   //是否横屏
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;

    this.ReloadResource=function(resource)
    {
        this.BorderColor=g_JSChartResource.TooltipPaint.BorderColor;    //边框颜色
        this.BGColor=g_JSChartResource.TooltipPaint.BGColor;            //背景色
        this.TitleColor=g_JSChartResource.TooltipPaint.TitleColor;      //标题颜色
        this.DateTimeColor=g_JSChartResource.TooltipPaint.DateTimeColor;      //日期时间颜色
        this.VolColor=g_JSChartResource.TooltipPaint.VolColor;       //标题成交量
        this.AmountColor=g_JSChartResource.TooltipPaint.AmountColor;    //成交金额
    }

    this.GetLeft=function()
    {
        if (this.IsHScreen) 
        {
            return this.ChartBorder.GetRightEx()-this.Height-this.Top;
        }
        else
        {
            if (this.ShowPosition==0)
                return this.ChartBorder.GetLeft()+this.Left;
            else 
                return this.ChartBorder.GetRight()-this.Width-this.Left;
        }
    }

    this.GetTop=function()
    {
        if (this.IsHScreen) 
        {
            if (this.ShowPosition==0)
                return this.ChartBorder.GetTop()+this.Left;
            else
                return this.ChartBorder.GetBottom()-this.Width-this.Left;
        }
        else
        {
            return this.ChartBorder.GetTopEx()+this.Top;
        }
    }

    this.IsEnableDraw=function()
    {
        if (!this.HQChart || !this.HQChart.TitlePaint || !this.HQChart.TitlePaint[0]) return false;
        if (this.HQChart.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
        {
            if (this.HQChart.TouchStatus.CorssCursorShow==false) return false;
        }
        else if (this.HQChart.EnableClickModel)
        {
            if (this.HQChart.ClickModel.IsShowCorssCursor===false) return false;
        }
        else if (this.HQChart.VerticalDrag)
        {
            if (this.HQChart.VerticalDrag.IsDrag) return false; //拖X轴的时候 不要显示tooltip
        }
        else if (!this.HQChart.IsOnTouch) 
        {
            return false;
        }

        if (this.HQChart.CurrentChartDrawPicture) return false;   //画图工具操作的时候 不显示

        return true;
    }

    this.Draw=function()
    {
        if (!this.IsEnableDraw()) return;

        this.IsHScreen=this.ChartFrame.IsHScreen===true;
        this.KLineTitlePaint=this.HQChart.TitlePaint[0];
        var klineData=this.KLineTitlePaint.GetCurrentKLineData();
        if (!klineData) return;

        var titleData=this.GetFormatTitle({Data:klineData});
        if (!titleData || !IFrameSplitOperator.IsNonEmptyArray(titleData.AryText)) return;

        this.CalculateTooltipSize(titleData);

        this.CalculateShowPosition();
        this.DrawBG();
        this.DrawTooltipData(titleData);
        this.DrawBorder();
    }

    this.CalculateTooltipSize=function(titleData)
    {
        this.Canvas.font=this.Font[0];
        this.LineHeight=this.Canvas.measureText("擎").width;
        var pixelRatio=GetDevicePixelRatio();
        var height=0;
        var maxTitleWidth=0, maxTextWidth=0, maxLineWidth=0;
        for(var i=0; i<titleData.AryText.length; ++i)
        {
            var item=titleData.AryText[i];

            if (height>0) height+=this.LineSpace;

            var lineWidth=0;
            if (item.Title)
            {
                var textWidth=this.Canvas.measureText(item.Title).width+2;
                if (maxTitleWidth<textWidth) maxTitleWidth=textWidth;
                lineWidth+=textWidth;
            }

            if (item.Text)
            {
                var textWidth=this.Canvas.measureText(item.Text).width+2;
                if (maxTextWidth<textWidth) maxTextWidth=textWidth;
                lineWidth+=textWidth;
            }

            if (maxLineWidth<lineWidth) maxLineWidth=lineWidth;

            height+=this.LineHeight;
        }

        this.Height=height+(this.Mergin.Top+this.Mergin.Bottom)*pixelRatio;
        this.Width=(maxLineWidth)+(this.Mergin.Left+this.Mergin.Right+this.ExtendLineWidth)*pixelRatio;

        return { Height:this.Height, Width:this.Width, MaxTitleWidth:maxTitleWidth, MaxTextWidth:maxTextWidth };
    }

    //判断显示位置
    this.CalculateShowPosition=function()
    {
        this.ShowPosition=0;
        if (!this.LatestPoint) return;

        if(this.IsHScreen)
        {
            var top=this.ChartBorder.GetTop();
            var height=this.ChartBorder.GetHeight();
            var yCenter=top+height/2;
            if (this.LatestPoint.Y<yCenter) this.ShowPosition=1;
        }
        else
        {
            var left=this.ChartBorder.GetLeft();
            var width=this.ChartBorder.GetWidth();
            var xCenter=left+width/2;
            if (this.LatestPoint.X<xCenter) this.ShowPosition=1;
        }
    }

    this.GetFormatTitle=function(data)
    {
        if (!data || !data.Data) return;

        var item=data.Data;
        var upperSymbol;
        if (this.HQChart.Symbol) upperSymbol=this.HQChart.Symbol.toUpperCase();
        var defaultfloatPrecision=GetfloatPrecision(this.HQChart.Symbol);//价格小数位数
        
        var aryText=[];
        var result={ AryText:aryText };
        var text, title, color;

        text=IFrameSplitOperator.FormatDateString(item.Date);
        aryText.push({ Text:text, Color:this.DateTimeColor });

        var period=this.HQChart.Period;
        if (ChartData.IsMinutePeriod(period,true) && IFrameSplitOperator.IsNumber(item.Time))
        {
            text=IFrameSplitOperator.FormatTimeString(item.Time);
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }
        else if (ChartData.IsSecondPeriod(period) && IFrameSplitOperator.IsNumber(item.Time))
        {
            text=IFrameSplitOperator.FormatTimeString(item.Time,'HH:MM:SS');
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }
        else if (ChartData.IsMilliSecondPeriod(period) && IFrameSplitOperator.IsNumber(item.Time))
        {
            text=IFrameSplitOperator.FormatTimeString(item.Time,'HH:MM:SS.fff');
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }

        if (IFrameSplitOperator.IsNumber(item.Open))    //开盘
        {
            title=g_JSChartLocalization.GetText('Tooltip-Open',this.LanguageID);
            color=this.KLineTitlePaint.GetColor(item.Open,item.YClose);
            text=item.Open.toFixed(defaultfloatPrecision);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        }

        if (IFrameSplitOperator.IsNumber(item.High))    //高
        {
            title=g_JSChartLocalization.GetText('Tooltip-High',this.LanguageID);
            color=this.KLineTitlePaint.GetColor(item.High,item.YClose);
            text=item.High.toFixed(defaultfloatPrecision);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        }

        if (IFrameSplitOperator.IsNumber(item.Low))    //低
        {
            title=g_JSChartLocalization.GetText('Tooltip-Low',this.LanguageID);
            color=this.KLineTitlePaint.GetColor(item.Low,item.YClose);
            text=item.Low.toFixed(defaultfloatPrecision);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        }

        if (IFrameSplitOperator.IsNumber(item.Close))    //收
        {
            title=g_JSChartLocalization.GetText('Tooltip-Close',this.LanguageID);
            color=this.KLineTitlePaint.GetColor(item.Close,item.YClose);
            text=item.Close.toFixed(defaultfloatPrecision);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        }

        //涨幅
        title=g_JSChartLocalization.GetText('Tooltip-Increase',this.LanguageID);
        if (IFrameSplitOperator.IsNumber(item.YFClose) && MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol))
        {
            var value=(item.Close-item.YFClose)/item.YFClose*100;
            color = this.KLineTitlePaint.GetColor(value, 0);
            text = value.toFixed(2)+'%';
        }
        else if (IFrameSplitOperator.IsNumber(item.YClose))
        {
            var value=(item.Close-item.YClose)/item.YClose*100;
            color = this.KLineTitlePaint.GetColor(value, 0);
            text = value.toFixed(2)+'%';
        }
        else
        {
            text='--.--';
            color=this.KLineTitlePaint.GetColor(0, 0);
        }
        aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
       
        if (IFrameSplitOperator.IsNumber(item.Vol))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Vol',this.LanguageID);
            var vol=item.Vol;
            if (upperSymbol && MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) vol/=100; //A股统一转成手
            text=IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.VolColor });
        }
       
        if (IFrameSplitOperator.IsNumber(item.Amount))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Amount',this.LanguageID);
            var text=IFrameSplitOperator.FormatValueString(item.Amount,2,this.LanguageID);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.AmountColor });
        }

        //换手率
        if (MARKET_SUFFIX_NAME.IsSHSZStockA(this.HQChart.Symbol) && item.FlowCapital>0)
        {
            title=g_JSChartLocalization.GetText('Tooltip-Exchange',this.LanguageID);
            var value=item.Vol/item.FlowCapital*100;
            var text=value.toFixed(2)+'%';
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.TitleColor });
        }

        //持仓量
        if (MARKET_SUFFIX_NAME.IsFutures(upperSymbol) && IFrameSplitOperator.IsNumber(item.Position))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Position',this.LanguageID);
            var text=IFrameSplitOperator.FromatIntegerString(item.Position,2,this.LanguageID);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.TitleColor });
        }

        return result;
    }

    this.DrawTooltipData=function(titleData)
    {
        if (!titleData || !IFrameSplitOperator.IsNonEmptyArray(titleData.AryText)) return;

        var pixelRatio=GetDevicePixelRatio();
        var left=this.GetLeft()+2*pixelRatio;
        var top=this.GetTop()+3*pixelRatio;
        if (this.IsHScreen)
        {
            this.Canvas.save(); 
            var x=this.GetLeft()+this.Height, y=this.GetTop();

            this.Canvas.translate(x, y);
            this.Canvas.rotate(90 * Math.PI / 180);

            //x, y 作为原点
            left=2*pixelRatio;
            top=3*pixelRatio;
        }

        
        this.Canvas.textBaseline="top";
        var right=left+this.Width-this.Mergin.Right*pixelRatio;
        left+=this.Mergin.Left*pixelRatio;
        top+=this.Mergin.Top*pixelRatio;
        

        for(var i=0; i<titleData.AryText.length; ++i)
        {
            var item=titleData.AryText[i];

            if (item.Title)
            {
                this.Canvas.textAlign="left";
                this.Canvas.fillStyle=item.TitleColor;
                this.Canvas.fillText(item.Title,left,top);
            }

            if (item.Text)
            {
                this.Canvas.textAlign="right";
                this.Canvas.fillStyle=item.Color;
                this.Canvas.fillText(item.Text,right,top);
            }

            top+=this.LineHeight+this.LineSpace;
        }



        if (this.IsHScreen) this.Canvas.restore();
    }

    /*
    this.DrawTooltipData=function(item)
    {
        //JSConsole.Chart.Log('[KLineTooltipPaint::DrawKLineData] ', item);
        var upperSymbol;
        if (this.HQChart.Symbol) upperSymbol=this.HQChart.Symbol.toUpperCase();
        var defaultfloatPrecision=GetfloatPrecision(this.HQChart.Symbol);//价格小数位数
        var left=this.GetLeft()+2*GetDevicePixelRatio();
        var top=this.GetTop()+3*GetDevicePixelRatio();
        
        if (this.IsHScreen)
        {
            this.Canvas.save(); 
            var x=this.GetLeft()+this.Height, y=this.GetTop();

            this.Canvas.translate(x, y);
            this.Canvas.rotate(90 * Math.PI / 180);

            //x, y 作为原点
            left=2*GetDevicePixelRatio();
            top=3*GetDevicePixelRatio();
        }

        this.Canvas.textBaseline="top";
        this.Canvas.textAlign="left";
        this.Canvas.font=this.Font[0];
        var labelWidth=this.Canvas.measureText('擎: ').width;

        var text=IFrameSplitOperator.FormatDateString(item.Date);
        this.Canvas.fillStyle=this.DateTimeColor;
        this.Canvas.fillText(text, left,top);

        var period=this.HQChart.Period;
        if (ChartData.IsMinutePeriod(period,true) && IFrameSplitOperator.IsNumber(item.Time))
        {
            top+=this.LineHeight;  
            text=IFrameSplitOperator.FormatTimeString(item.Time);
            this.Canvas.fillText(text, left,top);
        }
        else if (ChartData.IsSecondPeriod(period) && IFrameSplitOperator.IsNumber(item.Time))
        {
            top+=this.LineHeight;  
            text=IFrameSplitOperator.FormatTimeString(item.Time,'HH:MM:SS');
            this.Canvas.fillText(text, left,top);
        }

        top+=this.LineHeight;  
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-Open',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        var color=this.KLineTitlePaint.GetColor(item.Open,item.YClose);
        text=item.Open.toFixed(defaultfloatPrecision);
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        top+=this.LineHeight;   
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-High',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        var color=this.KLineTitlePaint.GetColor(item.High,item.YClose);
        var text=item.High.toFixed(defaultfloatPrecision);
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        top+=this.LineHeight;
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-Low',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        var color=this.KLineTitlePaint.GetColor(item.Low,item.YClose);
        var text=item.Low.toFixed(defaultfloatPrecision);
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        top+=this.LineHeight;
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-Close',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        var color=this.KLineTitlePaint.GetColor(item.Close,item.YClose);
        var text=item.Close.toFixed(defaultfloatPrecision);
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        top+=this.LineHeight;
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-Increase',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        if (item.YFClose>0 && MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol))
        {
            var value=(item.Close-item.YFClose)/item.YFClose*100;
            var color = this.KLineTitlePaint.GetColor(value, 0);
            var text = value.toFixed(2)+'%';
        }
        else if (item.YClose>0)
        {
            var value=(item.Close-item.YClose)/item.YClose*100;
            var color = this.KLineTitlePaint.GetColor(value, 0);
            var text = value.toFixed(2)+'%';
        }
        else
        {
            var text='--.--';
            var color=this.KLineTitlePaint.GetColor(0, 0);
        }
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        
        top+=this.LineHeight;
        text=g_JSChartLocalization.GetText('Tooltip-Vol',this.LanguageID);
        this.Canvas.fillStyle=this.TitleColor;
        this.Canvas.fillText(text, left,top);
        var vol=item.Vol;
        if (upperSymbol && MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) vol/=100; //A股统一转成手
        var text=IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID);
        this.Canvas.fillStyle=this.VolColor;
        this.Canvas.fillText(text,left+labelWidth,top);

        if (IFrameSplitOperator.IsNumber(item.Amount))
        {
            
            top+=this.LineHeight;
            text=g_JSChartLocalization.GetText('Tooltip-Amount',this.LanguageID);
            this.Canvas.fillStyle=this.TitleColor;
            this.Canvas.fillText(text, left,top);
            var text=IFrameSplitOperator.FormatValueString(item.Amount,2,this.LanguageID);
            this.Canvas.fillStyle=this.AmountColor;
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        //换手率
        if (MARKET_SUFFIX_NAME.IsSHSZStockA(this.HQChart.Symbol) && item.FlowCapital>0)
        {
            top+=this.LineHeight;
            text=g_JSChartLocalization.GetText('Tooltip-Exchange',this.LanguageID);
            this.Canvas.fillStyle=this.TitleColor;
            this.Canvas.fillText(text, left,top);
            var value=item.Vol/item.FlowCapital*100;
            var text=value.toFixed(2)+'%';
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        //持仓量
        var upperSymbol=this.HQChart.Symbol.toUpperCase();
        if (MARKET_SUFFIX_NAME.IsFutures(upperSymbol) && IFrameSplitOperator.IsNumber(item.Position))
        {
            this.Canvas.fillStyle=this.TitleColor;
            top+=this.LineHeight;
            text=g_JSChartLocalization.GetText('Tooltip-Position',this.LanguageID);
            this.Canvas.fillText(text, left,top);
            var text=IFrameSplitOperator.FromatIntegerString(item.Position,2,this.LanguageID);
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        if (this.IsHScreen) this.Canvas.restore();
    }
    */

    this.DrawBorder=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var left=this.GetLeft();
        var top=this.GetTop();
        this.Canvas.strokeStyle=this.BorderColor;
        if (isHScreen)  this.Canvas.strokeRect(ToFixedPoint(left),ToFixedPoint(top),this.Height,this.Width);
        else this.Canvas.strokeRect(ToFixedPoint(left),ToFixedPoint(top),ToFixedRect(this.Width),ToFixedRect(this.Height));
    }

    this.DrawBG=function()
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var left=this.GetLeft();
        var top=this.GetTop();
        this.Canvas.fillStyle=this.BGColor;
        if (isHScreen)   this.Canvas.fillRect(left,top,this.Height,this.Width);
        else  this.Canvas.fillRect(left,top,this.Width,this.Height);
    }

    //设置参数接口
    this.SetOption=function(option)
    {
        if (option.LineHeight>0) this.LineHeight=option.LineHeight*GetDevicePixelRatio();
        if (option.BGColor) this.BGColor=option.BGColor;
        if (option.LanguageID>0) this.LanguageID=option.LanguageID;
    }
}

function MinuteTooltipPaint()
{
    this.newMethod=KLineTooltipPaint;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='MinuteTooltipPaint';
    this.Left=1*GetDevicePixelRatio();
    this.Top=1*GetDevicePixelRatio();
    this.YClose;
    this.IsShowAveragePrice=true;   //是否显示均价

    this.TitlePaint;

    this.GetTop=function()
    {
        if (this.IsHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            if (this.ShowPosition==0)
                return border.TopEx+this.Left;
            else
                return border.BottomEx-this.Width-this.Left;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            return border.Top+this.Top;
        }
    }

    this.GetLeft=function()
    {
        if (this.IsHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            return border.Right-this.Height-this.Top;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            if (this.ShowPosition==0)
                return border.LeftEx+this.Left;
            else 
                return border.RightEx-this.Width-this.Left;
        }
    }

    this.Draw=function()
    {
        if (!this.IsEnableDraw()) return;

        this.IsHScreen=this.ChartFrame.IsHScreen===true;
        this.TitlePaint=this.HQChart.TitlePaint[0];
        if (!this.TitlePaint) return;

        var drawData;   //{ Type:0=连续交易 1=集合竞价, Data:数据 }
        var pointInfo=this.TitlePaint.PointInfo;
        if (pointInfo && (pointInfo.ClientPos==2 || pointInfo.ClientPos==3 ||  (pointInfo.ClientPos>=200&& pointInfo.ClientPos<=299) || (pointInfo.ClientPos>=300&& pointInfo.ClientPos<=399)))
        {
            var auctionData=this.TitlePaint.GetCurrentAuctionData();
            if (!auctionData) return;
            drawData={ Type:1, Data:auctionData };
        }
        else
        {
            var minuteData=this.TitlePaint.GetCurrentKLineData();
            if (!minuteData) return;
            drawData={ Type:0, Data:minuteData };
        }
       

        var titleData=this.GetFormatTitle(drawData);
        if (!titleData || !IFrameSplitOperator.IsNonEmptyArray(titleData.AryText)) return;

        this.CalculateTooltipSize(titleData);

        this.CalculateShowPosition();
        this.DrawBG();
        this.DrawTooltipData(titleData);
        this.DrawBorder();
    }

    this.GetFormatTitle=function(data)
    {
        if (!data || !data.Data) return;

        var item;
        var close, vol, amount;
        if (data.Type==0)   //盘中
        {
            item=data.Data;
            close=item.Close;
            vol=item.Vol;
            amount=item.Amount;
        }
        else if (data.Type==1)  //盘前 盘后
        {
            item=data.Data.Data;
            if (!item) return;
            close=item.Price;
        }
        
        var upperSymbol;
        if (this.HQChart.Symbol) upperSymbol=this.HQChart.Symbol.toUpperCase();
        var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //国内期货, 纽约期货交易所
        var defaultfloatPrecision=GetfloatPrecision(this.HQChart.Symbol);//价格小数位数

        this.YClose=this.TitlePaint.YClose;
        this.YClose=item.YClose;
        if (isFutures && IFrameSplitOperator.IsNumber(item.YClearing)) this.YClose=item.YClearing;
        
        var aryText=[];
        var result={ AryText:aryText };
        var text, title, color;

        if (IFrameSplitOperator.IsNumber(item.Date))
        {
            text=IFrameSplitOperator.FormatDateString(item.Date);
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }

        if (IFrameSplitOperator.IsNumber(item.Time))
        {
            text=IFrameSplitOperator.FormatTimeString(item.Time);
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }

        
        if (IFrameSplitOperator.IsNumber(close))    //最新
        {
            title=g_JSChartLocalization.GetText('Tooltip-Price',this.LanguageID);
            color=this.TitlePaint.GetColor(close,this.YClose);
            text=close.toFixed(defaultfloatPrecision);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        }

        var isShowAvPrice=true;
        if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol)) isShowAvPrice=false;                 //外汇没有均价
        else if (MARKET_SUFFIX_NAME.IsET(upperSymbol) && !MARKET_SUFFIX_NAME.IsETShowAvPrice(upperSymbol)) isShowAvPrice=false;
        else if (MARKET_SUFFIX_NAME.IsShowAvPrice && !MARKET_SUFFIX_NAME.IsShowAvPrice(upperSymbol)) isShowAvPrice=false;

        //均价
        if (isShowAvPrice && IFrameSplitOperator.IsNumber(item.AvPrice) && this.IsShowAveragePrice)   
        {
            title=g_JSChartLocalization.GetText('Tooltip-AvPrice',this.LanguageID);
            var color=this.TitlePaint.GetColor(item.AvPrice,this.YClose);
            text=item.AvPrice.toFixed(defaultfloatPrecision);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        }

        //涨幅
        if (IFrameSplitOperator.IsNumber(close) && IFrameSplitOperator.IsNumber(this.YClose))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Increase',this.LanguageID);
            if (this.YClose===0)
            {
                text = '--.--';
                color = this.TitleColor;
            }
            else
            {
                var value=(close-this.YClose)/this.YClose*100;
                color = this.TitlePaint.GetColor(value, 0);
                text = value.toFixed(2)+'%';
            }
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:color });
        } 

        //成交量
        if (IFrameSplitOperator.IsNumber(vol))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Vol',this.LanguageID);
            var text=IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.VolColor });
        }

        //成交金额
        if (IFrameSplitOperator.IsNumber(amount))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Amount',this.LanguageID);
            var text=IFrameSplitOperator.FormatValueString(amount,2,this.LanguageID);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.AmountColor });
        }

        if (IFrameSplitOperator.IsNumber(item.Position))
        {
            title=g_JSChartLocalization.GetText('Tooltip-Position',this.LanguageID);
            var text=IFrameSplitOperator.FormatValueString(item.Position,2,this.LanguageID);
            aryText.push({Title:title, TitleColor:this.TitleColor, Text:text, Color:this.TitleColor });
        }

        return result;
    }

    /*
    this.DrawTooltipData=function(item)
    {
        //JSConsole.Chart.Log('[KLineTooltipPaint::DrawKLineData] ', item);
        if (!this.HQChart.Symbol) return;
        
        var defaultfloatPrecision=GetfloatPrecision(this.HQChart.Symbol);//价格小数位数
        var left=this.GetLeft()+2*GetDevicePixelRatio();
        var top=this.GetTop()+3*GetDevicePixelRatio();
        this.YClose=this.KLineTitlePaint.YClose;
        var upperSymbol=this.HQChart.Symbol.toUpperCase();
        
        if (this.IsHScreen)
        {
            this.Canvas.save(); 
            var x=this.GetLeft()+this.Height, y=this.GetTop();

            this.Canvas.translate(x, y);
            this.Canvas.rotate(90 * Math.PI / 180);

            //x, y 作为原点
            left=2*GetDevicePixelRatio();
            top=3*GetDevicePixelRatio();
        }

        this.Canvas.textBaseline="top";
        this.Canvas.textAlign="left";
        this.Canvas.font=this.Font[0];
        var labelWidth=this.Canvas.measureText('擎: ').width;

        var aryDateTime=item.DateTime.split(' ');
        if (aryDateTime && aryDateTime.length==2)
        {
            var text=IFrameSplitOperator.FormatDateString(aryDateTime[0]);
            this.Canvas.fillStyle=this.TitleColor;
            this.Canvas.fillText(text, left,top);

            top+=this.LineHeight;  
            text=IFrameSplitOperator.FormatTimeString(aryDateTime[1]);
            this.Canvas.fillText(text, left,top);
        }

        var close=item.Close;
        var increase=item.Increase;
        var vol=item.Vol;
        var amount=item.Amount;
        if (item.Before)    //读取盘前数据
        {
            close=item.Before.Close;
            increase=item.Before.Increase;
            vol=item.Before.Vol;
            amount=item.Before.Amount;
        }

        //最新价格
        top+=this.LineHeight;
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-Price',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        var color=this.KLineTitlePaint.GetColor(close,this.YClose);
        var text=close.toFixed(defaultfloatPrecision);
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        var isShowAvPrice=true;
        if (item.Before) isShowAvPrice=false;   //集合竞价均价
        else if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol)) isShowAvPrice=false;     //外汇没有均价
        else if (MARKET_SUFFIX_NAME.IsET(upperSymbol) && !MARKET_SUFFIX_NAME.IsETShowAvPrice(upperSymbol)) isShowAvPrice=false;
        else if (MARKET_SUFFIX_NAME.IsShowAvPrice && !MARKET_SUFFIX_NAME.IsShowAvPrice(upperSymbol)) isShowAvPrice=false;

        //均价
        if (isShowAvPrice && IFrameSplitOperator.IsNumber(item.AvPrice) && this.IsShowAveragePrice)   
        {
            top+=this.LineHeight;
            this.Canvas.fillStyle=this.TitleColor;
            text=g_JSChartLocalization.GetText('Tooltip-AvPrice',this.LanguageID);
            this.Canvas.fillText(text, left,top);
            var color=this.KLineTitlePaint.GetColor(item.AvPrice,this.YClose);
            var text=item.AvPrice.toFixed(defaultfloatPrecision);
            this.Canvas.fillStyle=color;
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        //涨幅
        top+=this.LineHeight;
        this.Canvas.fillStyle=this.TitleColor;
        text=g_JSChartLocalization.GetText('Tooltip-Increase',this.LanguageID);
        this.Canvas.fillText(text, left,top);
        var value=(close-this.YClose)/this.YClose*100;
        var color = this.KLineTitlePaint.GetColor(value, 0);
        var text = value.toFixed(2)+'%';
        this.Canvas.fillStyle=color;
        this.Canvas.fillText(text,left+labelWidth,top);

        //成交量
        if (IFrameSplitOperator.IsNumber(vol))
        {
            this.Canvas.fillStyle=this.TitleColor;
            top+=this.LineHeight;
            text=g_JSChartLocalization.GetText('Tooltip-Vol',this.LanguageID);
            this.Canvas.fillText(text, left,top);
            var text=IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID);
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        //成交金额
        if (IFrameSplitOperator.IsNumber(amount))
        {
            top+=this.LineHeight;
            text=g_JSChartLocalization.GetText('Tooltip-Amount',this.LanguageID);
            this.Canvas.fillText(text, left,top);
            var text=IFrameSplitOperator.FormatValueString(amount,2,this.LanguageID);
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        if (IFrameSplitOperator.IsNumber(item.Position))
        {
            top+=this.LineHeight;
            text=g_JSChartLocalization.GetText('Tooltip-Position',this.LanguageID);
            this.Canvas.fillText(text, left,top);
            var text=IFrameSplitOperator.FormatValueString(item.Position,2,this.LanguageID);
            this.Canvas.fillText(text,left+labelWidth,top);
        }

        if (this.IsHScreen) this.Canvas.restore();
    }
    */
}

//PC端 分时图tooltip左侧固定
function MinuteLeftTooltipPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.IsDynamic=true;
    this.IsEraseBG=true;
    this.DrawAfterTitle=true;
    this.ClassName='MinuteLeftTooltipPaint';
    this.BorderColor=g_JSChartResource.PCTooltipPaint.BorderColor;    //边框颜色
    this.BGColor=g_JSChartResource.PCTooltipPaint.BGColor;            //背景色
    this.TitleColor=g_JSChartResource.PCTooltipPaint.TitleColor;      //标题颜色
    this.DateTimeColor=g_JSChartResource.PCTooltipPaint.DateTimeColor;      //日期时间颜色
    this.VolColor=g_JSChartResource.PCTooltipPaint.VolColor;          //标题成交量
    this.AmountColor=g_JSChartResource.PCTooltipPaint.AmountColor;    //成交金额
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.TitlePaint;

    this.UpColor=g_JSChartResource.UpTextColor;
    this.DownColor=g_JSChartResource.DownTextColor;
    this.UnchagneColor=g_JSChartResource.UnchagneTextColor;
    this.YClose;

    this.Mergin={ Left:2, Top:3, Bottom:2, Right:2 };
    this.LineHeight=15 //行高
    this.FixedWidth;         //固定宽度

    this.Font=g_JSChartResource.PCTooltipPaint.TitleFont;
    this.HQChart;

     //设置参数接口
    this.SetOption=function(option)
    {
        if (option.BGColor) this.BGColor=option.BGColor;
        if (option.LanguageID>0) this.LanguageID=option.LanguageID;
        if (IFrameSplitOperator.IsNumber(option.FixedWidth)) this.FixedWidth=option.FixedWidth;
    }

    this.IsEnableDraw=function()
    {
        if (!this.HQChart || !this.HQChart.TitlePaint || !this.HQChart.TitlePaint[0]) return false;
        var pt=this.HQChart.LastPoint;
        if (!pt) return false;

        return this.HQChart.IsMouseOnClient(pt.X, pt.Y);
    }

    this.Draw=function()
    {
        if (!this.IsEnableDraw()) return;

        this.TitlePaint=this.HQChart.TitlePaint[0];
        if (!this.TitlePaint) return;
        var pointInfo=this.TitlePaint.PointInfo;
        var drawData;   //{ Type:0=连续交易 1=集合竞价, Data:数据 }
        if (pointInfo && (pointInfo.ClientPos==2 || pointInfo.ClientPos==3 ||  (pointInfo.ClientPos>=200&& pointInfo.ClientPos<=299) || (pointInfo.ClientPos>=300&& pointInfo.ClientPos<=399)))
        {
            var auctionData=this.TitlePaint.GetCurrentAuctionData();
            if (!auctionData) return;
            drawData={ Type:1, Data:auctionData };
        }
        else
        {
            var minuteData=this.TitlePaint.GetCurrentKLineData();
            if (!minuteData) return;
            drawData={ Type:0, Data:minuteData };
        }
        
        this.YClose=this.TitlePaint.YClose;
        var aryText=this.GetForamtTitle(drawData);
        if (!IFrameSplitOperator.IsNonEmptyArray(aryText)) return;

        this.Canvas.font=this.Font;
        this.Canvas.textBaseline = 'top';
        this.LineHeight=GetFontHeight(this.Canvas, null, "擎");
        var border=this.ChartBorder.GetBorder();

        var height=this.LineHeight*aryText.length*2;
        var rtBorder={Left:1, Top:1, Right:border.Left };
        rtBorder.Bottom=rtBorder.Top+height;
        rtBorder.Width=rtBorder.Right-rtBorder.Left;
        rtBorder.Height=rtBorder.Bottom-rtBorder.Top;
        rtBorder.Height+=(this.Mergin.Top+this.Mergin.Bottom);
        rtBorder.Bottom=rtBorder.Top+rtBorder.Height;

        if (IFrameSplitOperator.IsNumber(this.FixedWidth)) rtBorder.Width=this.FixedWidth;

        this.Canvas.fillStyle = this.BGColor;
        this.Canvas.fillRect(rtBorder.Left,rtBorder.Top,rtBorder.Width,rtBorder.Height);

        this.Canvas.strokeStyle=this.BorderColor;
        this.Canvas.strokeRect(ToFixedPoint(rtBorder.Left),ToFixedPoint(rtBorder.Top),ToFixedRect(rtBorder.Width),ToFixedRect(rtBorder.Height));
        
        var right=(rtBorder.Left+rtBorder.Width)-this.Mergin.Right;
        var left=this.Mergin.Left+rtBorder.Left;
        var top=this.Mergin.Top+rtBorder.Top;
        var rtItem={ Left:left, Top:top, Right:right };
        rtItem.Width=rtItem.Right-rtItem.Left;
        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            this.DrawText(item, rtItem);
        }
    }

    this.DrawText=function(item, rtItem)
    {
        this.Canvas.fillStyle = item.TitleColor;

        this.Canvas.textAlign = 'left';
        this.Canvas.fillText(item.Title, rtItem.Left, rtItem.Top);
        rtItem.Top+=this.LineHeight;
        rtItem.Bottom=rtItem.Top+this.LineHeight;

        this.Canvas.textAlign = 'right';
        this.Canvas.fillStyle = item.TextColor;
        this.Canvas.fillText(item.Text, rtItem.Right, rtItem.Top);
        rtItem.Top+=this.LineHeight;
        rtItem.Bottom=rtItem.Top+this.LineHeight;
    }

    //{ Title:, Text:, Color: }
    this.GetForamtTitle=function(drawData)
    {
        if (!drawData || !drawData.Data) return null;

        var aryText=[];
        var isFutures=false;
        var upperSymbol;
        if (this.HQChart.Symbol) upperSymbol=this.HQChart.Symbol.toUpperCase();
        var defaultfloatPrecision=GetfloatPrecision(upperSymbol);//价格小数位数
        if (upperSymbol) isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //国内期货, 纽约期货交易所

        if (drawData.Type==0)   //连续交易
        {
            var item=drawData.Data;
            if (!item) return;

            this.YClose=item.YClose;
            if (isFutures && IFrameSplitOperator.IsNumber(item.YClearing)) this.YClose=item.YClearing;
            var titleItem=this.FormatDate(item.Date);
            if (titleItem) aryText.push(titleItem);

            var titleItem=this.ForamtTime(item.Time,"HH:MM",'PCTooltip-Time');
            if (titleItem) aryText.push(titleItem);

            var titleItem=this.ForamtPrice(item.Close,defaultfloatPrecision,'PCTooltip-Price');
            if (titleItem) aryText.push(titleItem);

            var titleItem=this.ForamtPrice(item.AvPrice,defaultfloatPrecision,'PCTooltip-AvPrice');
            if (titleItem) aryText.push(titleItem);

            var titleItem=this.ForamtIncrease(item.Close,"PCTooltip-Increase");
            if (titleItem) aryText.push(titleItem);

            var titleItem=this.FormatVol(item.Vol,'PCTooltip-Vol');
            if (titleItem) aryText.push(titleItem);

            if (IFrameSplitOperator.IsNumber(item.Amount))
            {
                var titleItem=
                { 
                    Title:g_JSChartLocalization.GetText('PCTooltip-Amount',this.LanguageID),
                    TitleColor:this.TitleColor,
                    Text:IFrameSplitOperator.FromatIntegerString(item.Amount,2,this.LanguageID),
                    TextColor:this.AmountColor
                };

                aryText.push(titleItem);
            }
        }
        else if (drawData.Type==1)  //集合竞价
        {
            var item=drawData.Data.Data;
            if (!item) return;
            
            this.YClose=item.YClose;
            if (isFutures && IFrameSplitOperator.IsNumber(item.YClearing)) this.YClose=item.YClearing;
            var titleItem=this.FormatDate(item.Date);
            if (titleItem) aryText.push(titleItem);

            var timeForamt="HH:MM:SS";
            if (item.Ver===1) timeForamt="HH:MM"
            
            var titleItem=this.ForamtTime(item.Time,timeForamt,'PCTooltip-Time');
            if (titleItem) aryText.push(titleItem);
           
            var titleItem=this.ForamtPrice(item.Price,defaultfloatPrecision,'PCTooltip-AC-Price');
            if (titleItem) aryText.push(titleItem);

            var titleItem=this.ForamtIncrease(item.Price,"PCTooltip-AC-Increase");
            if (titleItem) aryText.push(titleItem);

            if (IFrameSplitOperator.IsNonEmptyArray(item.Vol))
            {
                var titleItem=this.FormatVol(item.Vol[0],'PCTooltip-AC-Vol');
                if (titleItem) aryText.push(titleItem);
    
                var titleItem=this.FormatVol(item.Vol[1],'PCTooltip-AC-NotMatchVol');
                if (titleItem) aryText.push(titleItem);
            }
        }

        return aryText;
    }

    this.GetColor=function(price,yclse)
    {
        if(price>yclse) return this.UpColor;
        else if (price<yclse) return this.DownColor;
        else return this.UnchagneColor;
    }

    this.FormatDate=function(date)
    {
        if (!IFrameSplitOperator.IsNumber(date)) return null;
        
        var titleItem=
        { 
            Title:g_JSChartLocalization.GetText('PCTooltip-Date',this.LanguageID),
            TitleColor:this.TitleColor,
            Text:IFrameSplitOperator.FormatDateString(date, "MM-DD", this.LanguageID),
            TextColor:this.DateTimeColor
        };

        return titleItem;
    }

    this.ForamtTime=function(time, format, TitleID)
    {
        if (!IFrameSplitOperator.IsNumber(time)) return null;

        var titleItem=
        { 
            Title:g_JSChartLocalization.GetText(TitleID,this.LanguageID),
            TitleColor:this.TitleColor,
            Text:IFrameSplitOperator.FormatTimeString(time, format, this.LanguageID),
            TextColor:this.DateTimeColor
        };

        return titleItem;
    }

    this.ForamtPrice=function(price, defaultfloatPrecision, TitleID)
    {
        if (!IFrameSplitOperator.IsNumber(price)) return null;

        var titleItem=
        { 
            Title:g_JSChartLocalization.GetText(TitleID, this.LanguageID),
            TitleColor:this.TitleColor,
            Text:price.toFixed(defaultfloatPrecision),
            TextColor:this.GetColor(price, this.YClose)
        };

        return titleItem;
    }

    this.ForamtIncrease=function(price, TitleID)
    {
        if (!IFrameSplitOperator.IsNumber(price) || price==0) return null;
       
        var value=(price-this.YClose)/this.YClose*100;
        var titleItem=
        { 
            Title:g_JSChartLocalization.GetText(TitleID,this.LanguageID),
            TitleColor:this.TitleColor,
            Text:value.toFixed(2)+'%',
            TextColor:this.GetColor(value, 0)
        };

        if (this.YClose===0) 
        {
            titleItem.Text="--.--";
            titleItem.TextColor=this.TitleColor
        }
           

        return titleItem;
    }

    this.FormatVol=function(vol, TitleID)
    {
        if (!IFrameSplitOperator.IsNumber(vol)) return null;
        
        var titleItem=
        { 
            Title:g_JSChartLocalization.GetText(TitleID,this.LanguageID),
            TitleColor:this.TitleColor,
            Text:IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID),
            TextColor:this.VolColor
        };
        
        return titleItem;
    }
}

//股票信息
function StockInfoExtendChartPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Left=80;
    this.Right=1;
    this.Top=1;
    this.Bottom=1;

    this.BorderColor=g_JSChartResource.FrameBorderPen;

    this.Symbol;
    this.Name;

    this.TitleFont=["14px 微软雅黑"];

    this.Draw=function()
    {
        var left=this.ChartBorder.GetRight()+this.Left;
        var right=this.ChartBorder.GetChartWidth()-this.Right;
        var y=this.Top+18;
        var middle=left+(right-left)/2;

        if (this.Symbol && this.Name)
        {
            this.Canvas.font=this.TitleFont[0];

            this.Canvas.textAlign="right";
            this.Canvas.textBaseline="bottom";
            this.Canvas.fillText(this.Symbol,middle-2,y);

            this.Canvas.textAlign="left";
            this.Canvas.fillText(this.Name,middle+2,y);
        }
        ;
        this.Canvas.strokeStyle=this.BorderColor;
        this.Canvas.moveTo(left,y);
        this.Canvas.lineTo(right,y);
        this.Canvas.stroke();

        y+=30;

        this.DrawBorder();
    }

    this.DrawBorder=function()
    {
        var left=this.ChartBorder.GetRight()+this.Left;
        var right=this.ChartBorder.GetChartWidth()-this.Right;
        var top=this.Top;
        var bottom=this.ChartBorder.GetChartHeight()-this.Bottom;

        this.Canvas.strokeStyle=this.BorderColor;
        this.Canvas.strokeRect(left,top,(right-left),(bottom-top));
    }
}

//筹码分布
function StockChip()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Name='筹码分布';
    this.ClassName='StockChip';

    this.HQChart;
    this.PenBorder=g_JSChartResource.FrameBorderPen;    //边框
    this.ColorProfit='rgb(255,0,0)';            //盈利的线段
    this.ColorNoProfit='rgb(90,141,248)';       //非盈利
    this.ColorAveragePrice='rgb(0,139,0)';   //平均价线
    this.ColorBG='rgb(190,190,190)';           //筹码背景线段颜色

    this.PixelRatio=GetDevicePixelRatio();
    this.ShowType=0;    //0=所有筹码  1=周期前  2=周期内
    this.IsDynamic=true;
    this.ClientRect={};
    this.Font=g_JSChartResource.TitleFont;
    this.InfoColor=g_JSChartResource.StockChip.InfoColor;
    this.DayInfoColor=g_JSChartResource.StockChip.DayInfoColor;
    this.LineHeight=16;
    this.Left=50*this.PixelRatio;         //左边间距
    this.IsShowX=false;  //是否显示X刻度 成交量
    this.ShowXCount=3;
    this.Width=150*this.PixelRatio;       //筹码图宽度
    this.CalculateType=0;   //0=平均分布 1=三角分布
    this.PriceZoom=100;     //价格放大倍数

    this.NotSupportMessage="不支持筹码图";
    this.Buttons=[];

    this.DefaultButton=CloneData(g_JSChartResource.StockChip.DefaultButton);     //默认筹码分布图
    this.LongButton=CloneData(g_JSChartResource.StockChip.LongButton);           //远期筹码分布图
    this.RecentButton=CloneData(g_JSChartResource.StockChip.RecentButton);       //近期筹码分布图
    this.ButtonTooltip=CloneData(g_JSChartResource.Buttons.Tooltip);

    this.DAY_COLOR=
    [
        ['rgb(255,0,0)','rgb(255,128,128)','rgb(255,0,128)','rgb(255,100,0)','rgb(192,128,0)','rgb(255,192,0)'],
        ['rgb(120,80,225)','rgb(160,160,225)','rgb(80,80,255)','rgb(120,120,255)','rgb(32,64,192)','rgb(0,64,128)'],
    ];

    this.SetOption=function(option)
    {
        if (!option) return;
        if (option.ShowType>0) this.ShowType=option.ShowType;
        if (option.IsShowX) this.IsShowX=option.IsShowX;
        if (option.ShowXCount>0) this.ShowXCount=option.ShowXCount;
        if (option.Width>100) this.Width=option.Width*GetDevicePixelRatio();
        if (option.CalculateType>0) this.CalculateType=option.CalculateType;
        if (IFrameSplitOperator.IsNumber(option.PriceZoom)) this.PriceZoom=option.PriceZoom;
    }

    this.ReloadResource=function(resource)
    {
        this.PenBorder=g_JSChartResource.FrameBorderPen;
        this.Font=g_JSChartResource.TitleFont;
        this.InfoColor=g_JSChartResource.StockChip.InfoColor;
        this.DayInfoColor=g_JSChartResource.StockChip.DayInfoColor;

        this.DefaultButton=CloneData(g_JSChartResource.StockChip.DefaultButton);     //默认筹码分布图
        this.LongButton=CloneData(g_JSChartResource.StockChip.LongButton);           //远期筹码分布图
        this.RecentButton=CloneData(g_JSChartResource.StockChip.RecentButton);       //近期筹码分布图
        this.ButtonTooltip=CloneData(g_JSChartResource.Buttons.Tooltip);
    }
    
    this.Draw=function()
    {
        this.PixelRatio=GetDevicePixelRatio();
        var left=ToFixedPoint(this.ChartBorder.GetRight()+this.Left);
        var top=ToFixedPoint(this.ChartBorder.GetTop());
        var right=ToFixedPoint(left+this.Width-1*this.PixelRatio);
        var bottom=ToFixedPoint(this.ChartBorder.GetBottom());
        var width=right-left;
        var height=bottom-top;
        this.ClientRect={Left:left,Top:top,Width:width,Height:height};

        if (ChartData.IsTickPeriod(this.HQChart.Period))    //分笔图没有筹码
        {
            this.Canvas.font=this.Font;
            this.Canvas.fillStyle=this.InfoColor;

            var x=left+width/2;
            var y=top+height/2;

            this.Canvas.textAlign="center";
            this.Canvas.textBaseline="middle";
            this.Canvas.fillText(this.NotSupportMessage,x,y);

            this.DrawBorder();
            return;
        }

        if (this.CalculateChip())
        {
            this.DrawFrame();
            this.DrawAllChip();
            if (this.ShowType==1|| this.ShowType==2) this.DrawDayChip();

            this.CalculateCast();   //计算成本  
            this.DrawChipInfo();      
        }
        else
        {
            JSConsole.Chart.Log('[StockChip::Draw] no data');
        }

        this.DrawBorder();

        this.SizeChange=false;
    }

    this.DrawChipInfo=function()    
    {
        var bottom=this.ClientRect.Top+this.ClientRect.Height-1;
        var left=this.ClientRect.Left+2;
        var right=this.ClientRect.Left+this.ClientRect.Width;

        this.Canvas.font=this.Font;
        this.Canvas.fillStyle=this.InfoColor;
        this.Canvas.textBaseline='bottom';
        this.Canvas.textAlign='left';

        var lineHeight=this.LineHeight*GetDevicePixelRatio();
        var text='70%成本价 --.--';
        if (IFrameSplitOperator.IsNonEmptyArray(this.Data.Cast))
            text='70%成本价'+ this.Data.Cast[1].MinPrice.toFixed(2)+'-'+this.Data.Cast[1].MaxPrice.toFixed(2)+'集中'+this.Data.Cast[1].Rate.toFixed(2)+'%';
        this.Canvas.fillText(text,left,bottom);
        bottom-=lineHeight;

        text='90%成本价 --.--';
        if (IFrameSplitOperator.IsNonEmptyArray(this.Data.Cast))
            text='90%成本价'+ this.Data.Cast[0].MinPrice.toFixed(2)+'-'+this.Data.Cast[0].MaxPrice.toFixed(2)+'集中'+this.Data.Cast[0].Rate.toFixed(2)+'%';;
        this.Canvas.fillText(text,left,bottom);
        bottom-=lineHeight;

        text='平均成本：'+this.Data.ChipInfo.AveragePrice.toFixed(2)+'元';
        this.Canvas.fillText(text,left,bottom);
        bottom-=lineHeight;

        text=+this.Data.YPrice.toFixed(2)+'处获利盘：'+this.Data.ChipInfo.YProfitRate.toFixed(2)+'%';
        this.Canvas.fillText(text,left,bottom);
        bottom-=lineHeight;

        text='获利比例：';
        this.Canvas.fillText(text,left,bottom);
        var textWidth=this.Canvas.measureText(text).width+2;
        var barLeft=left+textWidth;
        var barWidth=(right-5-barLeft);
        this.Canvas.strokeStyle=this.ColorNoProfit;
        this.Canvas.strokeRect(barLeft,bottom-lineHeight,barWidth,lineHeight);
        this.Canvas.strokeStyle=this.ColorProfit;
        this.Canvas.strokeRect(barLeft,bottom-lineHeight,barWidth*(this.Data.ChipInfo.ProfitRate/100),lineHeight);
        text=this.Data.ChipInfo.ProfitRate.toFixed(2)+'%';
        this.Canvas.textAlign='center';
        this.Canvas.fillText(text,barLeft+barWidth/2,bottom);
        bottom-=lineHeight;

        this.Canvas.textAlign='left';
        text='成本分布,日期：'+IFrameSplitOperator.FormatDateString(this.Data.SelectData.Date);
        if (this.Data.SelectData.Time) text+=' '+IFrameSplitOperator.FormatTimeString(this.Data.SelectData.Time);
        this.Canvas.fillText(text,left,bottom);
        bottom-=lineHeight;

        if (this.ShowType!=1 && this.ShowType!=2) return;

        var right=this.ClientRect.Left+this.ClientRect.Width-1;
        this.Canvas.textAlign='right';
        var textWidth=50;
        this.Data.DayChip.sort(function(a,b){return b.Day-a.Day;})
        for(var i in this.Data.DayChip)
        {
            var item=this.Data.DayChip[i];
            var rate=0;
            if (this.Data.ChipInfo && this.Data.ChipInfo.Vol>0) rate=item.Vol/this.Data.ChipInfo.Vol*100;
            text=item.Day+'周期'+(this.ShowType==1?'前':'内')+'成本'+(IFrameSplitOperator.IsNumber(rate)? (rate.toFixed(2)+'%'):"--.--%");
            if (i==0) textWidth=this.Canvas.measureText(text).width+8;
            this.Canvas.fillStyle=item.Color;
            this.Canvas.fillRect(right-textWidth,bottom-lineHeight,textWidth,lineHeight);

            this.Canvas.fillStyle=this.DayInfoColor;
            this.Canvas.fillText(text,right,bottom);
            bottom-=lineHeight;
        }
    }

    this.DrawDayChip=function()
    {
        var KLineFrame=this.HQChart.Frame.SubFrame[0].Frame;
        for(var i in this.Data.DayChip)
        {
            var aryPoint=[];
            var chipData=this.Data.DayChip[i].Chip;
            if (!chipData) continue;
            var totalVol=0;
            for(var j=0;j<chipData.length;++j)
            {
                var vol=chipData[j];
                if(!vol) continue;
                totalVol+=vol;
                var price=(j+this.Data.MinPrice)/100;
                var y=KLineFrame.GetYFromData(price);
                var x=(vol/this.Data.MaxVol)*this.ClientRect.Width+this.ClientRect.Left;
                aryPoint.push({X:x,Y:y});
            }
            this.Data.DayChip[i].Vol=totalVol;
            this.DrawArea(aryPoint,this.Data.DayChip[i].Color);
        }
    }

    this.DrawToolbar=function(moveonPoint, mouseStatus)
    {
        this.Buttons=[];

        var left=this.ClientRect.Left;
        var right=this.ClientRect.Left+this.ClientRect.Width;
        var yButton=this.ClientRect.Top+this.ChartBorder.TitleHeight/2;
        
        var aryButton=
        [
            {ID:JSCHART_BUTTON_ID.CHIP_RECENT, Style: this.RecentButton, ShowType:2 },
            {ID:JSCHART_BUTTON_ID.CHIP_LONG, Style: this.LongButton , ShowType:1},
            {ID:JSCHART_BUTTON_ID.CHIP_DEFULT, Style: this.DefaultButton, ShowType:0 }
        ];

        //右往左绘制
        for(var i=0;i<aryButton.length;++i)
        {
            var item=aryButton[i];
            var size=item.Style.Size;
            var xBotton=right-size-item.Style.MerginLeft;
            var font=`${size}px ${item.Style.Family}`;
            var rtButton={ Left:xBotton, Top:yButton-size/2, Right:xBotton+size+item.Style.MerginLeft, Bottom:yButton+size/2, Width:size+item.Style.MerginLeft, Height:size };
            var color=item.Style.Color;

            var btnItem={ ID:item.ID, Rect:rtButton };
            if (this.ShowType==item.ShowType)
            {
                color=item.Style.SelectedColor;
                if (mouseStatus && moveonPoint &&  (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
                    mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:btnItem, Frame:this, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
            }
            else
            {
                if (moveonPoint &&  (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
                {
                    color=item.Style.MoveOnColor;
                    if (mouseStatus) mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:btnItem, Frame:this, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
                }
                    
            }
            
            this.Canvas.fillStyle=color;
            this.Canvas.font=font;
            this.Canvas.textAlign="left";
            this.Canvas.textBaseline="middle";
            this.Canvas.fillText(item.Style.Text, xBotton, yButton);

            this.Buttons.push(btnItem);

            right=xBotton;
        }
    }

    this.DrawToolbarTooltip=function(mouseOnToolbar)
    {
        if (!mouseOnToolbar) return;

        var left=this.ClientRect.Left;
        var right=this.ClientRect.Left+this.ClientRect.Width;
        
        var key='Toolbar-'+mouseOnToolbar.Item.ID;
        text=g_JSChartLocalization.GetText(key,0);
        
        if (!text) return;
        
        var rtButton=mouseOnToolbar.Rect;
        var xCenter=rtButton.Left+rtButton.Width/2;

        this.Canvas.font=this.ButtonTooltip.Font;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";

        var textWidth=this.Canvas.measureText(text).width+8;
        var textHeight=this.GetFontHeight();
        var bgHeight=textHeight+8;
        var x=xCenter-textWidth/2;
        var y=rtButton.Top-bgHeight;
        if (y<0) y=rtButton.Bottom+1;
        if (x+textWidth>right) x=right-textWidth-2;
        
        this.Canvas.fillStyle=this.ButtonTooltip.ColorBG; 
        this.Canvas.fillRect(x,y,textWidth,bgHeight);   //画一个背景色, 不然是一个黑的背景

        this.Canvas.fillStyle=this.ButtonTooltip.Color;
        this.Canvas.fillText(text, x+4,y+bgHeight/2);
    }

    this.PtInButtons=function(x,y) //坐标是否在按钮上
    {
        for(var i=0;i<this.Buttons.length;++i)
        {
            var item=this.Buttons[i];
            if (!item.Rect) continue;

            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.Left,rect.Top,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                return { ID:item.ID, Rect:rect };
            }
        }

        return null;
    }

    this.DrawAllChip=function()
    {
        var KLineFrame=this.HQChart.Frame.SubFrame[0].Frame;
        var selectPrice=this.Data.SelectData.Close;
        var aryProfitPoint=[];
        var aryNoProfitPoint=[];
        var totalVol=0,totalAmount=0,totalProfitVol=0, totalYProfitVol=0;   //总的成交量, 总的成交金额, 总的盈利的成交量
        var yPrice=this.Data.YPrice;

        var maxPrice=KLineFrame.HorizontalMax;
        var minPrice=KLineFrame.HorizontalMin;

        var MaxVol=1;
        for(var i=0;i<this.Data.AllChip.length;++i)
        {
            var vol=this.Data.AllChip[i];
            if(!vol) continue;
            var price=(i+this.Data.MinPrice)/this.PriceZoom;
            totalVol+=vol;
            totalAmount+=price*vol;

            if (price<yPrice) totalYProfitVol+=vol;     //获利的成交量
            if (price<selectPrice) totalProfitVol+=vol; //鼠标当前位置 获利的成交量

            if (price<=maxPrice && price>=minPrice)
            {
                if (MaxVol<vol) MaxVol=vol;
            }
        }
        this.Data.MaxVol=MaxVol;    //把成交量最大值替换成 当前屏成交量最大值
        
        for(var i=0;i<this.Data.AllChip.length;++i)
        {
            var vol=this.Data.AllChip[i];
            if(!vol) continue;
            var price=(i+this.Data.MinPrice)/this.PriceZoom;
            if (price>maxPrice || price<minPrice) continue;

            var y=KLineFrame.GetYFromData(price);
            var x=(vol/this.Data.MaxVol)*this.ClientRect.Width+this.ClientRect.Left;
           
            if (price<selectPrice) aryProfitPoint.push({X:x,Y:y});
            else aryNoProfitPoint.push({X:x,Y:y});
        }

        this.Data.ChipInfo=
        {
            Vol:totalVol, AveragePrice:totalAmount/totalVol, ProfitVol:totalProfitVol, 
            ProfitRate:totalVol>0?totalProfitVol/totalVol*100:0,
            YProfitRate:totalVol>0?totalYProfitVol/totalVol*100:0
        };

        if (this.ShowType==0)
        {
            this.DrawLines(aryProfitPoint,this.ColorProfit);
            this.DrawLines(aryNoProfitPoint,this.ColorNoProfit);
            var averagePrice=this.Data.ChipInfo.AveragePrice;
            if (averagePrice>0 && averagePrice<=maxPrice && averagePrice>=minPrice) 
            {
                averagePrice=averagePrice.toFixed(2);
                this.DrawAveragePriceLine(aryProfitPoint,aryNoProfitPoint,KLineFrame.GetYFromData(averagePrice),this.ColorAveragePrice);
            }
        }
        else    //在火焰山模式下, 筹码用一个颜色
        {
            this.DrawLines(aryProfitPoint,this.ColorBG);
            this.DrawLines(aryNoProfitPoint,this.ColorBG);
        }
    }

    this.CalculateCast=function()   //计算 90% 70%的成本价
    {
        if (!this.Data.ChipInfo || !this.Data.ChipInfo.Vol) return;

        var aryCast=
        [
            {Start:0.05,End:0.95, MaxPrice:0, MinPrice:0, Rate:0},
            {Start:0.15,End:0.85, MaxPrice:0, MinPrice:0, Rate:0}
        ];

        var averagePrice=this.Data.ChipInfo.AveragePrice;
        var totalProfitVol=this.Data.ChipInfo.ProfitVol;
        var tempVol=0;
        for(var i=0, castCount=0;i<this.Data.AllChip.length;++i)
        {
            if (castCount==4) break;
            var vol=this.Data.AllChip[i];
            if (vol<=0) continue;

            var price=(i+this.Data.MinPrice)/this.PriceZoom;
            tempVol+=vol;
            var rate=tempVol/totalProfitVol;
            
            for(var j in aryCast)
            {
                var itemCast=aryCast[j];
                if (itemCast.MinPrice<=0 && rate>itemCast.Start)
                {
                    itemCast.MinPrice=price;
                    ++castCount;
                }

                if (itemCast.MaxPrice<=0 && rate>itemCast.End)
                {
                    itemCast.MaxPrice=price;
                    ++castCount;
                }
            }
        }

        for(var i in aryCast)
        {
            var item=aryCast[i];
            var addPrice=item.MaxPrice+item.MinPrice;
            if (addPrice) item.Rate=Math.abs(item.MaxPrice-item.MinPrice)/addPrice*100;
        }

        this.Data.Cast=aryCast;
    }

    this.DrawArea=function(aryPoint,color)
    {
        if (aryPoint.length<=0) return;

        this.Canvas.fillStyle=color;
        this.Canvas.beginPath();
        this.Canvas.moveTo(this.ClientRect.Left,aryPoint[0].Y);
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            this.Canvas.lineTo(item.X,item.Y);
        }
        this.Canvas.lineTo(this.ClientRect.Left,aryPoint[aryPoint.length-1].Y);
        this.Canvas.fill();
    }

    this.DrawLines=function(aryPoint,color)
    {
        if (aryPoint.length<=0) return;
        this.Canvas.strokeStyle=color;
        this.Canvas.beginPath();
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            this.Canvas.moveTo(this.ClientRect.Left,item.Y);
            this.Canvas.lineTo(item.X,item.Y);
        }
        this.Canvas.stroke();
    }

    this.DrawAveragePriceLine=function(aryProfitPoint,aryNoProfitPoint,y,color)
    {
        for(var i in aryProfitPoint)
        {
            var item=aryProfitPoint[i];
            if (item.Y==y)
            {
                this.Canvas.strokeStyle=color;
                this.Canvas.beginPath();
                this.Canvas.moveTo(this.ClientRect.Left,item.Y);
                this.Canvas.lineTo(item.X,item.Y);
                this.Canvas.stroke();
                return;
            }
        }

        for(var i in aryNoProfitPoint)
        {
            var item=aryNoProfitPoint[i];
            if (item.Y==y)
            {
                this.Canvas.strokeStyle=color;
                this.Canvas.beginPath();
                this.Canvas.moveTo(this.ClientRect.Left,item.Y);
                this.Canvas.lineTo(item.X,item.Y);
                this.Canvas.stroke();
                return;
            }
        }
    }

    this.DrawBorder=function()
    {
        this.Canvas.strokeStyle=this.PenBorder;
        this.Canvas.strokeRect(this.ClientRect.Left,this.ClientRect.Top,this.ClientRect.Width,this.ClientRect.Height);
    }

    this.EvenlyDistribute=function(aryChip, data)    //平均分布 data={Low, High, Vol, MaxVol, MaxPrice, MinPrice }
    {
        var low=data.Low, high=data.High, maxPrice=data.MaxPrice, minPrice=data.MinPrice, maxVol=1;
        if ( (high-low)== 0) return;
        var averageVol=data.Vol/(high-low);

        for(var j=low;j<=high && j<=maxPrice;++j)
        {
            var index=j-minPrice;
            aryChip[index]+=averageVol;
            if (maxVol<aryChip[index]) maxVol=aryChip[index];
        }

        data.MaxVol=maxVol;
    }

    this.TriangleDistribute=function(aryChip, data)  //三角分布
    {
        var low=data.Low, high=data.High, maxPrice=data.MaxPrice, minPrice=data.MinPrice, maxVol=1;
        var ANGLE = 45, PI=3.1415926535;
        var middlePrice = (high - low) / 2.0 + low;

        var totalValue=0;
        var aryVol=[];
        for(var i=low+1, j=1 ;i<=middlePrice;++i,++j)
        {
            var y = Math.tan(ANGLE* PI / 180)*j;

            totalValue+=y;
            aryVol.push({Index:i-minPrice, Value:y});
        }

        for(var i=high-1, j=1 ;i>middlePrice;--i,++j)
        {
            var y = Math.tan(ANGLE* PI / 180)*j;

            totalValue+=y
            aryVol.push({Index:i-minPrice, Value:y});
        }

        if (totalValue>0)
        {
            for(var i=0;i<aryVol.length;++i)
            {
                var item=aryVol[i];
                aryChip[item.Index]+=item.Value*data.Vol/totalValue;
                if (maxVol<aryChip[item.Index]) maxVol=aryChip[item.Index];
            }

            data.MaxVol=maxVol;
        }
    }

    this.CalculateDistribute=function(aryChip, data)
    {
        if (this.CalculateType==1) this.TriangleDistribute(aryChip, data);
        else this.EvenlyDistribute(aryChip, data);
    }

    this.CalculateChip=function()   //计算筹码
    {
        if (!this.HQChart) return false;
        if (!this.HQChart.FlowCapitalReady) return false;
        var symbol=this.HQChart.Symbol;
        if (!symbol) return false;
        if (MARKET_SUFFIX_NAME.IsSHSZIndex(symbol)) return false;   //指数暂时不支持移动筹码

        var bindData=this.HQChart.ChartPaint[0].Data;
        //if (bindData.Period>=4) return false;   //分钟K线不支持, 没时间做,以后再做吧
        var count=bindData.DataOffset+parseInt(this.HQChart.CursorIndex);
        if (count>=bindData.Data.length) count=bindData.Data.length-1;
        var selData=bindData.Data[count];
        var yPrice=selData.Close;

        var mouseY=this.HQChart.LastPoint.Y;
        if (mouseY) yPrice=this.HQChart.Frame.SubFrame[0].Frame.GetYData(mouseY);
        
        //JSConsole.Chart.Log("[StockChip::CalculateChip]",count,this.HQChart.CursorIndex,selData);
        const rate=1;
        var aryVol=[];
        var seed=1,vol,maxPrice,minPrice;
        for(let i=count;i>=0;--i)
        {
            var item=bindData.Data[i];
            var changeRate=1;   //换手率
            if (item.FlowCapital>0) changeRate=item.Vol/item.FlowCapital;
            if (i==count) vol=item.Vol*changeRate;
            else vol=item.Vol*seed;
            var dataItem={Vol:vol,High:item.High,Low:item.Low};
            aryVol.push(dataItem);
            seed*=(1-changeRate*rate);

            if (!maxPrice || maxPrice<item.High) maxPrice=item.High;
            if (!minPrice || minPrice>item.Low) minPrice=item.Low;
        }

        //JSConsole.Chart.Log("[StockChip::CalculateChip]",maxPrice,minPrice);
        if (!maxPrice || !minPrice) return true;

        var priceZoom=this.PriceZoom;

        maxPrice=parseInt(maxPrice*priceZoom);
        minPrice=parseInt(minPrice*priceZoom);

        var dataCount=maxPrice-minPrice;
        var aryChip=new Array()
        for(let i=0;i<=dataCount;++i)
        {
            aryChip.push(0);
        }

        var dayChip=[];
        var distributeData;
        if (this.ShowType==2)
        {
            var dayChip=
            [
                {Day:100, Color:this.DAY_COLOR[1][5]}, {Day:60, Color:this.DAY_COLOR[1][4]}, {Day:30, Color:this.DAY_COLOR[1][3]},
                {Day:20, Color:this.DAY_COLOR[1][2]}, {Day:10, Color:this.DAY_COLOR[1][1]}, {Day:5, Color:this.DAY_COLOR[1][0]}
            ];
            for(let i in aryVol)
            {
                var item=aryVol[i];
                var high=parseInt(item.High*priceZoom);
                var low=parseInt(item.Low*priceZoom);
                var averageVol=item.Vol;
                if (high-low>0) averageVol=item.Vol/(high-low);
                if (averageVol<=0.000000001) continue;

                for(var k=0;k<dayChip.length;++k)
                {
                    if (i==dayChip[k].Day) 
                    {
                        dayChip[k].Chip=aryChip.slice(0);
                        break;
                    }
                }

                distributeData={Low:low, High:high, Vol:item.Vol, MaxPrice:maxPrice, MinPrice:minPrice};
                this.CalculateDistribute(aryChip, distributeData );
            }
        }
        else if (this.ShowType==1)
        {
            var dayChip=
            [
                {Day:5, Color:this.DAY_COLOR[0][0]},{Day:10, Color:this.DAY_COLOR[0][1]},{Day:20, Color:this.DAY_COLOR[0][2]},
                {Day:30, Color:this.DAY_COLOR[0][3]},{Day:60, Color:this.DAY_COLOR[0][4]},{Day:100, Color:this.DAY_COLOR[0][5]}
            ];

            for(let i=aryVol.length-1;i>=0;--i)
            {
                var item=aryVol[i];
                var high=parseInt(item.High*priceZoom);
                var low=parseInt(item.Low*priceZoom);
                var averageVol=item.Vol;
                if (high-low>0) averageVol=item.Vol/(high-low);
                if (averageVol<=0.000000001) continue;

                for(var k=0;k<dayChip.length;++k)
                {
                    if (i==dayChip[k].Day) 
                    {
                        dayChip[k].Chip=aryChip.slice(0);
                        break;
                    }
                }
                
                distributeData={Low:low, High:high, Vol:item.Vol, MaxPrice:maxPrice, MinPrice:minPrice};
                this.CalculateDistribute(aryChip, distributeData);
            }
        }
        else
        {
            for(let i in aryVol)
            {
                var item=aryVol[i];
                var high=parseInt(item.High*priceZoom);
                var low=parseInt(item.Low*priceZoom);
                var averageVol=item.Vol;
                if (high-low>0) averageVol=item.Vol/(high-low);
                if (averageVol<=0.000000001) continue;

                distributeData={Low:low, High:high, Vol:item.Vol, MaxPrice:maxPrice, MinPrice:minPrice};
                this.CalculateDistribute(aryChip, distributeData);
            }
        }

        if (!distributeData) return false;

        this.Data={AllChip:aryChip, MaxVol:distributeData.MaxVol, MaxPrice:maxPrice, MinPrice:minPrice,SelectData:selData, DayChip:dayChip, YPrice:yPrice};
        return true;
    }

    this.DrawFrame=function()  //X轴成交量坐标
    {
        if (this.IsShowX==false) return;
        if (this.Data.MaxVol<=0) return;

        var isDrawXFrame=this.HQChart.Frame.SubFrame.length===1 ? false:true;         //是否画X轴,如果只有1个窗口就不画
        var KLineFrame=this.HQChart.Frame.SubFrame[0].Frame;
        var chartBorder=KLineFrame.ChartBorder;
        var bottom=ToFixedPoint(chartBorder.GetBottomEx()+1);
        if (!isDrawXFrame) bottom=this.ClientRect.Top+this.ClientRect.Height;
        var left=this.ClientRect.Left;
        var right=left+this.ClientRect.Width;

        this.Canvas.strokeStyle=this.PenBorder;
        this.Canvas.beginPath();
        if (isDrawXFrame)
        {
            this.Canvas.moveTo(left,bottom);
            this.Canvas.lineTo(right,bottom);
        }
        
        var showCount=this.ShowXCount;
        var maxValue=this.Data.MaxVol;
        var perValue=Math.floor(maxValue/showCount);
        this.Canvas.font=this.Font;
        this.Canvas.textBaseline='top';
        this.Canvas.fillStyle=this.InfoColor;
        var xOffset=10*GetDevicePixelRatio();
        for(var i=1;i<=showCount;++i)
        {
            var vol=perValue*i;
            var x=(vol/this.Data.MaxVol)*this.ClientRect.Width+this.ClientRect.Left;
            x=ToFixedPoint(x);
            if (i==showCount)   //最后一个刻度不要画线了
            {
                this.Canvas.textAlign='right';
                var text=IFrameSplitOperator.FormatValueString(maxValue, 1);
                this.Canvas.fillText(text,x,bottom+2);
            }
            else
            {
                this.Canvas.moveTo(x,this.ClientRect.Top);
                this.Canvas.lineTo(x,bottom);
               
                this.Canvas.textAlign='center';
               
                var text=IFrameSplitOperator.FormatValueString(vol, 1);
                var textWidth=this.Canvas.measureText(text).width;
                this.Canvas.fillText(text,Math.floor(x-textWidth*0.25),bottom+2);
            }
        }

        this.Canvas.stroke();
    }
}

//窗口分割
function FrameSplitPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='FrameSplitPaint';
    this.LineColor='rgb(255,0,0)';
    this.TextColor="rgb(255,0,0)";
    this.LineWidth=2;
    this.Font='bold '+18*GetDevicePixelRatio() +"px 微软雅黑";
    this.TextTopOffset=10*GetDevicePixelRatio();

    //设置参数接口
    this.SetOption=function(option)
    {
        if (option)
        {
            if (option.LineColor) this.LineColor=option.LineColor;
            if (option.TextColor) this.TextColor=option.TextColor;
            if (option.Font) this.Font=option.Font;
            if (IFrameSplitOperator.IsNumber(option.LineWidth)) this.LineWidth=option.LineWidth;
            if (IFrameSplitOperator.IsNumber(option.TextTopOffset)) this.TextTopOffset=option.TextTopOffset;
        }
    }

    this.Draw=function()
    {
        if (!this.HQChart) return;
        if (this.HQChart.Period!=0 && this.HQChart.Period!=1) return;

        if (!this.HQChart.ChartPaint[0]) return;
        var data=this.HQChart.ChartPaint[0].Data;
        if (!data) return;
        this.Data=data;
        if (!this.ChartFrame || !this.ChartFrame.SubFrame) return;
        var subFrame=this.ChartFrame.SubFrame[0].Frame;
        if (!subFrame) return;

        var isHScreen=(subFrame.IsHScreen===true);
        var dataWidth=subFrame.DataWidth;
        var distanceWidth=subFrame.DistanceWidth;
        var xPointCount=subFrame.XPointCount;

        var lineWidth=this.LineWidth * GetDevicePixelRatio();

        if (isHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var drawHeight=border.ChartHeight-border.TopTitle-5*GetDevicePixelRatio();
        }

        this.Canvas.save();
        this.Canvas.lineWidth=lineWidth;
        this.Canvas.font=this.Font;
        this.Canvas.textAlign='center';
        this.Canvas.textBaseline='top';
        var preQuarter={ Left:border.LeftEx, Top:ToFixedPoint2(lineWidth,border.TopTitle), Height:drawHeight, LineWidth:lineWidth };
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (!item) continue;
            
            var dateInfo=this.GetQuarter(item.Date);
            if (!dateInfo) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;


            if (!preQuarter.DateInfo)
            {
                preQuarter.DateInfo=dateInfo;
                preQuarter.Right=x;
            }
            else
            {
                var preDateInfo=preQuarter.DateInfo;
                if (preDateInfo.Year!=dateInfo.Year || preDateInfo.Quarter!=dateInfo.Quarter)
                {
                    preQuarter.Right=x;
                    this.DrawQuarter(preQuarter);

                    preQuarter.Left=x;
                    preQuarter.Right=null;
                    preQuarter.DateInfo=dateInfo;
                }
                else
                {
                    preQuarter.Right=x;
                }
            }
        }

        this.DrawQuarter(preQuarter);

        this.Canvas.restore();
    }

    this.DrawQuarter=function(quarterInfo)
    {
        if (!IFrameSplitOperator.IsNumber(quarterInfo.Left) || !IFrameSplitOperator.IsNumber(quarterInfo.Right)) return;

        var left=ToFixedPoint2(quarterInfo.LineWidth,quarterInfo.Left);
        var right=ToFixedPoint2(quarterInfo.LineWidth,quarterInfo.Right);
        var drawWidth=right-left;
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.strokeRect(left, quarterInfo.Top, drawWidth, quarterInfo.Height);

        var date=quarterInfo.DateInfo;
        var shortYear=date.Year%100;
        if (shortYear<10) var strYear='0'+shortYear;
        else var strYear=shortYear.toString();
        var text=`${strYear}年${date.Quarter}季度`;
        var textWidth = this.Canvas.measureText(text).width;
        if (textWidth<(drawWidth+5))
        {
            var x=left+drawWidth/2;
            var y=quarterInfo.Top+this.TextTopOffset;
            this.Canvas.fillStyle=this.TextColor;
            this.Canvas.fillText(text,x,y);
        }
    }

    this.GetQuarter=function(date)
    {
        if (!IFrameSplitOperator.IsNumber(date)) return null;

        var year=parseInt(date/10000);
        var month=parseInt((date%10000)/100);

        switch(month)
        {
            case 1:
            case 2:
            case 3:
                var quarter=1;
                break;
            case 4:
            case 5:
            case 6:
                var quarter=2;
                break;
            case 7:
            case 8:
            case 9:
                var quarter=3;
                break;
            case 10:
            case 11:
            case 12:
                var quarter=4;
                break;
            default:
                return null;
        }

        return { Year:year, Month:month, Quarter:quarter };
    }
}


//区间选择选中范围背景
function RectSelectPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='RectSelectPaint';
    this.LineColor=g_JSChartResource.RectSelect.LineColor;          //竖线  
    this.LineWidth=g_JSChartResource.RectSelect.LineWidth;
    this.LineDotted=g_JSChartResource.RectSelect.LineDotted;  
    this.AreaColor=g_JSChartResource.RectSelect.AreaColor;          //面积
    this.SubAreaColor=g_JSChartResource.RectSelect.SubAreaColor;

    this.FirstPoint;
    this.SecondPoint;
    this.CenterPoint;
    this.PreventClose=false;        //如果外面有div,可以设置成true, 有外面控制
    this.SpaceReselected=false;     //空格重选

    this.SubClient={ FirstPoint:null, SecondPoint:null, Start:null, End:null };

    this.StartDate;     //{ Date:, Index: }
    this.EndDate;       //{ Date:, Index: }
    this.CenterDate;    //{ Date:, Index: }

    this.HQChart;
    this.DragRect;          //拖拽边框区域数组 []
    this.ShowRangeText=
    { 
        Enable:false, 
        Position:0, //0顶部 1=中间 2=底部
        Font:g_JSChartResource.RectSelect.RangeTextFont,
        Color:g_JSChartResource.RectSelect.RangeTextColor,
        BGColor:g_JSChartResource.RectSelect.RangeTextBGColor,

        SubPosition:0,
        SubFont:g_JSChartResource.RectSelect.RangeTextSubFont,
        SubColor:g_JSChartResource.RectSelect.RangeTextSubColor,
        SubBGColor:g_JSChartResource.RectSelect.RangeTextSubBGColor,
    };

    this.BorderCache;
    this.IsOnlyOnePoint=false;   //空格选中区间，单点模式
    this.IsFullFrame=false;       //区间选择包含子窗口

    //设置参数接口
    this.SetOption=function(option)
    {
        if (option)
        {
            if (option.LineColor) this.LineColor=option.LineColor;
            if (option.AreaColor) this.AreaColor=option.AreaColor;
            if (IFrameSplitOperator.IsBool(option.SpaceReselected)) this.SpaceReselected=option.SpaceReselected;
            if (option.ShowRangeText)
            {
                var item=option.ShowRangeText;
                if (IFrameSplitOperator.IsBool(item.Enable)) this.ShowRangeText.Enable=item.Enable;
                if (IFrameSplitOperator.IsNumber(item.Position)) this.ShowRangeText.Position=item.Position;
                if (IFrameSplitOperator.IsNumber(item.SubPosition)) this.ShowRangeText.SubPosition=item.SubPosition;
            }
        }
    }

    this.ReloadResource=function(resource)
    {
        this.LineColor=g_JSChartResource.RectSelect.LineColor;     //竖线  
        this.LineWidth=g_JSChartResource.RectSelect.LineWidth;
        this.LineDotted=g_JSChartResource.RectSelect.LineDotted;  
        this.AreaColor=g_JSChartResource.RectSelect.AreaColor;     //面积

        this.ShowRangeText.Font=g_JSChartResource.RectSelect.RangeTextFont;
        this.ShowRangeText.Color=g_JSChartResource.RectSelect.RangeTextColor;
        this.ShowRangeText.BGColor=g_JSChartResource.RectSelect.RangeTextBGColor;
    }

    this.IsMinuteChart=function()
    {
        var className=this.HQChart.ClassName;
        var isMinuteChart=(className=="MinuteChartContainer" || className=="MinuteChartHScreenContainer") ? true:false;
        return isMinuteChart;
    }

    this.GetKData=function()
    {
        if (!this.HQChart) return null;
        var isMinuteChart=this.IsMinuteChart();

        var data=null;
        if (isMinuteChart)
        {
            if (!this.HQChart.SourceData) return null;
            data=this.HQChart.SourceData;
        }
        else
        {
            if (!this.HQChart.ChartPaint[0]) return null;
            data=this.HQChart.ChartPaint[0].Data;
            if (!data) return null;
        }

        return data;
    }

    this.GetPointCount=function()
    {
        var count=0;
        if (this.FirstPoint) ++count;
        if (this.SecondPoint) ++count;
        return count;
    }

    this.DateToNumber=function(value, isMinuteChart)
    {
        if (isMinuteChart)
        {
            if (IFrameSplitOperator.IsNumber(value.Date)) return value.Date*10000+value.Time;
            else return value.Time;
        }
        else
        {
            var period=this.HQChart.Period;
            if (ChartData.IsDayPeriod(period, true)) return value.Date; //YYYYMMDD
            else if (ChartData.IsMinutePeriod(period, true)) return value.Date*10000+value.Time; //YYYYMMDDHHMM
            else if (ChartData.IsSecondPeriod(period) || ChartData.IsTickPeriod(period)) return value.Date*1000000+value.Time;  //YYYYMMDDHHMMSS
            else if (ChartData.IsMilliSecondPeriod(period) ) return value.Date*1000000000+value.Time;  //YYYYMMDDHHMMSSFFF
        }

        return null;
    }

    this.GetSelectRectData=function()
    {
        if (!this.FirstPoint || !this.SecondPoint) return null;
        
        var data=this.GetKData();
        if (!data) return null;
        var isMinuteChart=this.IsMinuteChart();
        var firstDate=this.DateToNumber(this.FirstPoint,isMinuteChart);
        var secondDate=this.DateToNumber(this.SecondPoint,isMinuteChart);
        var selectData={ Start:null, End:null, Data:data };
        for(var i=0;i<data.Data.length;++i)
        {
            var item=data.Data[i];
            if (!item) continue;
            var value=this.DateToNumber(item,isMinuteChart);

            if (firstDate==value) selectData.Start=i;
            if (secondDate==value) selectData.End=i;

            if (IFrameSplitOperator.IsNumber(selectData.Start) && IFrameSplitOperator.IsNumber(selectData.End))
            {
                if (selectData.Start>selectData.End)
                {
                    var temp=selectData.Start;
                    selectData.Start=selectData.End;
                    selectData.End=temp;
                }
                return selectData;
            }
        }

        return null;
    }

    this.SortPoint=function()  
    {
        var isMinuteChart=this.IsMinuteChart();
        this.CenterData=null;

        if (this.FirstPoint && !this.SecondPoint)
        {
            this.StartDate={ Date:this.DateToNumber(this.FirstPoint,isMinuteChart), Index:0 };
        }
        else if (this.FirstPoint && this.SecondPoint)
        {
            var firstValue=this.DateToNumber(this.FirstPoint,isMinuteChart);
            var secondValue=this.DateToNumber(this.SecondPoint,isMinuteChart);
            if (firstValue<secondValue)
            {
                this.StartDate={ Date:firstValue, Index:0 };
                this.EndDate={ Date:secondValue, Index:1 };
            }
            else
            {
                this.StartDate={ Date:secondValue, Index:1 };
                this.EndDate={ Date:firstValue, Index:0 };
            }

            if (this.CenterPoint)
            {
                var centerValue=this.DateToNumber(this.CenterPoint, isMinuteChart);
                this.CenterDate={ Date:centerValue, Index:2 };
            }


             //子区域
            if (this.SubClient.FirstPoint && this.SubClient.SecondPoint)
            {
                var firstValue=this.DateToNumber(this.SubClient.FirstPoint,isMinuteChart);
                var secondValue=this.DateToNumber(this.SubClient.SecondPoint,isMinuteChart);
                if (firstValue<secondValue)
                {
                    this.SubClient.Start={ Date:firstValue, Index:3 };
                    this.SubClient.End={ Date:secondValue, Index:4  };
                }
                else
                {
                    this.SubClient.Start={ Date:secondValue, Index:4 };
                    this.SubClient.End={ Date:firstValue, Index:3 };
                }

                //不能超出区间范围
                if (this.SubClient.End.Date<=this.StartDate.Date || this.SubClient.Start.Date>=this.EndDate.Date)
                {
                    this.SubClient.Start=null;
                    this.SubClient.End=null;
                }
                else
                {
                    if (this.SubClient.Start.Date<this.StartDate.Date) this.SubClient.Start.Date=this.StartDate.Date;
                    if (this.SubClient.End.Date>this.EndDate.Date) this.SubClient.End.Date=this.EndDate.Date;
                }
                
            }
        }
    }

    this.GetCenterPoint=function()
    {
        if (!this.FirstPoint || !this.SecondPoint) return null;
        if (!IFrameSplitOperator.IsNumber(this.FirstPoint.DataIndex)) return null;
        if (!IFrameSplitOperator.IsNumber(this.SecondPoint.DataIndex)) return null;

        var count=this.FirstPoint.DataIndex-this.SecondPoint.DataIndex;
        if (Math.abs(count)<3) return null;

        var centerIndex=parseInt(this.FirstPoint.DataIndex+(this.SecondPoint.DataIndex-this.FirstPoint.DataIndex)/2);
        if (centerIndex<0) return null;
        var data=this.GetKData();
        if (!data || !data.Data) return null;
        
        var kItem=data.Data[centerIndex];
        if (!kItem) return null;

       return { Date:kItem.Date, Time:kItem.Time, DataIndex:centerIndex };
    }

    this.MovePoint=function(offset)
    {
        if (!this.FirstPoint || !this.SecondPoint) return false;
        var data=this.GetKData();
        if (!data || !data.Data) return false;

        var dataIndex=this.FirstPoint.DataIndex+offset;
        var kItem=data.Data[dataIndex];
        if (!kItem) return false;
        var firstPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };

        var dataIndex=this.SecondPoint.DataIndex+offset;
        var kItem=data.Data[dataIndex];
        if (!kItem) return false;
        var secondPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };

        var dataIndex=this.CenterPoint.DataIndex+offset;
        var kItem=data.Data[dataIndex];
        if (!kItem) return false;
        var centerPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };

        this.FirstPoint=firstPoint;
        this.SecondPoint=secondPoint;
        this.CenterPoint=centerPoint;

        return true;
    }

    this.MoveSubRect=function(step, isLeft)
    {
        if (!this.FirstPoint || !this.SecondPoint) return false;
        if (!this.SubClient || !this.SubClient.FirstPoint || !this.SubClient.SecondPoint) return false;
        var data=this.GetKData();
        if (!data || !data.Data) return false;

        //区间范围
        var startIndex=Math.min(this.FirstPoint.DataIndex,this.SecondPoint.DataIndex);
        var endIndex=Math.max(this.FirstPoint.DataIndex,this.SecondPoint.DataIndex);

        var subStartPoint=this.SubClient.FirstPoint;
        var subEndPoint=this.SubClient.SecondPoint;
        if (this.SubClient.FirstPoint.DataIndex>this.SubClient.SecondPoint.DataIndex)
        {
            var subStartPoint=this.SubClient.SecondPoint;
            var subEndPoint=this.SubClient.FirstPoint;
        }

        var subStartIndex=subStartPoint.DataIndex;
        var subEndIndex=subEndPoint.DataIndex;

        if (isLeft)
        {
            if (subStartIndex<=startIndex) return false;

            subStartIndex-=step;
            subEndIndex-=step;
        }
        else
        {
            if (subEndPoint.DataIndex>=endIndex) return false;

            subStartIndex+=step;
            subEndIndex+=step;
        }

        var bChanged=false;
        if (subStartIndex!=subStartPoint.DataIndex)
        {
            subStartPoint.DataIndex=subStartIndex;
            var kItem=data.Data[subStartIndex];
            subStartPoint.Date=kItem.Date;
            subStartPoint.Time=kItem.Time;

            bChanged=true;
        }

        if (subEndIndex!=subStartPoint.DataIndex)
        {
            subEndPoint.DataIndex=subEndIndex;
            var kItem=data.Data[subEndIndex];
            subEndPoint.Date=kItem.Date;
            subEndPoint.Time=kItem.Time;

            bChanged=true;
        }

        return bChanged
    }

    this.SetPoint=function(kItem, option)
    {
        var dataIndex=null;
        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.DataIndex)) dataIndex=option.DataIndex;
        }

        if (option && IFrameSplitOperator.IsNumber(option.Index))
        {
            switch(option.Index)
            {
                case 0:
                    this.FirstPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex  };
                    this.CenterPoint=this.GetCenterPoint();
                    return true;
                case 1:
                    this.SecondPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex  };
                    this.CenterPoint=this.GetCenterPoint();
                    return true;
                case 2: //中心偏移
                    var offset=dataIndex-this.CenterPoint.DataIndex;
                    //this.CenterPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };
                    if (Math.abs(offset)>0) 
                        return this.MovePoint(offset);
                    return false;
                case 3:
                    this.SubClient.FirstPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };
                    return true;
                case 4:
                    this.SubClient.SecondPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };
                    return true;
                default:
                    return false;
            }
        }
        else
        {
            if (this.IsOnlyOnePoint)
            {
                this.FirstPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };
                return true;
            }

            if (!this.FirstPoint) 
            {
                this.FirstPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };
                return true;
            }
    
            if (!this.SecondPoint)
            {
                this.SecondPoint={ Date:kItem.Date, Time:kItem.Time, DataIndex:dataIndex };
                this.CenterPoint=this.GetCenterPoint();
                return true;
            }
            return false;
        }
    }

    this.ClearPoint=function()
    {
        if (this.PreventClose) return false;

        var bRedraw=false;
        if (this.FirstPoint) 
        {
            this.FirstPoint=null;
            bRedraw=true;
        }

        if (this.SecondPoint) 
        {
            this.SecondPoint=null;
            bRedraw=true;
        }

        this.SubClient.FirstPoint=null;
        this.SubClient.SecondPoint=null;

        return bRedraw;
    }

    this.Draw=function()
    {
        this.BorderCache=null;
        this.StartDate=null;
        this.EndDate=null;
        this.CenterDate=null;
        this.DragRect=[];
        this.SubClient.Start=null;
        this.SubClient.End=null;

        if (!this.FirstPoint && !this.SecondPoint) return;
        this.SortPoint();

        var data=this.GetKData();
        if (!data) return;
        this.Data=data;
        if (!this.ChartFrame || !this.ChartFrame.SubFrame) return;
        var subFrame=this.ChartFrame.SubFrame[0].Frame;
        if (!subFrame) return;

        var isHScreen=(subFrame.IsHScreen===true);
        var dataWidth=subFrame.DataWidth;
        var distanceWidth=subFrame.DistanceWidth;
        var xPointCount=subFrame.XPointCount;

        if (isHScreen)
        {
            var border=subFrame.GetBorder();
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.BottomEx;
            this.BorderCache=border;
        }
        else
        {
            var border=subFrame.GetBorder();
            if (this.IsFullFrame)  border=this.ChartFrame.ChartBorder.GetBorder();  //全部指标窗口选中
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
            var drawHeight=border.ChartHeight-border.TopTitle-5*GetDevicePixelRatio();
            var top=border.TopEx;
            var bottom=border.BottomEx;
            this.BorderCache=border;
        }

        this.Canvas.save();
        var isDayPeriod=ChartData.IsDayPeriod(this.HQChart.Period,true);
        var isMinuteChart=this.IsMinuteChart();
        var startPoint=null, endPoint=null, subStartPoint=null, subEndPoint=null;
        var startDate=null, startEnd=null;
        var aryLines=[];
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data.Data[i];
            if (!item) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            
            if (isMinuteChart)
                var x=subFrame.GetXFromIndex(j);
            else
                var x=left+(right-left)/2;

            var value=this.DateToNumber(item, isMinuteChart);

            if (this.StartDate && value==this.StartDate.Date)
            {
                startPoint={ XIndex:i, X:x, Top:top, Bottom: bottom, PointIndex:this.StartDate.Index, Type:0, Item:item };
                aryLines.push(startPoint);
            }
                   
            if (this.EndDate && value==this.EndDate.Date)
            {
                endPoint={ XIndex:i, X:x , Top:top, Bottom: bottom, PointIndex:this.EndDate.Index, Type:1, Item:item };
                aryLines.push(endPoint);
            }

            if (this.CenterDate && value==this.CenterDate.Date)
            {
                var centerPoint={ XIndex:i, X:x , Top:top, Bottom: bottom, PointIndex:this.CenterDate.Index, Type:2, Item:item };
                aryLines.push(centerPoint);
            }

            if (this.SubClient && this.SubClient.Start && this.SubClient.End)
            {
                if (value==this.SubClient.Start.Date)
                {
                    this.SubClient.Start.Point={ Date:value, X:x, Top:top, Bottom: bottom, KItem:item };
                }

                if (value==this.SubClient.End.Date)
                {
                    this.SubClient.End.Point={ Date:value, X:x, Top:top, Bottom: bottom, kItem:item };
                }

            }            

            if (!startDate) 
            {
                startDate={ Date:value, X:x, Top:top, Bottom: bottom };
                startEnd={ Date:value, X:x, Top:top, Bottom: bottom };
            }
            else
            {
                startEnd.Date=value;
                startEnd.X=x;
            }
        
            if (startPoint && endPoint) break;
        }

        this.DrawLines(aryLines);
        this.DrawArea(startPoint, endPoint, startDate, startEnd, this.AreaColor);

        if (this.SubClient && this.SubClient.Start && this.SubClient.End)
        {
            this.DrawArea(this.SubClient.Start.Point, this.SubClient.End.Point, startDate, startEnd, this.SubAreaColor, 4);
            if (this.SubClient.Start.Point)
            {
                var item=this.SubClient.Start.Point;
                var point={  X:item.X, Top:item.Top, Bottom: item.Bottom, PointIndex:item.DataIndex, Type:3, Item:item.KItem };
                aryLines.push(point);
            }
        }
            
        this.DrawRangeText(aryLines);

        this.Canvas.restore();
    }

    this.DrawRangeText=function(aryLines)
    {
        if (!this.ShowRangeText) return;
        if (this.ShowRangeText.Enable==false) return;

        //文字
        var border=this.BorderCache;
        var isMinuteChart=this.IsMinuteChart();
        var period=this.HQChart.Period;
        
        var x,y,text;
        for(var i=0;i<aryLines.length;++i)
        {
            var item=aryLines[i];

            if (item.Type===0 || item.Type==1 || item.Type==3)  //第1个点,第2个点
            {
                if (isMinuteChart)
                {
                    var strDate=IFrameSplitOperator.FormatDateString(item.Item.Date,"YYYY-MM-DD");
                    var strTime=IFrameSplitOperator.FormatTimeString(item.Item.Time,"HH:MM");
                    text=`${strDate} ${strTime}`;
                }
                else
                {
                    var strDate=IFrameSplitOperator.FormatDateString(item.Item.Date,"YYYY-MM-DD");
                    var strTime=null;
                    if (ChartData.IsMinutePeriod(period, true)) strTime=IFrameSplitOperator.FormatTimeString(item.Item.Time,"HH:MM");
                    else if (ChartData.IsSecondPeriod(period) || ChartData.IsTickPeriod(period)) strTime=IFrameSplitOperator.FormatTimeString(item.Item.Time,"HH:MM:SS");
                    if (strTime) text=`${strDate} ${strTime}`;
                    else text=strDate;
                }
                
                if (item.Type==3)
                {
                    var postion=this.ShowRangeText.SubPosition;
                    var bgColor=this.ShowRangeText.SubBGColor;
                    var textColor=this.ShowRangeText.SubColor;
                    this.Canvas.font=this.ShowRangeText.SubFont;
                    var textHeight=this.GetFontHeight();
                }
                else
                {
                    var postion=this.ShowRangeText.Position;
                    var bgColor=this.ShowRangeText.BGColor;
                    var textColor=this.ShowRangeText.Color;
                    this.Canvas.font=this.ShowRangeText.Font;
                    var textHeight=this.GetFontHeight();
                }

                var textWidth=this.Canvas.measureText(text).width+4;
                var rtBG={ Height:textHeight, Width:textWidth };

                if (item.Type==0 || item.Type==3)   //第1个点
                {
                    if (textWidth>item.X)
                    {
                        this.Canvas.textAlign="left";
                        this.Canvas.textBaseline="middle";
                        x=item.X+2;
                        rtBG.X=item.X;
                    }
                    else
                    {
                        this.Canvas.textAlign="right";
                        this.Canvas.textBaseline="middle";
                        x=item.X-2;
                        rtBG.X=item.X-textWidth;
                    }
                }
                else if (item.Type==1)  //第2个点
                {
                    if (textWidth>(border.Right-item.X))
                    {
                        this.Canvas.textAlign="right";
                        this.Canvas.textBaseline="middle";
                        x=item.X-2;
                        rtBG.X=item.X-textWidth;
                    }
                    else
                    {
                        this.Canvas.textAlign="left";
                        this.Canvas.textBaseline="middle";
                        x=item.X+2;
                        rtBG.X=item.X;
                    }
                }
                
                
                if (postion==1) 
                {
                    y=item.Top+(item.Bottom-item.Top)/2;
                    if (item.Type==3) y+=textHeight;
                    rtBG.Y=y-textHeight/2;
                }
                else if (postion==2) 
                {
                    y=item.Bottom;
                    rtBG.Y=y-textHeight/2;
                }
                else 
                {
                    y=item.Top;
                    rtBG.Y=y-textHeight/2;
                }

                if (bgColor)
                {
                    this.Canvas.fillStyle=bgColor;
                    this.Canvas.fillRect(ToFixedPoint(rtBG.X),ToFixedPoint(rtBG.Y),ToFixedRect(rtBG.Width),ToFixedRect(rtBG.Height));
                }
                
                if (textColor)
                {
                    this.Canvas.fillStyle=textColor;
                    this.Canvas.fillText(text,x,y,textWidth);
                }
            }
        }
    }

    this.DrawLines=function(aryLines)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryLines)) return;

        var lineWidth=this.LineWidth * GetDevicePixelRatio();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.lineWidth=lineWidth;

        for(var i=0;i<aryLines.length;++i)
        {
            var item=aryLines[i];
            var left=ToFixedPoint2(lineWidth,item.X);

            if (item.Type==0 || item.Type==1)
            {
                if (this.LineDotted) this.Canvas.setLineDash(this.LineDotted);   //虚线
                this.Canvas.beginPath();
                this.Canvas.moveTo(left,item.Top);
                this.Canvas.lineTo(left,item.Bottom);
                this.Canvas.stroke();
                if (this.LineDotted) this.Canvas.setLineDash([]);
            }
            else
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(left,item.Top);
                this.Canvas.lineTo(left,item.Bottom);
                this.Canvas.stroke();
            }

            var rtLine=new Rect(left-3,item.Top,10,item.Bottom-item.Top);
            this.DragRect[i]={ Rect:rtLine, PointIndex:item.PointIndex, Type:item.Type};
        }
    }

    this.PtInPaint=function(x,y)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.DragRect)) return null;

        for(var i=0;i<this.DragRect.length;++i)
        {
            var item=this.DragRect[i];
            var rtLine=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rtLine.X,rtLine.Y,rtLine.Width,rtLine.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                return { Index:i, PointIndex:item.PointIndex, Type:item.Type, Self:this, Type:item.Type };
            }
        }

        /*
        if (this.PreventClose && this.DragClientRect)
        {
            this.Canvas.beginPath();
            this.Canvas.rect(this.DragClientRect.Left,this.DragClientRect.Top,this.DragClientRect.Width, this.DragClientRect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                return { Index:-1, Type:3, Self:this };
            }
        }
        */

        return null;
    }

    this.DrawArea=function(startPoint, endPoint, startDate, startEnd, color, type)
    {
        if (!startDate || !startEnd || !this.StartDate || !this.EndDate) return;

        var aryArea;
        if (startPoint && endPoint) 
            aryArea=[startPoint, endPoint];
        else if (!startPoint && endPoint) 
            aryArea=[startDate, endPoint];
        else if (startPoint && !endPoint) 
            aryArea=[startPoint, startEnd];
        else if (startDate.Date>this.StartDate.Date && startEnd.Date<this.EndDate.Date)
            aryArea=[startDate,startEnd];

        if (aryArea && aryArea.length==2)
        {
            var start=aryArea[0],end=aryArea[1];
            var left=ToFixedPoint(start.X);
            var right=ToFixedPoint(end.X);
            var drawWidth=right-left;
            var drawHeight=start.Bottom-start.Top;
            this.Canvas.fillStyle=color;
            this.Canvas.fillRect(left, start.Top, drawWidth, drawHeight);

            var rtArea={ X:left, Y:start.Top, Right:right, Bottom:start.Top+drawHeight, Width:drawWidth, Height:drawHeight };

            if (IFrameSplitOperator.IsNumber(type)) this.DragRect.push( {Rect:rtArea, Type:type} );
        }
    }
}

//鼠标拖动选中区域
function RectDragPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='RectDragPaint';
    this.LineColor=g_JSChartResource.RectDrag.LineColor;          //竖线  
    this.LineWidth=g_JSChartResource.RectDrag.LineWidth;
    this.BGColor=g_JSChartResource.RectDrag.BGColor;
    this.ShowMode=0;    //0=只画边框 1=遮挡未选中区域 2=整体全选
    this.Enable=false;  

    this.FirstPoint;
    this.SecondPoint;

    this.IsClearCanvas=true;    //画布是否是清空状态

    //设置参数接口
    this.SetOption=function(option)
    {
        if (option)
        {
            if (option.LineColor) this.LineColor=option.LineColor;
            if (option.BGColor) this.BGColor=option.BGColor;
            if (IFrameSplitOperator.IsNumber(option.ShowMode)) this.ShowMode=option.ShowMode;
        }
    }

    this.ReloadResource=function(resource)
    {
        this.LineColor=g_JSChartResource.RectDrag.LineColor;     //竖线  
        this.LineWidth=g_JSChartResource.RectDrag.LineWidth; 
        this.BGColor=g_JSChartResource.RectDrag.BGColor;     //面积
    }

    this.ClearPoint=function()
    {
        this.FirstPoint=null;
        this.SecondPoint=null;

        if (!this.IsClearCanvas) this.Draw();
    }

    this.SetFirstPoint=function(x, y)
    {
        this.FirstPoint={ X:x, Y:y };
    }

    this.SetSecondPoint=function(x, y)
    {
        this.SecondPoint={ X:x, Y:y };
    }

    this.DrawSelectedBorderMode=function(rtSelect)
    {
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.strokeRect(ToFixedPoint(rtSelect.Left),ToFixedPoint(rtSelect.Top),ToFixedRect(rtSelect.Width),ToFixedRect(rtSelect.Height));
    }

    this.DrawUnselectedMaskMode=function(rtSelect, rtClient)
    {
        if (this.BGColor)
        {
            this.Canvas.save();

            var clipPath=new Path2D();
            clipPath.rect(rtClient.Left, rtClient.Top, rtClient.Width, rtSelect.Top-rtClient.Top);
    
            var leftPath=new Path2D();
            leftPath.rect(rtClient.Left,rtSelect.Top, rtSelect.Left-rtClient.Left, rtSelect.Height);
            clipPath.addPath(leftPath);
    
            var rightPath=new Path2D();
            rightPath.rect(rtSelect.Right,rtSelect.Top, rtClient.Right-rtSelect.Right, rtSelect.Height);
            clipPath.addPath(rightPath);
    
            var bottmPath=new Path2D();
            bottmPath.rect(rtClient.Left,rtSelect.Bottom, rtClient.Width, rtClient.Bottom-rtSelect.Bottom);
            clipPath.addPath(bottmPath);
    
            this.Canvas.clip(clipPath);
    
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtClient.Left,rtClient.Top,rtClient.Width,rtClient.Height);
    
            this.Canvas.restore();
        }
        
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.strokeRect(ToFixedPoint(rtSelect.Left),ToFixedPoint(rtSelect.Top),ToFixedRect(rtSelect.Width),ToFixedRect(rtSelect.Height));
    }

    this.DrawFullselectedMode=function(rtSelect, rtClient)
    {
        if (this.BGColor)
        {
            this.Canvas.save();

            var clipPath=new Path2D();
            clipPath.rect(rtClient.Left, rtClient.Top, rtSelect.Left-rtClient.Left, rtClient.Height);
    
            var rightPath=new Path2D();
            rightPath.rect(rtSelect.Right,rtClient.Top, rtClient.Right-rtSelect.Right, rtClient.Height);
            clipPath.addPath(rightPath);
    
            this.Canvas.clip(clipPath);
    
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtClient.Left,rtClient.Top,rtClient.Width,rtClient.Height);
    
            this.Canvas.restore();
        }

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.strokeRect(ToFixedPoint(rtSelect.Left),ToFixedPoint(rtClient.Top),ToFixedRect(rtSelect.Width),ToFixedRect(rtClient.Height));
    }

    this.Draw=function()
    {
        if (!this.Enable) return;
        if (!this.HQChart) return;

        var finder=this.HQChart.GetExtraCanvas(JSChart.RectDragCanvasKey);
        if (!finder) return;

        this.Canvas=finder.Canvas;
        this.HQChart.ClearCanvas(this.Canvas);
        this.IsClearCanvas=true;

        if (!this.FirstPoint && !this.SecondPoint) return;

        var top=this.ChartBorder.GetTop();
        var bottom=this.ChartBorder.GetBottom();
        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();

        var rtClient={Left:left, Top:top, Right:right, Bottom:bottom };
        rtClient.Width=rtClient.Right-rtClient.Left;
        rtClient.Height=rtClient.Bottom-rtClient.Top;

        var rtSelect=
        { 
            Left:Math.min(this.FirstPoint.X,this.SecondPoint.X), 
            Right:Math.max(this.FirstPoint.X,this.SecondPoint.X),
            Top:Math.min(this.FirstPoint.Y,this.SecondPoint.Y), 
            Bottom:Math.max(this.FirstPoint.Y,this.SecondPoint.Y)
        }

        if (rtSelect.Top<top) rtSelect.Top=top;
        else if (rtSelect.Top>bottom) rtSelect.Top=bottom;
        if (rtSelect.Bottom<top) rtSelect.Bottom=top;
        else if (rtSelect.Bottom>bottom) rtSelect.Bottom=bottom;

        if (rtSelect.Left<left) rtSelect.Left=left;
        else if (rtSelect.Left>right) rtSelect.Left=right;
        if (rtSelect.Right<left) rtSelect.Right=left;
        else if (rtSelect.Right>right) rtSelect.Right=right;

        rtSelect.Width=rtSelect.Right-rtSelect.Left;
        rtSelect.Height=rtSelect.Bottom-rtSelect.Top;

        switch(this.ShowMode)
        {
            case 1:
                this.DrawUnselectedMaskMode(rtSelect,rtClient);
                break;
            case 2:
                this.DrawFullselectedMode(rtSelect,rtClient);
                break;
            default:
                this.DrawSelectedBorderMode(rtSelect);
                break;
        }

        

        this.IsClearCanvas=false;
    }
}

//深度图 支持横屏
/*
    数据格式:
    [ 
        { 
            Data:[ {X,Y}, ],
            Type: 1=Up 2=Down 0=Default,
            LineColor:
            AreaColor:
            TextColor:
            Range:{X:{Max,Min:}, Y:{Max:,Min:} }
            Height:高度 百分比,
            Order:"ASC", //DESC=降序 ASC=升序
            IsShowCorssCursor:true/false;         //是否显示十字光标的提示信息
        },
    ]
*/

function DepthMapPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='DepthMapPaint';

    this.LineColor=g_JSChartResource.DepthMapPaint.LineColor;
    this.AreaColor=CloneData(g_JSChartResource.DepthMapPaint.AreaColor);
    this.TextColor=g_JSChartResource.DepthMapPaint.TextColor;
    this.TextBGColor=g_JSChartResource.DepthMapPaint.TextBGColor;

    //this.Width=200*GetDevicePixelRatio();
    this.FrameID=0;
    this.ID=Guid(); //唯一的ID

    this.IsDynamic=false;
    this.IsCallbackDraw=true;   //在回调函数里绘制, 不在Draw()中绘制

    this.YRange;    //Y值范围
    this.WidthRate=0.8; //最大使用宽度 0-1
    this.IsShow=true;

    /*
    this.Data=[
       { 
           Data: [ {X:100,Y:20}, {X:110,Y:30}, {X:120,Y:40},{X:130,Y:50} ],
           Type:1,
           Range:{ X:{Max:130, Min:100}, Y:{ Max:50, Min:0} },
           Height:0.5,
           LineColor:'rgba(255,106,106,0.6)',
           AreaColor:['rgba(255,106,106,0.5)','rgba(255,106,106,0.4)','rgba(255,106,106,0.3)','rgba(255,106,106,0.2)'],
           IsASC:false, //true=升序 false=降序
       },
       { 
            Data: [ {X:100,Y:20}, {X:110,Y:30}, {X:120,Y:40},{X:130,Y:50} ],
            Type:2,
            Range:{ X:{Max:130, Min:100}, Y:{ Max:50, Min:0} },
            Height:0.5,
            IsASC:true, //true=升序 false=降序
        },
        {
            Data:[ {X:11.60, Y:50}, {X:11.65, Y:80}, {X:11.68, Y:85},{X:11.70, Y:55}],
            Type:0,
            DrawType:0 , //0=面积 1=横线
            Range:{ Y:{ Max:100, Min:0} },

            LineColor:'rgba(255,165,0,0.6)',
            AreaColor:['rgba(255,165,0,0.5)','rgba(255,165,0,0.4)','rgba(255,165,0,0.3)','rgba(255,165,0,0.2)']
        }
    ];
    */

    this.SetOption=function(option) //设置
    {
        if (option.FrameID>0) this.FrameID=option.FrameID;
        if (IFrameSplitOperator.IsObjectExist(option.ID)) this.ID=option.ID;
        if (option.IsShowCorssCursor) this.IsShowCorssCursor=option.IsShowCorssCursor;
        if (IFrameSplitOperator.IsNumber(option.WidthRate)) this.WidthRate=option.WidthRate;
    }

    this.Draw=function()
    {
        if (!this.Data) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return;
        if (!this.ChartFrame || !this.ChartFrame.SubFrame || this.ChartFrame.SubFrame.length<=this.FrameID) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var frame=this.ChartFrame.SubFrame[this.FrameID].Frame;
        var chartBorder=frame.ChartBorder;

        var height=chartBorder.GetHeightEx();
        var left=chartBorder.GetRight();
        var top=chartBorder.GetTopEx();
        var bottom=chartBorder.GetBottomEx();
        var width=this.ChartBorder.Right*this.WidthRate;

        if (isHScreen)
        {
            left=chartBorder.GetBottom();
            top=chartBorder.GetRight();
            bottom=chartBorder.GetLeft();
            var width=this.Width;
            if (width>this.ChartBorder.Bottom) width=this.ChartBorder.Bottom;
        }

        var rtClient={ Left:left, Top:top, Right:left+width, Bottom:bottom, Height:height, Width:width };
        this.YRange={ Max:null, Min:0 };
        for(var i=0; i<this.Data.length; ++i)
        {
            var item=this.Data[i];
            this.CalculateYRange(item, this.YRange);
        }

        for(var i=0;i<this.Data.length;++i)
        {
            var item=this.Data[i];
            if (item.Height>0 && item.Height<=1) rtClient.Height=height*item.Height;
            else rtClient.Height=height;
            
            if (item.Type==1)
            {
                rtClient.Top=top;
                rtClient.Bottom=top+rtClient.Height;
                this.DrawUpArea(item,rtClient);
            }
            else if (item.Type==2)
            {
                rtClient.Bottom=bottom;
                rtClient.Top=rtClient.Bottom-rtClient.Height;
                this.DrawDownArea(item,rtClient);
            }
            else
            {
                rtClient.Top=top;
                rtClient.Bottom=bottom;
                this.DrawDefaultArea(item,rtClient);
            }
        }
    }

    this.CalculateYRange=function(drawData, yRange)
    {
        for(var i in drawData.Data)
        {
            var item=drawData.Data[i];
            if (yRange.Max==null || yRange.Max<item.Y) yRange.Max=item.Y;
            if (yRange.Min==null || yRange.Min>item.Y) yRange.Min=item.Y;
        }
    }


    this.GetXFromData=function(value, rtClient, minMax)    //获取X轴坐标
    {
        var width = rtClient.Width * (value - minMax.Min) / (minMax.Max - minMax.Min);
        return rtClient.Left + width;
    }

    this.GetYFromData=function(value, rtClient, minMax, isASC)
    {
        if (isASC)
        {
            var height = rtClient.Height * (value - minMax.Min) / (minMax.Max - minMax.Min);
            return rtClient.Bottom - height;
        }
        else
        {
            var height = rtClient.Height * (value - minMax.Min) / (minMax.Max - minMax.Min);
            return rtClient.Top + height;
        }
    }

    this.DrawDefaultArea=function(drawData, rtClient)
    {
        var frame=this.ChartFrame.SubFrame[this.FrameID].Frame;
        var yRange=(drawData.Range && drawData.Range.Y) ? drawData.Range.Y : this.YRange;

        var aryPoint=[];
        for(var i=0; i<drawData.Data.length; ++i)
        {
            var item=drawData.Data[i];
            var x=this.GetXFromData(item.Y,rtClient,yRange);
            if (item.X>frame.HorizontalMax || item.X<frame.HorizontalMin) continue;
            var y=frame.GetYFromData(item.X);

            aryPoint.push({X:x,Y:y});
        }

        var lineColor=drawData.LineColor? drawData.LineColor: this.LineColor;
        var areaColor=drawData.AreaColor? drawData.AreaColor: this.AreaColor;
        if (aryPoint.length>0) 
        {
            if (drawData.DrawType==1) this.DrawHLine(aryPoint,lineColor,rtClient);
            else this.DrawLine(aryPoint,lineColor, areaColor,rtClient);
        }
    }

    this.DrawUpArea=function(drawData,rtClient)
    {
        var aryPoint=[];
        for(var i in drawData.Data)
        {
            var item=drawData.Data[i];
            var x=this.GetXFromData(item.Y,rtClient,drawData.Range.Y);
            var y=this.GetYFromData(item.X,rtClient,drawData.Range.X,drawData.IsASC);

            aryPoint.push({X:x,Y:y});
        }

        var lineColor=drawData.LineColor? drawData.LineColor: this.LineColor;
        var areaColor=drawData.AreaColor? drawData.AreaColor: this.AreaColor;
        if (aryPoint.length>0) this.DrawLine(aryPoint,lineColor, areaColor,rtClient);
    }

    this.DrawDownArea=function(drawData,rtClient)
    {
        var aryPoint=[];
        for(var i in drawData.Data)
        {
            var item=drawData.Data[i];
            var x=this.GetXFromData(item.Y,rtClient,drawData.Range.Y);
            var y=this.GetYFromData(item.X,rtClient,drawData.Range.X,drawData.IsASC);

            aryPoint.push({X:x,Y:y});
        }

        var lineColor=drawData.LineColor? drawData.LineColor: this.LineColor;
        var areaColor=drawData.AreaColor? drawData.AreaColor: this.AreaColor;
        if (aryPoint.length>0) this.DrawLine(aryPoint,lineColor, areaColor,rtClient);
    }

    this.DrawHLine=function(aryPoint, lineColor, rtClient)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        this.Canvas.strokeStyle=lineColor;
        this.Canvas.beginPath();
        var drawCount=0;
        for(var i=0; i<aryPoint.length; ++i)
        {
            var item=aryPoint[i];
            if (isHScreen)
            {
                
               
            }
            else
            {
                this.Canvas.moveTo(rtClient.Left,item.Y);
                this.Canvas.lineTo(item.X,item.Y);
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();
    }
    
    this.DrawLine=function(aryPoint,lineColor, areaColor,rtClient)
    {
        var isHScreen=(this.ChartFrame.IsHScreen===true);
        var bFirstPoint=true;
        var drawCount=0;
        this.Canvas.strokeStyle=lineColor;
        
        for(var i in aryPoint)
        {
            var item=aryPoint[i];
            if (bFirstPoint)
            {
                this.Canvas.beginPath();
                if (isHScreen) this.Canvas.moveTo(item.Y,item.X);
                else this.Canvas.moveTo(item.X,item.Y);
                bFirstPoint=false;
            }
            else
            {
                if (isHScreen) this.Canvas.lineTo(item.Y,item.X);
                else this.Canvas.lineTo(item.X,item.Y);
            }

            ++drawCount;
        }

        if (drawCount>0) this.Canvas.stroke();

        //面积
        var firstPoint=aryPoint[0];
        var lastPoint=aryPoint[aryPoint.length-1];
        if (isHScreen)
        {
            this.Canvas.lineTo(lastPoint.Y,rtClient.Left);
            this.Canvas.lineTo(firstPoint.Y,rtClient.Left);
        }
        else
        {
            this.Canvas.lineTo(rtClient.Left,lastPoint.Y);
            this.Canvas.lineTo(rtClient.Left,firstPoint.Y);
        }
        this.Canvas.closePath();

        if (Array.isArray(areaColor))
        {
            if (isHScreen)
            {
                let gradient = this.Canvas.createLinearGradient(this.ChartBorder.GetRightEx(),this.ChartBorder.GetTop(), this.ChartBorder.GetLeft(),this.ChartBorder.GetTop());
                gradient.addColorStop(0, areaColor[0]);
                gradient.addColorStop(1, areaColor[1]);
                this.Canvas.fillStyle=gradient;
            }
            else
            {
                let gradient = this.Canvas.createLinearGradient(rtClient.Right,rtClient.Top, rtClient.Left,rtClient.Top);
                var offset=1/areaColor.length;
                for(var i=0; i<areaColor.length; ++i)
                {
                    gradient.addColorStop(i*offset, areaColor[i]);
                }
                this.Canvas.fillStyle=gradient;
            }
        }
        else
        {
            this.Canvas.fillStyle=areaColor;
        }
        
        this.Canvas.fill();
        
    }

    this.GetYValueByXValue=function(x,floatPrecision)
    {
        var aryXValue=[];
        var value=0;
        var zoom=ZOOM_VALUE[floatPrecision];
        for(var i=0; i<this.Data.length; ++i)
        {
            var item=this.Data[i];
            if (item.Type!=0 || !item.Data || item.Data.length<0 || item.IsShowCorssCursor==false) continue;

            var bFind=false;
            for(var j=0; j<item.Data.length; ++j)
            {
                var dataItem=item.Data[j];
                value=parseInt(dataItem.X*zoom);
                if (value==x) 
                {
                    bFind=true;
                    var findItem=
                    { 
                        X:dataItem.X, Y:dataItem.Y, 
                        TextColor:item.TextColor? item.TextColor: this.TextColor,
                        TextBGColor:item.TextBGColor? item.TextBGColor: this.TextBGColor  
                    };
                    if (dataItem.YText) findItem.YText=dataItem.YText;

                    aryXValue.push(findItem);
                    break;
                }
            }

            if (!bFind)
            {
                var first=item.Data[0];
                var last=item.Data[item.Data.length-1];
                if (x>first.X*zoom && x<last.X*zoom)
                {
                    aryXValue.push( 
                    { 
                        X:null, Y:null, 
                        TextColor:item.TextColor? item.TextColor: this.TextColor,
                        TextBGColor:item.TextBGColor? item.TextBGColor: this.TextBGColor  
                    } ); 
                }
            }
        }

        return aryXValue;
    }
}


// Y轴右侧背景颜色
function KLineYAxisBGPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='KLineYAxisBGPaint';

    this.SplitData=[];  //[ { Value: , Color:, TextColor: }, ]
    this.Font=g_JSChartResource.KLineYAxisBGPaint.Font; 
    
    this.FrameID=0;
    this.ID=Guid(); //唯一的ID

    this.IsDynamic=false;
    this.IsCallbackDraw=true;   //在回调函数里绘制, 不在Draw()中绘制
    this.IsShow=true;
    this.BGWidth=50;

    this.LineColor=g_JSChartResource.KLineYAxisBGPaint.LineColor;
    this.DiffValutTextColor=g_JSChartResource.KLineYAxisBGPaint.DiffValutTextColor;
    this.DiffValueBGColor=g_JSChartResource.KLineYAxisBGPaint.DiffValueBGColor;   //点差背景

    //临时内部变量
    this.KLineFrame;
    this.KLineData;
    this.Range={Max:null, Min:null };

    this.SetOption=function(option) //设置
    {
        if (option)
        {
            if (IFrameSplitOperator.IsNonEmptyArray(option.SplitData)) this.SplitData=option.SplitData;
        }
    }

    this.Draw=function()
    {
        if (!this.IsShow) return;

        if (!this.ChartFrame || !this.ChartFrame.SubFrame || this.ChartFrame.SubFrame.length<=this.FrameID) return;
        var kline=this.HQChart.ChartPaint[0];
        if (!kline) return;

        var isHScreen=(this.ChartFrame.IsHScreen===true);
        if (isHScreen) return;

        this.KLineFrame=this.ChartFrame.SubFrame[this.FrameID].Frame;
        var chartBorder=this.KLineFrame.ChartBorder;

        var dataWidth=this.KLineFrame.DataWidth;
        var distanceWidth=this.KLineFrame.DistanceWidth;
        var xPointCount=this.KLineFrame.XPointCount;
        var border=chartBorder.GetBorder();
        var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=border.RightEx;
        this.KLineData=kline.Data;

        //计算最大最小值
        var max=null, min=null;
        for(var i=this.KLineData.DataOffset,j=0;i<this.KLineData.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var data=this.KLineData.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;

            if (max==null || max<data.High) max=data.High;
            if (min==null || min>data.Low) min=data.Low;
        }

        if (!IFrameSplitOperator.IsNumber(max) || !IFrameSplitOperator.IsNumber(min)) return;

        this.Range.Max=max;
        this.Range.Min=min;

        this.DrawBackground();
    }

    this.DrawBackground=function()
    {
        var start=this.Range.Min;
        var border=this.KLineFrame.ChartBorder.GetBorder();
        var bottom=this.KLineFrame.GetYFromData(start,false);
        var left=border.Right;
        var right=left+this.BGWidth;
        
        this.Canvas.font=this.Font;
        this.Canvas.textBaseline = 'top';
        this.Canvas.textAlign = 'left';
        for(var i=0;i<this.SplitData.length;++i)
        {
            var item=this.SplitData[i];
            if (item.Value+start>this.KLineFrame.HorizontalMax)
                break;

           
            var top=this.KLineFrame.GetYFromData(start+item.Value, false);
            this.Canvas.fillStyle=item.Color;
            this.Canvas.fillRect(ToFixedRect(left),ToFixedRect(top),ToFixedRect(right-left),ToFixedRect(bottom-top));

            if (item.Text && item.TextColor)
            {
                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.fillText(item.Text,right+1,top);
            }

            bottom=top;

            //AuotRightWidth
        }

        //点位差
        var value=this.Range.Max-this.Range.Min;
        var floatPrecision=GetfloatPrecision(this.HQChart.Symbol);
        var text=value.toFixed(floatPrecision);
        
        var x=this.KLineFrame.GetYFromData(this.Range.Max,false);

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(left), ToFixedPoint(x));
        this.Canvas.lineTo(ToFixedPoint(right), ToFixedPoint(x));
        this.Canvas.stroke();

        var textWidth=this.Canvas.measureText(text).width+4;
        var textHeight=this.Canvas.measureText("擎").width+2;
        var rtBG={ Left: right+1, Top:x-textHeight, Width:textWidth, Height:textHeight };
        if (this.DiffValueBGColor)
        {
            this.Canvas.fillStyle=this.DiffValueBGColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
        }

        this.Canvas.textBaseline = 'bottom';
        this.Canvas.fillStyle=this.DiffValutTextColor;
        this.Canvas.fillText(text,rtBG.Left+1,x);
    }
}


//背景图 支持横屏
function BackgroundPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='BackgroundPaint';

    this.IsDynamic=false;
    this.IsCallbackDraw=true;   //在回调函数里绘制, 不在Draw()中绘制

    this.FrameID=0;
    this.Data;      //背景数据 { Start:, End:, Color:[] }
    this.ID=Guid(); //唯一的ID

    /*
    this.Data=
    [ 
        { Start:{ Date:20181201 }, End:{ Date:20181230 }, Color:'rgb(44,55,44)' } , 
        { Start:{ Date:20190308 }, End:{ Date:20190404 }, Color:['rgb(44,55,255)','rgb(200,55,255)'] } 
    ]
    */

    this.ChartSubFrame;
    this.ChartBorder;
    this.KData;
    this.Period;
    this.XPointCount=0;

    this.SetOption=function(option) //设置
    {
        if (option.FrameID>0) this.FrameID=option.FrameID;
        if (IFrameSplitOperator.IsObjectExist(option.ID)) this.ID=option.ID;
    }

    this.Draw=function()
    {
        if (!this.Data || !this.HQChart) return;
        if (!this.ChartFrame || !this.ChartFrame.SubFrame || this.ChartFrame.SubFrame.length<=this.FrameID) return;
        var klineChart=this.HQChart.ChartPaint[0];
        if (!klineChart || !klineChart.Data) return;

        this.ChartSubFrame=this.ChartFrame.SubFrame[this.FrameID].Frame;
        this.ChartBorder=this.ChartSubFrame.ChartBorder;
        this.KData=klineChart.Data;
        this.Period=this.HQChart.Period;
        if (!this.KData || this.KData.Data.length<=0) return;

        var isHScreen=(this.ChartSubFrame.IsHScreen===true);
        this.XPointCount=this.ChartSubFrame.XPointCount;
        var xPointCount=this.ChartSubFrame.XPointCount;
        
        var firstKItem=this.KData.Data[this.KData.DataOffset];
        var endIndex=this.KData.DataOffset+xPointCount-1;
        if (endIndex>=this.KData.Data.length) endIndex=this.KData.Data.length-1;
        var endKItem=this.KData.Data[endIndex];
        var showData=this.GetShowData(firstKItem,endKItem);
        if (!showData || showData.length<=0) return;

        var kLineMap=this.BuildKLineMap();
        var bottom=this.ChartBorder.GetBottomEx();
        var top=this.ChartBorder.GetTopEx();
        var height=this.ChartBorder.GetHeightEx();
        if (isHScreen)
        {
            top=this.ChartBorder.GetRightEx();
            bottom=this.ChartBorder.GetLeftEx();
            height=this.ChartBorder.GetWidthEx(); 
        }

        for(var i in showData)
        {
            var item=showData[i];
            var rt=this.GetBGCoordinate(item,kLineMap);
            if (!rt) continue;

            if (Array.isArray(item.Color))
            {
                var gradient;
                if (isHScreen) gradient = this.Canvas.createLinearGradient(bottom,rt.Left, top, rt.Left);
                else gradient = this.Canvas.createLinearGradient(rt.Left,top, rt.Left,bottom);
                var offset=1/item.Color.length;
                for(var i in item.Color)
                {
                    gradient.addColorStop(i*offset, item.Color[i]);
                }
                this.Canvas.fillStyle=gradient;
            }
            else
            {
                this.Canvas.fillStyle=item.Color;
            }

            if (isHScreen) this.Canvas.fillRect(ToFixedRect(bottom),ToFixedRect(rt.Left),ToFixedRect(height),ToFixedRect(rt.Width));
            else this.Canvas.fillRect(ToFixedRect(rt.Left),ToFixedRect(top),ToFixedRect(rt.Width),ToFixedRect(height));
        }
    }

    this.GetShowData=function(first, end)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return null;

        var aryData=[];
        for(var i=0;i<this.Data.length;++i)
        {
            var item=this.Data[i];
            var showItem={ };
            if (item.Start.Date>=first.Date && item.Start.Date<=end.Date) showItem.Start=item.Start;
            if (item.End.Date>=first.Date && item.End.Date<=end.Date) showItem.End=item.End;

            if (item.Start.Date<first.Date && item.End.Date>end.Date)
            {
                showItem.Start=first;
                showItem.End=end;
            }
                

            if (showItem.Start || showItem.End) 
            {
                showItem.Color=item.Color;
                aryData.push(showItem);
            }
        }

        //JSConsole.Chart.Log('[BackgroundPaint::GetShowData]  aryData ', aryData);
        return aryData;
    }

    this.BuildKLineMap=function()
    {
        var isHScreen=(this.ChartSubFrame.IsHScreen===true);
        var dataWidth=this.ChartSubFrame.DataWidth;
        var distanceWidth=this.ChartSubFrame.DistanceWidth;
        var xOffset=this.ChartBorder.GetLeft()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        if (isHScreen) xOffset=this.ChartBorder.GetTop()+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        var chartright=this.ChartBorder.GetRight();
        if (isHScreen) chartright=this.ChartBorder.GetBottom();

        var mapKLine={ Data:new Map() ,Start:null, End:null } ; //Key: date / date time, Value:索引
        for(var i=this.KData.DataOffset,j=0; i<this.KData.Data.length && j<this.XPointCount; ++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var kItem=this.KData.Data[i];
            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;

            if (j==0) mapKLine.XLeft=left;
            mapKLine.XRight=right;

            var value={ Index:i, ShowIndex:j , X:x, Right:right, Left:left, Date:kItem.Date };
            if (ChartData.IsMinutePeriod(this.Period,true))
            {
                var key=`Date:${kItem.Date} Time:${kItem.Time}`;
                value.Time=kItem.Time;
            }
            else
            {
                var key=`Date:${kItem.Date}`;
            }
               
            mapKLine.Data.set(key,value);

            //保存下起始和结束位置
            if (j==0) mapKLine.Start=value;
            mapKLine.End=value;
        }

        return mapKLine;
    }

    this.GetBGCoordinate=function(item,kLineMap)
    {
        var xLeft=null, xRight=null;
        var isMinutePeriod=ChartData.IsMinutePeriod(this.Period,true);
        var bSingleDate=false;
        //JSConsole.Chart.Log('[BackgroundPaint::GetBGCoordinate]  item ', item);
        if (isMinutePeriod)
        {
            if (item.Start && item.End && item.Start.Date==item.End.Date && item.Start.Time==item.End.Time) bSingleDate=true;
        }
        else
        {
            if (item.Start && item.End && item.Start.Date==item.End.Date) bSingleDate=true;
        }

        if (bSingleDate)
        {
            if (isMinutePeriod)
                var key=`Date:${item.Start.Date} Time:${item.Start.Time}`;
            else 
                var key=`Date:${item.Start.Date}`;

            if (!kLineMap.Data.has(key)) return null;
            var findItem=kLineMap.Data.get(key);
            xLeft=findItem.Left;
            xRight=findItem.Right;
            return { Left:xLeft, Right:xRight, Width:xRight-xLeft };
        }
        
        if (item.Start)
        {
            if (isMinutePeriod)
                var key=`Date:${item.Start.Date} Time:${item.Start.Time}`;
            else 
                var key=`Date:${item.Start.Date}`;

            if (kLineMap.Data.has(key)) 
            {
                var findItem=kLineMap.Data.get(key);
                xLeft=findItem.Left;
            }
            else 
            {
                if (isMinutePeriod)
                {
                    if (item.Start.Date<kLineMap.Start.Date || (item.Start.Date==kLineMap.Start.Date && item.Start.Time<=kLineMap.Start.Time) ) 
                    {
                        xLeft=kLineMap.Start.Left;
                    }
                    else
                    {
                        for(var kItem of kLineMap.Data)
                        {
                            var value=kItem[1];
                            if (value.Date>item.Start.Date || (value.Date==item.Start.Date && value.Time>item.Start.Time))
                            {
                                xLeft=value.Left;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    if (item.Start.Date<=kLineMap.Start.Date) 
                    {
                        xLeft=kLineMap.Start.Left;
                    }
                    else
                    {
                        for(var kItem of kLineMap.Data)
                        {
                            var value=kItem[1];
                            if (value.Date>item.Start.Date)
                            {
                                xLeft=value.Left;
                                break;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            xLeft=kLineMap.XLeft;
        }

        if (item.End)
        {
            if (isMinutePeriod)
                var key=`Date:${item.End.Date} Time:${item.End.Time}`;
            else 
                var key=`Date:${item.End.Date}`;

            if (kLineMap.Data.has(key))
            {
                var findItem=kLineMap.Data.get(key);
                xRight=findItem.Right;
            }
            else
            {
                if (isMinutePeriod)
                {
                    if (item.End.Date<kLineMap.Start.Date || (item.End.Date==kLineMap.Start.Date && item.End.Time<kLineMap.Start.Time)) return null;

                    if (item.End.Date<kLineMap.End.Date || (item.End.Date==kLineMap.End.Date && item.End.Time>=kLineMap.End.Time) ) 
                    {
                        xRight=kLineMap.End.Right;
                    }
                    else
                    {
                        var previousX=null;
                        for(var kItem of kLineMap.Data)
                        {
                            var value=kItem[1];
                            if (value.Date>item.End.Date || (value.Date==item.End.Date && value.Time>item.End.Time) )
                            {
                                xRight=previousX;
                                break;
                            }
                            previousX=value.Right;
                        }
                    }
                }
                else
                {
                    if (item.End.Date<kLineMap.Start.Date) return null;

                    if (item.End.Date<=kLineMap.End.Date) 
                    {
                        xRight=kLineMap.End.Right;
                    }
                    else
                    {
                        var previousX=null;
                        for(var kItem of kLineMap.Data)
                        {
                            var value=kItem[1];
                            if (value.Date>item.End.Date)
                            {
                                xRight=previousX;
                                break;
                            }
                            previousX=value.Right;
                        }
                    }
                }
            }
        }
        else
        {
            xRight=kLineMap.XRight;
        }

        if (xLeft==null || xRight==null) return null;

        return { Left:xLeft, Right:xRight, Width:xRight-xLeft };
    }
}

function MinuteBackgroundPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='MinuteBackgroundPaint';

    this.IsDynamic=true;
    this.IsCallbackDraw=false;   //在回调函数里绘制, 不在Draw()中绘制

    this.HQChart;
    this.Data;      //背景数据 { [Date:, Text:, TextColor:, Font:  }
    //this.Data=[ {Date:20210421, Text:"测试测试测试！！！！！"}];
    this.Font=g_JSChartResource.DefaultTextFont;
    this.TextColor=g_JSChartResource.DefaultTextColor;
    this.MerginTop=20;
    this.ID=Guid(); //唯一的ID
    this.FrameID=0;

    this.SetOption=function(option) //设置
    {
        if (!option) return;
        if (option.Font) this.Font=option.Font;
        if (IFrameSplitOperator.IsObjectExist(option.ID)) this.ID=option.ID;
        if (option.FrameID>0) this.FrameID=option.FrameID;
        if (option.MerginTop>0) this.MerginTop=option.MerginTop;
    }

    this.Draw=function()
    {
        if (!this.Data || !this.HQChart) return;
        if (!this.ChartFrame || !this.ChartFrame.SubFrame || this.ChartFrame.SubFrame.length<=this.FrameID) return;
        var subFrameItem=this.ChartFrame.SubFrame[this.FrameID];
        if (!subFrameItem || !subFrameItem.Frame) return;
        var subFrame=subFrameItem.Frame;
        var minuteData=this.HQChart.SourceData;
        if (!minuteData) return;


        var xPointCount=subFrame.XPointCount;
        var preDate=0;
        var range=null;
        var mapDate=new Map();
        for(var i=minuteData.DataOffset,j=0;i<minuteData.Data.length && j<xPointCount;++i,++j)
        {
            var item = minuteData.Data[i];
            if (!item) continue;

            if (item.Date!=preDate)
            {
                preDate=item.Date;
                if (!range)
                {
                    range={ Left:this.ChartFrame.GetXFromIndex(j) , Date: item.Date};
                }
                else
                {
                    range.Right=this.ChartFrame.GetXFromIndex(j-1);
                    mapDate.set(range.Date, range);
                    range={ Left:this.ChartFrame.GetXFromIndex(j) , Date: item.Date};
                }
            }
        }

        if (range && !range.Right)
        {
            range.Right=this.ChartFrame.GetXFromIndex(xPointCount-1);
            mapDate.set(range.Date, range);
        }

        this.Canvas.textAlign='center';
        this.Canvas.textBaseline='top';
        //this.Canvas.fillStyle=this.TextColor;
        //this.Canvas.font=this.Font;
        var yText=subFrame.ChartBorder.GetTopEx()+this.MerginTop;
        for(var i=0;i<this.Data.length;++i)
        {
            var item=this.Data[i];
            if (!mapDate.has(item.Date)) continue;

            var range=mapDate.get(item.Date);
            var xCenter=range.Left+(range.Right-range.Left)/2;

            if (item.Font) this.Canvas.font=item.Font;
            else this.Canvas.font=this.Font;
            if (item.TextColor) this.Canvas.fillStyle=item.TextColor;
            else this.Canvas.fillStyle=this.TextColor;

            this.Canvas.fillText(item.Text,xCenter,yText);
        }
    }
}

//拖拽效果图
var JSCHART_DRAGCHART_TYPE_ID=
{
    MAIN_KLINE:1,
    OVERLAY_KLINE:2,
    MAIN_INDEX:3,
    OVERLAY_INDEX:4,

    OVERLAY_MINUTE:5,       //叠加走势图
    MAIN_MINUTE:6,          //走势图
    MAIN_AVERAGE_MINUTE:7,  //均线
    MAIN_MINUTE_VOL:8       //成交量
};

function DragMovePaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='DragMovePaint';
    this.DrawAfterTitle=true;
    this.IsDynamic=true;
    this.Info;
    this.IsShow=false;
    this.Point;         //显示的点

    this.TextColor=g_JSChartResource.DragMovePaint.TextColor;
    this.Font=g_JSChartResource.DragMovePaint.Font;

    this.ReloadResource=function(resource)
    {
        this.TextColor=g_JSChartResource.DragMovePaint.TextColor;
        this.Font=g_JSChartResource.DragMovePaint.Font;
    }
   
    this.Clear=function()
    {
        this.Info=null;
        this.IsShow=false;
        this.Point=null;
    }

    this.Draw=function()
    {
        if (!this.Info || !this.IsShow || !this.Point) return;

        var text;
        var windowsIndex=this.Info.FrameID+1;
        if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.MAIN_KLINE)
        {
            text=`K线:${this.Info.Name}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_KLINE)
        {
            text=`叠加K线:${this.Info.Name}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.MAIN_INDEX)
        {
            text=`指标:${this.Info.IndexName}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_INDEX)
        {
            text=`叠加指标:${this.Info.IndexName}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_MINUTE)
        {
            text=`走势图, 叠加价格线:${this.Info.Name}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.MAIN_MINUTE)
        {
            text=`走势图, 价格线:${this.Info.Name}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.MAIN_AVERAGE_MINUTE)
        {
            text=`走势图, 均线:${this.Info.Name}, 窗口:${windowsIndex}`;
        }
        else if (this.Info.Type==JSCHART_DRAGCHART_TYPE_ID.MAIN_MINUTE_VOL)
        {
            text=`走势图, 成交量:${this.Info.Name}, 窗口:${windowsIndex}`;
        }
        
        if (text)
        {
            this.Canvas.font=this.Font;
            this.Canvas.fillStyle=this.TextColor;
            this.Canvas.textAlign = 'left';
            this.Canvas.textBaseline = 'bottom';
            this.Canvas.fillText(text,this.Point.X,this.Point.Y);
        }
    }
}


function SessionBreaksPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='SessionBreaksPaint';
    this.IsDynamic=false;
    this.IsCallbackDraw=true;   //在回调函数里绘制, 不在Draw()中绘制
    this.FrameID=0;
    this.KDataFeature;   //数据特征 { Symbol, Period, DataCount }
    this.Data;
    this.ChartFrame;

    this.BGColor=g_JSChartResource.SessionBreaksPaint.BGColor.slice();
    this.SplitLine=
    { 
        Color:g_JSChartResource.SessionBreaksPaint.SplitLine.Color, 
        Width:g_JSChartResource.SessionBreaksPaint.SplitLine.Width, 
        Dash:g_JSChartResource.SessionBreaksPaint.SplitLine.Dash
    };

    this.MapPeriod=new Map(
    [
        [0, { SplitType:1 }],   //日
        [1, { SplitType:1 }],   //周
        [2, { SplitType:2 }],   //月
        [21, { SplitType:2 }],  //双周

        [4, { SplitType:3 }],   //1分钟
        [5, { SplitType:3 }],   //5分钟
        [6, { SplitType:3 }],   //15分钟
        [7, { SplitType:3 }],
        [8, { SplitType:3 }],
    ]);   //周期和分割对应关系

    this.SetOption=function(option) //设置
    {
        if (option.FrameID>0) this.FrameID=option.FrameID;
    }

    this.Draw=function()
    {
        if (!this.HQChart) return;
        var hisData=this.HQChart.ChartOperator_Temp_GetHistroyData();;
        if (!hisData) return;  //数据还没有到达
        if (!IFrameSplitOperator.IsNonEmptyArray(hisData.Data)) return;

        if (this.IsKDataChange(hisData))
        {
            this.BuildCacheData(hisData);
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(this.Data)) return;

        var mainFrame=this.HQChart.Frame.SubFrame[0].Frame;
        var bHScreen=(this.ChartFrame.IsHScreen===true);
        var dataWidth=mainFrame.DataWidth;
        var distanceWidth=mainFrame.DistanceWidth;
        var xPointCount=mainFrame.XPointCount;

        if (bHScreen)
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var chartright=border.BottomEx;
            var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var preID=null;
        var aryBG=[];
        var bgItem=null;
        for(var i=hisData.DataOffset,j=0;i<hisData.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=this.Data[i];
            if (!item) continue;

            var left=xOffset;
            var right=xOffset+dataWidth;
            if (right>chartright) break;
            var x=left+(right-left)/2;

            var xStart=left-distanceWidth/2;
            var xEnd=right+distanceWidth/2;

            var id=item.ID;
            if (!IFrameSplitOperator.IsNumber(id)) continue;

            if (preID==null)
            {
                bgItem={ Start:{ X:xStart }, End:{ X:xEnd }, ColorIndex:id, Count:1, IsStart:false, IsEnd:false };
                preID=id;
                if (i-1>=0)
                {
                    var preItem=this.Data[i-1];
                    if (preItem && preItem.ID!=id) bgItem.IsStart=true;
                }
            }
            else if (preID!=id)
            {
                bgItem.End.X=xStart;
                bgItem.IsEnd=true;
                aryBG.push(bgItem);

                bgItem={ Start:{ X:xStart }, End:{ X:xEnd }, ColorIndex:id, Count:1, IsStart:true, IsEnd:false };
                preID=id;
            }
            else
            {
                bgItem.End.X=xEnd;
                ++bgItem.Count;
            }
        }

        if (bgItem && bgItem.Count>=2) aryBG.push(bgItem);

        this.Canvas.save();
        this.DrawBG(aryBG);
        this.Canvas.restore();
    }

    this.DrawBG=function(aryBG)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryBG)) return;

        var bHScreen=(this.ChartFrame.IsHScreen===true);
        if (bHScreen) 
        {
            var border=this.ChartBorder.GetHScreenBorder();
            var top=border.RightEx;
            var bottom=border.Left;
            var height=bottom-top;
        }
        else 
        {
            var border=this.ChartBorder.GetBorder();
            var top=border.TopEx;
            var bottom=border.BottomEx;
            var height=bottom-top;
        }
        
       
        var bDrawSplitLine=false;
        if (this.SplitLine.Color) bDrawSplitLine=true;
        var lineCount=0;
        for(var i=0;i<aryBG.length;++i)
        {
            var item=aryBG[i];
            var xLeft=item.Start.X;
            var xRight=item.End.X;

            var index=item.ColorIndex%this.BGColor.length;
            var bgColor=this.BGColor[index];
            if (bgColor)
            {
                this.Canvas.fillStyle=bgColor;
                if (bHScreen)
                    this.Canvas.fillRect(ToFixedPoint(top),ToFixedPoint(xLeft),ToFixedRect(height),ToFixedRect(xRight-xLeft));
                else
                    this.Canvas.fillRect(ToFixedPoint(xLeft),ToFixedPoint(top),ToFixedRect(xRight-xLeft),ToFixedRect(height));
            }

            if (bDrawSplitLine && item.IsStart)
            {
                if (lineCount==0) this.Canvas.beginPath();
                if (bHScreen)
                {
                    this.Canvas.moveTo(top, ToFixedPoint(xLeft));
                    this.Canvas.lineTo(bottom, ToFixedPoint(xLeft));
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(xLeft), top);
                    this.Canvas.lineTo(ToFixedPoint(xLeft), bottom);
                }
                
                ++lineCount;
            }
        }

        if (bDrawSplitLine && lineCount>=1)
        {
            if (this.SplitLine.Width>=1) this.Canvas.linewidth=this.SplitLine.Width;
            if (this.SplitLine.Dash) this.Canvas.setLineDash(this.SplitLine.Dash);
            if (this.SplitLine.Color) this.Canvas.strokeStyle=this.SplitLine.Color;
    
            this.Canvas.stroke();
        }
    }

    this.IsKDataChange=function(hisData)
    {
        if (!this.KDataFeature) return true;

        if (this.KDataFeature.Symbol!=this.HQChart.Symbol) return true;
        if (this.KDataFeature.Period!=this.HQChart.Period) return true;
        if (this.KDataFeature.DataCount!=hisData.Data.length) return true;

        return false;
    }

    this.BuildCacheData=function(hisData)
    {
        var period=this.HQChart.Period;
        if (!this.MapPeriod.has(period))
        {
            this.Data=[];
            this.KDataFeature={ Symbol:this.HQChart.Symbol, Period:period, DataCount:hisData.Data.length };
            return;
        }

        var splitType=this.MapPeriod.get(period).SplitType;    //1=month 2=year 3=day 4=1hour

        var startDate=0;
        var index=-1;
        this.Data=[];
        for(var i=0;i<hisData.Data.length;++i)
        {
            var item=hisData.Data[i];
            switch(splitType)
            {
                case 1: //月
                    if (parseInt(item.Date/100)!=parseInt(startDate/100))
                    {
                        startDate=item.Date;
                        ++index;
                    }
                    this.Data.push({ ID:index, Date:item.Date });
                    break;
                case 2: //年
                    if (parseInt(item.Date/10000)!=parseInt(startDate/10000))
                    {
                        startDate=item.Date;
                        ++index;
                    }
                    this.Data.push({ ID:index, Date:item.Date });
                    break;
                case 3: //日
                    if (item.Date!=startDate)
                    {
                        startDate=item.Date;
                        ++index;
                    }
                    this.Data.push({ ID:index, Date:item.Date });
                    break;
            }
            
        }


        this.KDataFeature={ Symbol:this.HQChart.Symbol, Period:period, DataCount:hisData.Data.length };
    }
}

//窗口底部工具栏
function FrameButtomToolbarPaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='FrameButtomToolbarPaint';
    this.FrameID=-1;
    this.FrameGuid=null;
    this.IsDynamic=true;
    this.DrawAfterTitle=true;

    this.AryButton=[];      // { Title:, ID:, Data:数据, TooltipText:提示信息 }
    this.SelectedID=null;   // 选中按钮ID
    this.AryRectButton=[];

    this.BGColor=g_JSChartResource.FrameButtomToolbar.BGColor;
    this.BorderColor=g_JSChartResource.FrameButtomToolbar.BorderColor;
    this.ButtonConfig=CloneData(g_JSChartResource.FrameButtomToolbar.Button);
    /*
    {
        Font:{ Family:"微软雅黑" },
        TitleColor: 
        { 
            Selected:"rgb(255,255,255)", Default:"rgb(140,140,140)", MoveOn:"rgb(255,255,255)" 
        },
        BGColor: {  Selected:"rgb(234,85,4)", Default:"rgb(25,25,25)", MoveOn:"rgb(59,59,59)" },
        BorderColor:"rgb(60,60,60)",

        Mergin: { Left:5*GetDevicePixelRatio(), Right:5*GetDevicePixelRatio(), Top:4*GetDevicePixelRatio(), Bottom:2*GetDevicePixelRatio() }
    };
    */

    /*
    this.AryButton=
    [
        { Title:"MACD", ID:"A", TooltipText:"切换MACD指标", Data:{ IndexID:"MACD"}}, 
        { Title:"RSI", ID:"A1", TooltipText:"切换RSI指标", Data:{ IndexID:"RSI"} }, 
        { Title:"大狗棍法", ID:"B1" }, 
        { Title:"降龙掌", ID:"B3"}
    ];
    this.SelectedID="A1"
    */
    
    this.ReloadResource=function(resource)
    {
        this.BGColor=g_JSChartResource.FrameButtomToolbar.BGColor;
        this.BorderColor=g_JSChartResource.FrameButtomToolbar.BorderColor;

        this.ButtonConfig=CloneData(g_JSChartResource.FrameButtomToolbar.Button);
    }

    this.SetOption=function(option)
    {
        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.FrameID))  this.FrameID=option.FrameID;
            if (option.FrameGuid)  this.FrameGuid=option.FrameGuid;
            if (IFrameSplitOperator.IsNonEmptyArray(option.AryButton)) this.AryButton=option.AryButton.slice();
            if (option.SelectedID) this.SelectedID=option.SelectedID;
        }
    }

    //设置当前选中的菜单ID
    this.SetSelectedID=function(id)
    {
        this.SelectedID=id;
    }

    this.Draw=function(moveonPoint, mouseStatus)
    {
        this.AryRectButton=[];

        var frame=this.GetFrame();
        if (!frame) return;
        if (frame.IsHScreen) return;    //不支持横屏
        if (frame.IsMinSize) return;
        if (frame.ChartBorder.IsShowTitleOnly) return;

        var border=frame.ChartBorder.GetBorder();
        var rtBG={ Left:border.Left+1, Right:border.Right-1, Top:border.BottomEx+1, Bottom:border.Bottom-1 };
        rtBG.Width=rtBG.Right-rtBG.Left;
        rtBG.Height=rtBG.Bottom-rtBG.Top;
        if (rtBG.Height<10) return;

        if (this.BGColor)
        {
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
        }

        var font=this.GetTitleFont(rtBG.Height-this.ButtonConfig.Mergin.Top-this.ButtonConfig.Mergin.Bottom);
        var svgFont=this.GetSVGFont(rtBG.Height-this.ButtonConfig.Mergin.Top-this.ButtonConfig.Mergin.Bottom);
        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='center';
        this.Canvas.font=font;
        var xBotton=rtBG.Left;
        for(var i=0;i<this.AryButton.length;++i)
        {
            var item=this.AryButton[i];
            if (!item.Title && !(item.SVGButton && item.SVGButton.Symbol)) return;

            var textWidth=0;
            if (item.Title)
            {
                textWidth=this.Canvas.measureText(item.Title).width+2;
            }
            
            var svgButtonWidth=0;
            if (item.SVGButton && item.SVGButton.Symbol) 
            {
                svgButtonWidth=this.ButtonConfig.SVG.Size;
                if (textWidth>0) svgButtonWidth+=this.ButtonConfig.SVG.MerginLeft;
                
            }

            var buttonWidth=textWidth+svgButtonWidth+this.ButtonConfig.Mergin.Left+this.ButtonConfig.Mergin.Right;
            var rtButton={ Left:xBotton, Top:rtBG.Top, Bottom:rtBG.Bottom, Height:rtBG.Height, Width:buttonWidth };
            rtButton.Right=rtButton.Left+rtButton.Width;

            //鼠标是否在按钮上
            var bgColor=this.ButtonConfig.BGColor.Default;
            var titleColor=this.ButtonConfig.TitleColor.Default;
            if (moveonPoint && (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
            {
                bgColor=this.ButtonConfig.BGColor.MoveOn;
                titleColor=this.ButtonConfig.TitleColor.MoveOn;
                if (mouseStatus)
                    mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:item, Frame:frame, Point:{X:moveonPoint.X, Y:moveonPoint.Y}, ID:"TitleButton" };
            }

            if (this.SelectedID && this.SelectedID==item.ID)
            {
                bgColor=this.ButtonConfig.BGColor.Selected;
                titleColor=this.ButtonConfig.TitleColor.Selected;
            }
            

            if (bgColor)
            {
                this.Canvas.fillStyle=bgColor;
                this.Canvas.fillRect(rtButton.Left,rtButton.Top,rtButton.Width,rtButton.Height);
            }
            
            if (this.ButtonConfig.BorderColor)
            {
                this.Canvas.strokeStyle=this.ButtonConfig.BorderColor;
                this.Canvas.beginPath();
                this.Canvas.moveTo(ToFixedPoint(rtButton.Right),rtButton.Top);
                this.Canvas.lineTo(ToFixedPoint(rtButton.Right),rtButton.Bottom);
                this.Canvas.stroke();
            }

            if (item.Title)
            {
                this.Canvas.fillStyle=titleColor;
                var xText=rtButton.Left+(rtButton.Width-svgButtonWidth)/2;   //居中
                var yText=rtButton.Top+this.ButtonConfig.Mergin.Top+(rtButton.Height-this.ButtonConfig.Mergin.Top-this.ButtonConfig.Mergin.Bottom)/2;
                this.Canvas.fillText(item.Title,xText,yText);
            }
           

            var rtSVG=null;
            if (item.SVGButton && item.SVGButton.Symbol) 
            {
                this.Canvas.font=svgFont;
                this.Canvas.fillStyle=titleColor;
                var xText=rtButton.Right-this.ButtonConfig.SVG.Size/2-this.ButtonConfig.Mergin.Right;
                this.Canvas.fillText(item.SVGButton.Symbol,xText,yText);
                this.Canvas.font=font;

                rtSVG={Left:rtButton.Right-this.ButtonConfig.Mergin.Right-this.ButtonConfig.SVG.Size, Top:rtButton.Top, Width:this.ButtonConfig.SVG.Size, Height:this.ButtonConfig.SVG.Size};
                rtSVG.Right=rtSVG.Left+rtSVG.Width;
                rtSVG.Bottom=rtSVG.Top+rtSVG.Height;
            }

            //{ Rect:rtButton, ID:item.ID, Data:item, RectSVG:rtSVG }
            if (textWidth>0 && svgButtonWidth>0)
            {
                var rtText={ Left:rtButton.Left, Top:rtButton.Top, Bottom:rtButton.Bottom };
                rtText.Right=rtText.Left+textWidth+this.ButtonConfig.Mergin.Left+this.ButtonConfig.SVG.MerginLeft/2;
                var cacheItem={ Rect:rtText, ID:item.ID, Data:item, RectCell:rtButton, ButtonType:0 };  
                this.AryRectButton.push(cacheItem);

                var rtSVG={Left:rtText.Right, Right:rtButton.Right, Top:rtButton.Top, Bottom:rtButton.Bottom };
                var cacheItem={ Rect:rtSVG, ID:item.ID, Data:item, RectCell:rtButton, ButtonType:1 };  
                this.AryRectButton.push(cacheItem);
            }
            else
            {
                var cacheItem={ Rect:rtButton, ID:item.ID, Data:item, RectCell:rtButton };  //RectCell 全部的大小
                if (textWidth>0) cacheItem.ButtonType=0;
                else if (svgButtonWidth>0) cacheItem.ButtonType=1;
                this.AryRectButton.push(cacheItem);
            }
            
            

            xBotton+=buttonWidth+1;
        }

        if (this.BorderColor)
        {
            this.Canvas.strokeStyle=this.BorderColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(border.Left,ToFixedPoint(border.BottomEx));
            this.Canvas.lineTo(border.Right,ToFixedPoint(border.BottomEx));
            this.Canvas.stroke();
        }
    }

    this.GetFrame=function()
    {
        if (!this.ChartFrame) return null;
        if (this.FrameID>=0)
        {
            var subFrame=this.ChartFrame.SubFrame[this.FrameID];
            if (!subFrame || !subFrame.Frame) return null;
            
            return subFrame.Frame;
        }

        return null;
    }

    this.GetTitleFont=function(height)
    {
        var config=this.ButtonConfig.Font;
        var fontSize=height*GetDevicePixelRatio();
        if (IFrameSplitOperator.IsPlusNumber(config.Size)) fontSize=config.Size;
        
        var font=`${fontSize}px ${config.Family}`;
        return font;
    }

    this.GetSVGFont=function(height)
    {
        var config=this.ButtonConfig.SVG;
        var fontSize=height*GetDevicePixelRatio();
        if (IFrameSplitOperator.IsPlusNumber(config.Size)) fontSize=config.Size;
        var font=`${fontSize}px ${config.Family}`;
        return font;
    }

    this.PtInButtons=function(x,y)
    {
        for(var i=0;i<this.AryRectButton.length;++i)
        {
            var item=this.AryRectButton[i];
            var rect=item.Rect;
            if (x>rect.Left && x<rect.Right && y>rect.Top && y<rect.Bottom)
            {
                var frame=this.GetFrame();
                var result={ ID:item.Data.ID, Rect:rect, FrameID:this.FrameID, Frame:frame, Data:item.Data, ButtonType:item.ButtonType, RectCell:item.RectCell, };
                return result;
            }
        }

        return null;
    }
}



//弹幕数据 { X:X偏移, Y:Y偏移, Text:内容, Color:颜色 }
function BarrageList()
{
    this.PlayList=[];   //正在播放队列
    this.Cache=[];      //没有播放的弹幕数据
    this.MinLineHeight=40*GetDevicePixelRatio();
    this.Height;        //高度
    this.Step=1;

    //{Canves:画布, Right:右边坐标, Left:左边坐标, Font:默认字体 }
    this.GetPlayList=function(obj)
    {
        var canves=obj.Canves;
        var right=obj.Right;
        var left=obj.Left;
        var width=right-left;
        var isMoveStep=obj.IsMoveStep;

        var list=[];
        var yOffset=0;
        for(var i=0;i<this.PlayList.length;++i)
        {
            var ary=this.PlayList[i];
            var lineHeight=this.MinLineHeight;
            if (ary.Height>this.MinLineHeight) lineHeight=ary.Height;

            var bAddNewItem=true;  //是否需要加入新弹幕
            var bRemoveFirst=false; //是否删除第1个数据
            for(var j=0;j<ary.Data.length;++j)
            {
                var item=ary.Data[j];
                var playItem={ X:item.X, Y:yOffset, Text:item.Text, Color:item.Color, Height:lineHeight, Font:item.Font, Info:item.Info };
                list.push(playItem);

                if (!isMoveStep) continue;
                
                if(j==ary.Data.length-1 && this.Cache.length>0)    //最后一个数据了 判断是否需要增加弹幕
                {
                    bAddNewItem=false;
                    if (!item.TextWidth)
                    {
                        if (item.Font && item.Font.Name) canves.font=item.Font.Name;
                        else canves.font=obj.Font;
                        item.TextWidth=canves.measureText(playItem.Text+'擎擎').width;
                    }
                    
                    if (item.X>=item.TextWidth) 
                        bAddNewItem=true;
                }
                else if (j==0)
                {
                    bRemoveFirst=false;
                    if (!item.TextWidth)
                    {
                        if (item.Font && item.Font.Name) canves.font=item.Font.Name;
                        else canves.font=obj.Font;
                        item.TextWidth=canves.measureText(playItem.Text+'擎擎').width;
                    }

                    if (item.X>width+item.TextWidth) bRemoveFirst=true;
                }

                item.X+=this.Step;
            }

            if(isMoveStep && bAddNewItem && this.Cache.length>0)    //最后一个数据了 判断是否需要增加弹幕
            {
                var cacheItem=this.Cache.shift();
                var newItem={ X:0, Text:cacheItem.Text, Color:cacheItem.Color , Font:cacheItem.Font, Info:cacheItem.Info };
                ary.Data.push(newItem);
            }

            if (isMoveStep && bRemoveFirst && ary.Data.length>0)
            {
                var removeItem=ary.Data.shift();
                this.OnItemPlayEnd(obj.HQChart,removeItem);
            }

            yOffset+=lineHeight;
        }

        return list;
    }

    //根据高度计算播放队列个数
    this.CacluatePlayLine=function(height)
    {
        this.Height=height;
        var lineCount=parseInt(height/this.MinLineHeight);
        if (this.PlayList.length<lineCount)
        {
            var addCount=lineCount-this.PlayList.length;
            for(var i=0;i<addCount;++i)
            {
                this.PlayList.push({Data:[]});
            }
        }
        else if (this.PlayList.length>lineCount)
        {
            var removeCount=this.PlayList.length-lineCount;
            for(var i=0;i<removeCount;++i)
            {
                var ary=this.PlayList.pop();
                for(var j=0;j<ary.Data.length;++j)
                {
                    var item=ary.Data[j];
                    var cacheItem={ Text:item.Text, Color:item.Color, Font:item.Font, Info:item.Info };
                    this.Cache.unshift(cacheItem);
                }
            }
        }

        JSConsole.Chart.Log(`[BarrageList::CacluatePlayLine] LineCount=${this.PlayList.length} Height=${this.Height}` )
    }

    //添加弹幕
    this.AddBarrage=function(barrageData)
    {
        for(var i in barrageData)
        {
            var item=barrageData[i];
            this.Cache.push(item);
        }
    }

    this.OnItemPlayEnd=function(hqChart, item)  //单挑弹幕播放完毕
    {
        //监听事件
        if (!hqChart.mapEvent.has(JSCHART_EVENT_ID.BARRAGE_PLAY_END)) return;
        var event=hqChart.mapEvent.get(JSCHART_EVENT_ID.BARRAGE_PLAY_END);
        if (!event.Callback) return;

        event.Callback(event,item,this);
    }

    this.Count=function() { return this.Cache.length; } //未播放的弹幕个数
}

//弹幕
function BarragePaint()
{
    this.newMethod=IExtendChartPainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='BarragePaint';
    this.IsAnimation=true;
    this.IsEraseBG=true;
    this.HQChart;

    this.Font=g_JSChartResource.Barrage.Font;
    this.TextColor=g_JSChartResource.Barrage.Color;
    this.FontHeight=g_JSChartResource.Barrage.Height;

    this.BarrageList=new BarrageList();  //字幕列表
    this.IsMoveStep=false;


    //设置参数接口
    this.SetOption=function(option)
    {
        if (option)
        {
            if (option.Step>0) this.BarrageList.Step=option.Step;
            if (option.MinLineHeight) this.Barrage.MinLineHeight=option.MinLineHeight;
        }
    }

    this.DrawHScreen=function()
    {
        var height=this.ChartBorder.GetWidth();
        var left=this.ChartBorder.GetTop();
        var right=this.ChartBorder.GetBottom();
        var top=this.ChartBorder.GetRightEx();
        var wdith=this.ChartBorder.GetChartWidth();

        if (height!=this.BarrageList.Height)
            this.BarrageList.CacluatePlayLine(height);

        this.Canvas.textBaseline="middle";
        this.Canvas.textAlign="left";

        var play=this.BarrageList.GetPlayList({Canves:this.Canvas, Right:right, Left:left, Font:this.Font, IsMoveStep:this.IsMoveStep, HQChart:this.HQChart});
        this.IsMoveStep=false;
        if (!play) return;

        this.Canvas.save(); 
        this.Canvas.translate(this.ChartBorder.GetChartHeight(), 0);
        this.Canvas.rotate(90 * Math.PI / 180);

        for(var i=0;i<play.length;++i)
        {
            var item=play[i];
            if (item.Color) this.Canvas.fillStyle=item.Color;
            else this.Canvas.fillStyle=this.TextColor;
            if (item.Font) this.Canvas.font=item.Font.Name;
            else this.Canvas.font=this.Font;

            var fontHeight=this.FontHeight;
            if (item.Font && item.Font.Height>0) fontHeight=item.Font.Height;
            var yOffset=item.Y+parseInt((item.Height-fontHeight)/2);

            this.Canvas.fillText(item.Text, right-item.X,top+yOffset);
        }

        this.Canvas.restore();
    }

    this.Draw=function()
    {
        if (this.ChartFrame.IsHScreen)
        {
            this.DrawHScreen();
            return;
        }

        var left=this.ChartBorder.GetLeft();
        var right=this.ChartBorder.GetRight();
        var top=this.ChartBorder.GetTopEx();
        var height=this.ChartBorder.GetHeight();

        if (height!=this.BarrageList.Height)
            this.BarrageList.CacluatePlayLine(height);

        this.Canvas.textBaseline="middle";
        this.Canvas.textAlign="left";

        var play=this.BarrageList.GetPlayList({Canves:this.Canvas, Right:right, Left:left, Font:this.Font, IsMoveStep:this.IsMoveStep, HQChart:this.HQChart});
        this.IsMoveStep=false;
        if (!play) return;

        for(var i=0;i<play.length;++i)
        {
            var item=play[i];
            if (item.Color) this.Canvas.fillStyle=item.Color;
            else this.Canvas.fillStyle=this.TextColor;
            if (item.Font) this.Canvas.font=item.Font.Name;
            else this.Canvas.font=this.Font;

            var fontHeight=this.FontHeight;
            if (item.Font && item.Font.Height>0) fontHeight=item.Font.Height;
            var yOffset=item.Y+parseInt((item.Height-fontHeight)/2);

            this.Canvas.fillText(item.Text, right-item.X,top+yOffset);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//坐标分割
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
//Y轴自定义刻度类型ID
var JSCHART_CUSTOM_YCOORDINATE_ID=
{
    LATEST_VALUE_ID:0,      //最新价格刻度
    FIXED_VALUE_ID:1,       //固定价格刻度
    PAGE_LAST_PRICE_ID:2,   //当前屏最后一个K线收盘价刻度
    PAGE_DATA_INCREASE:3,   //当前屏数据涨幅
    PAGE_LAST_INDEX_VALUE_ID:4,   //指标前屏最后一个数据刻度
    PAGE_LAST_OVERLAY_INDEX_VALUE_ID:5,   //叠加指标前屏最后一个数据刻度

};

function IFrameSplitOperator()
{
    this.ChartBorder;                   //边框信息
    this.Frame;                         //框架信息
    this.FrameSplitData;                //坐标轴分割方法
    this.SplitCount=5;                  //刻度个数
    this.StringFormat=0;                //刻度字符串格式    2=原始格式
    this.IsShowLeftText=true;           //显示左边刻度 
    this.IsShowRightText=true;          //显示右边刻度
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.GetEventCallback;              //事件回调
    this.GetKLineChartCallback;         //获取K线图形

    //////////////////////
    // data.Min data.Max data.Interval data.Count
    //
    this.IntegerCoordinateSplit=function(data)
    {
        var splitItem=this.FrameSplitData.Find(data.Interval);
        if (!splitItem) return false;

        if (data.Interval==splitItem.FixInterval) return true;

        var fixMax=data.Max, fixMin=data.Min;

        var maxValue=data.Max/splitItem.FixInterval;
        var minValue=data.Min/splitItem.FixInterval;
        //调整到整数倍数,不能整除的 +1
        if (IFrameSplitOperator.IsFloat(maxValue)) fixMax=parseInt((maxValue+0.5).toFixed(0))*splitItem.FixInterval;
        if (IFrameSplitOperator.IsFloat(minValue)) fixMin=parseInt((minValue-0.5).toFixed(0))*splitItem.FixInterval;

        if (data.Min==0) fixMin=0;  //最小值是0 不用调整了.
        if (fixMin<0 && data.Min>0) fixMin=0;   //都是正数的, 最小值最小调整为0

        var count=0;
        for(var i=fixMin;(i-fixMax)<0.00000001;i+=splitItem.FixInterval)
        {
            ++count;
        }

        data.Interval=splitItem.FixInterval;
        data.Max=fixMax;
        data.Min=fixMin;
        data.Count=count;

        return true;
    }

    this.Filter=function(aryInfo, keepZero, filterType) 
    {
        if (this.SplitCount <= 0 || aryInfo.length <= 0 || aryInfo.length <= this.SplitCount) return aryInfo;

        //分割线比预设的多, 过掉一些
        var filter = parseInt(aryInfo.length / this.SplitCount);
        if (filter <= 1) filter = 2;
        var data = [];
        if (filterType==1)
        {
            for (var i = 0; i < aryInfo.length; i += filter) 
            {
                data.push(aryInfo[i]);
            }
        }
        else
        {
            for (var i = 0; i < aryInfo.length; i += filter) 
            {
                if (i + filter >= aryInfo.length && i != aryInfo.length - 1) //最后一个数据放进去
                {
                    data.push(aryInfo[aryInfo.length - 1]);
                }
                else 
                {
                    data.push(aryInfo[i]);
                }
            }
        }
        

        if (this.SplitCount == 2 && data.length>2) //之显示第1个和最后一个刻度
        {
            for(var i=1;i<data.length-1;++i)
            {
                var item=data[i];
                item.Message[0]=null;
                item.Message[1]=null;
            }
        }

        if (keepZero)   //如果不存在0轴,增加一个0轴,刻度信息部显示
        {
            var bExsitZero=false;
            for(var i=0;i<data.length;++i)
            {
                var item=data[i];
                if (Math.abs(item.Value) < 0.00000001) 
                {
                    bExsitZero=true;
                    break;
                }
            }

            if (bExsitZero==false)
            {
                var zeroCoordinate = new CoordinateInfo();
                zeroCoordinate.Value = 0;
                zeroCoordinate.Message[0] = null
                zeroCoordinate.Message[1] = null;
                data.push(zeroCoordinate);
            }
        }

        return data;
    }

    this.RemoveZero=function(aryInfo)   //移除小数后面多余的0
    {
        //所有的数字小数点后面都0,才会去掉
        var isAllZero = [true, true, true, true];
        for (var i=0; i<aryInfo.length; ++i) 
        {
            var item = aryInfo[i];
            var message = item.Message[0];
            if (!this.IsDecimalZeroEnd(message)) isAllZero[0] = false;

            var message = item.Message[1];
            if (!this.IsDecimalZeroEnd(message)) isAllZero[1] = false;

            var message = item.Message[2];
            if (!this.IsDecimalZeroEnd(message)) isAllZero[2] = false;

            var message = item.Message[3];
            if (!this.IsDecimalZeroEnd(message)) isAllZero[3] = false;
        }

        if (isAllZero[0] == false && isAllZero[1] == false && isAllZero[2]==false && isAllZero[3]==false) return;
        for (var i=0; i<aryInfo.length; ++i) 
        {
            var item = aryInfo[i];
            if (isAllZero[0]) 
            {
                var message = item.Message[0];
                if (message!=null)
                {
                    if (typeof (message) == 'number') message = message.toString();
                    item.Message[0] = message.replace(/[.][0]+/g, '');
                }
            }

            if (isAllZero[1])
            {
                var message = item.Message[1];
                if (message!=null)
                {
                    if (typeof (message) == 'number') message = message.toString();
                    item.Message[1] = message.replace(/[.][0]+/g, '');
                }
            }

            if (isAllZero[2])
            {
                var message = item.Message[2];
                if (message!=null)
                {
                    if (typeof (message) == 'number') message = message.toString();
                    item.Message[2] = message.replace(/[.][0]+/g, '');
                }
            }

            if (isAllZero[3])
            {
                var message = item.Message[3];
                if (message!=null)
                {
                    if (typeof (message) == 'number') message = message.toString();
                    item.Message[3] = message.replace(/[.][0]+/g, '');
                }
            }
        }
    }

    this.IsDecimalZeroEnd = function (text)   //是否是0结尾的小数
    {
        if (text==null) return true;
        if (typeof(text)=='number') text=text.toString();
        if (text=='0') return true;
        
        var pos = text.search(/[.]/);
        if (pos < 0) return false;

        for (var i = pos + 1; i < text.length; ++i) 
        {
            var char = text.charAt(i);
            if (char >= '1' && char <= '9') return false;
        }

        return true;
    }

    //当前屏K线起始和结束的信息
    this.GetKLinePageInfo=function()
    {
        if (!this.GetKLineChartCallback) return null;
        var chart=this.GetKLineChartCallback();
        if (!chart || !chart.Data || !(chart.Data.DataOffset>=0)) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(chart.Data.Data)) return null;

        var aryKData=chart.Data.Data;
        var startIndex=chart.Data.DataOffset;
        var endIndex=chart.Data.DataOffset+chart.ChartFrame.XPointCount-1;
        if (endIndex>=aryKData.length) endIndex=aryKData.length-1;

        var result= 
        { 
            Start:{ Item:aryKData[startIndex], Index:startIndex }, 
            End:{ Item:aryKData[endIndex], Index:endIndex }, 
            IsLast:endIndex==aryKData.length-1 
        };

        return result;
    }

    //当前屏最新指标数据
    this.CustomLatestIndexDataCoordinate=function(option)
    {
        var pageInfo=this.GetKLinePageInfo();   //获取当前屏信息
        if (!pageInfo) return;
        if (!this.HQChart) return;

        var event=null;
        if (this.GetEventCallback) 
            event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_INDEX_Y_LABEL);

        var endIndex=pageInfo.End.Index;
        var floatPrecision=2;
        if (IFrameSplitOperator.IsNumber(this.FloatPrecision)) floatPrecision=this.FloatPrecision;
        for(var i=0, j=0;i<this.HQChart.ChartPaint.length;++i)
        {
            var chart=this.HQChart.ChartPaint[i];
            if (!chart.ChartFrame) continue;
            if (!chart.GetItemData) continue;
            if (chart.ChartFrame.Identify==this.Frame.Identify || chart.ChartFrame==this.Frame)
            {
                var aryItem=chart.GetItemData( {Index:endIndex} );
                if (!IFrameSplitOperator.IsNonEmptyArray(aryItem)) continue;

                for(j=0; j<aryItem.length; ++j)
                {
                    var item=aryItem[j];

                    var info=new CoordinateInfo();
                    info.Type=1;
                    info.TextColor=g_JSChartResource.FrameLatestPrice.TextColor;
                    info.LineColor=item.Color;
                    info.LineType=-1;   //默认不画线
                    info.IsLast=pageInfo.IsLast;//是否是最后一个数据
                    if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;
        
                    info.Value=item.Value;
                    var text=IFrameSplitOperator.FormatValueString(item.Value, floatPrecision,this.LanguageID);

                    if (option.Position=='left') info.Message[0]=text;
                    else info.Message[1]=text;

                    if (!pageInfo.IsLast)
                    {
                        var config={};
                        if (!pageInfo.IsLast) config.EmptyBGColor=g_JSChartResource.FrameLatestPrice.EmptyBGColor;

                        info.ExtendData={ Custom:config };
                    }

                    if (event)
                    {
                        var sendData={ PreventDefault:false, Label:info, Data:item, IndexName:chart.IndexName, FrameID:this.Frame.Identify };
                        event.Callback(event,sendData,this);

                        if (sendData.PreventDefault) continue;
                    }
        
                    this.Frame.CustomHorizontalInfo.push(info);
                }
            }
        }
    }

    this.CustomLatestOverlayIndexDataCoordinate=function(option)
    {
    var pageInfo=this.GetKLinePageInfo();   //获取当前屏信息
    if (!pageInfo) return;
    if (!this.OverlayIndex) return;
    if (!IFrameSplitOperator.IsNonEmptyArray(this.OverlayIndex.ChartPaint)) return;

    var event=null;
    if (this.GetEventCallback) 
        event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_OVERLAY_INDEX_Y_LABEL);

    var endIndex=pageInfo.End.Index;
    var floatPrecision=2;
    if (IFrameSplitOperator.IsNumber(this.FloatPrecision)) floatPrecision=this.FloatPrecision;

    for(var i=0, j=0;i<this.OverlayIndex.ChartPaint.length;++i)
    {
        var chart=this.OverlayIndex.ChartPaint[i];
        if (!chart.ChartFrame) continue;
        if (!chart.GetItemData) continue;

        var aryItem=chart.GetItemData( {Index:endIndex} );
        if (!IFrameSplitOperator.IsNonEmptyArray(aryItem)) continue;
        for(j=0; j<aryItem.length; ++j)
        {
            var item=aryItem[j];
            var info=new CoordinateInfo();
            info.Type=1;
            info.TextColor=g_JSChartResource.FrameLatestPrice.TextColor;
            info.LineColor=item.Color;
            info.LineType=-1;           //默认不画线
            info.IsLast=pageInfo.IsLast;//是否是最后一个数据
            if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;

            info.Value=item.Value;
            var text=IFrameSplitOperator.FormatValueString(item.Value, floatPrecision,this.LanguageID);

            if (option.Position=='left') info.Message[0]=text;
            else info.Message[1]=text;

            if (!pageInfo.IsLast)
            {
                var config={};
                if (!pageInfo.IsLast) config.EmptyBGColor=g_JSChartResource.FrameLatestPrice.EmptyBGColor;

                info.ExtendData={ Custom:config };
            }

            if (event)
            {
                var sendData={ PreventDefault:false, Label:info, Data:item, IndexName:chart.IndexName, OverlayIdentify:this.OverlayIndex.Identify };
                event.Callback(event,sendData,this);

                if (sendData.PreventDefault) continue;
            }

            this.Frame.CustomHorizontalInfo.push(info);
        }
    }
    },

    //回调外部处理自定义Y轴刻度
    this.InvokeCustomYCoordinateCallback=function()
    {
        if (!this.GetEventCallback) return null;
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_CUSTOM_Y_COORDINATE);
        if (!event || !event.Callback) return null;

        var data={ ID:this.Frame.Identify, Frame:this.Frame, PreventDefault:false, Custom:this.Custom };
        if (this.OverlayIdentify) data.OverlayIdentify=this.OverlayIdentify;
        event.Callback(event,data,this);

        return data;
    }

    this.Reset=function()   //重置
    {

    }

    this.SetOption=function(option) { }

    //计算上下预留
    this.ReservedHeight=function(splitData)
    {
        if (!this.Frame) return;
        if (this.Frame.IsHScreen) return;   //横屏以后再搞

        var yReserved=this.Frame.HorizontalReserved;
        if (!yReserved) return;

        var reservedHeight=0;
        if (IFrameSplitOperator.IsPlusNumber(yReserved.Top)) reservedHeight+=yReserved.Top;
        if (IFrameSplitOperator.IsPlusNumber(yReserved.Bottom)) reservedHeight+=yReserved.Bottom;
        if (reservedHeight<=0) return;

        var border=this.Frame.GetBorder();
        var top=border.TopEx;
        var bottom=border.BottomEx;
        var srcHeight=bottom-top;
        if (srcHeight<reservedHeight) return;

        var max=splitData.Max;
        var min=splitData.Min;
        if (IFrameSplitOperator.IsPlusNumber(yReserved.Top)) top-=yReserved.Top;
        if (IFrameSplitOperator.IsPlusNumber(yReserved.Bottom)) bottom+=yReserved.Bottom;

        var value=(max-min)/(bottom-top);   //1个像素点对应的数值
        if (IFrameSplitOperator.IsPlusNumber(yReserved.Top))
        {
            var topValue=value*yReserved.Top;
            max+=topValue;
        }
        
        if (IFrameSplitOperator.IsPlusNumber(yReserved.Bottom))
        {
            var bottomValue=value*yReserved.Bottom;
            min-=bottomValue;
        }

        splitData.Max=max;
        splitData.Min=min;

        this.Frame.HorizontalMax=splitData.Max;
        this.Frame.HorizontalMin=splitData.Min;
    }
}

//字符串格式化 千分位分割
IFrameSplitOperator.FormatValueThousandsString=function(value,floatPrecision)
{
    if (value==null || isNaN(value))
    {
        if (floatPrecision>0)
        {
            var nullText='-.';
            for(var i=0;i<floatPrecision;++i)
                nullText+='-';
            return nullText;
        }

        return '--';
    }

    var result='';
    var num=value.toFixed(floatPrecision);
    if(floatPrecision>0){
        var numFloat = num.split('.')[1];
        var numM = num.split('.')[0];
        while (numM.length > 3)
        {
            result = ',' + numM.slice(-3) + result;
            numM = numM.slice(0, numM.length - 3);
        }
        if (numM) { result = numM + result + '.' + numFloat; }
    }else{
        while (num.length > 3)
        {
            result = ',' + num.slice(-3) + result;
            num = num.slice(0, num.length - 3);
        }
        if (num) { result = num + result; }
    }
    
    return result;
}

//数据输出格式化 floatPrecision=小数位数
IFrameSplitOperator.FormatValueString=function(value, floatPrecision,languageID)
{
    /*
    if (value==null || isNaN(value))
    {
        if (floatPrecision>0)
        {
            var nullText='-.';
            for(var i=0;i<floatPrecision;++i)
                nullText+='-';
            return nullText;
        }

        return '--';
    }

    if (value<0.00000000001 && value>-0.00000000001)
    {
        return "0";
    }

    var absValue = Math.abs(value);
    if (languageID===JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID)
    {
        if (absValue < 10000)
            return value.toFixed(floatPrecision);
        else if (absValue < 1000000)
            return (value/1000).toFixed(floatPrecision)+"K";
        else if (absValue < 1000000000)
            return (value/1000000).toFixed(floatPrecision)+"M";
        else if (absValue < 1000000000000)
            return (value/1000000000).toFixed(floatPrecision)+"B";
        else 
            return (value/1000000000000).toFixed(floatPrecision)+"T";
    }
    else if (languageID===JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID)  //繁体
    {
        if (absValue < 10000)
            return value.toFixed(floatPrecision);
        else if (absValue < 100000000)
            return (value/10000).toFixed(floatPrecision)+"萬";
        else if (absValue < 1000000000000)
            return (value/100000000).toFixed(floatPrecision)+"億";
        else
            return (value/1000000000000).toFixed(floatPrecision)+"萬億";
    }
    else
    {
        if (absValue < 10000)
            return value.toFixed(floatPrecision);
        else if (absValue<1000000)
            return (value/10000).toFixed(floatPrecision)+"万";
        else if (absValue < 100000000)
            return (value/10000).toFixed(floatPrecision)+"万";
        else if (absValue < 1000000000000)
            return (value/100000000).toFixed(floatPrecision)+"亿";
        else
            return (value/1000000000000).toFixed(floatPrecision)+"万亿";
    }
    */
    

    return IFrameSplitOperator.FormatValueStringV2(value, floatPrecision, floatPrecision, languageID);
}

//数据输出格式化 floatPrecision=原始小数位数 floatPrecision2=转换成'万','亿'..的小数位
IFrameSplitOperator.FormatValueStringV2=function(value, floatPrecision, floatPrecision2, languageID)
{
    if (value==null || isNaN(value))
    {
        if (floatPrecision>0)
        {
            var nullText='-.';
            for(var i=0;i<floatPrecision;++i)
                nullText+='-';
            return nullText;
        }

        return '--';
    }

    if (value<0.00000000001 && value>-0.00000000001)
    {
        return "0";
    }

    var absValue = Math.abs(value);
    if (languageID===JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID)
    {
        if (absValue < 10000)
            return value.toFixed(floatPrecision);
        else if (absValue < 1000000)
            return (value/1000).toFixed(floatPrecision2)+"K";
        else if (absValue < 1000000000)
            return (value/1000000).toFixed(floatPrecision2)+"M";
        else if (absValue < 1000000000000)
            return (value/1000000000).toFixed(floatPrecision2)+"B";
        else 
            return (value/1000000000000).toFixed(floatPrecision2)+"T";
    }
    else if (languageID===JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID)  //繁体
    {
        if (absValue < 10000)
            return value.toFixed(floatPrecision);
        else if (absValue < 100000000)
            return (value/10000).toFixed(floatPrecision2)+"萬";
        else if (absValue < 1000000000000)
            return (value/100000000).toFixed(floatPrecision2)+"億";
        else
            return (value/1000000000000).toFixed(floatPrecision2)+"萬億";
    }
    else
    {
        if (absValue < 10000)
            return value.toFixed(floatPrecision);
        else if (absValue<1000000)
            return (value/10000).toFixed(floatPrecision2)+"万";
        else if (absValue < 100000000)
            return (value/10000).toFixed(floatPrecision2)+"万";
        else if (absValue < 1000000000000)
            return (value/100000000).toFixed(floatPrecision2)+"亿";
        else
            return (value/1000000000000).toFixed(floatPrecision2)+"万亿";
    }

    return '';
}


 //成交量显示
 IFrameSplitOperator.FormatVolString=function(value,languageID)
 {
     var absValue = Math.abs(value);
     if (absValue<100000) 
         return value.toFixed(0);
     else if (absValue<10000000)
         return (value/10000).toFixed(1)+"万";
     else if (absValue<100000000)
         return (value/10000).toFixed(0)+"万";
     else if (absValue<1000000000)
         return (value/100000000).toFixed(2)+"亿";
     else if (absValue < 1000000000000)
         return (value/100000000).toFixed(1)+"亿";
     else
         return (value/1000000000000).toFixed(1)+"万亿";
 }

//整形输出格式化 floatPrecision=小数位数
IFrameSplitOperator.FromatIntegerString=function(value, floatPrecision,languageID)
{
    if (value<10000 && IFrameSplitOperator.IsInteger(value)) floatPrecision=0;  //<10000的整形 去掉小数位数
    return IFrameSplitOperator.FormatValueString(value, floatPrecision,languageID);
}

IFrameSplitOperator.NumberToString=function(value)
{
    if (value<10) return '0'+value.toString();
    return value.toString();
}

//毫秒格式 固定3位, 不足前面自动补0 
IFrameSplitOperator.MillisecondToString=function(value)
{
    if (value<10) return '00'+value.toString();
    else if (value<100) return '0'+value.toString();
    else return value.toString();
}

IFrameSplitOperator.FormatDateString=function(value,format, languageID)
{
    var year=parseInt(value/10000);
    var month=parseInt(value/100)%100;
    var day=value%100;

    switch(format)
    {
        case 'MM-DD':
            return IFrameSplitOperator.NumberToString(month) + '-' + IFrameSplitOperator.NumberToString(day);
        case "MM/DD":
            return `${IFrameSplitOperator.NumberToString(month)}/${IFrameSplitOperator.NumberToString(day)}`;
        case "MM/DD/W":
            var date=new Date(year,month-1,day);
            var week=g_JSChartLocalization.GetText(WEEK_NAME[date.getDay()],languageID);
            return `${IFrameSplitOperator.NumberToString(month)}/${IFrameSplitOperator.NumberToString(day)}/${week}`;

        case "YYYY-MM":
            return `${year}-${IFrameSplitOperator.NumberToString(month)}`;
        case "YYYY/MM/DD":
            return year.toString() + '/' + IFrameSplitOperator.NumberToString(month) + '/' + IFrameSplitOperator.NumberToString(day);
        case "YYYY/MM/DD/W":
            {
                var date=new Date(year,month-1,day);
                var week=g_JSChartLocalization.GetText(WEEK_NAME[date.getDay()],languageID);
                return year.toString() + '/' + IFrameSplitOperator.NumberToString(month) + '/' + IFrameSplitOperator.NumberToString(day)+"/"+ week.toString();
            }
        case "DD/MM/YYYY":
            return IFrameSplitOperator.NumberToString(day) + '/' + IFrameSplitOperator.NumberToString(month) + '/' + year.toString();
        default:    //YYYY-MM-DD
            return year.toString() + '-' + IFrameSplitOperator.NumberToString(month) + '-' + IFrameSplitOperator.NumberToString(day);
    }
}

IFrameSplitOperator.FormatTimeString=function(value, format)    //format hh:mm:ss
{
    if (format=='HH:MM:SS')
    {
        var hour=parseInt(value/10000);
        var minute=parseInt((value%10000)/100);
        var second=value%100;
        return IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute) + ':' + IFrameSplitOperator.NumberToString(second);
    }
    else if (format=="hh:mm")
    {
        var hour=parseInt(value/10000);
        var minute=parseInt((value%10000)/100);
        var second=value%100;
        return IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute);
    }
    else if (format=='HH:MM')
    {
        var hour=parseInt(value/100);
        var minute=value%100;
        return IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute);
    }
    else if (format=="HH:MM:SS.fff")
    {
        var millisecond=value%1000;
        var dateTime=parseInt(value/1000);

        var hour=parseInt(dateTime/10000);
        var minute=parseInt((dateTime%10000)/100);
        var second=dateTime%100;

        return `${IFrameSplitOperator.NumberToString(hour)}:${IFrameSplitOperator.NumberToString(minute)}:${IFrameSplitOperator.NumberToString(second)}.${IFrameSplitOperator.MillisecondToString(millisecond)}`;
    }
    else
    {
        if (value<10000)
        {
            var hour=parseInt(value/100);
            var minute=value%100;
            return IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute);
        }
        else
        {
            var hour=parseInt(value/10000);
            var minute=parseInt((value%10000)/100);
            var second=value%100;
            return IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute) + ':' + IFrameSplitOperator.NumberToString(second);
        }
    }
}

//报告格式化
IFrameSplitOperator.FormatReportDateString=function(value)
{
    var year=parseInt(value/10000);
    var month=parseInt(value/100)%100;
    var monthText;
    switch(month)
    {
        case 3:
            monthText="一季度报";
            break;
        case 6:
            monthText="半年报";
            break;
        case 9:
            monthText="三季度报";
            break;
        case 12:
            monthText="年报";
            break;
    }

    return year.toString()+ monthText;
}

IFrameSplitOperator.FormatDateTimeString=function(value,isShowDate,isShowTime)
{
    var aryValue=value.split(' ');
    if (aryValue.length<2) return "";
    var result="";

    if (isShowDate)
    {
        var date=parseInt(aryValue[0]);
        var year=parseInt(date/10000);
        var month=parseInt(date%10000/100);
        var day=date%100;
        var text=year.toString() +'-'+ (month<10? ('0'+month.toString()) :month.toString()) +'-'+ (day<10? ('0'+day.toString()):day.toString());
        result+=text;
    }

    if (isShowTime)
    {
        var time=parseInt(aryValue[1]);
        if (time<10000)
        {
            var minute=time%100;
            var hour=parseInt(time/100);
            var text=IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute);
            if (result.length>0) result+=" ";
            result+=text;
        }
        else
        {
            var hour=parseInt(time/10000);
            var minute=parseInt((time%10000)/100);
            var second=time%100;
            var text=IFrameSplitOperator.NumberToString(hour)+':'+ IFrameSplitOperator.NumberToString(minute) + ':' + IFrameSplitOperator.NumberToString(second);
            if (result.length>0) result+=" ";
            result+=text;
        }
    }
    
    return result;
}

//字段颜色格式化
IFrameSplitOperator.FormatValueColor = function (value, value2) 
{
    if (value != null && value2 == null)  //只传一个值的 就判断value正负
    {
        if (value == 0) return 'PriceNull';
        else if (value > 0) return 'PriceUp';
        else return 'PriceDown';
    }

    //2个数值对比 返回颜色
    if (value == null || value2 == null) return 'PriceNull';
    if (value == value2) return 'PriceNull';
    else if (value > value2) return 'PriceUp';
    else return 'PriceDown';
}

IFrameSplitOperator.IsNumber=function(value)
{
    if (value==null) return false;
    if (isNaN(value)) return false;

    return typeof(value)=='number';
}

//批量判断是否是数值类型
IFrameSplitOperator.IsNumberV2=function(...aryValue)
{
    if (!aryValue) return false;
    if (aryValue.length==0) return false;

    for(const value of aryValue)
    {
        if (value==null) return false;
        if (isNaN(value)) return false;
        if (typeof(value)!='number') return false;
    }
   
    return true;
}

//判断是否是正数
IFrameSplitOperator.IsPlusNumber=function(value)
{
    if (value==null) return false;
    if (isNaN(value)) return false;

    return value>0;
}

//是否是整形
IFrameSplitOperator.IsInteger=function(x) 
{
    return (typeof x === 'number') && (x % 1 === 0);
}

//判断字段是否存在
IFrameSplitOperator.IsObjectExist=function(obj)
{
    if (obj===undefined) return false;
    if (obj==null) return false;
    
    return true;
}

//是否时bool
IFrameSplitOperator.IsBool=function(value)
{
    if (value===true || value===false) return true;
    return false;
}

IFrameSplitOperator.IsString=function(value)
{
    var type=typeof(value);
    if (type=='string') return true;
    return false;
}

//是否是非空的数组
IFrameSplitOperator.IsNonEmptyArray=function(ary)
{
    if (!ary) return false;
    if (!Array.isArray(ary)) return false;

    return ary.length>0;
}

IFrameSplitOperator.IsFloat=function(value)
{
    if (value===undefined) return false;
    if (value==null) return false;
    if (isNaN(value)) return false;

    return value!=parseInt(value);
}

//是否有效
IFrameSplitOperator.IsVaild=function(value)
{
    if (isNaN(value)) return false;
    if (value==null) return false;
    if (value===undefined) return false;

    return true;
}

IFrameSplitOperator.IsUndefined=function(value)
{
    return value===undefined;
}

IFrameSplitOperator.RemoveZero=function(strValue)
{
    while(strValue.length>0)
    {
        var index=strValue.length-1;
        var ch=strValue[index];
        if (ch=="0")
        {
            strValue=strValue.substr(0,index);
        }
        else if (ch==".")
        {
            strValue=strValue.substr(0,index);
            break;
        }
        else
        {
            break;
        }
    }

    return strValue;
}

function FrameSplitKLinePriceY()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;
    this.CoordinateType=0;  //坐标类型 0=普通坐标  1=百分比坐标 (右边坐标刻度) 2=对数对标 3=等比坐标 4=等分坐标 5=黄金分割
    this.Symbol;
    this.Data;              //K线数据 (计算百分比坐标)
    this.FrameSplitData2;                //坐标轴分割方法(计算百分比刻度)
    this.FloatPrecision=null;   //小数位数 (设置了就使用这个位数,否则使用品种对应的小数位数)

    this.Period;            //周期
    this.KLineChart;
    this.Custom=[]; //[{Type:0}];   定制刻度 0=显示最后的价格刻度
    this.SplitType=0;       //0=自动分割  1=固定分割 2=分笔图价格分割
    this.DefaultSplitType=0;

    this.DefaultYMaxMin;    //{ Max:null, Min:null };    //指定最大,最小, Y轴范围必须比最大值大， 比最小值小
    this.FixedYMaxMin;      //{ Max, Min} 固定Y轴最大最小值
    this.EnableZoomUpDown=false;    //上下左右拖拽
    this.LastMaxMin;        //当前显示的最高最低范围

    this.PercentageTextFormat=0;    //0=显示第1行  1=显示2行 2=单行格式: 价格/百分比

    this.IsEnableDragY=function()
    {
        return this.CoordinateType==0 || this.CoordinateType==1;
    }

    this.Operator=function()
    {
        var splitData={};
        splitData.Max=this.Frame.HorizontalMax;
        splitData.Min=this.Frame.HorizontalMin;
        splitData.Count=this.SplitCount;
        if (this.Frame.YMaxMin) //原始的数据范围
        {
            var item=this.Frame.YMaxMin;
            if (IFrameSplitOperator.IsNumber(item.Max) && IFrameSplitOperator.IsNumber(item.Min))
            {
                splitData.Max=item.Max;
                splitData.Min=item.Min;
            }
        }

        if (splitData.Max==splitData.Min)   //如果一样上下扩大下
		{
			splitData.Max+=splitData.Max*0.01;
			splitData.Min-=splitData.Min*0.01
		}

        var isFixedMaxMin=(this.FixedYMaxMin && IFrameSplitOperator.IsNumber(this.FixedYMaxMin.Max) && IFrameSplitOperator.IsNumber(this.FixedYMaxMin.Min));
        if (isFixedMaxMin)
        {
            splitData.Max=this.FixedYMaxMin.Max;
            splitData.Min=this.FixedYMaxMin.Min;
            //JSConsole.Chart.Log(`[FrameSplitKLinePriceY::Operator] FixedYMaxMin.Max=${this.FixedYMaxMin.Max} FixedYMaxMin.Min=${this.FixedYMaxMin.Min} `);
        }
        else if (this.DefaultYMaxMin)    //指定最小的Y轴范围
        {
            var range=this.DefaultYMaxMin;
            if (IFrameSplitOperator.IsNumber(range.Max))
            {
                if (splitData.Min>range.Max) splitData.Min=range.Max;
                else if (splitData.Max<range.Max) splitData.Max=range.Max;
            }

            if (IFrameSplitOperator.IsNumber(range.Min))
            {
                if (splitData.Max<range.Min) splitData.Max=range.Min;
                else if (splitData.Min>range.Min) splitData.Min=range.Min;
            }
        }

        splitData.Interval=(splitData.Max-splitData.Min)/(splitData.Count-1);
        var pixelTatio = GetDevicePixelRatio();             //获取设备的分辨率
        var width=this.Frame.ChartBorder.GetChartWidth();   //画布的宽度
        var isPhoneModel=width<450*pixelTatio;
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        if (isPhoneModel && MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol)) defaultfloatPrecision = 0;    //手机端指数不显示小数位数,太长了
        if (this.FloatPrecision!=null) defaultfloatPrecision=this.FloatPrecision;
        JSConsole.Chart.Log(`[FrameSplitKLinePriceY::Operator] Max=${splitData.Max} Min=${splitData.Min} Count=${splitData.Count} isPhoneModel=${isPhoneModel} defaultfloatPrecision=${defaultfloatPrecision} `);

        this.Frame.Logarithmic=null;
        this.Frame.MultiTextFormat=0;
        var bFilter=true;   //是否需要通过高度过滤刻度
        splitData.IsFixedMaxMin=isFixedMaxMin;
        splitData.IsFilter=bFilter;
        if (ChartData.IsTickPeriod(this.Period))
        {
            this.SplitTickData(splitData,defaultfloatPrecision);
            bFilter=splitData.IsFilter;
        }
        else if (FrameSplitKLinePriceY.SplitCustom)
        {
            FrameSplitKLinePriceY.SplitCustom(this,splitData,defaultfloatPrecision);    //自定义分割
            bFilter=false;
        }
        else
        {
            switch(this.CoordinateType)
            {
                case 1:
                    if (!this.SplitPercentage(splitData,defaultfloatPrecision,isFixedMaxMin))
                    {
                        this.SplitDefault(splitData,defaultfloatPrecision,isFixedMaxMin);
                    }
                    else
                    {
                        this.Frame.MultiTextFormat=this.PercentageTextFormat;
                        bFilter=false;
                    }
                    break;
                case 3: //等比坐标 +10%/-10% 涨幅分割
                    if (!this.SplitIncrease(splitData,defaultfloatPrecision))
                        this.SplitDefault(splitData,defaultfloatPrecision);
                    else
                        bFilter=false;
                    break;
                case 4: //等分坐标
                    this.SplitAverage(splitData,defaultfloatPrecision);
                    bFilter=false;
                    break;
                case 5: //黄金分割
                    this.SplitGoldenSection(splitData,defaultfloatPrecision);
                    bFilter=false;
                    break;
                case 2: //对数坐标
                    if (this.SplitLogarithmic(splitData,defaultfloatPrecision))
                    {
                        bFilter=false;
                    }
                    else
                    {
                        this.SplitDefault(splitData,defaultfloatPrecision);
                    }
                    break;
                default:
                    if (this.SplitType==1) 
                    {
                        this.SplitFixed(splitData,defaultfloatPrecision);
                        bFilter=false;
                    }
                    else if (this.SplitType==2)
                    {
                        this.SplitFixedV2(splitData,defaultfloatPrecision);
                        bFilter=false;
                    }
                    else 
                    {
                        this.SplitDefault(splitData,defaultfloatPrecision,isFixedMaxMin);
                    }
                    break;
            }
        }

        this.CustomCoordinate(defaultfloatPrecision);
        if (bFilter) this.Frame.HorizontalInfo = this.Filter(this.Frame.HorizontalInfo,false);
        this.Frame.HorizontalMax=splitData.Max;
        this.Frame.HorizontalMin=splitData.Min;

        if (this.EnableZoomUpDown==true && !this.FixedYMaxMin)
            this.FixedYMaxMin={ Max:splitData.Max, Min:splitData.Min };

        /*
        for(var i=0;i<this.Frame.HorizontalInfo.length;++i)
        {
            JSConsole.Chart.Log(`[FrameSplitKLinePriceY::Operator] ${i}=${this.Frame.HorizontalInfo[i].Message[0]}`);
        }
        */

        this.ReservedHeight(splitData); //预留高度
        
        JSConsole.Chart.Log(`[FrameSplitKLinePriceY::Operator] fixed . Max=${splitData.Max} Min=${splitData.Min} Count=${splitData.Count}`);

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SPLIT_YCOORDINATE);
            if (event && event.Callback)
            {
                var data={ID:this.Frame.Identify, Frame:this.Frame };
                event.Callback(event,data,this);
            }
        }
    }

    this.SplitTickData=function(splitData,floatPrecision)
    {
        switch(this.CoordinateType)
        {
            case 1: //百分比
                if (!this.SplitPercentage(splitData,floatPrecision,splitData.IsFixedMaxMin))
                {
                    this.SplitDefault(splitData,floatPrecision,splitData.IsFixedMaxMin);
                }
                else
                {
                    this.Frame.MultiTextFormat=this.PercentageTextFormat;
                    splitData.IsFilter=false;
                }
                break;
            default:
                if (this.SplitType==3) 
                {
                    this.SplitTickPrice(splitData,floatPrecision);
                }
                else 
                {
                    this.SplitDefault(splitData, floatPrecision, splitData.IsFixedMaxMin);
                }
        }
    }

    this.SplitTickPrice=function(splitData,floatPrecision)
    {
        var aryPrice=this.KLineChart.GetAllPrice();

        this.Frame.HorizontalInfo=[];
        for(var i in aryPrice)
        {
            var value=aryPrice[i];
            this.Frame.HorizontalInfo[i]= new CoordinateInfo();
            this.Frame.HorizontalInfo[i].Value=value;
            if (this.IsShowLeftText) this.Frame.HorizontalInfo[i].Message[0]=value.toFixed(floatPrecision);
            if (this.IsShowRightText) this.Frame.HorizontalInfo[i].Message[1]=value.toFixed(floatPrecision);
        }
    }

    this.SplitPercentage=function(splitData,floatPrecision,isFixedMaxMin)    //百分比坐标
    {
        var firstOpenPrice=this.GetFirstOpenPrice();
        if (!IFrameSplitOperator.IsNumber(firstOpenPrice)) return false;

        splitData.Max=(splitData.Max-firstOpenPrice)/firstOpenPrice;
        splitData.Min=(splitData.Min-firstOpenPrice)/firstOpenPrice;
        splitData.Interval=(splitData.Max-splitData.Min)/(splitData.Count-1);
        if (!isFixedMaxMin) this.IntegerCoordinateSplit2(splitData);

        var minValue=(1+splitData.Min)*firstOpenPrice;
        var maxValue=(1+splitData.Max)*firstOpenPrice;

        var textColor;
        if (g_JSChartResource.Frame && g_JSChartResource.Frame.PercentageText)
        {
            var item=g_JSChartResource.Frame.PercentageText;
            textColor={PriceColor:item.PriceColor, PercentageColor:item.PercentageColor, SplitColor:item.SplitColor, Font:item.Font };
        }   

        var aryHorizontal=[];
        for(var value=0;value<=splitData.Max; value+=splitData.Interval)
        {
            var price=(value+1)*firstOpenPrice;
            var item=new CoordinateInfo();
            item.Value=price;
            if (this.IsShowLeftText) item.Message[0]=price.toFixed(floatPrecision);     //左边价格坐标  
            
            if (this.IsShowRightText) 
            {
                var strPrice=price.toFixed(floatPrecision);
                var text=(value*100).toFixed(2);    //右边百分比
                text=IFrameSplitOperator.RemoveZero(text);
                text+='%';
                item.Message[1]=[text,strPrice];
                item.ExtendData=textColor;
            }
            aryHorizontal.push(item);
        }

        for(var value=-splitData.Interval;value>=splitData.Min;value-=splitData.Interval)
        {
            var price=(value+1)*firstOpenPrice;
            if (price<minValue || price>maxValue) continue;

            var item=new CoordinateInfo();
            item.Value=price;
            if (this.IsShowLeftText) item.Message[0]=price.toFixed(floatPrecision);   //左边价格坐标      
            if (this.IsShowRightText) 
            {
                var strPrice=price.toFixed(floatPrecision);
                var text=(value*100).toFixed(2);    //右边百分比
                text=IFrameSplitOperator.RemoveZero(text);
                text+='%';
                item.Message[1]=[text,strPrice];  
                item.ExtendData=textColor;
            }
            aryHorizontal.push(item);
        }

        aryHorizontal.sort((left, right)=> 
        {
            return left.Value - right.Value;
        });

        this.Frame.HorizontalInfo=aryHorizontal;

        splitData.Min=minValue; //最大最小值调整
        splitData.Max=maxValue;
        return true;
    }

    //等比坐标 当前屏最后第2根K线的收盘加为基准, 上下涨幅10%分割
    this.SplitIncrease=function(splitData,floatPrecision)    
    {
        var basePrice=this.GetLast2ndClose();
        if (!IFrameSplitOperator.IsNumber(basePrice)) return false;
        this.IntegerCoordinateSplit(splitData);
        this.Frame.HorizontalInfo=[];

        var increase=g_JSChartResource.FrameSplitIncrease.Increase;
        var aryHorizontal=[];
        for(var price=basePrice; price<splitData.Max; price=price*(1+increase))
        {
            var item= new CoordinateInfo();
            item.Value=price;
            var text=price.toFixed(floatPrecision);
            if (this.IsShowLeftText) item.Message[0]=text;  
            if (this.IsShowRightText) item.Message[1]=text;
            aryHorizontal.push(item);
        }

        for(var price=basePrice*0.9;price>splitData.Min; price=price*(1-increase))
        {
            var item= new CoordinateInfo();
            item.Value=price;
            var text=price.toFixed(floatPrecision);
            if (this.IsShowLeftText) item.Message[0]=text;  
            if (this.IsShowRightText) item.Message[1]=text;
            aryHorizontal.push(item);
        }

        this.Frame.HorizontalInfo=aryHorizontal;
        return true;
    }

    //等分坐标：以画面显示的最高价、最低价为基准，对这个区域N等分，显示分割的数值线
    this.SplitAverage=function(splitData,floatPrecision)
    {
        var max=splitData.Max;
        var min=splitData.Min;
        //this.IntegerCoordinateSplit(splitData);
        this.Frame.HorizontalInfo=[];
        var count=g_JSChartResource.FrameSplitAverage.Count;
        var interval=(max-min)/count;

        for(var i=0;i<=count;++i)
        {
            var item=new CoordinateInfo();
            item.Value=min+interval*i;
            var text=item.Value.toFixed(floatPrecision);
            if (this.IsShowLeftText)  item.Message[0]=text;
            if (this.IsShowRightText)   item.Message[1]=text;

            this.Frame.HorizontalInfo[i]=item;
        }
    }

    this.SplitGoldenSection=function(splitData,floatPrecision)
    {
        var max=splitData.Max;
        var min=splitData.Min;
        //this.IntegerCoordinateSplit(splitData);
        this.Frame.HorizontalInfo=[];

        var aryHorizontal=[];
        var GOLDEN_ARRAY=g_JSChartResource.FrameGoldenSection.Golden;
        for(var i in GOLDEN_ARRAY)
        {
            var value=(max-min)*GOLDEN_ARRAY[i]+min;
            item=new CoordinateInfo();
            item.Value=value;
            var text=value.toFixed(floatPrecision);
            if (this.IsShowLeftText)  item.Message[0]=text;
            if (this.IsShowRightText)   item.Message[1]=text;
            aryHorizontal.push(item);
        }

        this.Frame.HorizontalInfo=aryHorizontal;
    }

    this.SplitLogarithmic=function(splitData,floatPrecision) //对数坐标
    {
        var minInterval=g_JSChartResource.FrameLogarithmic.MinInterval;       //最小间距
        var firstOpenPrice=this.GetFirstOpenPrice();    //获取当前屏第1个K线的开盘价
        if (!IFrameSplitOperator.IsNumber(firstOpenPrice)) return false;
        var height=this.ChartBorder.GetHeightEx();

        var ARRAY_INCREASE=[0.01, 0.02, 0.04, 0.08, 0.1, 0.2];
        var increase=ARRAY_INCREASE[ARRAY_INCREASE.length-1];
        for(var i=0; i<ARRAY_INCREASE.length;++i)
        {
            var value=ARRAY_INCREASE[i];
            var interval=(firstOpenPrice*value)*(height/(splitData.Max-splitData.Min));
            if (interval>minInterval)
            {
                increase=value;
                break;
            }
        }

        var aryUp=[];
        var price=firstOpenPrice;
        var i=increase;
        do
        {
            var item={ Start:price };
            price=firstOpenPrice*(1+i);
            item.End=price;
            aryUp.push(item);

            i+=increase;
        } while(price<splitData.Max);
        var max=price;

        var aryDown=[];
        var price=firstOpenPrice;
        var i=increase;
        do
        {
            var item={ End:price };
            price=firstOpenPrice*(1-i);
            item.Start=price;
            aryDown.push(item);

            i+=increase;
        } while(price>splitData.Min);
        var min=price;

        splitData.Max=max;
        splitData.Min=min;
        
        JSConsole.Chart.Log("[FrameSplitKLinePriceY::SplitLogarithmic] up, down", aryUp, aryDown);

        this.Frame.HorizontalInfo=[];
        var item=new CoordinateInfo();
        item.Value=firstOpenPrice;
        item.Font=g_JSChartResource.FrameLogarithmic.OpenPriceFont;
        var strText=item.Value.toFixed(floatPrecision);
        if (this.IsShowLeftText) item.Message[0]=strText;     //左边价格坐标      
        if (this.IsShowRightText) item.Message[1]=strText;    //右边价格坐标 
        this.Frame.HorizontalInfo.push(item);

        for(var i in aryUp)
        {
            var item=new CoordinateInfo();
            item.Value=aryUp[i].End;
            var strText=item.Value.toFixed(floatPrecision);
            if (this.IsShowLeftText) item.Message[0]=strText;     //左边价格坐标      
            if (this.IsShowRightText) item.Message[1]=strText;    //右边价格坐标 
            this.Frame.HorizontalInfo.push(item);
        }

        for(var i in aryDown)
        {
            var item=new CoordinateInfo();
            item.Value=aryDown[i].End;
            var strText=item.Value.toFixed(floatPrecision);
            if (this.IsShowLeftText) item.Message[0]=strText;     //左边价格坐标      
            if (this.IsShowRightText) item.Message[1]=strText;    //右边价格坐标 
            this.Frame.HorizontalInfo.splice(0,0,item);
        }

        this.Frame.Logarithmic={ Up:aryUp, Down:aryDown, OpenPrice:firstOpenPrice };
        return true;
    }

    this.SplitDefault=function(splitData,floatPrecision,isFixedMaxMin)       //默认坐标
    {
        //固定最大最小值 不自动调整范围
        if (!isFixedMaxMin) this.IntegerCoordinateSplit(splitData);
       
        this.Frame.HorizontalInfo=[];
        for(var i=0,value=splitData.Min;i<splitData.Count;++i,value+=splitData.Interval)
        {
            this.Frame.HorizontalInfo[i]= new CoordinateInfo();
            this.Frame.HorizontalInfo[i].Value=value;
            if (this.IsShowLeftText)  this.Frame.HorizontalInfo[i].Message[0]=value.toFixed(floatPrecision);
            if (this.IsShowRightText)  this.Frame.HorizontalInfo[i].Message[1]=value.toFixed(floatPrecision);
        }
    }

    this.SplitFixed=function(splitData,floatPrecision)      //固定分割坐标
    {
        this.Frame.HorizontalInfo=[];
        for(var i=0,value=splitData.Min;i<splitData.Count;++i,value+=splitData.Interval)
        {
            this.Frame.HorizontalInfo[i]= new CoordinateInfo();
            this.Frame.HorizontalInfo[i].Value=value;
            if (this.IsShowLeftText)  this.Frame.HorizontalInfo[i].Message[0]=value.toFixed(floatPrecision);
            if (this.IsShowRightText)   this.Frame.HorizontalInfo[i].Message[1]=value.toFixed(floatPrecision);
        }
    }

    this.SplitFixedV2=function(splitData,floatPrecision)      //固定分割坐标
    {
        this.Frame.HorizontalInfo=[];
        for(var i=0,value=splitData.Min;i<splitData.Count;++i,value+=splitData.Interval)
        {
            this.Frame.HorizontalInfo[i]= new CoordinateInfo();
            this.Frame.HorizontalInfo[i].Value=value;
            if (this.IsShowLeftText)  this.Frame.HorizontalInfo[i].Message[0]=value.toFixed(floatPrecision);
            if (this.IsShowRightText)   this.Frame.HorizontalInfo[i].Message[1]=value.toFixed(floatPrecision);
        }

        if (!splitData.IsFixedMaxMin)   //缩放不需要调整大小
        {
            if (floatPrecision==0)
            {
                splitData.Max+=1;
                splitData.Min-=1;
            }
            else if (floatPrecision==1)
            {
                splitData.Max+=0.1;
                splitData.Min-=0.1;
            }
            else if (floatPrecision==2)
            {
                splitData.Max+=0.01;
                splitData.Min-=0.01;
            }
        }
    }

    this.CustomCoordinate=function(floatPrecision)
    {
        if (!IFrameSplitOperator.IsNumber(floatPrecision))
        {
            var pixelTatio = GetDevicePixelRatio();             //获取设备的分辨率
            var width=this.Frame.ChartBorder.GetChartWidth();   //画布的宽度
            var isPhoneModel=width<450*pixelTatio;
            floatPrecision=GetfloatPrecision(this.Symbol);
            if (isPhoneModel && MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol)) floatPrecision = 0;    //手机端指数不显示小数位数,太长了
            if (this.FloatPrecision!=null) floatPrecision=this.FloatPrecision;
        }

        this.Frame.CustomHorizontalInfo=[];

        var data=this.InvokeCustomYCoordinateCallback();
        if (data && data.PreventDefault==true) return;

        var lastCoordinate, pageLastCoordinate;
        for(var i=0; i<this.Custom.length; ++i)
        {
            var item=this.Custom[i];
            if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.LATEST_VALUE_ID || item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.PAGE_DATA_INCREASE || item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.PAGE_LAST_PRICE_ID)
            {
                var dec=floatPrecision;
                //外部设置小数位数
                if (IFrameSplitOperator.IsNumber(item.FloatPrecision) && item.FloatPrecision>=0) dec=item.FloatPrecision;
                var latestItem=this.GetLatestPrice(dec, item);
                if (latestItem) 
                {
                    if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.LATEST_VALUE_ID) 
                        lastCoordinate=latestItem;
                    else if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.PAGE_LAST_PRICE_ID) 
                        pageLastCoordinate=latestItem;
                    else 
                        this.Frame.CustomHorizontalInfo.push(latestItem);
                }
            }
            else if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.FIXED_VALUE_ID)   //固定刻度
            {
                this.CustomFixedCoordinate(item);
            }
            else if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.PAGE_LAST_INDEX_VALUE_ID)   //当前屏指标最后一个数据
            {
                this.CustomLatestIndexDataCoordinate(item);
            }
        }

        //当前页最后一个数据和最新数据刻度如果相同,只显示一个
        if (lastCoordinate || pageLastCoordinate)
        {
            if (lastCoordinate && pageLastCoordinate && pageLastCoordinate.IsLast===true)
            {
                this.Frame.CustomHorizontalInfo.unshift(lastCoordinate);
            }
            else
            {
                if (lastCoordinate) this.Frame.CustomHorizontalInfo.unshift(lastCoordinate);
                if (pageLastCoordinate) this.Frame.CustomHorizontalInfo.push(pageLastCoordinate);
            }
        }
        
    }

    

    this.GetLatestPrice=function(floatPrecision,option)
    {
        if (!this.Data || !this.Data.Data) return null;
        if (this.Data.Data.length<=0) return null;

        var latestItem=this.Data.Data[this.Data.Data.length-1];
        var isLast=true;
        if (option.Type==2) //当前屏最后的价格
        {
            var pageInfo=this.GetKLinePageInfo();
            if (pageInfo)
            {
                latestItem=pageInfo.End.Item;
                isLast=pageInfo.IsLast;
            }
        }
        
        var info=new CoordinateInfo();
        info.Type=0;
        if (option && IFrameSplitOperator.IsNumber(option.Type)) info.Type=option.Type;
        info.Value=latestItem.Close;
        info.TextColor=g_JSChartResource.FrameLatestPrice.TextColor;
        info.LineType=2;    //虚线
        var strPrice=latestItem.Close.toFixed(floatPrecision);

        //颜色
        if (latestItem.Close>latestItem.Open) info.LineColor=g_JSChartResource.FrameLatestPrice.UpBarColor;
        else if (latestItem.Close<latestItem.Open) info.LineColor=g_JSChartResource.FrameLatestPrice.DownBarColor;
        else info.LineColor=g_JSChartResource.FrameLatestPrice.UnchagneBarColor;

        if (option.Type==3)   //百分比显示
        {
            var pageInfo=this.GetKLinePageInfo();
            if (pageInfo)
            {
                if (IFrameSplitOperator.IsNumber(pageInfo.Start.Item.YClose))
                {
                    var value=(pageInfo.End.Item.Close-pageInfo.Start.Item.YClose)/pageInfo.Start.Item.YClose*100;
                    var strPrice=`${value.toFixed(2)}%`;

                    if (value>0) info.LineColor=g_JSChartResource.FrameLatestPrice.UpBarColor;
                    else if (value<0) info.LineColor=g_JSChartResource.FrameLatestPrice.DownBarColor;
                    else info.LineColor=g_JSChartResource.FrameLatestPrice.UnchagneBarColor;

                    info.Value=pageInfo.End.Item.Close;
                    isLast=pageInfo.IsLast;
                }
            }
        }

        if (option.DateTime=='HH:MM' && ChartData.IsMinutePeriod(this.Period,true))
        {
            var strTime=IFrameSplitOperator.FormatTimeString(latestItem.Time,option.DateTime);
            var aryText=[{Text:strPrice}, { Text:strTime} ];
            if (option.Position=='left') info.Message[0]=aryText;
            else info.Message[1]=aryText;
        }
        else if (IFrameSplitOperator.IsBool(option.CountDown))  //倒计时
        {
            var aryText=[ {Text:strPrice}, { Type:1 } ];
            if (option.Position=='left') info.Message[0]=aryText;
            else info.Message[1]=aryText;
        }
        else
        {
            if (option.Position=='left') info.Message[0]=strPrice
            else info.Message[1]=strPrice;
        }
        
        if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;
        if (IFrameSplitOperator.IsPlusNumber(option.LineWidth)) info.LineWidth=option.LineWidth;
        if (option.LineDash) info.LineDash=option.LineDash;
        if (option.IsShowLine==false) info.LineType=-1;
        info.IsLast=isLast;//是否是最后一个数据

        if (!isLast || option.PositionEx===1)
        {
            var config={};

            if (!isLast) config.EmptyBGColor=g_JSChartResource.FrameLatestPrice.EmptyBGColor;
            if (option.PositionEx===1) config.Position=1;   //强制画在内部

            info.ExtendData={ Custom:config };
        }

        return info;
    }

    this.GetFirstOpenPrice=function()   //获取显示第1个数据的开盘价
    {
        if (!this.Data) return null;

        var xPointCount=this.Frame.XPointCount;
        for(var i=this.Data.DataOffset,j=0;i<this.Data.Data.length && j<xPointCount;++i,++j)
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            if (ChartData.IsTickPeriod(this.Period)) 
                return data.YClose;
            else
                return data.Open;
        }

        return null;
    }

    this.GetLast2ndClose=function() //获取最后第2根K线收盘加
    {
        if (!this.Data) return null;
        if (this.Data.Data.length<=0) return null;

        var xPointCount=this.Frame.XPointCount;
        var endIndex=this.Data.DataOffset+xPointCount-1;
        if (endIndex>=this.Data.Data.length) endIndex=this.Data.Data.length-1;
        var price=null;
        for(var i=endIndex, count=0; i>=0 && i<this.Data.Data.length; --i)
        {
            var data=this.Data.Data[i];
            if (data.Open==null || data.High==null || data.Low==null || data.Close==null) continue;

            if (count==0) price=data.Open;
            else if (count==1) price=data.Close;

            ++count;
            if (count>=2) break;
        }

        return price;
    }

    this.CustomFixedCoordinate=function(option)    //固定坐标刻度
    {
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        for(var i=0; i<option.Data.length; ++i)
        {
            var item=option.Data[i];
            var info=new CoordinateInfo();
            info.Type=1;
            info.TextColor=item.TextColor;
            info.LineColor=item.Color;
            info.LineType=2;    //虚线
            if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;
            if (IFrameSplitOperator.IsPlusNumber(option.LineWidth)) info.LineWidth=option.LineWidth;
            if (option.LineDash) info.LineDash=option.LineDash;
            if (option.IsShowLine==false) info.LineType=-1;

            info.Value=item.Value;
            var text;
            if (item.Text) text=item.Text;
            else text=info.Value.toFixed(defaultfloatPrecision);
            if (option.Position=='left') info.Message[0]=text;
            else info.Message[1]=text;

            if (option.PositionEx===1) info.ExtendData={ Custom:{ Position:1 } };   //强制画在内部
            if (IFrameSplitOperator.IsNonEmptyArray(item.ExtendLine)) info.ExtendLine=item.ExtendLine.slice();

            this.Frame.CustomHorizontalInfo.push(info);
        }
    }

    //////////////////////
    // data.Min data.Max data.Interval data.Count
    //
    this.IntegerCoordinateSplit2=function(data)
    {
        var splitItem=this.FrameSplitData2.Find(data.Interval);
        if (!splitItem) return false;

        if (data.Interval==splitItem.FixInterval) return true;

        //调整到整数倍数,不能整除的 +1
        var fixMax=parseInt((data.Max/(splitItem.FixInterval)+0.5).toFixed(0))*splitItem.FixInterval;
        var fixMin=parseInt((data.Min/(splitItem.FixInterval)-0.5).toFixed(0))*splitItem.FixInterval;
        if (data.Min==0) fixMin=0;  //最小值是0 不用调整了.
        if (fixMin<0 && data.Min>0) fixMin=0;   //都是正数的, 最小值最小调整为0

        var count=0;
        for(var i=fixMin;(i-fixMax)<0.00000001;i+=splitItem.FixInterval)
        {
            ++count;
        }

        data.Interval=splitItem.FixInterval;
        data.Max=fixMax;
        data.Min=fixMin;
        data.Count=count;

        return true;
    }
}

function FrameSplitY()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;

    this.SplitCount=3;                        //刻度个数
    this.FloatPrecision = 2;                  //坐标小数位数(默认2)
    this.FLOATPRECISION_RANGE=[1,0.1,0.01,0.001,0.0001];
    this.SplitType=0;       //0=自动分割  1=固定分割 2=堆积图(0-100)
    this.FilterType=0;      //自动分割过滤算法
    this.DefaultSplitType=0;
    this.Custom=[];         //[{Type:0}]; 定制刻度
    this.DefaultYMaxMin;    //{ Max:null, Min:null };    //指定最大,最小, Y轴范围必须比最大值大， 比最小值小
    this.EnableRemoveZero=g_JSChartResource.Frame.EnableRemoveZero;
    this.LineType=null;     //线段样式
    this.IgnoreYValue = null;                 //在这个数组里的数字不显示在刻度上 
    this.FixedYMaxMin;      //{ Max, Min} 固定Y轴最大最小值
    this.EnableZoomUpDown=false;

    this.IsBeforeData=false;
    this.BeforeOpenData;

    this.IsAfterData=false;
    this.AfterCloseData;
    this.ShareAfterVol=0;

    this.MultiDayBeforeOpenData;
    this.MultiDayAfterCloseData;

    this.OverlayIdentify;
    this.HQChart;
    this.OverlayIndex;  //叠加指标信息

    this.IsEnableDragY=function()
    {
        return true;
    }


    this.Reset=function()   //重置
    {
        this.EnableRemoveZero=g_JSChartResource.Frame.EnableRemoveZero;
        this.StringFormat=g_JSChartResource.Frame.StringFormat;
    }

    this.SetOption=function(option)
    {
        if (!option) return;

        if (IFrameSplitOperator.IsNumber(option.FloatPrecision)) this.FloatPrecision=option.FloatPrecision;
        if (IFrameSplitOperator.IsNumber(option.StringFormat)) this.StringFormat=option.StringFormat;
        if (IFrameSplitOperator.IsBool(option.EnableRemoveZero)) this.EnableRemoveZero=option.EnableRemoveZero;
    }

    this.GetFloatPrecision=function(value,floatPrecision)
    {
        if (value>this.FLOATPRECISION_RANGE[0]) return floatPrecision;
        if (floatPrecision<0) return 2;
        for(;floatPrecision<this.FLOATPRECISION_RANGE.length;++floatPrecision)
        {
            if (value>this.FLOATPRECISION_RANGE[floatPrecision]) break;
        }

        return floatPrecision;
    }

    this.Operator=function()
    {
        var splitData={};
        splitData.Max=this.Frame.HorizontalMax;
        splitData.Min=this.Frame.HorizontalMin;
        
        if (this.Frame.YMaxMin) //原始的数据范围
        {
            var item=this.Frame.YMaxMin;
            if (IFrameSplitOperator.IsNumber(item.Max) && IFrameSplitOperator.IsNumber(item.Min))
            {
                splitData.Max=item.Max;
                splitData.Min=item.Min;
            }
        }

        if (splitData.Max==splitData.Min)   //如果一样上下扩大下
		{
            if (splitData.Max==0)
            {
                splitData.Max=1;
                splitData.Min=-1;
            }
            else
            {
                splitData.Max+=splitData.Max*0.01;
                splitData.Min-=splitData.Min*0.01;
            }
		}
        
        var isFixedMaxMin=false;
        if (this.FixedYMaxMin && IFrameSplitOperator.IsNumber(this.FixedYMaxMin.Max) && IFrameSplitOperator.IsNumber(this.FixedYMaxMin.Min)) isFixedMaxMin=true;
        if (isFixedMaxMin)
        {
            splitData.Max=this.FixedYMaxMin.Max;
            splitData.Min=this.FixedYMaxMin.Min;
        }
        else if (this.DefaultYMaxMin)    //指定最小的Y轴范围
        {
            var range=this.DefaultYMaxMin;
            if (IFrameSplitOperator.IsNumber(range.Max))
            {
                if (splitData.Min>range.Max) splitData.Min=range.Max;
                else if (splitData.Max<range.Max) splitData.Max=range.Max;
            }

            if (IFrameSplitOperator.IsNumber(range.Min))
            {
                if (splitData.Max<range.Min) splitData.Max=range.Min;
                else if (splitData.Min>range.Min) splitData.Min=range.Min;
            }
        }

        if(this.Frame.YSpecificMaxMin)
        {
            splitData.Count=this.Frame.YSpecificMaxMin.Count;
            splitData.Interval=(splitData.Max-splitData.Min)/(splitData.Count-1);
        }
        else if (this.SplitType==1 || isFixedMaxMin)
        {
            splitData.Count=this.SplitCount;
            splitData.Interval=(splitData.Max-splitData.Min)/(splitData.Count-1);
        }
        else if (this.SplitType==2)
        {
            splitData.Max=100;
            splitData.Min=0;
            splitData.Count=this.SplitCount;
            splitData.Interval=(splitData.Max-splitData.Min)/(splitData.Count-1);
        }
        else
        {
            splitData.Count=this.SplitCount;
            splitData.Interval=(splitData.Max-splitData.Min)/(splitData.Count-1);
            this.IntegerCoordinateSplit(splitData);
        }

        this.Frame.HorizontalMax=splitData.Max;
        this.Frame.HorizontalMin=splitData.Min;
        this.Frame.HorizontalInfo=[];

        if (this.Frame.YSplitScale) //固定坐标
        {
            for(var i in this.Frame.YSplitScale)
            {
                var value=this.Frame.YSplitScale[i];
                var coordinate=new CoordinateInfo();
                coordinate.Value=value;
                if (IFrameSplitOperator.IsNumber(this.LineType)) coordinate.LineType=this.LineType;

                var absValue=Math.abs(value);
                if (absValue<0.0000000001) 
                {
                    coordinate.Message[1]=0;
                }
                else if (absValue<this.FLOATPRECISION_RANGE[this.FLOATPRECISION_RANGE.length-1]) 
                {
                    coordinate.Message[1] = value.toExponential(2).toString();
                }
                else
                {
                    var floatPrecision=this.GetFloatPrecision(absValue,this.FloatPrecision); //数据比小数位数还小, 调整小数位数
                    coordinate.Message[1] = IFrameSplitOperator.FormatValueString(value, floatPrecision,this.LanguageID);
                }

                coordinate.Message[0]=coordinate.Message[1];

                if (this.IsShowLeftText==false) this.Frame.HorizontalInfo[i].Message[0]=null;
                if (this.IsShowRightText==false) this.Frame.HorizontalInfo[i].Message[1]=null;

                this.Frame.HorizontalInfo.push(coordinate);
            }
        }
        else
        {
            for(var i=0,value=splitData.Min;i<splitData.Count;++i,value+=splitData.Interval)
            {
                var coordinate=new CoordinateInfo();
                this.Frame.HorizontalInfo[i]= coordinate;
                coordinate.Value=value;
                if (IFrameSplitOperator.IsNumber(this.LineType)) coordinate.LineType=this.LineType;

                var text=this.FormatValueString(value);
                this.Frame.HorizontalInfo[i].Message[0]=this.Frame.HorizontalInfo[i].Message[1]=text;
                if (this.IsShowLeftText==false) this.Frame.HorizontalInfo[i].Message[0]=null;
                if (this.IsShowRightText==false) this.Frame.HorizontalInfo[i].Message[1]=null;
                //this.Frame.HorizontalInfo[i].Font="14px 微软雅黑";
                //this.Frame.HorizontalInfo[i].TextColor="rgb(100,0,200)";
                //this.Frame.HorizontalInfo[i].LineColor="rgb(220,220,220)";
            }
        }

        this.FilterIgnoreYValue();

        this.CustomCoordinate();
        if (this.SplitType!=1) 
            this.Frame.HorizontalInfo = this.Filter(this.Frame.HorizontalInfo,(splitData.Max>0 && splitData.Min<0), this.FilterType);
        
        this.RightFrameSplitY();
        this.MainOverlayFrameSplitY();  //主图Y轴绑定叠加Y轴坐标
        this.CallAcutionSplitY(this.SplitCount,splitData);

        if (this.EnableRemoveZero) this.RemoveZero(this.Frame.HorizontalInfo);

        this.DynamicMessageText();

        this.Frame.HorizontalMax=splitData.Max;
        this.Frame.HorizontalMin=splitData.Min;

        if (this.EnableZoomUpDown==true && !this.FixedYMaxMin)
            this.FixedYMaxMin={ Max:splitData.Max, Min:splitData.Min };

        this.ReservedHeight(splitData); //预留高度

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SPLIT_YCOORDINATE);
            if (event && event.Callback)
            {
                var data={ID:this.Frame.Identify, Frame:this.Frame };
                if (this.OverlayIdentify) data.OverlayIdentify=this.OverlayIdentify;
                event.Callback(event,data,this);
            }
        }
    }

    this.FormatValueString=function(value)
    {
        var text;
        if (this.StringFormat==1)   //手机端格式 如果有万,亿单位了 去掉小数
        {
            var floatPrecision=this.FloatPrecision;
            if (IFrameSplitOperator.IsNumber(value) && Math.abs(value) > 1000) floatPrecision=0;
            text=IFrameSplitOperator.FormatValueString(value,floatPrecision,this.LanguageID);
        }
        else if (this.StringFormat==2)   //原始数据输出
        {
            text=`${value.toFixed(this.FloatPrecision)}`;
        }
        else
        {
            var absValue=Math.abs(value);
            if (absValue<0.0000000001) 
            {
                text=0;
            }
            else if (absValue<this.FLOATPRECISION_RANGE[this.FLOATPRECISION_RANGE.length-1]) 
            {
                text = value.toExponential(2).toString();
            }
            else
            {
                var floatPrecision=this.GetFloatPrecision(absValue,this.FloatPrecision);                //数据比小数位数还小, 调整小数位数
                text = IFrameSplitOperator.FormatValueString(value, floatPrecision,this.LanguageID);
            }
        }

        return text;
    }

    this.FilterIgnoreYValue = function () 
    {
        if (!this.IgnoreYValue || this.IgnoreYValue.length <= 0) return;

        var setValue = new Set(this.IgnoreYValue);
        this.Frame.HorizontalInfo = this.Frame.HorizontalInfo.filter(item => !setValue.has(item.Value));
    }

    this.DynamicMessageText=function()
    {
        if (this.SplitType==2)
        {
            for(var i=0;i<this.Frame.HorizontalInfo.length; ++i)
            {
                var item=this.Frame.HorizontalInfo[i];
                if (item.Message[0]) item.Message[0]+='%';
                if (item.Message[1]) item.Message[1]+='%';
            }
        }
    }

    this.CallAcutionSplitY=function(count,splitData)
    {
        if (this.Frame.Identify!=1) return null;
        var aryCallAcution=this.GetCallAcutionSplitY(count,splitData);
        if (!aryCallAcution) return;

        for(var i=0; i<this.Frame.HorizontalInfo.length; ++i) //把显示的数据迁移到 Message[2] Message[3]
        {
            var item=this.Frame.HorizontalInfo[i];
            if (aryCallAcution.IsBeforeData)
            {
                item.Message[2]=item.Message[0];    
                item.Message[0]=null;
            }

            if (aryCallAcution.IsAfterData &&  (this.ShareAfterVol==0 || this.ShareAfterVol==2) )
            {
                item.Message[3]=item.Message[1];
                item.Message[1]=null;
            }
        }

        //集合竞价的坐标插入最后
        for(var i=0; i<aryCallAcution.HorizontalInfo.length; ++i)
        {
            var item=aryCallAcution.HorizontalInfo[i];
            this.Frame.HorizontalInfo.push(item);
        }
    }

    this.GetCallAcutionSplitY=function(count,splitData)
    {
        if (this.Frame.Identify!=1) return null;

        var isBeforeData=(this.IsBeforeData==true && this.BeforeOpenData && (this.BeforeOpenData.Ver==2.0 || this.BeforeOpenData.Ver==3.0));
        var isAfterData=(this.IsAfterData==true && this.AfterCloseData && (this.AfterCloseData.Ver==2.0 || this.AfterCloseData.Ver==3.0));

        if (isBeforeData || isAfterData)
        {
            var intervalY=(splitData.Max-splitData.Min)/(count-1);
            if (isBeforeData) var intervalLeft=(this.BeforeOpenData.VolMax-this.BeforeOpenData.VolMin)/(count-1);
            if (isAfterData)  var intervalRight=(this.AfterCloseData.VolMax-this.AfterCloseData.VolMin)/(count-1);

            var aryHorizontalInfo=[];
            for(var i=0;i<count;++i)
            {
                var item=new CoordinateInfo();
                var yValue=intervalY*i;
                item.Value=yValue;
                item.LineType=8;
                if (isBeforeData )
                {
                    var leftValue=intervalLeft*i;
                    item.Message[0]=this.FormatValueString(leftValue);
                }

                if (isAfterData && (this.ShareAfterVol==0 || this.ShareAfterVol==2) )
                {
                    var rightValue=intervalRight*i;
                    item.Message[1]=this.FormatValueString(rightValue);
                }                
                aryHorizontalInfo.push(item);
            }
            return { HorizontalInfo:aryHorizontalInfo,  IsBeforeData:isBeforeData, IsAfterData:isAfterData };
        }

        var isMultiDayBeforeData=false;
        var intervalLeft=null;
        if (this.MultiDayBeforeOpenData && IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData))
        {
            isMultiDayBeforeData=true;
            var firstDayData=this.MultiDayBeforeOpenData[0];
            if (firstDayData.Ver==2.0 || firstDayData.Ver==3.0)
            {
                var intervalLeft=(firstDayData.VolMax-firstDayData.VolMin)/(count-1);
            }
        }

        var isMultiDayAfterData=false;
        var intervalRight=null;
        if (this.MultiDayAfterCloseData && IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData))
        {
            isMultiDayAfterData=true;
            var firstDayData=this.MultiDayAfterCloseData[0];
            if (firstDayData.Ver==2.0 || firstDayData.Ver==3.0)
            {
                var intervalRight=(firstDayData.VolMax-firstDayData.VolMin)/(count-1);
            }
        }

        if (isMultiDayBeforeData || isMultiDayAfterData)
        {
            var intervalY=(splitData.Max-splitData.Min)/(count-1);
            var aryHorizontalInfo=[];
            for(var i=0;i<count;++i)
            {
                var item=new CoordinateInfo();
                var yValue=intervalY*i;
                item.Value=yValue;
                item.LineType=9;
                var isVaild=false;
                if (intervalLeft!=null)
                {
                    var leftValue=intervalLeft*i;
                    item.Message[0]=this.FormatValueString(leftValue);
                    isVaild=true;
                }

                if (intervalRight!=null && (this.ShareAfterVol==0 || this.ShareAfterVol==2))
                {
                    var rightValue=intervalRight*i;
                    item.Message[1]=this.FormatValueString(rightValue);
                    isVaild=true;
                } 

                if (isVaild) aryHorizontalInfo.push(item);
            }

            if (IFrameSplitOperator.IsNonEmptyArray(aryHorizontalInfo))
                return { HorizontalInfo:aryHorizontalInfo,  IsBeforeData:isMultiDayBeforeData, IsAfterData:isMultiDayAfterData };
        }

        return null;
    }

    this.RightFrameSplitY=function()
    {
        if (!this.Frame.RightFrame) return;

        var rightFrame=this.Frame.RightFrame;
        if (rightFrame.YSplitOperator) rightFrame.YSplitOperator.Operator();

        for(var i=0;i<this.Frame.HorizontalInfo.length;++i)
        {
            var item=this.Frame.HorizontalInfo[i];
            var y=this.Frame.GetYFromData(item.Value);
            var yValue=rightFrame.GetYData(y);
            item.Message[1] = IFrameSplitOperator.FormatValueString(yValue, this.FloatPrecision,this.LanguageID);
        }
    }

    this.MainOverlayFrameSplitY=function()
    {
        if (!this.Frame.GetMainOverlayFrame) return;
        var aryOverlayFrame=this.Frame.GetMainOverlayFrame();
        if (!aryOverlayFrame ) return;

        if (aryOverlayFrame[1])
        {
            var rightFrame=aryOverlayFrame[1];
            var ySplitOper=rightFrame.YSplitOperator;
            if (ySplitOper) ySplitOper.Operator();

            for(var i=0;i<this.Frame.HorizontalInfo.length;++i)
            {
                var item=this.Frame.HorizontalInfo[i];
                var y=this.Frame.GetYFromData(item.Value);
                var yValue=rightFrame.GetYData(y);
                if (ySplitOper && ySplitOper.FormatValueString) item.Message[1] = ySplitOper.FormatValueString(yValue); 
                else item.Message[1] = this.FormatValueString(yValue);
            }
        }

        if (aryOverlayFrame[0])
        {
            var leftFrame=aryOverlayFrame[0];
            var ySplitOper=leftFrame.YSplitOperator
            if (ySplitOper) ySplitOper.Operator();

            for(var i=0;i<this.Frame.HorizontalInfo.length;++i)
            {
                var item=this.Frame.HorizontalInfo[i];
                var y=this.Frame.GetYFromData(item.Value);
                var yValue=leftFrame.GetYData(y);
                if (ySplitOper && ySplitOper.FormatValueString)  item.Message[0] = ySplitOper.FormatValueString(yValue); 
                else item.Message[0] = this.FormatValueString(yValue);
            }
        }
    }

    this.CustomCoordinate=function()
    {
        this.Frame.CustomHorizontalInfo=[];

        var data=this.InvokeCustomYCoordinateCallback();
        if (data && data.PreventDefault==true) return;

        if (!IFrameSplitOperator.IsNonEmptyArray(this.Custom)) return;

        for(var i=0; i<this.Custom.length; ++i)
        {
            var item=this.Custom[i];
            if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.PAGE_LAST_INDEX_VALUE_ID)   //当前屏最后一个数据
            {
                this.CustomLatestIndexDataCoordinate(item);
            }
            else if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.FIXED_VALUE_ID)  //自定义刻度
            {
                this.CustomFixedCoordinate(item);
            }
            else if (item.Type==JSCHART_CUSTOM_YCOORDINATE_ID.PAGE_LAST_OVERLAY_INDEX_VALUE_ID) //叠加指标当前屏最后一个数据
            {
                this.CustomLatestOverlayIndexDataCoordinate(item);
            }
        }
    }

    this.CustomFixedCoordinate=function(option)    //固定坐标刻度
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(option.Data)) return;

        var defaultfloatPrecision=2;
        for(var i=0;i<option.Data.length; ++i)
        {
            var item=option.Data[i];
            var info=new CoordinateInfo();
            info.Type=1;
            info.TextColor=item.TextColor;
            info.LineColor=item.Color;
            info.LineType=2;    //虚线
            if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;
            if (option.IsShowLine==false) info.LineType=-1;

            info.Value=item.Value;
            var text;
            if (item.Text) text=item.Text;
            else text=info.Value.toFixed(defaultfloatPrecision);
            if (option.Position=='left') info.Message[0]=text;
            else info.Message[1]=text;

            this.Frame.CustomHorizontalInfo.push(info);
        }
    }
}

function FrameSplitKLineX()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ShowText=true;                 //是否显示坐标信息
    this.Period;                        //周期
    this.Symbol;                        //股票代码
    this.MinTextDistance=50*GetDevicePixelRatio();
    this.MinBarDistance=5; //刻度间最小的K线间距


    this.SplitDateTime=function()   //根据时间分割
    {
        this.Frame.VerticalInfo=[];
        var itemWidth=this.Frame.DistanceWidth+this.Frame.DataWidth;
        var xOffset=this.Frame.Data.DataOffset;
        var xPointCount=this.Frame.XPointCount;
        var lastYear=null, lastMonth=null;
        var textDistance=0;
        var barDistance=0;
        for(var i=0, index=xOffset; i<xPointCount && index<this.Frame.Data.Data.length; ++i,++index)
        {
            textDistance+=itemWidth;
            ++barDistance;
            var infoData=null;
            if (i==0)
            {
                var date=IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date,'MM-DD');
                infoData={Value:index-xOffset, Text:date};
            }
            else if (textDistance>this.MinTextDistance && barDistance>=this.MinBarDistance)
            {
                var time=IFrameSplitOperator.FormatTimeString(this.Frame.Data.Data[index].Time);
                infoData={Value:index-xOffset, Text:time};
            }

            if (infoData)
            {
                var info= new CoordinateInfo();
                info.Value=infoData.Value;
                if (this.ShowText) info.Message[0]=infoData.Text;
                if (info.Value==0) info.LineType=-1;    //第1个分割线不画
                this.Frame.VerticalInfo.push(info);
                textDistance=0;
                barDistance=0;
                if (i==0) textDistance=-(this.MinTextDistance/2);
            }
        }
    }

    this.SplitSecond=function()   //根据时间分割
    {
        this.Frame.VerticalInfo=[];
        var itemWidth=this.Frame.DistanceWidth+this.Frame.DataWidth;
        var xOffset=this.Frame.Data.DataOffset;
        var xPointCount=this.Frame.XPointCount;
        var textDistance=0;
        var barDistance=0;

        for(var i=0, index=xOffset; i<xPointCount && index<this.Frame.Data.Data.length; ++i,++index)
        {
            textDistance+=itemWidth;
            ++barDistance;
            var infoData=null;
            if (i==0)
            {
                var date=IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date,'MM-DD');
                infoData={Value:index-xOffset, Text:date};
            }
            else if (textDistance>this.MinTextDistance && barDistance>=this.MinBarDistance)
            {
                var time=IFrameSplitOperator.FormatTimeString(this.Frame.Data.Data[index].Time,"HH:MM:SS");
                infoData={Value:index-xOffset, Text:time};
            }

            if (infoData)
            {
                var info= new CoordinateInfo();
                info.Value=infoData.Value;
                if (this.ShowText) info.Message[0]=infoData.Text;
                this.Frame.VerticalInfo.push(info);
                textDistance=0;
                barDistance=0;
                if (i==0) textDistance=-(this.MinTextDistance/2);
            }
        }
    }

    this.SplitMilliSecond=function()
    {
        this.Frame.VerticalInfo=[];
        var itemWidth=this.Frame.DistanceWidth+this.Frame.DataWidth;
        var xOffset=this.Frame.Data.DataOffset;
        var xPointCount=this.Frame.XPointCount;
        var textDistance=0;
        var barDistance=0;

        for(var i=0, index=xOffset; i<xPointCount && index<this.Frame.Data.Data.length; ++i,++index)
        {
            textDistance+=itemWidth;
            ++barDistance;
            var infoData=null;
            if (i==0)
            {
                var date=IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date,'HH:MM:SS.fff');
                infoData={Value:index-xOffset, Text:date};
            }
            else if (textDistance>this.MinTextDistance && barDistance>=this.MinBarDistance)
            {
                var time=IFrameSplitOperator.FormatTimeString(this.Frame.Data.Data[index].Time,"HH:MM:SS.fff");
                infoData={Value:index-xOffset, Text:time};
            }

            if (infoData)
            {
                var info= new CoordinateInfo();
                info.Value=infoData.Value;
                if (this.ShowText) info.Message[0]=infoData.Text;
                this.Frame.VerticalInfo.push(info);
                textDistance=0;
                barDistance=0;
                if (i==0) textDistance=-(this.MinTextDistance/2);
            }
        }
    }

    this.SplitDate=function()   //根据日期分割
    {
        this.Frame.VerticalInfo=[];
        var xOffset=this.Frame.Data.DataOffset;
        var xPointCount=this.Frame.XPointCount;
        var lastYear=null, lastMonth=null;
        var minDistance=12;
        var monthCount=0;
        for(var i=0, index=xOffset, distance=minDistance;i<xPointCount && index<this.Frame.Data.Data.length ;++i,++index)
        {
            var year=parseInt(this.Frame.Data.Data[index].Date/10000);
            var month=parseInt(this.Frame.Data.Data[index].Date/100)%100;

            if (lastMonth!=month) 
                ++monthCount;

            if (distance<minDistance ||
                (lastYear!=null && lastYear==year && lastMonth!=null && lastMonth==month))
            {
                lastMonth=month;
                ++distance;
                continue;
            }

            var info= new CoordinateInfo();
            info.Value=index-xOffset;
            var text;
            if (lastYear==null || lastYear!=year)
            {
                text=year.toString();
            }
            else if (lastMonth==null || lastMonth!=month)
            {
                text=month.toString()+'月';
                text=g_JSChartLocalization.GetText(text, this.LanguageID);
            }

            lastYear=year;
            lastMonth=month;
            if (this.ShowText) info.Message[0]=text;
            if (info.Value==0) info.LineType=-1;    //第1个分割线不画

            this.Frame.VerticalInfo.push(info);
            distance=0;
        }

        if (this.Period==0 && monthCount<=2)
            this.SplitShortDate();
    }

    //分隔在2个月一下的格式
    this.SplitShortDate=function()
    {
        this.Frame.VerticalInfo=[];
        var xOffset=this.Frame.Data.DataOffset;
        var xPointCount=this.Frame.XPointCount;
        var minDistance=12;
        var isFirstYear=true;
        for(var i=0, index=xOffset, distance=minDistance;i<xPointCount && index<this.Frame.Data.Data.length ;++i,++index)
        {
            var year=parseInt(this.Frame.Data.Data[index].Date/10000);
            //var month=parseInt(this.Frame.Data.Data[index].Date/100)%100;
            //var day=parseInt(this.Frame.Data.Data[index].Date%100);

            if (distance<minDistance)
            {
                ++distance;
                continue;
            }

            var info= new CoordinateInfo();
            info.Value=index-xOffset;
            var text;
            if (isFirstYear)
            {
                text=year.toString();
                isFirstYear=false;
            }
            else
            {
                text=IFrameSplitOperator.FormatDateString(this.Frame.Data.Data[index].Date,'MM-DD');
            }

            if (this.ShowText) info.Message[0]=text;
            if (info.Value==0) info.LineType=-1;    //第1个分割线不画

            this.Frame.VerticalInfo.push(info);
            distance=0;
        }

        if (this.Frame.VerticalInfo.length==1)  //只有1个刻度, 就显示年+月
        {
            var item=this.Frame.VerticalInfo[0];
            var index=item.Value+xOffset;
            var kitem=this.Frame.Data.Data[index];
            var text=IFrameSplitOperator.FormatDateString(kitem.Date,'YYYY-MM');
            if (this.ShowText) item.Message[0]=text;
        }
    }

    this.Operator=function()
    {
        if (this.Frame.Data==null) return;
        if (FrameSplitKLineX.SplitCustom) FrameSplitKLineX.SplitCustom(this);   //自定义分割
        else if (ChartData.IsMinutePeriod(this.Period, true)) this.SplitDateTime();
        else if (ChartData.IsSecondPeriod(this.Period)) this.SplitSecond();
        else if (ChartData.IsTickPeriod(this.Period)) this.SplitSecond();
        else if (ChartData.IsMilliSecondPeriod(this.Period)) this.SplitMilliSecond();
        else this.SplitDate();

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SPLIT_XCOORDINATE);
            if (event && event.Callback)
            {
                var data={ID:this.Frame.Identify, Frame:this.Frame };
                event.Callback(event,data,this);
            }
        }
    }

    this.CreateCoordinateInfo=function()
    {
        return new CoordinateInfo();
    }
}

//FrameSplitKLineX.SplitCustom=function(split) { }

function FrameSplitMinutePriceY()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;

    this.High=null;                 //最高最低价
    this.Low=null;

    this.YClose;                        //昨收
    this.Data;                          //分钟数据
    this.SourceData;                    //原始数据
    this.OverlayChartPaint;
    this.SplitCount=7;
    this.Symbol;
    this.SplitType=0;                   //0=默认根据最大最小值分割 1=涨跌停分割 2=数据最大最大值分割
    this.DefaultSplitType=0;
    this.LimitPrice;                    //{Max: Min:} 涨跌停价
    this.Custom;
    this.RightTextFormat=0;           //右边刻度显示模式 0=百分比  1=价格

    this.BeforeOpenData;
    this.IsBeforeData=false;
    this.AfterCloseData;
    this.IsAfterData=false;

    this.MultiDayBeforeOpenData;
    this.MultiDayAfterCloseData;
    this.DayOffset;

    this.AverageData;             //均线
    this.DayCount=1;
    this.GlobalOption;
    this.HQChart;

    this.IsEnableDragY=function()
    {
        return false;
    }

    this.Operator=function()
    {
        this.Frame.HorizontalInfo=[];
        this.Frame.CustomHorizontalInfo=[];
        if (!this.Data) return;

        var range=this.GetMaxMin();

        if (this.Symbol && MARKET_SUFFIX_NAME.IsUSA(this.Symbol.toUpperCase()))
        {
            this.USASplit(range);
        }
        else if (this.SplitType==2)
        {
            this.USASplit(range);
        }
        else
        {
            this.DefaultSplit(range);
        }

        this.CustomCoordinate();

        this.ReservedHeight({ Max:this.Frame.HorizontalMax, Min:this.Frame.HorizontalMin });     //预留高度

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SPLIT_YCOORDINATE);
            if (event && event.Callback)
            {
                var data={ID:this.Frame.Identify, Frame:this.Frame };
                event.Callback(event,data,this);
            }
        }
    }

    this.CustomCoordinate=function()    //自定义刻度
    {
        this.Frame.CustomHorizontalInfo=[];

        var data=this.InvokeCustomYCoordinateCallback();
        if (data && data.PreventDefault==true) return;

        if (!this.Custom) return;

        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        for(var i in this.Custom)
        {
            var item=this.Custom[i];
            if (item.Type==1) this.CustomFixedCoordinate(item);
            else if (item.Type==0) 
            {
                var latestItem=this.GetLatestPrice(defaultfloatPrecision,item);
                if (latestItem) this.Frame.CustomHorizontalInfo.push(latestItem);
            }
        }
    }

    this.GetLatestPrice=function(floatPrecision,option)
    {
        if (!this.Data || !this.Data.Data) return null;
        if (this.Data.Data.length<=0) return null;
        var price=this.Data.Data[this.Data.Data.length-1];
        if (!IFrameSplitOperator.IsNumber(price) || !IFrameSplitOperator.IsNumber(this.YClose)) return null;

        var info=new CoordinateInfo();
        info.Type=0;
        info.Value=price;
        info.TextColor=g_JSChartResource.FrameLatestPrice.TextColor;
        info.LineType=2;    //虚线

        var strPrice=price.toFixed(floatPrecision);
        if (option.DateTime=='HH:MM')
        {
            var latestItem=this.Frame.Data.Data[this.Frame.Data.Data.length-1];
            var strTime=IFrameSplitOperator.FormatTimeString(latestItem.Time,option.DateTime);
            var aryText=[{Text:strPrice}, { Text:strTime} ];
            if (option.Position=='left') info.Message[0]=aryText;
            else info.Message[1]=aryText;
        }
        else
        {
            if (option.Position=='left') info.Message[0]=strPrice;
            else info.Message[1]=strPrice;
        }
       
        if (price>this.YClose) info.LineColor=g_JSChartResource.FrameLatestPrice.UpBarColor;
        else if (price<this.YClose) info.LineColor=g_JSChartResource.FrameLatestPrice.DownBarColor;
        else info.LineColor=g_JSChartResource.FrameLatestPrice.UnchagneBarColor;

        if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;
        if (IFrameSplitOperator.IsPlusNumber(option.LineWidth)) info.LineWidth=option.LineWidth;
        if (option.LineDash) info.LineDash=option.LineDash;
        if (option.IsShowLine==false) info.LineType=-1;
        if (option.PositionEx===1) info.ExtendData={ Custom:{ Position:1 } };   //强制画在内部

        return info;
    }

    this.CustomFixedCoordinate=function(option)    //固定坐标刻度
    {
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        for(var i=0; i<option.Data.length; ++i)
        {
            var item=option.Data[i];
            var info=new CoordinateInfo();
            info.Type=1;
            info.TextColor=item.TextColor;
            info.LineColor=item.Color;
            info.LineType=2;    //虚线
            if (IFrameSplitOperator.IsNumber(option.LineType)) info.LineType=option.LineType;
            if (IFrameSplitOperator.IsPlusNumber(option.LineWidth)) info.LineWidth=option.LineWidth;
            if (option.LineDash) info.LineDash=option.LineDash;
            if (option.IsShowLine==false) info.LineType=-1;
            if (option.PositionEx===1) info.ExtendData={ Custom:{ Position:1 } };   //强制画在内部

            if (IFrameSplitOperator.IsNumber(item.Increase)) //涨幅计算价格
            {
                if (!IFrameSplitOperator.IsNumber(this.YClose)) continue;
                info.Value=this.YClose*(1+item.Increase);
            }
            else 
            {
                info.Value=item.Value;
            }
            
            var text;
            if (item.Text) text=item.Text;
            else text=info.Value.toFixed(defaultfloatPrecision);
            if (option.Position=='left') info.Message[0]=text;
            else info.Message[1]=text;

            this.Frame.CustomHorizontalInfo.push(info);
        }
    }


    this.GetCallAuctionMaxMin=function(callAuctionData, range)
    {
        for(var i in callAuctionData.Data)
        {
            var item=callAuctionData.Data[i];
            if (!item) continue;
            if (IFrameSplitOperator.IsNumber(item.Price))
            {
                if (range.Max==null) range.Max=item.Price;
                if (range.Min==null) range.Min=item.Price;

                if (range.Max<item.Price) range.Max=item.Price;
                if (range.Min>item.Price) range.Min=item.Price;
            }
            
            //集合竞价均线统计
            if (callAuctionData.Ver==3.0 && IFrameSplitOperator.IsNumber(item.AvPrice))
            {
                if (range.Max==null) range.Max=item.AvPrice;
                if (range.Min==null) range.Min=item.AvPrice;

                if (range.Max<item.AvPrice) range.Max=item.AvPrice;
                if (range.Min>item.AvPrice) range.Min=item.AvPrice;
            }
        }
    }

    //多日分时图 集合竞价数据
    this.GetMultiDayBeforeOpenData=function()
    {
        if (!this.MultiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData)) return null;
        if (!this.DayOffset) return this.MultiDayBeforeOpenData;
        if (!IFrameSplitOperator.IsNumber(this.DayOffset.Offset) || !IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) return null;
        if (this.GlobalOption && this.GlobalOption.IsValueFullRange===true) return this.MultiDayBeforeOpenData;

        var showCount= this.DayOffset.ShowDayCount;
        var offset=this.DayOffset.Offset;
        var aryData=this.MultiDayBeforeOpenData.slice(offset, offset+showCount);
        return aryData;
    }

    this.GetMultiDayAfterCloseData=function()
    {
        if (!this.MultiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData)) return null;
        if (!this.DayOffset) return this.MultiDayAfterCloseData;
        if (!IFrameSplitOperator.IsNumber(this.DayOffset.Offset) || !IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) return null;
        if (this.GlobalOption && this.GlobalOption.IsValueFullRange===true) return this.MultiDayAfterCloseData;

        var showCount= this.DayOffset.ShowDayCount;
        var offset=this.DayOffset.Offset;
        var aryData=this.MultiDayAfterCloseData.slice(offset, offset+showCount);
        return aryData;
    }

    this.GetMaxMin=function()   //计算图中所有的数据的最大最小值
    {
        var max=this.YClose;
        var min=this.YClose;

        var data=this.Data;
        var isBerforeData=false;
        if (this.SourceData)
        {
            data=this.SourceData;
            isBerforeData=true;
        }

        if (this.DayCount>1)    //多日
        {
            var offset=this.DayOffset.DataOffset;
            var showDataCount=this.DayOffset.ShowDataCount;
            if (this.GlobalOption && this.GlobalOption.IsValueFullRange===true)
            {
                offset=0;
                showDataCount=data.Data.length;
            }

            for(var i=offset, j=0; i<data.Data.length && j<showDataCount ;++i,++j)
            {
                var value=null;
                if (isBerforeData)
                {
                    var item=data.Data[i];
                    if (item.Before) value=item.Before.Close;
                    else value=item.Close;
                }
                else
                {
                    value=data.Data[i];
                }
                if (value==null) continue;
                if (max<value) max=value;
                if (min>value) min=value;
            }

            if (this.AverageData)
            {
                for(var i=offset,j=0; i<this.AverageData.Data.length && j<showDataCount; ++i,++j)
                {
                    if (this.AverageData.Data[i]==null) continue;
                    if (max<this.AverageData.Data[i]) max=this.AverageData.Data[i];
                    if (min>this.AverageData.Data[i]) min=this.AverageData.Data[i];
                }
            }
        }
        else
        {
            for(var i=0;i<data.Data.length;++i)
            {
                var value=null;
                if (isBerforeData)
                {
                    var item=data.Data[i];
                    if (item.Before) value=item.Before.Close;
                    else value=item.Close;
                }
                else
                {
                    value=data.Data[i];
                }
                if (value==null) continue;
                if (max<value) max=value;
                if (min>value) min=value;
            }

            if (this.AverageData)
            {
                for(var i=0;i<this.AverageData.Data.length;++i)
                {
                    if (this.AverageData.Data[i]==null) continue;
                    if (max<this.AverageData.Data[i]) max=this.AverageData.Data[i];
                    if (min>this.AverageData.Data[i]) min=this.AverageData.Data[i];
                }
            }
        }
        
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            //if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;
            var range=item.GetMaxMin();
            if (range.Max && range.Max>max) max=range.Max;
            if (range.Min && range.Min<min) min=range.Min;
        }

        if (this.SplitType==1 && this.LimitPrice)
        {
            if (max<this.LimitPrice.Max) max=this.LimitPrice.Max;
            if (min>this.LimitPrice.Min) min=this.LimitPrice.Min;
        }

        if (IFrameSplitOperator.IsNumber(this.High) && IFrameSplitOperator.IsNumber(this.Low))
        {
            if (max<this.High) max=this.High;
            if (min>this.Low) min=this.Low;
        }

        var range={ Max:null, Min:null };
        if (this.IsAfterData && this.AfterCloseData)
        {
            this.GetCallAuctionMaxMin(this.AfterCloseData,range);
        }

        if (this.IsBeforeData && this.BeforeOpenData)
        {
            this.GetCallAuctionMaxMin(this.BeforeOpenData,range);
        }

        var multiDayBeforeOpenData=this.GetMultiDayBeforeOpenData();
        if (multiDayBeforeOpenData && this.ChartBorder.MultiDayMinute.Count>1 && this.ChartBorder.MultiDayMinute.Left>0)
        {
            for(var i=0;i<multiDayBeforeOpenData.length; ++i)
            {
                var dayItem=multiDayBeforeOpenData[i];
                this.GetCallAuctionMaxMin(dayItem,range);
            }
        }

        var multiDayAfterCloseData=this.GetMultiDayAfterCloseData();
        if (multiDayAfterCloseData && this.ChartBorder.MultiDayMinute.Count>1 && this.ChartBorder.MultiDayMinute.Right>0)
        {
            for(var i=0;i<multiDayAfterCloseData.length; ++i)
            {
                var dayItem=multiDayAfterCloseData[i];
                this.GetCallAuctionMaxMin(dayItem,range);
            }
        }
       
        if (IFrameSplitOperator.IsNumber(range.Max) && max<range.Max) max=range.Max;
        if (IFrameSplitOperator.IsNumber(range.Min) && min>range.Min) min=range.Min;

        //叠加指标
        var overlayRange=this.GetOverlayMaxMin();
        if (overlayRange)
        {
            if (IFrameSplitOperator.IsNumber(overlayRange.Max) && overlayRange.Max>max) max=overlayRange.Max;
            if (IFrameSplitOperator.IsNumber(overlayRange.Min) && overlayRange.Min<min) min=overlayRange.Min;
        }
 

        return { Max:max, Min:min };
    }

    //获取共享Y轴叠加指标最大，最小值
    this.GetOverlayMaxMin=function()
    {
        if (!this.HQChart) return null;
        if (!this.HQChart.Frame || !this.HQChart.Frame.SubFrame) return null;
        var subFrame=this.HQChart.Frame.SubFrame[0];
        if (!subFrame) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(subFrame.OverlayIndex)) return null;

        var range={ Max:null, Min:null };
        for(var i=0;i<subFrame.OverlayIndex.length;++i)
        {
            var item=subFrame.OverlayIndex[i];
            if (!item || !item.Frame) continue;
            var overlayFrame=item.Frame;
            if (overlayFrame.IsShareY!=true) continue;
            if (overlayFrame.IsCalculateYMaxMin===false) continue;  //叠加坐标Y轴不调整
            for(var j=0;j<item.ChartPaint.length; ++j)
            {
                var paint=item.ChartPaint[j];
                if (paint.IsShow==false) continue;

                var value=paint.GetMaxMin();
                if (value==null || value.Max==null || value.Min==null) continue;

                if (range.Max==null || range.Max<value.Max) range.Max=value.Max;
                if (range.Min==null || range.Min>value.Min ) range.Min=value.Min;
            }
        }

        return range;
    }

    this.USASplit=function(range)
    {
        var max=range.Max;
        var min=range.Min;

        if (max==min)
        {
            max=max+max*0.1;
            min=min-min*0.1;
        }
        else
        {
            var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
            var height=this.Frame.ChartBorder.GetHeight();   //画布的高度
            var spacePrice=5*pixelTatio*(max-min)/height;
            max+=spacePrice;
            min-=spacePrice;
            if (min<0) min=range.Min;
        }

        var showCount=this.SplitCount;
        var distance=(max-min)/(showCount-1);
        const minDistance=[1, 0.1, 0.01, 0.001, 0.0001];
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        if (distance<minDistance[defaultfloatPrecision]) 
        {
            distance=minDistance[defaultfloatPrecision];
            max=min+distance*showCount;
            //min=this.YClose-(distance*(showCount-1)/2);
        }

        for(var i=0;i<showCount;++i)
        {
            var price=min+(distance*i);
            if (this.YClose && price==this.YClose) continue;
            var coordinate=new CoordinateInfo();
            coordinate.Value=price;
            var strPrice=price.toFixed(defaultfloatPrecision);  //价格刻度字符串
            if (this.IsShowLeftText) coordinate.Message[0]=strPrice;

            if (this.YClose && this.YClose!=0)
            {
                var per=(price/this.YClose-1)*100;
                if (per>0) coordinate.TextColor=g_JSChartResource.UpTextColor;
                else if (per<0) coordinate.TextColor=g_JSChartResource.DownTextColor;
                if (this.IsShowRightText) 
                {
                    if (this.RightTextFormat==1) coordinate.Message[1]=strPrice;
                    else coordinate.Message[1]=IFrameSplitOperator.FormatValueString(per,2)+'%'; //百分比
                }
            }

            this.Frame.HorizontalInfo.push(coordinate);
        }

        if (this.YClose>min && this.YClose<max) //前收盘线
        {
            var coordinate=new CoordinateInfo();
            coordinate.Value=this.YClose;
            coordinate.LineType=2;//中间的线画虚线
            if (g_JSChartResource.FrameDotSplitPen) coordinate.LineColor=g_JSChartResource.FrameDotSplitPen;

            var strPrice=this.YClose.toFixed(defaultfloatPrecision);  //价格刻度字符串
            if (this.IsShowLeftText) coordinate.Message[0]=strPrice;

            if (this.IsShowRightText) 
            {
                if (this.RightTextFormat==1) coordinate.Message[1]=strPrice;
                else coordinate.Message[1]='0.00%'; //百分比
            }

            this.Frame.HorizontalInfo.push(coordinate);
        }

        this.Frame.HorizontalInfo.sort(function(a,b) { return a.Value-b.Value; });

        this.Frame.HorizontalMax=max;
        this.Frame.HorizontalMin=min;
    }

    this.DefaultSplit=function(range)
    {
        var max=range.Max;
        var min=range.Min;
        
        if (this.YClose==max && this.YClose==min)
        {
            max=this.YClose+this.YClose*0.1;
            min=this.YClose-this.YClose*0.1
        }
        else
        {
            var distanceValue=Math.max(Math.abs(this.YClose-max),Math.abs(this.YClose-min));
            max=this.YClose+distanceValue;
            min=this.YClose-distanceValue;
            if (min<0) min=range.Min;
        }

        var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
        var width=this.Frame.ChartBorder.GetChartWidth();   //画布的宽度
        var isPhoneModel=width<450*pixelTatio;
        JSConsole.Chart.Log('[FrameSplitMinutePriceY]'+ 'max='+ max + ' min='+ min +' isPhoneModel='+isPhoneModel);

        var showCount=this.SplitCount;
        var distance=(max-min)/(showCount-1);
        const minDistance=[1, 0.1, 0.01, 0.001, 0.0001];
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
        if (isPhoneModel && MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol)) defaultfloatPrecision = 0;    //手机端指数不显示小数位数,太长了
        if (distance<minDistance[defaultfloatPrecision]) 
        {
            distance=minDistance[defaultfloatPrecision];
            max=this.YClose+(distance*(showCount-1)/2);
            min=this.YClose-(distance*(showCount-1)/2);
        }

        for(var i=0;i<showCount;++i)
        {
            var price=min+(distance*i);
            var coordinate=new CoordinateInfo();
            this.Frame.HorizontalInfo[i]=coordinate
            coordinate.Value=price;
            var strPrice=price.toFixed(defaultfloatPrecision);  //价格刻度字符串
            if (this.IsShowLeftText) coordinate.Message[0]=strPrice

            if (IFrameSplitOperator.IsNumber(this.YClose) && this.YClose!=0)
            {
                var per=(price/this.YClose-1)*100;
                if (per>0) coordinate.TextColor=g_JSChartResource.UpTextColor;
                else if (per<0) coordinate.TextColor=g_JSChartResource.DownTextColor;

                if (this.IsShowRightText) 
                {
                    if (this.RightTextFormat==1)  coordinate.Message[1]=strPrice;
                    else coordinate.Message[1]=IFrameSplitOperator.FormatValueString(per,2)+'%'; //百分比
                }

                if (Math.abs(price-this.YClose) <0.00000000001) //小数有精度问题 使用差值
                {
                    coordinate.LineType=2;//中间的线画虚线
                    coordinate.TextColor=g_JSChartResource.UnchagneTextColor;
                    if (g_JSChartResource.FrameDotSplitPen) coordinate.LineColor=g_JSChartResource.FrameDotSplitPen;
                }
            }
            
        }

        this.Frame.HorizontalMax=max;
        this.Frame.HorizontalMin=min;
    }

}

function FrameSplitMinuteX()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ShowText=true;                 //是否显示坐标信息
    this.Symbol=null;                   //股票代码 x轴刻度根据股票类型来调整
    this.DayCount=1;
    this.DateFormat=0;             //0=MM-DD 1=MM/DD 2=MM/DD/Week

    this.Operator=function()
    {
        this.Frame.VerticalInfo=[];
        var xPointCount=this.Frame.XPointCount;
        var width = this.Frame.ChartBorder.GetWidth();
        var isHScreen=(this.Frame.IsHScreen===true);
        if (isHScreen) width = this.Frame.ChartBorder.GetHeight();
        width=width/GetDevicePixelRatio();

        const minuteCoordinate = g_MinuteCoordinateData;
        var xcoordinateData = minuteCoordinate.GetCoordinateData(this.Symbol,width);
        var minuteCount=xcoordinateData.Count;
        var minuteMiddleCount=xcoordinateData.MiddleCount>0? xcoordinateData.MiddleCount: parseInt(minuteCount/2);
        var xcoordinate = xcoordinateData.Data;

        this.Frame.XPointCount=minuteCount*this.DayCount;   //计算一共显示的数据个数
        this.Frame.MinuteCount=minuteCount;
        this.Frame.VerticalInfo=[];

        if (this.Frame.GlobalOption)
        {
            var item=this.Frame.GlobalOption;
            if (IFrameSplitOperator.IsNumber(item.XDateFormat)) this.DateFormat=item.XDateFormat;
        }
        
        if (this.DayCount<=1)
        {
            //设置成1日的数据
            this.DayOffset.DataOffset=0;
            this.DayOffset.ShowDataCount=minuteCount;
            this.DayOffset.PageInfo=null;
            for(var i=0; i<xcoordinate.length; ++i)
            {
                var info=new CoordinateInfo();
                var item=xcoordinate[i];
                if (g_JSChartResource.Minute.FrameSplitTextColor) info.TextColor=g_JSChartResource.Minute.FrameSplitTextColor;
                info.Value=item[0];
                if (this.ShowText) info.Message[0]=item[3];
                if (item[4]) info.LineColor=item[4];    //线段颜色
                if (item[5]) info.TextBGColor=item[5];  //文字背景色
                this.Frame.VerticalInfo[i]=info;
            }
        }
        else
        {
            var offset=0, showDayCount=this.DayData.length;
            if (this.DayOffset)
            {
                if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
                if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
            }
            this.DayOffset.DataOffset=offset*minuteCount;
            this.DayOffset.ShowDataCount=this.DayOffset.ShowDayCount*minuteCount;
            this.DayOffset.PageInfo={ Day:[] };
            for(var i=this.DayData.length-1-offset, j=0; i>=0 && j<showDayCount; --i,++j)
            {
                var info=new CoordinateInfo();
                info.Value=j*minuteCount+minuteMiddleCount;
                info.LineType=-1;    //线段不画
                if (this.ShowText) 
                {
                    info.Message[0]=this.FormatDate(this.DayData[i].Date);
                    info.BG={ Index: { Start:j*minuteCount+1, End: (j+1)*minuteCount-1 }, Date:this.DayData[i].Date };  //背景设置
                }
                this.Frame.VerticalInfo.push(info);

                var info=new CoordinateInfo();
                info.Value=(j+1)*minuteCount;
                this.Frame.VerticalInfo.push(info);

                this.DayOffset.PageInfo.Day.push({ Date:this.DayData[i].Date, Index:i });
            }
        }

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SPLIT_XCOORDINATE);
            if (event && event.Callback)
            {
                var data={ID:this.Frame.Identify, Frame:this.Frame };
                event.Callback(event,data,this);
            }
        }
    }

    this.FormatDate=function(date)
    {
        switch(this.DateFormat)
        {
        case 1: 
            return IFrameSplitOperator.FormatDateString(date, 'MM/DD');
        case 2:
            return IFrameSplitOperator.FormatDateString(date, 'MM/DD/W');
        default:    //MM-DD
            return IFrameSplitOperator.FormatDateString(date, 'MM-DD');
        }
    }
}

function FrameSplitXData()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ShowText=true;                 //是否显示坐标信息
    this.Symbol;                        //股票代码
    this.MinTextDistance=50*GetDevicePixelRatio();
    this.MinBarDistance=5; //刻度间最小的K线间距

    this.Operator=function()
    {
        if (this.Frame.Data==null || this.Frame.XData==null) return;
        this.Frame.VerticalInfo=[];
        var xOffset=this.Frame.Data.DataOffset;
        var xPointCount=this.Frame.XPointCount;

        for(var i=0, index=xOffset; i<xPointCount && index<this.Frame.Data.Data.length ;++i,++index)
        {
            var info= new CoordinateInfo();
            info.Value=index-xOffset;
            
            if (this.ShowText)
                info.Message[0]=this.Frame.XData[i];

            this.Frame.VerticalInfo.push(info);
            distance=0;
        }
    }
}

//深度图X轴价格信息
function FrameSplitXDepth()
{
    this.newMethod=IFrameSplitOperator;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ShowText=true;                 //是否显示坐标信息
    this.SplitCount=3;
    this.Symbol;
    this.LineType=3;

    this.Operator=function()
    {
        var xRange=this.Frame.VerticalRange;
        if (!xRange) return;
        this.Frame.VerticalInfo=[];

        var floatPrecision=2;
        if (this.Symbol) floatPrecision=GetfloatPrecision(this.Symbol);
        var xMax=xRange.Max;
        var xMin=xRange.Min;
        if (xRange.Bid)
        {
            var interval=(xRange.Bid.Max-xMin)/this.SplitCount;
            for(var i=0;i<this.SplitCount;++i)
            {
                var info= new CoordinateInfo();
                info.Value=xMin+(interval*i);
                if (info.Value<=0) continue;
                
                if (IFrameSplitOperator.IsNumber(this.LineType)) info.LineType=this.LineType;
                if (this.ShowText) info.Message[0]=info.Value.toFixed(floatPrecision);
                this.Frame.VerticalInfo.push(info);
            }
        }

        var info=new CoordinateInfo();
        info.Value=xRange.Center;
        //if (IFrameSplitOperator.IsNumber(this.LineType)) info.LineType=this.LineType;
        this.Frame.VerticalInfo.push(info);

        if (xRange.Ask)
        {
            var interval=(xMax-xRange.Ask.Min)/this.SplitCount;
            for(var i=1;i<=this.SplitCount;++i)
            {
                var info= new CoordinateInfo();
                info.Value=xRange.Ask.Min+(interval*i);
                if (IFrameSplitOperator.IsNumber(this.LineType)) info.LineType=this.LineType;
                if (this.ShowText) info.Message[0]=info.Value.toFixed(floatPrecision);
                this.Frame.VerticalInfo.push(info);
            }
        }

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SPLIT_XCOORDINATE);
            if (event && event.Callback)
            {
                var data={ID:this.Frame.Identify, Frame:this.Frame };
                event.Callback(event,data,this);
            }
        }
    }
}

//把X位置调整到有数据上面
function CallAcutionXOperator()
{
    this.Frame;
    this.Value;
    this.Point;
    this.ClientPos;
    this.BeforOpeneData;
    this.AfterCloseData;
    this.X;
    this.Item;
    this.DataIndex;
    this.DayIndex;
    this.MultiDayBeforeOpenData;
    this.MultiDayAfterCloseData;
    this.DayOffset;

    this.Operator=function()
    {
        this.Item=null;
        this.DataIndex=null;
        this.DayIndex=null;

        if (this.ClientPos==2)
        {
            return this.GetBeforeOpenXIndex();
        }
        else if (this.ClientPos==3)
        {
            return this.GetAfterCloseXIndex();
        }
        else if (this.ClientPos>=200 && this.ClientPos<=299)
        {
            return this.GetMultiDayBeforeOpenXIndex();
        }
        else if (this.ClientPos>=300 && this.ClientPos<=399)
        {
            return this.GetMultiDayAfterCloseXIndex();
        }

        return false;
    }

    this.GetBeforeOpenXIndex=function()
    {
        if (!IFrameSplitOperator.IsNumber(this.Value)) return false;
        if (!this.BeforeOpenData || !this.BeforeOpenData.Data) return false;

        var index=this.Frame.GetLeftExtendXData(this.Value, this.BeforeOpenData);
        index=parseInt(index.toFixed(0));

        if (index>=0 && index<this.BeforeOpenData.Data.length)
        {
            var item=this.BeforeOpenData.Data[index];
            if (IFrameSplitOperator.IsNumber(item.Price)) 
            {
                this.Item=item;
                this.X=this.Value;
                this.DataIndex=index;
                return true;
            }
        }

        if (index<0) index=0;
        else if (index>=this.BeforeOpenData.Data.length) index=this.BeforeOpenData.Data.length-1;

        var findIndex=-1;
        for(var i=index; i>=0; --i)
        {
            var item=this.BeforeOpenData.Data[i];
            if (IFrameSplitOperator.IsNumber(item.Price))
            {
                findIndex=i;
                break;
            }
        }

        if (findIndex<0)
        {
            for(var i=index+1; i<this.BeforeOpenData.Data.length;++i)
            {
                var item=this.BeforeOpenData.Data[i];
                if (IFrameSplitOperator.IsNumber(item.Price))
                {
                    findIndex=i;
                    break;
                }
            }
        }

        if (findIndex<0) return false;

        this.Item=item;
        this.DataIndex=findIndex;
        this.X=this.Frame.GetLeftExtendXFromIndex(findIndex, this.BeforeOpenData);  //调整X轴坐标
        return true;
    }

    this.GetMultiDayBeforeOpenData=function()
    {
        if (!this.MultiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData)) return null;
        if (!this.DayOffset) this.MultiDayBeforeOpenData;
        if (!IFrameSplitOperator.IsNumber(this.DayOffset.Offset) || !IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) return null;

        var showCount= this.DayOffset.ShowDayCount;
        var offset=this.DayOffset.Offset;
        var aryData=this.MultiDayBeforeOpenData.slice(offset, offset+showCount);
        return aryData;
    }

    this.GetMultiDayBeforeOpenXIndex=function()
    {
        var multiDayBeforeOpenData=this.GetMultiDayBeforeOpenData();
        if (!multiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(multiDayBeforeOpenData)) return false;
        var dayIndex=this.ClientPos-200;
        if (dayIndex<0 || dayIndex>=multiDayBeforeOpenData.length) return false;

        var dayData=multiDayBeforeOpenData[dayIndex];
        var indexData=this.Frame.GetLeftExtendXData(this.Value, multiDayBeforeOpenData);
        if (!indexData || !IFrameSplitOperator.IsNumber(indexData.DataIndex)) return false;
        var index=parseInt(indexData.DataIndex.toFixed(0));
        var dayIndex=indexData.DayIndex;

        if (index>=0 && index<dayData.Data.length)
        {
            var item=dayData.Data[index];
            if (IFrameSplitOperator.IsNumber(item.Price)) 
            {
                this.Item=item;
                this.X=this.Value;
                this.DataIndex=index;
                this.DayIndex=dayIndex;
                return true;
            }
        }

        if (index<0) index=0;
        else if (index>=dayData.Data.length) index=dayData.Data.length-1;
        var findIndex=-1;
        for(var i=index; i>=0; --i)
        {
            var item=dayData.Data[i];
            if (item && IFrameSplitOperator.IsNumber(item.Price))
            {
                findIndex=i;
                break;
            }
        }

        if (findIndex<0) return false;

        this.Item=item;
        this.DataIndex=findIndex;
        this.DayIndex=dayIndex;
        this.X=this.Frame.GetLeftExtendXFromIndex(findIndex, dayData);  //调整X轴坐标
        return true;
    }

    this.GetAfterCloseXIndex=function()
    {
        if (!IFrameSplitOperator.IsNumber(this.Value)) return false;
        if (!this.AfterCloseData || !this.AfterCloseData.Data) return false;

        var index=this.Frame.GetRightExtendXData(this.Value, this.AfterCloseData);
        index=parseInt(index.toFixed(0));

        if (index>=0 && index<this.AfterCloseData.Data.length)
        {
            var item=this.AfterCloseData.Data[index];
            if (IFrameSplitOperator.IsNumber(item.Price)) 
            {
                this.Item=item;
                this.X=this.Value;
                this.DataIndex=index;
                return true;
            }
        }
        
        if (index<0) index=0;
        else if (index>=this.AfterCloseData.Data.length) index=this.AfterCloseData.Data.length-1;
        var findIndex=-1;
        for(var i=index; i>=0; --i)
        {
            var item=this.AfterCloseData.Data[i];
            if (IFrameSplitOperator.IsNumber(item.Price))
            {
                findIndex=i;
                break;
            }
        }

        if (findIndex<0)
        {
            for(var i=index+1; i<this.AfterCloseData.Data.length;++i)
            {
                var item=this.AfterCloseData.Data[i];
                if (IFrameSplitOperator.IsNumber(item.Price))
                {
                    findIndex=i;
                    break;
                }
            }
        }

        if (findIndex<0) return false;

        this.Item=item;
        this.DataIndex=findIndex;
        this.X=this.Frame.GetRightExtendXFromIndex(findIndex, this.AfterCloseData);  //调整X轴坐标
        return true;
    }

    this.GetMultiDayAfterCloseData=function()
    {
        if (!this.MultiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData)) return null;
        if (!this.DayOffset) this.MultiDayAfterCloseData;
        if (!IFrameSplitOperator.IsNumber(this.DayOffset.Offset) || !IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) return null;

        var showCount= this.DayOffset.ShowDayCount;
        var offset=this.DayOffset.Offset;
        var aryData=this.MultiDayAfterCloseData.slice(offset, offset+showCount);
        return aryData;
    }

    this.GetMultiDayAfterCloseXIndex=function()
    {
        var multiDayAfterCloseData=this.GetMultiDayAfterCloseData();
        if (!multiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(multiDayAfterCloseData)) return;
        var dayIndex=this.ClientPos-300;
        if (dayIndex<0 || dayIndex>=multiDayAfterCloseData.length) return;

        var dayData=multiDayAfterCloseData[dayIndex];
        var indexData=this.Frame.GetRightExtendXData(this.Value, multiDayAfterCloseData);
        if (!indexData) return;
        var index=parseInt(indexData.DataIndex.toFixed(0));
        var dayIndex=indexData.DayIndex;

        if (index>=0 && index<dayData.Data.length)
        {
            var item=dayData.Data[index];
            if (IFrameSplitOperator.IsNumber(item.Price)) 
            {
                this.Item=item;
                this.X=this.Value;
                this.DataIndex=index;
                this.DayIndex=dayIndex;
                return true;
            }
        }

        if (index<0) index=0;
        else if (index>=dayData.Data.length) index=dayData.Data.length-1;
        var findIndex=-1;
        for(var i=index; i>=0; --i)
        {
            var item=dayData.Data[i];
            if (item && IFrameSplitOperator.IsNumber(item.Price))
            {
                findIndex=i;
                break;
            }
        }

        if (findIndex<0) return false;

        this.Item=item;
        this.DataIndex=findIndex;
        this.DayIndex=dayIndex;
        this.X=this.Frame.GetRightExtendXFromIndex(findIndex, dayData);  //调整X轴坐标
        return true;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//十字光标
function ChartCorssCursor()
{
    this.ClassName="ChartCorssCursor";
    this.Frame;
    this.Canvas;                            //画布

    this.HPenColor=g_JSChartResource.CorssCursorHPenColor; //水平线颜色
    this.HPenType=0;  //水平线样式 0=虚线 1=实线

    this.VPenColor=g_JSChartResource.CorssCursorVPenColor; //垂直线颜色
    this.VPenType=0;  //垂直线颜色 0=虚线 1=实线 2=K线宽度
    this.VLineType=0;   //垂直线 0=默认指标标题栏不画， 1=指标标题栏也画

    this.Font=g_JSChartResource.CorssCursorTextFont;            //字体
    this.TextColor=g_JSChartResource.CorssCursorTextColor;      //文本颜色
    this.TextBGColor=g_JSChartResource.CorssCursorBGColor;      //文本背景色
    this.BorderColor=g_JSChartResource.CorssCursorBorderColor;  //边框颜色
    this.XRangeBGColor=g_JSChartResource.CorssCursorXRangeBGColor;
    this.TextHeight=20;                                         //文本字体高度
    this.LastPoint;
    this.CursorIndex;
    this.IsOnlyDrawKLine=false;                                 //是否只能画在K线上 (手机端)
    this.IsOnlyDrawMinute=false;                                //是否只能画在走势图价格线上
    this.IsFixXLastTime=false;                                  //是否修正X轴,超出当前时间的,X轴调整到当前最后的时间.
    this.IsDrawXRangeBG=false;                                  //是否绘制十字光标背景

    this.EnableNewIndex=false;      //分时图是否使用最新的索引结构 (由外部chart容器传入)
    this.CorssCursorIndex;          //分时图新版本的索引结构 (由外部chart容器传入)

    this.PointX;
    this.PointY;

    this.StringFormatX;
    this.StringFormatY;

    this.ShowTextMode={ Left:1, Right:1, Bottom:1 }; //0=不显示  1=显示在框架外 2=显示在框架内
    this.TextFormat= { Right:0 };               //0=默认 1=价格显示(分时图才有用)
    this.IsShowCorss=true;      //是否显示十字光标
    this.IsShow=true;
    this.IsShowClose=false;     //Y轴始终显示收盘价
    this.ClientPos=-1;
    this.CallAcutionXOperator;
    

    this.RightButton=
    { 
        Enable:false, Rect:null, 
        BGColor:g_JSChartResource.CorssCursor.RightButton.BGColor , 
        PenColor:g_JSChartResource.CorssCursor.RightButton.PenColor, 
        Icon:g_JSChartResource.CorssCursor.RightButton.Icon
    };

    this.RightMargin={ Left:2, Right:2, Top:4, Bottom:3 };
    CopyMarginConfig(this.RightMargin, g_JSChartResource.CorssCursor.RightMargin);

    //内部使用
    this.Close=null;     //收盘价格
    this.Status=0;       //当前状态 0=隐藏 1=显示

    this.ReloadResource=function(resource)
    {
        this.Font=g_JSChartResource.CorssCursorTextFont;            //字体

        this.HPenColor=g_JSChartResource.CorssCursorHPenColor; //水平线颜色
        this.VPenColor=g_JSChartResource.CorssCursorVPenColor; //垂直线颜色
        this.TextColor=g_JSChartResource.CorssCursorTextColor;      //文本颜色
        this.TextBGColor=g_JSChartResource.CorssCursorBGColor;      //文本背景色
        this.BorderColor=g_JSChartResource.CorssCursorBorderColor;  //边框颜色
        this.XRangeBGColor=g_JSChartResource.CorssCursorXRangeBGColor;
    }

    this.GetCloseYPoint=function(index)
    {
        if (!this.StringFormatX.Data) return null;
        var data = this.StringFormatX.Data;
        if (!data.Data || data.Data.length <= 0) return null;
        var dataIndex = data.DataOffset + index;
        if (dataIndex >= data.Data.length) dataIndex = data.Data.length - 1;
        if (dataIndex < 0) return null;

        var klineData = data.Data[dataIndex];
        if (!klineData) return null;
        this.Close=klineData.Close;
        var yPoint = this.Frame.GetYFromData(this.Close);
        return yPoint;
    }

    this.GetMinuteCloseYPoint=function(index)
    {
        if (this.EnableNewIndex && this.CorssCursorIndex)
        {
            if (!this.StringFormatX || !this.StringFormatX.GetMinuteCloseYPoint) return null;
            
            var closeData=this.StringFormatX.GetMinuteCloseYPoint(this.CorssCursorIndex);
            if (!closeData) return null;
            
            this.Close=closeData.Price;
            return closeData.Y;
        }
        else
        {

            if (!IFrameSplitOperator.IsNumber(index)) return null;
            index=parseInt(index);
            if (!this.StringFormatX.Data) return null;
            var data = this.StringFormatX.Data;
            if (!data.Data || data.Data.length <= 0) return null;
            var dataIndex = data.DataOffset + index;
            if (dataIndex >= data.Data.length) dataIndex = data.Data.length - 1;
            if (dataIndex < 0) return null;
    
            var close = data.Data[dataIndex];
            if (!IFrameSplitOperator.IsNumber(index)) return null;
            this.Close=close;
            var yPoint = this.Frame.GetYFromData(this.Close);
            return yPoint;
        }
    }

    this.GetDateTimeRange=function(index, option)
    {
        if (!IFrameSplitOperator.IsNumber(index)) return null;
        index=parseInt(index);
        var data = this.StringFormatX.Data;
        if (!data.Data || data.Data.length <= 0) return null;
        var dataIndex = data.DataOffset + index;
        if (dataIndex>=data.Data.length || dataIndex<0) return null;
        if (!this.Frame || !this.Frame.SubFrame[0] || !this.Frame.SubFrame[0].Frame) return null;
        var frame=this.Frame.SubFrame[0].Frame;

        var dataWidth=frame.DataWidth;
        var distanceWidth=frame.DistanceWidth;
        var xPointCount=frame.XPointCount;

        var kItem = data.Data[dataIndex];
        if (!kItem) return null;

        var date=kItem.Date*1000000;
        var time=parseInt(kItem.Time/100)*100;
        var startTime=date+time;
        var endTime=date+time+59;

        var endIndex=dataIndex;
        for(var i=dataIndex; i<data.Data.length; ++i)
        {
            var item=data.Data[i];
            var dateTime=item.Date*1000000+item.Time;
            if (dateTime>endTime) break;
            if (i-data.DataOffset>=xPointCount) break;
            endIndex=i;
        }

        var startIndex=dataIndex;
        for(var i=dataIndex;i>=0 && i>=data.DataOffset;--i)
        {
            var item=data.Data[i];
            var dateTime=item.Date*1000000+item.Time;
            if (dateTime<startTime) break;
            startIndex=i;
        }

        var range={ StartIndex:startIndex, EndIndex:endIndex };

        range.XStart=this.Frame.GetXFromIndex(startIndex-data.DataOffset);
        range.XEnd=this.Frame.GetXFromIndex(endIndex-data.DataOffset);

        range.XStart-=(distanceWidth+dataWidth)/2;
        range.XEnd+=(distanceWidth+dataWidth)/2;

        return range;
    }

    this.FixMinuteLastTimeXPoint=function(index)
    {
        if (!IFrameSplitOperator.IsNumber(index)) return null;
        index=parseInt(index);
        if (!this.StringFormatX.Data) return null;
        var data = this.StringFormatX.Data;
        if (!data.Data || data.Data.length <= 0) return null;
        var dataIndex = data.DataOffset + index;
        if (dataIndex<data.Data.length) return null;

        dataIndex=data.Data.length - 1;
        dataIndex-=data.DataOffset;
        var xPoint=this.Frame.GetXFromIndex(dataIndex);

        return { X:xPoint, Index:dataIndex };
    }

    //返回 -1=不在客户区  1=在主区域  2=左边扩展  3=右边扩展
    this.PtInClient=function(x,y)
    {
        this.Canvas.beginPath();
        if (this.Frame.IsHScreen===true)
        {
            var border=this.Frame.ChartBorder.GetHScreenBorder();
            this.Canvas.rect(border.Left,border.TopEx,border.Right-border.Left,border.BottomEx-border.TopEx);
        }
        else
        {
            var border=this.Frame.ChartBorder.GetBorder();
            this.Canvas.rect(border.LeftEx,border.Top,border.RightEx-border.LeftEx,border.Bottom-border.Top);
        }

        if (this.Canvas.isPointInPath(x,y)) return 1;

        if (this.Frame.ChartBorder.LeftExtendWidth>10)
        {
            this.Canvas.beginPath();
            if (this.Frame.IsHScreen===true)
            {
                this.Canvas.rect(border.Left,border.Top,border.Right-border.Left,border.TopEx-border.Top);
            }
            else
            {
                this.Canvas.rect(border.Left,border.Top,border.LeftEx-border.Left,border.Bottom-border.Top);
            }
    
            if (this.Canvas.isPointInPath(x,y)) return 2;
        }

        if (this.Frame.ChartBorder.RightExtendWidth>10)
        {
            this.Canvas.beginPath();
            if (this.Frame.IsHScreen===true)
            {
                this.Canvas.rect(border.Left,border.BottomEx,border.Right-border.Left,border.Bottom-border.BottomEx);
            }
            else
            {
                this.Canvas.rect(border.RightEx,border.Top,border.Right-border.RightEx,border.Bottom-border.Top);
            }
    
            if (this.Canvas.isPointInPath(x,y)) return 3;
        }
        
        return -1;
    }

    this.GetFontHeight=function(font)
    {
        return GetFontHeight(this.Canvas, font, "擎");
    }

    this.Draw=function()
    {
        this.Status=0;
        this.RightButton.Rect=null;

        if (!this.LastPoint) return;

        this.Close=null;
        var x=this.LastPoint.X;
        var y=this.LastPoint.Y;
        
        var clientPos=this.PtInClient(x,y);

        this.PointY=null;
        this.PointY==null;
        this.ClientPos=clientPos;
        if (clientPos<=0) return;

        if (this.Frame.IsHScreen===true)
        {
            this.HScreenDraw();
            return;
        }

        var border=this.Frame.ChartBorder.GetBorder();
        var left=border.Left
        var right=border.Right;
        var top=border.TopTitle;
        var bottom=border.Bottom;
        var rightWidth=this.Frame.ChartBorder.Right;
        var chartRight=border.ChartWidth;

        if (this.IsOnlyDrawKLine)   //手机端 十字只能画在K线上
        {
            x=this.Frame.GetXFromIndex(this.CursorIndex);
            if (this.IsShowClose)
            {
                var yPoint = this.GetCloseYPoint(this.CursorIndex);
                if (yPoint != null) y=yPoint;
            }
        }
        else if (this.IsOnlyDrawMinute)
        {
            var yPoint = this.GetMinuteCloseYPoint(this.CursorIndex);
            if (yPoint != null) y=yPoint;
        }

        if (this.CallAcutionXOperator)
        {
            this.CallAcutionXOperator.Value=x;
            this.CallAcutionXOperator.Point={X:x, Y:y};
            this.CallAcutionXOperator.ClientPos=clientPos;

            if (this.CallAcutionXOperator.Operator())
            {
                x=this.CallAcutionXOperator.X;
            }
        }

        if (this.IsFixXLastTime)
        {
            var value=this.FixMinuteLastTimeXPoint(this.CursorIndex)
            if (value)
            {
                x=value.X;
                this.CursorIndex=value.Index;
            }
        }

        this.PointY=[[left,y],[right,y]];
        this.PointX=[[x,top],[x,bottom]];

        //十字线
        if (this.IsShowCorss)
        {
            var rangeBG=null;
            if (this.IsDrawXRangeBG)
            {
                rangeBG=this.GetDateTimeRange(this.CursorIndex);
            }

            var pixel=GetDevicePixelRatio();
            if (this.HPenType==1 || this.HPenType==0)   //0=实线 1=虚线
            {
                this.Canvas.strokeStyle=this.HPenColor;
                if (this.HPenType==0) this.Canvas.setLineDash([3*pixel,2*pixel]);   //虚线
                //this.Canvas.lineWidth=0.5
                this.Canvas.beginPath();
                this.Canvas.moveTo(left,ToFixedPoint(y));
                this.Canvas.lineTo(right,ToFixedPoint(y));
                this.Canvas.stroke();
                if (this.HPenType==0) this.Canvas.setLineDash([]);
            }
            
            this.Canvas.save();
            this.Canvas.strokeStyle=this.VPenColor;
            if (this.VPenType==0) 
            {
                this.Canvas.setLineDash([3*pixel,2*pixel]);   //虚线
            }
            else if (this.VPenType==2) 
            {
                let barWidth=this.Frame.SubFrame[0].Frame.DataWidth;    //和K线一样宽度
                if (barWidth>2*pixel) this.Canvas.lineWidth=barWidth;
            }

            this.Canvas.beginPath();
            if (this.VLineType==1)
            {
                if (rangeBG)
                {
                    this.Canvas.fillStyle=this.XRangeBGColor;
                    this.Canvas.fillRect(rangeBG.XStart, border.Top, (rangeBG.XEnd-rangeBG.XStart),(border.Bottom-border.Top));
                }

                this.Canvas.moveTo(ToFixedPoint(x),border.Top);
                this.Canvas.lineTo(ToFixedPoint(x),border.Bottom);
            }
            else
            {
                if (this.Frame.SubFrame.length>0)
                {
                    for(var i in this.Frame.SubFrame)
                    {
                        var frame=this.Frame.SubFrame[i].Frame;
                        var subBorder=frame.ChartBorder.GetBorder();
                        top=subBorder.TopTitle;
                        bottom=subBorder.Bottom;

                        if (rangeBG)
                        {
                            this.Canvas.fillStyle=this.XRangeBGColor;
                            this.Canvas.fillRect(rangeBG.XStart, top, (rangeBG.XEnd-rangeBG.XStart),(bottom-top));
                        }

                        this.Canvas.moveTo(ToFixedPoint(x),top);
                        this.Canvas.lineTo(ToFixedPoint(x),bottom);
                    }
                }
                else
                {
                    this.Canvas.moveTo(ToFixedPoint(x),top);
                    this.Canvas.lineTo(ToFixedPoint(x),bottom);
                }
            }
            
            this.Canvas.stroke();
            this.Canvas.restore();
            
        }

        var xValue=this.Frame.GetXData(x);
        var yValueExtend={};
        var yValue=this.Frame.GetYData(y,yValueExtend);
        if ( (this.IsOnlyDrawMinute || this.IsShowClose) && this.Close != null) yValue=this.Close;

        //this.StringFormatX.Value=xValue;
        this.StringFormatX.Value=this.CursorIndex;
        this.StringFormatX.Point={X:x, Y:y};
        this.StringFormatX.ClientPos=clientPos;

        this.StringFormatY.Value=yValue;
        this.StringFormatY.RValue=yValueExtend.RightYValue; //右侧子坐标
        this.StringFormatY.FrameID=yValueExtend.FrameID;
        this.StringFormatY.Point={X:x, Y:y};
        this.StringFormatY.ClientPos=clientPos;

        this.Canvas.font=this.Font;
        var textHeight=this.GetFontHeight();
        if (textHeight>this.TextHeight) this.TextHeight=textHeight;

        //Y轴
        if ( ((this.ShowTextMode.Left==1 && this.Frame.ChartBorder.Left>=30) || this.ShowTextMode.Left==2 ||
             (this.ShowTextMode.Right==1 && this.Frame.ChartBorder.Right>=30) || this.ShowTextMode.Right==2 ) && this.StringFormatY.Operator() )
        {
            var text=this.StringFormatY.Text;
            this.Canvas.font=this.Font;
            var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素
            var textSize={ Width:textWidth, Height:this.TextHeight, Text:[] };
            var buttonData={Y:y, YValue:yValue, FrameID:yValueExtend.FrameID };
            if (this.Frame.ChartBorder.Left>=30 && this.ShowTextMode.Left==1)
            {
                if (left<textWidth ) //左边空白的地方太少了画布下
                {
                    this.DrawTextBGRect(ToFixedPoint(2),ToFixedPoint(y-this.TextHeight/2),ToFixedRect(textWidth),ToFixedRect(this.TextHeight));
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,2+2,y,textWidth);
                }
                else
                {
                    this.DrawTextBGRect(left-2,y-this.TextHeight/2,-textWidth,this.TextHeight);
                    this.Canvas.textAlign="right";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,left-4,y,textWidth);
                }
            }
            else if (this.ShowTextMode.Left==2) //在框架内显示
            {
                this.DrawTextBGRect(left,y-this.TextHeight/2,textWidth,this.TextHeight);
                this.Canvas.textAlign="left";
                this.Canvas.textBaseline="middle";
                this.Canvas.fillStyle=this.TextColor;
                this.Canvas.fillText(text,left+2,y,textWidth);
            }

            var complexText=
            { 
                ShowType:0, //0=单行(默认)  1=多行 
                Font:this.Font, Color:this.TextColor,
                Text:[ { Text:text, Margin:this.RightMargin } ],
            };

            var yTop=y-this.TextHeight/2;

            if (this.StringFormatY.PercentageText)
            {
                if (this.TextFormat.Right==0)
                {
                    text=this.StringFormatY.PercentageText+'%';
                    complexText.Text[0].Text=text;
                }
            }

            if (this.StringFormatY.RText) 
            {
                text=this.StringFormatY.RText;
                complexText.Text[0].Text=text;
            }

            if (this.StringFormatY.RComplexText && IFrameSplitOperator.IsNonEmptyArray(this.StringFormatY.RComplexText.Text))
            {
                complexText=this.StringFormatY.RComplexText;
                if (!complexText.Font) complexText.Font=this.Font;
                if (!complexText.Color) complexText.Color=this.TextColor;
            }
                
            

            this.CalculateComplexTextSize(complexText, textSize);

            if (this.Frame.ChartBorder.Right>=30 && this.ShowTextMode.Right==1)
            {
                var isOverlayIndex=false;       //是否有叠加子坐标
                var overlayIndexInterval=null;  //子坐标间距
                if (yValueExtend.FrameID>=0)
                {
                    var frame=this.Frame.SubFrame[yValueExtend.FrameID];
                    isOverlayIndex=frame.OverlayIndex.length>0;
                    overlayIndexInterval=null
                    if (isOverlayIndex)
                    {
                        for(var i=0;i<=frame.OverlayIndex.length;++i)
                        {
                            var item=frame.OverlayIndex[i];
                            if (!item || !item.Frame) continue;
                            if (item.Frame.IsShow===false) continue;
                            if (!item.Frame.GetXHorizontal) continue;

                            var overlayLeft=item.Frame.GetXHorizontal();
                            overlayIndexInterval=overlayLeft-right;
                            break;
                        }
                    }
                }

                //叠加坐标
                if (isOverlayIndex && textSize.Width>overlayIndexInterval && overlayIndexInterval>0)   //大于子坐标宽度
                {
                    var drawRight=right+overlayIndexInterval;
                    if (drawRight>chartRight) drawRight=chartRight;

                    var itemLeft=drawRight-2-textSize.Width;
                    this.DrawTextBGRect(itemLeft,yTop,textSize.Width,textSize.Height);
                    this.DrawComplexTextV2(itemLeft, yTop, complexText, textSize);

                    if (this.RightButton.Enable) this.DrawRightButton(yTop, itemLeft,this.TextHeight,this.TextHeight,buttonData);
                }
                else if (rightWidth<textSize.Width)   //右边空白显示不下, 
                {
                    var itemLeft=chartRight-2-textSize.Width;
                    this.DrawTextBGRect(itemLeft,yTop,textSize.Width,textSize.Height);
                    this.DrawComplexTextV2(itemLeft, yTop ,complexText, textSize);
                    
                    if (this.RightButton.Enable) this.DrawRightButton(yTop, chartRight-2-textSize.Width,this.TextHeight,this.TextHeight,buttonData);
                }
                else
                {
                    var itemLeft=right+2;
                    this.DrawTextBGRect(itemLeft,yTop,textSize.Width,textSize.Height);
                    this.DrawComplexTextV2(itemLeft,yTop,complexText,textSize);

                    if (this.RightButton.Enable) this.DrawRightButton(yTop, right+2,this.TextHeight,this.TextHeight,buttonData);
                }

                /*
                if (this.StringFormatY.RExtendText && this.StringFormatY.RExtendText.length>0)
                {
                    var yOffset=0;
                    for(var i in this.StringFormatY.RExtendText)
                    {
                        var item=this.StringFormatY.RExtendText[i];
                        var rText='--.--'
                        if (item.YText) rText=item.YText;
                        else if (IFrameSplitOperator.IsNumber(item.Y)) rText=item.Y.toFixed(0);
                        var rTextWidth=this.Canvas.measureText(rText).width+4;    //前后各空2个像素
                        
                        if (rightWidth<rTextWidth)
                        {
                            this.DrawTextBGRect(chartRight-2-rTextWidth,y+yOffset+this.TextHeight/2,rTextWidth,this.TextHeight);
                            this.Canvas.textAlign="right";
                            this.Canvas.textBaseline="middle";
                            this.Canvas.fillStyle=item.TextColor;
                            this.Canvas.fillText(rText,chartRight-4,y+yOffset+this.TextHeight,rTextWidth);
                        }
                        else
                        {
                            this.DrawTextBGRect(right+2,y+yOffset+this.TextHeight/2,rTextWidth,this.TextHeight);
                            this.Canvas.textAlign="left";
                            this.Canvas.textBaseline="middle";
                            this.Canvas.fillStyle=item.TextColor;
                            this.Canvas.fillText(rText,right+4,y+yOffset+this.TextHeight,rTextWidth);
                        }

                        yOffset+=this.TextHeight;
                    }
                }
                */
            }
            else if (this.ShowTextMode.Right==2)
            {
                this.Canvas.fillStyle=this.TextBGColor;
                var showLeft=right-textSize.Width;
                this.DrawTextBGRect(showLeft,yTop,textSize.Width,textSize.Height);
                this.DrawComplexTextV2(showLeft,yTop,complexText,textSize);

                if (this.RightButton.Enable) this.DrawRightButton(yTop, showLeft,this.TextHeight,this.TextHeight,buttonData);
            }
        }

        //X轴 Bottom==8 自定义
        if ((this.ShowTextMode.Bottom==1 || this.ShowTextMode.Bottom==2 || this.ShowTextMode.Bottom==8) && this.StringFormatX.Operator())
        {
            var text=this.StringFormatX.Text;
            this.Canvas.font=this.Font;
            this.Canvas.fillStyle=this.TextBGColor;
            var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素

            var yCenter=bottom+2+this.TextHeight/2;
            var yTop=bottom+2;
            var bShowText=true;
            if (this.ShowTextMode.Bottom==2)
            {
                yCenter=bottom-this.TextHeight/2-2;
                yTop=bottom-this.TextHeight-2;
            }
            else if (this.ShowTextMode.Bottom==8)
            {
                var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_CORSSCURSOR_POSITION);
                if (event && event.Callback)
                {
                    var sendData={ YCenter:yCenter, YTop:yTop, Height:this.TextHeight, IsShowText:bShowText };
                    event.Callback(event, sendData, this);

                    yCenter=sendData.YCenter;
                    yTop=sendData.YTop;
                    bShowText=sendData.IsShowText;
                }
            }

            //JSConsole.Chart.Log('[ChartCorssCursor::Draw] ',yCenter);
            if (bShowText)
            {
                if (x-textWidth/2<3)    //左边位置不够了, 顶着左边画
                {
                    this.DrawTextBGRect(x-1,yTop,textWidth,this.TextHeight);
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,x+1,yCenter,textWidth);
                }
                else if (x+textWidth/2>=right)
                {
                    this.DrawTextBGRect(right-textWidth,yTop,textWidth,this.TextHeight);
                    this.Canvas.textAlign="right";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,right-2,yCenter,textWidth);
                }
                else
                {
                    this.DrawTextBGRect(x-textWidth/2,yTop,textWidth,this.TextHeight);
                    this.Canvas.textAlign="center";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,x,yCenter,textWidth);
                }
            }
        }

        //子坐标Y轴
        if (yValueExtend.FrameID>=0)
        {
            var frame=this.Frame.SubFrame[yValueExtend.FrameID];
            var overlayLeft=right;
            this.Canvas.font=this.Font;
            for(var i=0; i<frame.OverlayIndex.length; ++i)
            {
                var item=frame.OverlayIndex[i];
                if (item.Frame.IsShow===false) continue;
                if (!item.Frame.GetXHorizontal) continue;

                overlayLeft=item.Frame.GetXHorizontal();

                //if (overlayLeft+30>chartRight) break;
                var yValue=item.Frame.GetYData(y);
                var text=IFrameSplitOperator.FormatValueString(yValue,2);
                var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素
                
                /*
                for(var j=2;j>=0;--j)
                {
                    var text=IFrameSplitOperator.FormatValueString(yValue,j);
                    var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素
                    if (textWidth<frame.Interval) break;
                }
                */

                this.Canvas.fillStyle=this.TextBGColor;
                this.Canvas.fillRect(overlayLeft+1,y-this.TextHeight/2,textWidth,this.TextHeight);
                this.Canvas.textAlign="left";
                this.Canvas.textBaseline="middle";
                this.Canvas.fillStyle=this.TextColor;
                this.Canvas.fillText(text,overlayLeft+4,y,textWidth);
            }
        }

        this.Status=1;
    }

    this.DrawComplexTextV2=function(left, yTop, complexText, size)
    {
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        var showType=0;
        if (complexText.ShowType==1) showType=complexText.ShowType;
        if (showType==1)    //多行
        {
            var xLeft=left;
            var yText=yTop;    //顶
            for(var i=0; i<complexText.Text.length; ++i)
            {
                var item=complexText.Text[i];
                var itemSize=size.Text[i];

                if (item.Font) this.Canvas.font=item.Font;
                else this.Canvas.font=complexText.Font;
                
                if (item.Color) this.Canvas.fillStyle=item.Color;
                else this.Canvas.fillStyle=complexText.Color;

                var y=yText+itemSize.Height;
                var x=xLeft;
                if (item.Margin)
                {
                    var margin=item.Margin;
                    if (IFrameSplitOperator.IsNumber(margin.Bottom)) y-=margin.Bottom;
                    if (IFrameSplitOperator.IsNumber(margin.Left)) x+=margin.Left;
                }

                this.Canvas.fillText(item.Text,x,y,itemSize.Width);
                
                yText+=itemSize.Height;
            }
        }
        else    //水平 单行
        {
            var xText=left;
            var yBottom=yTop+size.Height;
            for(var i=0; i<complexText.Text.length; ++i)
            {
                var item=complexText.Text[i];
                var itemSize=size.Text[i];

                if (item.Font) this.Canvas.font=item.Font;
                else this.Canvas.font=complexText.Font;
                
                if (item.Color) this.Canvas.fillStyle=item.Color;
                else this.Canvas.fillStyle=complexText.Color;

                var y=yBottom;
                var x=xText;
                if (item.Margin)
                {
                    var margin=item.Margin;
                    if (IFrameSplitOperator.IsNumber(margin.Bottom)) y-=margin.Bottom;
                    if (IFrameSplitOperator.IsNumber(margin.Left)) x+=margin.Left;
                }

                this.Canvas.fillText(item.Text,x,y,itemSize.Width);
                
                xText+=itemSize.Width;
            }
        }
    }

    this.CalculateComplexTextSize=function(complexText, size)
    {
        if (!complexText || !IFrameSplitOperator.IsNonEmptyArray(complexText.Text)) return;

        var showType=0;
        if (complexText.ShowType==1) showType=complexText.ShowType;
        if (showType==1)    //多行
        {
            var textWidth=0, textHeight=0;
            for(var i=0; i<complexText.Text.length; ++i)
            {
                var item=complexText.Text[i];
                if (item.Font) this.Canvas.font=item.Font;
                else this.Canvas.font=complexText.Font;
                var itemWidth=this.Canvas.measureText(item.Text).width;    //前后各空2个像素
                var itemHeight=this.Canvas.measureText("擎").width;
                if (item.Margin)
                {
                    var margin=item.Margin;
                    if (IFrameSplitOperator.IsNumber(margin.Left)) itemWidth+=margin.Left;
                    if (IFrameSplitOperator.IsNumber(margin.Right)) itemWidth+=margin.Right;
                    if (IFrameSplitOperator.IsNumber(margin.Top)) itemHeight+=margin.Top;
                    if (IFrameSplitOperator.IsNumber(margin.Bottom)) itemHeight+=margin.Bottom;
                }

                size.Text[i]={ Width:itemWidth, Height:itemHeight };    //保存所有文字的大小信息

                if (textWidth<itemWidth) textWidth=itemWidth;
                textHeight+=itemHeight;
            }

            size.Width=textWidth;
            size.Height=textHeight;
        }
        else    //水平 单行
        {
            var textWidth=0, textHeight=0;
            for(var i=0; i<complexText.Text.length; ++i)
            {
                var item=complexText.Text[i];
                if (item.Font) this.Canvas.font=item.Font;
                else this.Canvas.font=complexText.Font;

                var itemWidth=this.Canvas.measureText(item.Text).width;    //前后各空2个像素
                var itemHeight=this.Canvas.measureText("擎").width;
                if (item.Margin)
                {
                    var margin=item.Margin;
                    if (IFrameSplitOperator.IsNumber(margin.Left)) itemWidth+=margin.Left;
                    if (IFrameSplitOperator.IsNumber(margin.Right)) itemWidth+=margin.Right;
                    if (IFrameSplitOperator.IsNumber(margin.Top)) itemHeight+=margin.Top;
                    if (IFrameSplitOperator.IsNumber(margin.Bottom)) itemHeight+=margin.Bottom;
                }

                size.Text[i]={ Width:itemWidth, Height:itemHeight };    //保存所有文字的大小信息

                textWidth+=itemWidth;
                if (textHeight<itemHeight) textHeight=itemHeight;
            }

            size.Width=textWidth;
            size.Height=textHeight;
        }
    }

    this.DrawRightButton=function(drawTop, drawRight, drawWidth, drawHeight, data)
    {
        this.Canvas.fillStyle=this.RightButton.BGColor;
        var rtButton={Left:drawRight-drawWidth, Top:drawTop, Width:drawWidth, Height:drawHeight };
        rtButton.Right=rtButton.Left+rtButton.Width;
        rtButton.Bottom=rtButton.Top+rtButton.Height;
        this.RightButton.Rect=rtButton;
        this.RightButton.Data=data;
        this.Canvas.fillRect(ToFixedPoint(rtButton.Left+1),ToFixedPoint(rtButton.Top),ToFixedRect(rtButton.Width),ToFixedRect(rtButton.Height));

        var pixelRatio=GetDevicePixelRatio();
        var spaceWidth=3;
        var yCenter=(rtButton.Top+spaceWidth)+(rtButton.Height-spaceWidth*2)/2;
        var xCenter=(rtButton.Left+spaceWidth)+(rtButton.Width-spaceWidth*2)/2;

        if (this.RightButton.Icon)
        {
            var icon=this.RightButton.Icon;
            this.Canvas.font=`${icon.Size*pixelRatio}px ${icon.Family}`;
            this.Canvas.textAlign="center";
            this.Canvas.textBaseline="middle";
            this.Canvas.fillStyle=icon.Color;
            this.Canvas.fillText("\ue6a3",xCenter,yCenter);
        }
        else
        {
            //画加号
            this.Canvas.strokeStyle=this.RightButton.PenColor;
            var x=rtButtom.Left+spaceWidth;
            var y=rtButtom.Top+spaceWidth;
            this.Canvas.save();
            this.Canvas.linewidth=1*pixelRatio;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(x), ToFixedPoint(yCenter));
            this.Canvas.lineTo(ToFixedPoint(x+rtButton.Width-spaceWidth*2), ToFixedPoint(yCenter));

            this.Canvas.moveTo(ToFixedPoint(xCenter),ToFixedPoint(y));
            this.Canvas.lineTo(ToFixedPoint(xCenter), ToFixedPoint(y+rtButton.Height-spaceWidth*2));

            this.Canvas.stroke();
            this.Canvas.restore();
        }
    }

    this.PtInButton=function(x,y)
    {
        if (!this.RightButton.Enable) return null;
        if (!this.RightButton.Rect) return null;

        var rect=this.RightButton.Rect;
        this.Canvas.beginPath();
        this.Canvas.rect(rect.Left,rect.Top,rect.Width,rect.Height);
        if (this.Canvas.isPointInPath(x,y))
        {
            return { Data:this.RightButton.Data, Rect:rect };
        }
    }

    this.DrawTextBGRect=function(x,y, height, width)
    {
        this.Canvas.fillStyle=this.TextBGColor;
        this.Canvas.fillRect(ToFixedPoint(x),ToFixedPoint(y),ToFixedRect(height),ToFixedRect(width));

        if (this.BorderColor) 
        {
            this.Canvas.strokeStyle=this.BorderColor;
            this.Canvas.strokeRect(ToFixedPoint(x),ToFixedPoint(y),ToFixedRect(height),ToFixedRect(width))
        }
    }

    this.HScreenDraw=function()
    {
        var x=this.LastPoint.X;
        var y=this.LastPoint.Y;

        if (this.IsOnlyDrawKLine)   //手机端 十字只能画在K线上
        {
            y=this.Frame.GetXFromIndex(this.CursorIndex);
            if (this.IsShowClose)
            {
                var yPoint = this.GetCloseYPoint(this.CursorIndex);
                if (yPoint != null) x=yPoint;
            }
        }
        else if (this.IsOnlyDrawMinute)
        {
            var yPoint = this.GetMinuteCloseYPoint(this.CursorIndex);
            if (yPoint != null) x=yPoint;
        }

        var border=this.Frame.ChartBorder.GetHScreenBorder();
        var left=border.Left;
        var right=border.Right;
        var top=border.Top;
        var bottom=border.Bottom;
        var bottomWidth=this.Frame.ChartBorder.Bottom;

        if (this.CallAcutionXOperator)
        {
            this.CallAcutionXOperator.Value=y;
            this.CallAcutionXOperator.Point={X:x, Y:y};
            this.CallAcutionXOperator.ClientPos=this.ClientPos;

            if (this.CallAcutionXOperator.Operator())
            {
                y=this.CallAcutionXOperator.X;
            }
        }

        this.PointY=[[left,y],[right,y]];
        this.PointX=[[x,top],[x,bottom]];

        //十字线
        if (this.IsShowCorss)
        {
            var pixel=GetDevicePixelRatio();
            this.Canvas.save();
            this.Canvas.strokeStyle=this.HPenColor;
            if (this.HPenType==0) this.Canvas.setLineDash([3*pixel,2*pixel]);   //虚线

            //画竖线
            this.Canvas.beginPath();
            this.Canvas.moveTo(ToFixedPoint(x),top);
            this.Canvas.lineTo(ToFixedPoint(x),bottom);
            this.Canvas.stroke();
            this.Canvas.restore();

            //画横线
            this.Canvas.save();
            this.Canvas.strokeStyle=this.VPenColor;
            if (this.VPenType==0) 
            {
                this.Canvas.setLineDash([3*pixel,2*pixel]);   //虚线
            }
            else if (this.VPenType==2) 
            {
                let barWidth=this.Frame.SubFrame[0].Frame.DataWidth;    //和K线一样宽度
                if (barWidth>2*pixel) this.Canvas.lineWidth=barWidth;
            }

            this.Canvas.beginPath();
            if (this.VLineType==1)
            {
                this.Canvas.moveTo(left,ToFixedPoint(y));
                this.Canvas.lineTo(right,ToFixedPoint(y));
            }
            else
            {
                if (this.Frame.SubFrame.length>0)
                {
                    for(var i in this.Frame.SubFrame)
                    {
                        var frame=this.Frame.SubFrame[i].Frame;
                        var subBorder=frame.ChartBorder.GetHScreenBorder();
                        this.Canvas.moveTo(subBorder.Left,ToFixedPoint(y));
                        this.Canvas.lineTo(subBorder.RightEx,ToFixedPoint(y));
                    }
                }
                else
                {
                    this.Canvas.moveTo(left,ToFixedPoint(y));
                    this.Canvas.lineTo(right,ToFixedPoint(y));
                }
            }

            this.Canvas.stroke();
            this.Canvas.restore();
        }

        var xValue=this.Frame.GetXData(y);
        var yValueExtend={};
        var yValue=this.Frame.GetYData(x,yValueExtend);

        this.StringFormatX.Value=xValue;
        this.StringFormatX.Point={X:x, Y:y};
        this.StringFormatX.ClientPos=this.ClientPos;

        this.StringFormatY.Value=yValue;
        this.StringFormatY.FrameID=yValueExtend.FrameID;
        this.StringFormatY.RValue=yValueExtend.RightYValue; //右侧子坐标
        this.StringFormatY.Point={X:x, Y:y};
        this.StringFormatY.ClientPos=this.ClientPos;

        this.Canvas.font=this.Font;
        var textHeight=this.GetFontHeight();
        if (textHeight>this.TextHeight) this.TextHeight=textHeight;

        if ( ((this.ShowTextMode.Left==1 && this.Frame.ChartBorder.Top>=30) || this.ShowTextMode.Left==2 ||
            (this.ShowTextMode.Right==1 && this.Frame.ChartBorder.Bottom>=30) || this.ShowTextMode.Right==2) && this.StringFormatY.Operator() )
        {
            var text=this.StringFormatY.Text;
            this.Canvas.font=this.Font;
            var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素

            if (this.Frame.ChartBorder.Top>=30 && this.ShowTextMode.Left==1)
            {
                var xText=x;
                var yText=top;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度
                
                this.Canvas.fillStyle=this.TextBGColor;
                if (top>=textWidth)
                {
                    this.Canvas.fillRect(0,-(this.TextHeight/2),-textWidth,this.TextHeight);
                    this.Canvas.textAlign="right";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,-2,0,textWidth);
                }
                else
                {
                    this.Canvas.fillRect((textWidth-top),-(this.TextHeight/2),-textWidth,this.TextHeight);
                    this.Canvas.textAlign="right";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,(textWidth-top)-2,0,textWidth);
                }

                this.Canvas.restore();
            }
            else if (this.ShowTextMode.Left==2)
            {
                var xText=x;
                var yText=top;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

                this.Canvas.fillStyle=this.TextBGColor;
                this.Canvas.fillRect(0,-(this.TextHeight/2),textWidth,this.TextHeight);
                this.Canvas.textAlign="left";
                this.Canvas.textBaseline="middle";
                this.Canvas.fillStyle=this.TextColor;
                this.Canvas.fillText(text,2,0,textWidth);

                this.Canvas.restore();
            }

            if (this.StringFormatY.RText) 
            {
                text=this.StringFormatY.RText;
                var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素
            }

            if (this.Frame.ChartBorder.Bottom>=30 && this.ShowTextMode.Right==1)
            {
                var xText=x;
                var yText=bottom;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度
                
                this.Canvas.fillStyle=this.TextBGColor;
                if (bottomWidth>textWidth)
                {
                    this.Canvas.fillRect(0,-(this.TextHeight/2),textWidth,this.TextHeight);
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,2,0,textWidth);
                }
                else
                {
                    this.Canvas.fillRect((bottomWidth-textWidth),-(this.TextHeight/2),textWidth,this.TextHeight);
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,(bottomWidth-textWidth)+2,0,textWidth);
                }

                if (this.StringFormatY.RExtendText && this.StringFormatY.RExtendText.length>0)
                {
                    var yOffset=0;
                    for(var i in this.StringFormatY.RExtendText)
                    {
                        var item=this.StringFormatY.RExtendText[i];
                        var rText='--.--'
                        if (item.YText) rText=item.YText;
                        else if (IFrameSplitOperator.IsNumber(item.Y)) rText=item.Y.toFixed(0);
                        var rTextWidth=this.Canvas.measureText(rText).width+4;    //前后各空2个像素
                        
                        this.Canvas.fillStyle=item.TextBGColor;
                        if (bottomWidth>rTextWidth)
                        {
                            this.Canvas.fillRect(0,yOffset+this.TextHeight/2,rTextWidth,this.TextHeight);
                            this.Canvas.textAlign="left";
                            this.Canvas.textBaseline="middle";
                            this.Canvas.fillStyle=item.TextColor;
                            this.Canvas.fillText(rText,2,yOffset+this.TextHeight,rTextWidth);
                        }
                        else
                        {
                            var rTextLeft=bottomWidth-rTextWidth;
                            this.Canvas.fillRect(rTextLeft,yOffset+this.TextHeight/2,rTextWidth,this.TextHeight);
                            this.Canvas.textAlign="left";
                            this.Canvas.textBaseline="middle";
                            this.Canvas.fillStyle=item.TextColor;
                            this.Canvas.fillText(rText,rTextLeft+2,yOffset+this.TextHeight,rTextWidth);
                        }
                        

                        yOffset+=this.TextHeight;
                    }
                }

                this.Canvas.restore();
            }
            else if (this.ShowTextMode.Right==2)
            {
                var xText=x;
                var yText=bottom;
                this.Canvas.save();
                this.Canvas.translate(xText, yText);
                this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

                this.Canvas.fillStyle=this.TextBGColor;
                this.Canvas.fillRect(0,-(this.TextHeight/2),-textWidth,this.TextHeight);
                this.Canvas.textAlign="right";
                this.Canvas.textBaseline="middle";
                this.Canvas.fillStyle=this.TextColor;
                this.Canvas.fillText(text,-2,0,textWidth);

                this.Canvas.restore();
            }
        }

        //X轴 Bottom=8 自定义X轴文字位置
        if ((this.ShowTextMode.Bottom===1 || this.ShowTextMode.Bottom==8) && this.StringFormatX.Operator())
        {
            var text=this.StringFormatX.Text;
            this.Canvas.font=this.Font;

            this.Canvas.fillStyle=this.TextBGColor;
            var textWidth=this.Canvas.measureText(text).width+4;    //前后各空2个像素
            var xText=left;
            var bShowText=true;
            if (this.ShowTextMode.Bottom==8)
            {
                var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_CORSSCURSOR_POSITION);
                if (event && event.Callback)
                {
                    var sendData={ XText:xText, Height:this.TextHeight, IsShowText:bShowText };
                    event.Callback(event, sendData, this);

                    xText=sendData.XText;
                    bShowText=sendData.IsShowText;
                }
            }

            if (bShowText)
            {
                if (y-textWidth/2<3)    //左边位置不够了, 顶着左边画
                {
                    var yText=y;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

                    this.Canvas.fillRect(0,0,textWidth,this.TextHeight);
                    this.Canvas.textAlign="left";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,2,this.TextHeight/2,textWidth);

                    this.Canvas.restore();
                }
                else if (y+textWidth/2>=bottom)
                {
                    var yText=y;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

                    this.Canvas.fillRect(-textWidth,0,textWidth,this.TextHeight);
                    this.Canvas.textAlign="right";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,-2,this.TextHeight/2,textWidth);

                    this.Canvas.restore();
                }
                else
                {
                    var yText=y;
                    this.Canvas.save();
                    this.Canvas.translate(xText, yText);
                    this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

                    this.Canvas.fillRect(-textWidth/2,0,textWidth,this.TextHeight);
                    this.Canvas.textAlign="center";
                    this.Canvas.textBaseline="middle";
                    this.Canvas.fillStyle=this.TextColor;
                    this.Canvas.fillText(text,0,this.TextHeight/2,textWidth);

                    this.Canvas.restore();
                }
            }
        }

        this.Status=1;
    }
}


////////////////////////////////////////////////////////////////////////////////
//深度图十字光标
function DepthChartCorssCursor()
{
    this.Frame;
    this.HQChart;
    this.Canvas;                            //画布
    this.Data;
    this.Symbol;

    this.HPenType=0;  //水平线样式 0=虚线 1=实线
    this.VPenType=0;  //垂直线颜色 0=虚线 1=实线
    this.LineDash=g_JSChartResource.DepthCorss.LineDash;
    this.IsShowTooltip=true;

    this.AskColor=g_JSChartResource.DepthCorss.AskColor.Line;   //卖
    this.BidColor=g_JSChartResource.DepthCorss.BidColor.Line;   //买
    this.LineWidth=g_JSChartResource.DepthCorss.LineWidth;

    this.ClassName="DepthChartCorssCursor";

    this.Tooltip=
    { 
        Border:
        { 
            Top:g_JSChartResource.DepthCorss.Tooltip.Border.Top, 
            Left:g_JSChartResource.DepthCorss.Tooltip.Border.Left, 
            Right:g_JSChartResource.DepthCorss.Tooltip.Border.Right,
            Bottom:g_JSChartResource.DepthCorss.Tooltip.Border.Bottom, 
            ItemSpace: g_JSChartResource.DepthCorss.Tooltip.Border.ItemSpace
        },
        Font:g_JSChartResource.DepthCorss.Tooltip.Font,
        TextColor:g_JSChartResource.DepthCorss.Tooltip.TextColor,
        BGColor:g_JSChartResource.DepthCorss.Tooltip.BGColor
    };    // Width: Height:

    this.Font=g_JSChartResource.CorssCursorTextFont;            //字体
    this.TextColor=g_JSChartResource.CorssCursorTextColor;      //文本颜色
    this.TextBGColor=g_JSChartResource.CorssCursorBGColor;      //文本背景色
    this.TextHeight=20;                                         //文本字体高度
    this.LastPoint;

    this.PointX;
    this.PointY;

    this.StringFormatX;
    this.StringFormatY;

    this.IsShowCorss=true;  //是否显示十字光标
    this.IsShow=true;
    //this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;    //多语言

    this.GetVol=function(price, isAsk)
    {
        if (!this.Data) return null;
        var aryData=isAsk? this.Data.Asks:this.Data.Bids;
        if (!aryData || !Array.isArray(aryData) || aryData.length<=0) return null;

        for(var i in aryData)
        {
            var item=aryData[i];
            if (item.Price==price) return item.Vol;
        }

        return null;
    }

    this.Draw=function()
    {
        this.Status=0;
        if (!this.LastPoint) return;
        if (!this.Data) return;
        if (!this.IsShow) return;

        var x=this.LastPoint.X;
        var y=this.LastPoint.Y;

        var isInClient=false;
        this.Canvas.beginPath();
        this.Canvas.rect(this.Frame.ChartBorder.GetLeft(),this.Frame.ChartBorder.GetTop(),this.Frame.ChartBorder.GetWidth(),this.Frame.ChartBorder.GetHeight());
        isInClient=this.Canvas.isPointInPath(x,y);

        this.PointY=null;
        this.PointY==null;

        if (!isInClient) return;

        if (this.Frame.IsHScreen===true)
        {
            return;
        }

        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var top=this.Frame.ChartBorder.GetTopTitle();
        var bottom=this.Frame.ChartBorder.GetBottom();
        var rightWidth=this.Frame.ChartBorder.Right;
        var chartRight=this.Frame.ChartBorder.GetChartWidth();

        var xValue=this.Frame.GetXData(x);
        var xInfo=this.Frame.GetXFromPrice(xValue); //调整价格到有数据的点上

        if (!xInfo) return;

        var yVol=this.GetVol(xInfo.Price, xInfo.IsAsk);
        y=this.Frame.GetYFromData(yVol);    //调整Y轴, 让它在线段上

        xInfo.Vol=yVol;
        xInfo.Y=y;
        
        this.PointY=[[left,y],[right,y]];
        this.PointX=[[x,top],[x,bottom]];

        if (this.IsShowCorss)
        {
            if (xInfo.IsAsk) this.Canvas.strokeStyle=this.AskColor;
            else this.Canvas.strokeStyle=this.BidColor;
            var lineWidthBackup=this.Canvas.lineWidth;
            var pixel=GetDevicePixelRatio();
            this.Canvas.lineWidth=this.LineWidth*pixel;
            var lineWidth=this.Canvas.lineWidth;

            if (this.HPenType==1 || this.HPenType==0)   //0=实线 1=虚线
            {
                if (this.HPenType==0) this.Canvas.setLineDash(this.LineDash);   //虚线
                var yFix=ToFixedPoint2(lineWidth, y);
                this.Canvas.beginPath();
                this.Canvas.moveTo(left,yFix);
                this.Canvas.lineTo(right,yFix);
                this.Canvas.stroke();
                if (this.HPenType==0) this.Canvas.setLineDash([]);
            }
            
            if (this.VPenType==0) this.Canvas.setLineDash(this.LineDash);   //虚线
            var xFix=ToFixedPoint2(lineWidth, xInfo.X);
            this.Canvas.beginPath();
            this.Canvas.moveTo(xFix,top);
            this.Canvas.lineTo(xFix,bottom);
            this.Canvas.stroke();
            if (this.VPenType==0) this.Canvas.setLineDash([]);

            this.Canvas.lineWidth=lineWidthBackup;
        }

        if (this.HQChart)
        {
            var event=this.HQChart.GetEventCallback(JSCHART_EVENT_ID.ON_DRAW_DEPTH_TOOLTIP);
            if (event)
            {
                event.Callback(event,xInfo,this);
            }
        }

        if (this.IsShowTooltip) 
        {
            var aryText=this.GetFormatTooltip(xInfo);
            this.DrawTooltip(aryText,xInfo);
        }
    }

    //[{Title:, TitleColor:,  Text:, Color:}]
    this.GetFormatTooltip=function(drawData)
    {
        var aryText=[];

        var floatPrecision=2;
        if (this.Symbol) floatPrecision=GetfloatPrecision(this.Symbol); //价格小数位数

        var item= 
        { 
            Title:g_JSChartLocalization.GetText('Depth-Price',this.HQChart.LanguageID),
            TitleColor:this.Tooltip.TextColor,
            Text:drawData.Price.toFixed(floatPrecision),
            Color:this.Tooltip.TextColor
        };
        aryText.push(item);

        var item= 
        { 
            Title:g_JSChartLocalization.GetText('Depth-Sum',this.HQChart.LanguageID),
            TitleColor:this.Tooltip.TextColor,
            Text:drawData.Vol.toFixed(4),
            Color:this.Tooltip.TextColor
        };
        aryText.push(item);

        return aryText;
    }
    

    this.DrawTooltip=function(aryText, data)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryText)) return;

        this.Canvas.font=this.Tooltip.Font;
        var maxWidth=0, lineCount=0, itemCount=0;
        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            if (!item) continue;

            var isVaild=false;
            if (item.Title)
            {
                var textWidth=this.Canvas.measureText(item.Title).width;
                if (maxWidth<textWidth) maxWidth=textWidth;
                ++lineCount;
                isVaild=true;
            }

            if (item.Text)
            {
                var textWidth=this.Canvas.measureText(item.Text).width;
                if (maxWidth<textWidth) maxWidth=textWidth;
                ++lineCount;
                isVaild=true;
            }

            if (isVaild) ++itemCount;
        }

        if (maxWidth<=0 || lineCount<=0) return;

        this.Tooltip.LineHeight=this.Canvas.measureText("擎").width+2;
        var pixel=GetDevicePixelRatio();
        var border=this.Tooltip.Border;

        this.Tooltip.Width=maxWidth+(border.Left+border.Right)*pixel;
        this.Tooltip.Height=this.Tooltip.LineHeight*lineCount + (border.Top+border.Bottom)*pixel + (border.ItemSpace*pixel)*(itemCount-1)

        var chartRight=this.Frame.ChartBorder.GetRight();
        var chartTop=this.Frame.ChartBorder.GetTop();

        var left=data.X;
        var top=data.Y-this.Tooltip.Height
        if (left+this.Tooltip.Width>=chartRight) left=data.X-this.Tooltip.Width;
        if (top<chartTop) top=data.Y;

        this.Canvas.fillStyle=this.Tooltip.BGColor;
        this.Canvas.fillRect(left,top,this.Tooltip.Width,this.Tooltip.Height);

        this.Canvas.textBaseline="top";
        this.Canvas.textAlign="left";
        var x=border.Left*pixel+left;
        var y=border.Top*pixel+top;
        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            var isVaild=false;
            if (item.Title)
            {
                if (item.TitleColor) this.Canvas.fillStyle=item.TitleColor;
                else this.Canvas.fillStyle=this.Tooltip.TextColor;
                this.Canvas.fillText(item.Title,x,y);
                y+=this.Tooltip.LineHeight;
                isVaild=true;
            }

            if (item.Text)
            {
                if (item.Color) this.Canvas.fillStyle=item.Color;
                else this.Canvas.fillStyle=this.Tooltip.TextColor;

                this.Canvas.fillText(item.Text,x,y);
                y+=this.Tooltip.LineHeight;
                isVaild=true;
            }

            if (isVaild) y+=border.ItemSpace*pixel;
        }

       
    }

    this.PtInButton=function(x,y)
    {
        return null;
    }
}
////////////////////////////////////////////////////////////////////////////////
// 等待提示
function ChartSplashPaint()
{
    this.Frame;
    this.Canvas;                            //画布
    this.Font=g_JSChartResource.SplashScreen.Font;                  //字体
    this.TextColor=g_JSChartResource.SplashScreen.TextColor;        //文本颜色
    this.IsEnableSplash=false;
    this.SplashTitle='数据加载中';
    this.HQChart;
    this.Position=0;    //显示位置  0=中间  1=第1个窗口中间

    this.EnableSplash=function(bEnable)
    {
        this.IsEnableSplash=bEnable;
        if (this.HQChart)
        {
            var event=this.HQChart.GetEventCallback(JSCHART_EVENT_ID.ON_ENABLE_SPLASH_DRAW);
            if (event)
            {
                var data={ Enable:bEnable };
                event.Callback(event,data,this);
            }
        }
    }

    this.SetTitle=function(title)
    {
        this.SplashTitle=title;
    }

    this.Draw=function()
    {
        if (!this.IsEnableSplash) return;

        if (this.Frame.IsHScreen===true)
        {
            this.HScreenDraw();
            return;
        }

        var xCenter=null, yCenter=null;

        if (this.Position==1)
        {
            if (this.HQChart.Frame && this.HQChart.Frame.SubFrame && this.HQChart.Frame.SubFrame[0])
            {
                var frame=this.HQChart.Frame.SubFrame[0].Frame;
                if (frame)
                {
                    xCenter = (frame.ChartBorder.GetLeft() + frame.ChartBorder.GetRight()) / 2;
                    yCenter = (frame.ChartBorder.GetTop() + frame.ChartBorder.GetBottom()) / 2;
                }
            }
        }

        if (!IFrameSplitOperator.IsNumber(xCenter) || !IFrameSplitOperator.IsNumber(yCenter))
        {
            var xCenter = (this.Frame.ChartBorder.GetLeft() + this.Frame.ChartBorder.GetRight()) / 2;
            var yCenter = (this.Frame.ChartBorder.GetTop() + this.Frame.ChartBorder.GetBottom()) / 2;
        }

        
        this.Canvas.textAlign='center';
        this.Canvas.textBaseline='middle';
        this.Canvas.fillStyle=this.TextColor;
        this.Canvas.font=this.Font;
        this.Canvas.fillText(this.SplashTitle,xCenter,yCenter);
    }

    this.HScreenDraw=function() //横屏
    {
        var xCenter = (this.Frame.ChartBorder.GetLeft() + this.Frame.ChartBorder.GetRight()) / 2;
        var yCenter = (this.Frame.ChartBorder.GetTop() + this.Frame.ChartBorder.GetBottom()) / 2;

        this.Canvas.save();
        this.Canvas.translate(xCenter, yCenter);
        this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

        this.Canvas.textAlign='center';
        this.Canvas.textBaseline='middle';
        this.Canvas.fillStyle=this.TextColor;
        this.Canvas.font=this.Font;
        this.Canvas.fillText(this.SplashTitle,0,0);

        this.Canvas.restore();
    }
}

/////////////////////////////////////////////////////////////////////////////////
//

function IChangeStringFormat()
{
    this.Data;
    this.Value;     //数据
    this.Text;      //输出字符串

    this.Operator=function()
    {
        return false;
    }


    //多日分时图 集合竞价数据
    this.GetMultiDayBeforeOpenData=function()
    {
        if (!this.MultiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData)) return null;
        if (!this.DayOffset) this.MultiDayBeforeOpenData;
        if (!IFrameSplitOperator.IsNumber(this.DayOffset.Offset) || !IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) return null;

        var showCount= this.DayOffset.ShowDayCount;
        var offset=this.DayOffset.Offset;
        var aryData=this.MultiDayBeforeOpenData.slice(offset, offset+showCount);
        return aryData;
    }

    this.GetMultiDayAfterCloseData=function()
    {
        if (!this.MultiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData)) return null;
        if (!this.DayOffset) this.MultiDayAfterCloseData;
        if (!IFrameSplitOperator.IsNumber(this.DayOffset.Offset) || !IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) return null;

        var showCount= this.DayOffset.ShowDayCount;
        var offset=this.DayOffset.Offset;
        var aryData=this.MultiDayAfterCloseData.slice(offset, offset+showCount);
        return aryData;
    }
}

//数值放大
var ZOOM_VALUE= [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000];

function HQPriceStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Symbol;
    this.FrameID;
    this.Frame;
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.YClose;            //收盘价
    this.PercentageText;    //百分比
    this.RValue;            //右边值
    this.RText;
    this.RComplexText;      //{ Space:2 间距, Text:[ {Color:, Text: }] }  支持单行多颜色
    this.Point;
    this.ClientPos=-1;

    this.ExtendChartPaint;
    this.RExtendText=[];
    this.BeforeOpenData;
    this.AfterCloseData;
    this.MultiDayBeforeOpenData;
    this.MultiDayAfterCloseData;
    this.ShareAfterVol=0;    //1=主图共享 2=盘前共享

    this.PriceFormatType=0; //主窗口格式    0=默认 1=科学计数
    this.DataFormatType=0;  //副图指标格式   0=默认 1=科学计数

    this.GetEventCallback

    //盘前集合竞价
    this.GetBeforeOpen=function()
    {
        if (!this.Frame) return false;

        var item=this.Frame.SubFrame[this.FrameID];
        if (!item || !item.Frame) return false;
        if (!this.BeforeOpenData) return false;

        var range={ Max:this.BeforeOpenData.VolMax, Min:this.BeforeOpenData.VolMin };
        var y=this.Frame.IsHScreen? this.Point.X: this.Point.Y;
        var value=item.Frame.GetLeftExtendYData(y,false,{ Range:range } );
        var defaultfloatPrecision=2;     //价格小数位数 
        if (IFrameSplitOperator.IsNumber(value))  
        {
            this.RText=this.Text=IFrameSplitOperator.FormatValueString(value,defaultfloatPrecision,this.LanguageID);
        }
    }

    //收盘集合竞价
    this.GetAfterClose=function()
    {
        if (!this.Frame) return false;

        var item=this.Frame.SubFrame[this.FrameID];
        if (!item || !item.Frame) return false;
        if (!this.AfterCloseData) return false;

        var range={ Max:this.AfterCloseData.VolMax, Min:this.AfterCloseData.VolMin };
        var y=this.Frame.IsHScreen? this.Point.X: this.Point.Y;
        var value=item.Frame.GetRightExtendYData(y,false,{ Range:range } );
        var defaultfloatPrecision=2;     //价格小数位数 
        if (IFrameSplitOperator.IsNumber(value))  
        {
            this.RText=this.Text=IFrameSplitOperator.FormatValueString(value,defaultfloatPrecision,this.LanguageID);
        }
    }

    this.GetMultiDayBeforeOpen=function()
    {
        if (!this.Frame) return false;
        var item=this.Frame.SubFrame[this.FrameID];
        if (!item || !item.Frame) return false;
        var multiDayBeforeOpenData=this.GetMultiDayBeforeOpenData();
        if (!multiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(multiDayBeforeOpenData)) return;
        var dayIndex=this.ClientPos-200;
        if (dayIndex<0 || dayIndex>=multiDayBeforeOpenData.length) return false;
        var dayData=multiDayBeforeOpenData[dayIndex];
        var range={ Max:dayData.VolMax, Min:dayData.VolMin };
        var y=this.Frame.IsHScreen? this.Point.X: this.Point.Y;
        var value=item.Frame.GetLeftExtendYData(y,false,{ Range:range } );
        var defaultfloatPrecision=2;     //价格小数位数 
        if (IFrameSplitOperator.IsNumber(value))  
        {
            this.RText=this.Text=IFrameSplitOperator.FormatValueString(value,defaultfloatPrecision,this.LanguageID);
        }
    }

    this.GetMultiDayAfterClose=function()
    {
        if (!this.Frame) return false;
        var item=this.Frame.SubFrame[this.FrameID];
        if (!item || !item.Frame) return false;
        var multiDayAfterCloseData=this.GetMultiDayAfterCloseData();
        if (!multiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(multiDayAfterCloseData)) return;
        var dayIndex=this.ClientPos-300;
        if (dayIndex<0 || dayIndex>=multiDayAfterCloseData.length) return false;
        var dayData=multiDayAfterCloseData[dayIndex];   
        
        var range={ Max:dayData.VolMax, Min:dayData.VolMin };
        var y=this.Frame.IsHScreen? this.Point.X: this.Point.Y;
        var value=item.Frame.GetRightExtendYData(y,false,{ Range:range } );
        var defaultfloatPrecision=2;     //价格小数位数 
        if (IFrameSplitOperator.IsNumber(value))  
        {
            this.RText=this.Text=IFrameSplitOperator.FormatValueString(value,defaultfloatPrecision,this.LanguageID);
        }
    }

    this.Operator=function()
    {
        this.RText=null;
        this.RComplexText=null;
        this.RExtendText=[];
        if (IFrameSplitOperator.IsString(this.RValue)) this.RText=this.RValue;
        if (!this.Value) return false;

        this.PercentageText=null;
        var defaultfloatPrecision=2;     //价格小数位数 
        if (this.FrameID==0)    //第1个窗口显示原始价格
        {
            var defaultfloatPrecision=GetfloatPrecision(this.Symbol);
            if (this.PriceFormatType==1)
                this.Text=IFrameSplitOperator.FormatValueThousandsString(this.Value,defaultfloatPrecision);
            else 
                this.Text=this.Value.toFixed(defaultfloatPrecision);

            if (this.YClose>0) this.PercentageText=((this.Value-this.YClose)*100/this.YClose).toFixed(2);   //走势图右边坐标显示百分比

            this.GetExtendPaintData(defaultfloatPrecision);
        }
        else if (this.FrameID==1)
        {
            if (this.DataFormatType==1)
            {
                this.Text=IFrameSplitOperator.FormatValueThousandsString(this.Value,defaultfloatPrecision);
                if (IFrameSplitOperator.IsNumber(this.RValue)) this.RText=IFrameSplitOperator.FormatValueString(this.RValue,defaultfloatPrecision,this.LanguageID);
            }
            else
            {
                this.Text=IFrameSplitOperator.FormatValueString(this.Value,defaultfloatPrecision,this.LanguageID);
                if (IFrameSplitOperator.IsNumber(this.RValue)) this.RText=IFrameSplitOperator.FormatValueString(this.RValue,defaultfloatPrecision,this.LanguageID);
            }
            
            if (this.ClientPos==2) 
            {
                this.GetBeforeOpen();
            }
            else if (this.ClientPos==3)
            {
                if (this.ShareAfterVol==0 || this.ShareAfterVol==2) 
                    this.GetAfterClose();
            }
            else if (this.ClientPos>=200 && this.ClientPos<=299) 
            {
                this.GetMultiDayBeforeOpen();
            }
            else if (this.ClientPos>=300 && this.ClientPos<=399 ) 
            {
                if (this.ShareAfterVol==0 || this.ShareAfterVol==2)
                    this.GetMultiDayAfterClose();
            }
        }
        else
        {
            if (this.DataFormatType==1) this.Text=IFrameSplitOperator.FormatValueThousandsString(this.Value,defaultfloatPrecision);
            else this.Text=IFrameSplitOperator.FormatValueString(this.Value,defaultfloatPrecision,this.LanguageID);
            if (IFrameSplitOperator.IsNumber(this.RValue)) this.RText=IFrameSplitOperator.FormatValueString(this.RValue,defaultfloatPrecision,this.LanguageID);
        }

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_CORSSCURSOR_Y_TEXT);
            if (event)
            {
                var data={ Value:this.Value, FrameID:this.FrameID, PreventDefault:false };
                event.Callback(event,data,this);
                if (data.PreventDefault==true) return false;
            }
        }

        return true;
    }

    //深度图刻度
    this.GetExtendPaintData=function(floatPrecision)
    {
        var value=parseInt(this.Value*ZOOM_VALUE[floatPrecision]);
        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName=='DepthMapPaint' && item.FrameID==this.FrameID)
            {
                var aryData=item.GetYValueByXValue(value,floatPrecision);
                for(var j in aryData)
                {
                    this.RExtendText.push(aryData[j]);
                }
            }
        }
    }
}

function HQDateStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.DateFormatType=0;  //0=YYYY-MM-DD 1=YYYY/MM/DD  2=YYYY/MM/DD/W 3=DD/MM/YYYY
    this.LanguageID=0;

    this.Operator=function()
    {
        if (!IFrameSplitOperator.IsNumber(this.Value)) return false;
        if (!this.Data) return false;

        var index=this.Value;
        index=parseInt(index.toFixed(0));
        if (this.Data.DataOffset+index>=this.Data.Data.length) return false;
        var currentData = this.Data.Data[this.Data.DataOffset+index];
        var dateFormatString="YYYY-MM-DD";
        if (this.DateFormatType==1) dateFormatString="YYYY/MM/DD";
        else if (this.DateFormatType==2) dateFormatString="YYYY/MM/DD/W";
        else if (this.DateFormatType==3) dateFormatString="DD/MM/YYYY";
        this.Text=IFrameSplitOperator.FormatDateString(currentData.Date, dateFormatString,this.LanguageID);
        if (ChartData.IsMinutePeriod(this.Data.Period,true) ) // 分钟周期
        {
            var time = IFrameSplitOperator.FormatTimeString(currentData.Time);
            this.Text = this.Text + "  " + time;
        }
        else if (ChartData.IsSecondPeriod(this.Data.Period))
        {
            var time = IFrameSplitOperator.FormatTimeString(currentData.Time,'HH:MM:SS');
            this.Text = this.Text + "  " + time;
        }
        else if (ChartData.IsMilliSecondPeriod(this.Data.Period))
        {
            var time = IFrameSplitOperator.FormatTimeString(currentData.Time,'HH:MM:SS.fff');
            this.Text = this.Text + "  " + time;
        }
        else if (ChartData.IsTickPeriod(this.Data.Period))  //分笔
        {
            var time = IFrameSplitOperator.FormatTimeString(currentData.Time);
            this.Text = this.Text + "  " + time;
        }

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_CORSSCURSOR_X_TEXT);
            if (event)
            {
                var data={ Item:currentData, Period:this.Data.Period, Date:currentData.Date, Time:currentData.Time,Index:this.Data.DataOffset+index, PreventDefault:false };
                event.Callback(event,data,this);

                if (data.PreventDefault==true) return false;
            }
        }

        return true;
    }
}

function HQMinuteTimeStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="HQMinuteTimeStringFormat";
    this.Frame;
    this.Symbol;
    this.Point;
    this.ClientPos=-1;
    this.BeforeOpenData;    //单日分时图 盘前数据
    this.AfterCloseData;    //单日分时图 收盘数据

    this.MultiDayBeforeOpenData;    //多日分时图 盘前数据
    this.MultiDayAfterCloseData;    //多日分时图 收盘数据

    this.GetEventCallback

    this.GetBeforeOpen=function()
    {
        if (!this.BeforeOpenData || !this.BeforeOpenData.Data) return false;

        var x=this.Frame.IsHScreen==true?this.Point.Y:this.Point.X;
        var index=this.Frame.GetLeftExtendXData(x, this.BeforeOpenData);
        index=parseInt(index.toFixed(0));
        if (index>=this.BeforeOpenData.Data.length) return false;

        var item=this.BeforeOpenData.Data[index];
        this.Text=this.FormatCallAcutionDateTime(item, this.BeforeOpenData);

        return true;
    }

    this.GetAfterClose=function()
    {
        if (!this.AfterCloseData || !this.AfterCloseData.Data) return false;

        var x=this.Frame.IsHScreen==true?this.Point.Y:this.Point.X;
        var index=this.Frame.GetRightExtendXData(x, this.AfterCloseData);
        index=parseInt(index.toFixed(0));
        if (index>=this.AfterCloseData.Data.length) return false;

        var item=this.AfterCloseData.Data[index];
        this.Text=this.FormatCallAcutionDateTime(item, this.AfterCloseData);

        return true;
    }


    this.GetMultiDayBeforeOpen=function()
    {
        var multiDayBeforeOpenData=this.GetMultiDayBeforeOpenData();
        if (!multiDayBeforeOpenData) return false;
        if (this.Frame.ChartBorder.MultiDayMinute.Count<=1 || this.Frame.ChartBorder.MultiDayMinute.Left<=0) return false;

        var x=this.Frame.IsHScreen==true?this.Point.Y:this.Point.X;
        var index=this.Frame.GetLeftExtendXData(x, multiDayBeforeOpenData);
        if (!index) return false;

        if (index.DayIndex>=multiDayBeforeOpenData.length) return false;
        var dayItem=multiDayBeforeOpenData[index.DayIndex];
        index.DataIndex=parseInt(index.DataIndex.toFixed(0));
        if (index.DataIndex>=dayItem.Data.length || index.DataIndex<0) return false;

        var item=dayItem.Data[index.DataIndex];
        this.Text=this.FormatCallAcutionDateTime(item, dayItem);

        return true;
    }

    this.GetMultiDayAfterClose=function()
    {
        var multiDayAfterCloseData=this.GetMultiDayAfterCloseData();
        if (!multiDayAfterCloseData) return false;
        if (this.Frame.ChartBorder.MultiDayMinute.Count<=1 || this.Frame.ChartBorder.MultiDayMinute.Right<=0) return false;

        var x=this.Frame.IsHScreen==true?this.Point.Y:this.Point.X;
        var index=this.Frame.GetRightExtendXData(x, multiDayAfterCloseData);
        if (!index) return false;
        if (index.DayIndex>=multiDayAfterCloseData.length) return false;
        var dayItem=multiDayAfterCloseData[index.DayIndex];
        index.DataIndex=parseInt(index.DataIndex.toFixed(0));
        if (index.DataIndex>=dayItem.Data.length) return false;

        var item=dayItem.Data[index.DataIndex];
        this.Text=this.FormatCallAcutionDateTime(item, dayItem);

        return true;
    }

    this.FormatCallAcutionDateTime=function(item, callAcutionData)
    {
        var time=item.Time;
        if (callAcutionData.Ver==1.0) 
            return IFrameSplitOperator.FormatTimeString(time,"HH:MM");
        else 
            return IFrameSplitOperator.FormatTimeString(time,"HH:MM:SS");
    }

    this.Operator=function()
    {
        if (this.ClientPos==2) return this.GetBeforeOpen();
        else if (this.ClientPos==3) return this.GetAfterClose();
        else if (this.ClientPos>=200 && this.ClientPos<=299) return this.GetMultiDayBeforeOpen();
        else if (this.ClientPos>=300 && this.ClientPos<=399) return this.GetMultiDayAfterClose();

        if (!IFrameSplitOperator.IsNumber(this.Value)) return false;
        
        var index=Math.abs(this.Value);
        index=parseInt(index.toFixed(0));
        var showIndex=index;
        if (this.Frame && this.Frame.MinuteCount) showIndex=index%this.Frame.MinuteCount;

        var timeStringData=g_MinuteTimeStringData;
        var timeData=timeStringData.GetTimeData(this.Symbol);
        if (!timeData) return false;

        if (showIndex<0) showIndex=0;
        else if (showIndex>timeData.length) showIndex=timeData.length-1;
        if (this.Frame && index>=this.Frame.XPointCount) 
            showIndex=timeData.length-1;

        var time=timeData[showIndex];
        this.Text=IFrameSplitOperator.FormatTimeString(time);

        if (this.GetEventCallback)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_CORSSCURSOR_X_TEXT);
            if (event)
            {
                var data={ Time:time, Index:showIndex, PreventDefault:false };
                event.Callback(event,data,this);

                if (data.PreventDefault==true) return false;
            }
        }

        return true;
    }

    this.GetMinuteCloseYPoint=function(cursorIndexData)
    {
        var type=cursorIndexData.Type;
        if (type==1 || type==2 || type==3)  //单日  1=主图 2=盘前 3=盘后
        {
            if (type==1)
            {
                if (!this.Data || this.Data.Data.length <= 0) return null;
                var index=cursorIndexData.DataIndex;
                if (index<0 || index>=this.Data.Data.length) index=this.Data.Data.length-1;

                var close = this.Data.Data[index];
                var yPoint = this.Frame.GetYFromData(close);
                return { Price:close, Y:yPoint };
            }
            else if (type==2)
            {
                if (!this.BeforeOpenData || !this.BeforeOpenData.Data) return false;
                if (cursorIndexData.DataIndex<0 || cursorIndexData.DataIndex>=this.BeforeOpenData.Data.length) return null;
                var item=this.BeforeOpenData.Data[cursorIndexData.DataIndex];

                var close=item.Price;
                var yPoint = this.Frame.GetYFromData(close);
                return { Price:close, Y:yPoint };
            }
            else if (type==3)
            {
                if (!this.AfterCloseData || !this.AfterCloseData.Data) return false;
                if (cursorIndexData.DataIndex<0 || cursorIndexData.DataIndex>=this.AfterCloseData.Data.length) return null;
                var item=this.AfterCloseData.Data[cursorIndexData.DataIndex];

                var close=item.Price;
                var yPoint = this.Frame.GetYFromData(close);
                return { Price:close, Y:yPoint };
            }
        }
        else if (type==10 || type==20 || type==30)  //多日  10=主图 20=盘前 30=盘后
        {
            if (type==10)
            {
                if (!this.Data || this.Data.Data.length <= 0) return null;
                var index=this.Frame.MinuteCount*cursorIndexData.DayIndex+cursorIndexData.DataIndex;
                if (index<0 || index>=this.Data.Data.length) index=this.Data.Data.length-1;

                var close = this.Data.Data[index];
                var yPoint = this.Frame.GetYFromData(close);
                return { Price:close, Y:yPoint };
            }
            else if (type==20)
            {
                var multiDayBeforeOpenData=this.GetMultiDayBeforeOpenData();
                if (!multiDayBeforeOpenData) return null;
                if (cursorIndexData.DayIndex<0 || cursorIndexData.DayIndex>=multiDayBeforeOpenData.length) return null;

                var dayItem=multiDayBeforeOpenData[cursorIndexData.DayIndex];
                if (cursorIndexData.DataIndex<0 || cursorIndexData.DataIndex>=dayItem.Data.length) return null;
                var item=dayItem.Data[cursorIndexData.DataIndex];

                var close=item.Price;
                var yPoint = this.Frame.GetYFromData(close);
                return { Price:close, Y:yPoint };
            }
            else if (type==30)
            {
                var multiDayAfterCloseData=this.GetMultiDayAfterCloseData();
                if (!multiDayAfterCloseData) return null;
                if (cursorIndexData.DayIndex<0 || cursorIndexData.DayIndex>=multiDayAfterCloseData.length) return null;

                var dayItem=multiDayAfterCloseData[cursorIndexData.DayIndex];
                if (cursorIndexData.DataIndex<0 || cursorIndexData.DataIndex>=dayItem.Data.length) return null;
                var item=dayItem.Data[cursorIndexData.DataIndex];

                var close=item.Price;
                var yPoint = this.Frame.GetYFromData(close);
                return { Price:close, Y:yPoint };
            }
        }


        return null;
    }
}


//行情tooltip提示信息格式
var WEEK_NAME=["日","一","二","三","四","五","六"];
function HistoryDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName="HistoryDataStringFormat";

    this.Symbol;
    this.UpColor=g_JSChartResource.UpTextColor;
    this.DownColor=g_JSChartResource.DownTextColor;
    this.UnchagneColor=g_JSChartResource.UnchagneTextColor;

    this.VolColor=g_JSChartResource.Title.VolColor;
    this.AmountColor=g_JSChartResource.Title.AmountColor;
    this.TurnoverRateColor=g_JSChartResource.Title.TurnoverRateColor;
    this.PositionColor=g_JSChartResource.Title.PositionColor;
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.LineCount=0;                   //一共几行
    this.LineHeight=g_JSChartResource.PCTooltip.LineHeight;                 //单行高度
    this.Width=157;                     //宽度
    this.Height=this.LineHeight*5;      //高度
    

    this.Operator=function()
    {
        var data=this.Value.Data;
        if (!data) return false;

        this.Width=157;
        if (this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID) this.Width=180;
        var titleData=this.GetFormatTitle(data);
        if (!titleData) return false;
        var outData=this.GenerateTitleHtml(titleData);
        if (!outData) return false;

        this.Text=outData.Html;
        this.Height=outData.LineCount*this.LineHeight;
        return true;

        /*
        var date=new Date(parseInt(data.Date/10000),(data.Date/100%100-1),data.Date%100);
        var strDate=IFrameSplitOperator.FormatDateString(data.Date);
        var title2=g_JSChartLocalization.GetText(WEEK_NAME[date.getDay()],this.LanguageID);
        var isTickPeriod=ChartData.IsTickPeriod(this.Value.ChartPaint.Data.Period);
        if (ChartData.IsMinutePeriod(this.Value.ChartPaint.Data.Period,true)) // 分钟周期
        {
            title2=IFrameSplitOperator.FormatTimeString(data.Time);
        }
        else if (ChartData.IsSecondPeriod(this.Value.ChartPaint.Data.Period) || isTickPeriod)
        {
            title2=IFrameSplitOperator.FormatTimeString(data.Time,'HH:MM:SS');
        }

        var upperSymbol=this.Symbol.toUpperCase();
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数
        var increase=null;
        if (data.YClose>0) increase=(data.Close-data.YClose)/data.YClose*100;
        if (isTickPeriod)
        {
            var strText=
            "<span class='tooltip-title'>"+strDate+"&nbsp&nbsp"+title2+"</span>"+
            "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Price',this.LanguageID)+"</span>"+
            "<span class='tooltip-num' style='color:"+this.GetColor(data.Open,data.YClose)+";'>"+data.Open.toFixed(defaultfloatPrecision)+"</span><br/>"+
            "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Increase',this.LanguageID)+"</span>"+
            (increase==null? "<span class='tooltip-num' style='color:"+this.GetColor(0,0)+";'>"+'--'+"</span><br/>" :
            "<span class='tooltip-num' style='color:"+this.GetColor(increase,0)+";'>"+increase.toFixed(2)+'%'+"</span><br/>");

            this.LineCount=4;
        }
        else if (data.IsNonTrade)   //非交易日就显示日期
        {
            var strText= `<span class='tooltip-title'>${strDate}&nbsp&nbsp${title2}</span>`;
            this.LineCount=2;
        }
        else
        {
            var vol=data.Vol;
            if (upperSymbol && MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) vol/=100; //A股统一转成手
            var eventUnchangeKLine=null;    //定制平盘K线颜色事件
            if (this.GetEventCallback) eventUnchangeKLine=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_UNCHANGE_KLINE_TITLE_COLOR);
            var strText=
                "<span class='tooltip-title'>"+strDate+"&nbsp&nbsp"+title2+"</span>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Open',this.LanguageID)+"</span>"+
                "<span class='tooltip-num' style='color:"+this.GetPriceColor("DivTooltip-Open",data.Open,data.YClose,data,eventUnchangeKLine)+";'>"+ (IFrameSplitOperator.IsNumber(data.Open)? data.Open.toFixed(defaultfloatPrecision):'--') +"</span><br/>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-High',this.LanguageID)+"</span>"+
                "<span class='tooltip-num' style='color:"+this.GetPriceColor("DivTooltip-High",data.High,data.YClose,data,eventUnchangeKLine)+";'>"+ (IFrameSplitOperator.IsNumber(data.High)? data.High.toFixed(defaultfloatPrecision):'--') +"</span><br/>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Low',this.LanguageID)+"</span>"+
                "<span class='tooltip-num' style='color:"+this.GetPriceColor('DivTooltip-Low',data.Low,data.YClose,data,eventUnchangeKLine)+";'>"+ (IFrameSplitOperator.IsNumber(data.Low)? data.Low.toFixed(defaultfloatPrecision):'--') +"</span><br/>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Close',this.LanguageID)+"</span>"+
                "<span class='tooltip-num' style='color:"+this.GetPriceColor('DivTooltip-Close',data.Close,data.YClose,data,eventUnchangeKLine)+";'>"+ (IFrameSplitOperator.IsNumber(data.Close)? data.Close.toFixed(defaultfloatPrecision):'--') +"</span><br/>"+
                //"<span style='color:"+this.YClose+";font:微软雅黑;font-size:12px'>&nbsp;前收: "+IFrameSplitOperator.FormatValueString(data.YClose,2)+"</span><br/>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Vol',this.LanguageID)+"</span>"+
                "<span class='tooltip-num' style='color:"+this.VolColor+";'>"+ (IFrameSplitOperator.IsNumber(vol)? IFrameSplitOperator.FormatValueString(vol,2,this.LanguageID):'--') +"</span><br/>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Amount',this.LanguageID)+"</span>"+
                "<span class='tooltip-num' style='color:"+this.AmountColor+";'>"+ (IFrameSplitOperator.IsNumber(data.Amount)? IFrameSplitOperator.FormatValueString(data.Amount,2,this.LanguageID):'--') +"</span><br/>"+
                "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Increase',this.LanguageID)+"</span>"+
                (increase==null? "<span class='tooltip-num' style='color:"+this.GetColor(0,0)+";'>"+'--'+"</span><br/>" :
                "<span class='tooltip-num' style='color:"+this.GetColor(increase,0)+";'>"+increase.toFixed(2)+'%'+"</span><br/>");

            this.LineCount=8;

            if(MARKET_SUFFIX_NAME.IsSHSZStockA(this.Symbol) && data.FlowCapital>0)  //换手率
            {
                var value=data.Vol/data.FlowCapital*100;
                strText+= "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Exchange',this.LanguageID)+"</span>" +
                    "<span class='tooltip-num' style='color:"+this.TurnoverRateColor+";'>"+value.toFixed(2)+'%'+"</span><br/>";
                ++this.LineCount;
            }

            if (MARKET_SUFFIX_NAME.IsFutures(upperSymbol) && IFrameSplitOperator.IsNumber(data.Position))
            {
                strText+= "<span class='tooltip-con'>"+g_JSChartLocalization.GetText('DivTooltip-Position',this.LanguageID)+"</span>" +
                    "<span class='tooltip-num' style='color:"+this.PositionColor+";'>"+data.Position+"</span><br/>";
                ++this.LineCount;
            }

            //叠加股票
            if (this.Value.ChartPaint.Name=="Overlay-KLine")
            {
                var title="<span style='color:rgb(0,0,0);font:微软雅黑;font-size:12px;text-align:center;display: block;'>"+this.Value.ChartPaint.Title+"</span>";
                strText=title+strText;
                ++this.LineCount;
            }
        }

        this.Text=strText;

        this.Height=this.LineCount*this.LineHeight;
        return true;
        */
    }

    this.GenerateTitleHtml=function(data)
    {
        var lineCount=0;
        var strHtml="", text;
        if (data.Name)
        {
            text=`<span style='color:rgb(0,0,0);font:微软雅黑;font-size:12px;text-align:center;display: block;'>${data.Name}</span>`;
            strHtml+=text;
            ++lineCount;
        }

        if (data.Title)
        {
            if (Array.isArray(data.Title))
            {
                for(var i=0;i<data.Title.length;++i)
                {
                    var item=data.Title[i];
                    text=`<span class='tooltip-title'>${item}</span>`;
                    strHtml+=text;
                    ++lineCount;
                }
            }
            else
            {
                text=`<span class='tooltip-title'>${data.Title}</span>`;
                strHtml+=text;
                ++lineCount;
            }
        }

        if (IFrameSplitOperator.IsNonEmptyArray(data.AryText))
        {
            for(var i=0;i<data.AryText.length;++i)
            {
                var item=data.AryText[i];
                if (i>0) strHtml+='<br/>';
                var text=`<span class='tooltip-con'>${item.Title}</span><span class='tooltip-num' style='color:${item.Color};'>${item.Text}</span>`;
                strHtml+=text;
                ++lineCount;
            }
        }

        return { Html:strHtml, LineCount:lineCount };
    }

    this.GetFormatTitle=function(data)
    {
        if (!data) return null;

        var upperSymbol=this.Symbol.toUpperCase();
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数
        var date=new Date(parseInt(data.Date/10000),(data.Date/100%100-1),data.Date%100);
        var strDate=IFrameSplitOperator.FormatDateString(data.Date);

        var title=strDate,value;
        var isTickPeriod=ChartData.IsTickPeriod(this.Value.ChartPaint.Data.Period);
        if (ChartData.IsDayPeriod(this.Value.ChartPaint.Data.Period,true))  //日线
        {
            value=g_JSChartLocalization.GetText(WEEK_NAME[date.getDay()],this.LanguageID);
            title=`${strDate}&nbsp&nbsp${value}`;
        }
        else if (ChartData.IsMinutePeriod(this.Value.ChartPaint.Data.Period,true)) // 分钟周期
        {
            value=IFrameSplitOperator.FormatTimeString(data.Time);
            title=`${strDate}&nbsp&nbsp${value}`;
        }
        else if (ChartData.IsSecondPeriod(this.Value.ChartPaint.Data.Period) || isTickPeriod)
        {
            value=IFrameSplitOperator.FormatTimeString(data.Time,'HH:MM:SS');
            title=`${strDate}&nbsp&nbsp${value}`;
        }
        else if (ChartData.IsMilliSecondPeriod(this.Value.ChartPaint.Data.Period))
        {
            value=IFrameSplitOperator.FormatTimeString(data.Time,'HH:MM:SS.fff');
            title=
            [
                `${strDate}&nbsp&nbsp${g_JSChartLocalization.GetText(WEEK_NAME[date.getDay()],this.LanguageID)}`,
                value
            ];
        }

        var result={ AryText:null, Title:title, Name:null };


        if (isTickPeriod)
        {
            var aryText=
            [
                { 
                    Title:g_JSChartLocalization.GetText('DivTooltip-Price',this.LanguageID), 
                    Text:IFrameSplitOperator.IsNumber(data.Open)? data.Open.toFixed(defaultfloatPrecision):'--',
                    Color:this.GetColor(data.Open,data.YClose)
                },
            ];

            if (IFrameSplitOperator.IsNumber(data.YClose)) 
            {
                var increase=(data.Close-data.YClose)/data.YClose*100;
                var item=
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Increase',this.LanguageID),
                    Text:`${increase.toFixed(2)}%`,
                    Color:this.GetColor(increase,0)
                }
                aryText.push(item);
            }

            result.AryText=aryText;
        }
        else if (data.IsNonTrade)
        {

        }
        else
        {
            var vol=data.Vol;
            if (upperSymbol && MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) vol/=100; //A股统一转成手
            var eventUnchangeKLine=null;    //定制平盘K线颜色事件
            if (this.GetEventCallback) eventUnchangeKLine=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_UNCHANGE_KLINE_TITLE_COLOR);

            var aryText=
            [
                { 
                    Title:g_JSChartLocalization.GetText('DivTooltip-Open',this.LanguageID), 
                    Text:IFrameSplitOperator.IsNumber(data.Open)? data.Open.toFixed(defaultfloatPrecision):'--',
                    Color:this.GetPriceColor("DivTooltip-Open",data.Open,data.YClose,data,eventUnchangeKLine),
                },
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-High',this.LanguageID),
                    Text:IFrameSplitOperator.IsNumber(data.High)? data.High.toFixed(defaultfloatPrecision):'--',
                    Color:this.GetPriceColor("DivTooltip-High",data.High,data.YClose,data,eventUnchangeKLine)
                },
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Low',this.LanguageID),
                    Text:IFrameSplitOperator.IsNumber(data.Low)? data.Low.toFixed(defaultfloatPrecision):'--',
                    Color:this.GetPriceColor('DivTooltip-Low',data.Low,data.YClose,data,eventUnchangeKLine)
                },
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Close',this.LanguageID),
                    Text:IFrameSplitOperator.IsNumber(data.Close)? data.Close.toFixed(defaultfloatPrecision):'--',
                    Color:this.GetPriceColor('DivTooltip-Close',data.Close,data.YClose,data,eventUnchangeKLine)
                },
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Vol',this.LanguageID),
                    Text:IFrameSplitOperator.IsNumber(vol)? IFrameSplitOperator.FormatValueString(vol,2,this.LanguageID):'--',
                    Color:this.VolColor
                },
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Amount',this.LanguageID),
                    Text:IFrameSplitOperator.IsNumber(data.Amount)? IFrameSplitOperator.FormatValueString(data.Amount,2,this.LanguageID):'--',
                    Color:this.AmountColor
                }
            ];

            if (IFrameSplitOperator.IsNumber(data.YClose)) 
            {
                var increase=(data.Close-data.YClose)/data.YClose*100;
                var item=
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Increase',this.LanguageID),
                    Text:`${increase.toFixed(2)}%`,
                    Color:this.GetColor(increase,0)
                }
                aryText.push(item);
            }

            if(MARKET_SUFFIX_NAME.IsSHSZStockA(this.Symbol) && data.FlowCapital>0)  //换手率
            {
                var value=data.Vol/data.FlowCapital*100;
                var item=
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Exchange',this.LanguageID),
                    Text:`${value.toFixed(2)}%`,
                    Color:this.TurnoverRateColor
                }
                aryText.push(item);
            }

            if (MARKET_SUFFIX_NAME.IsFutures(upperSymbol) && IFrameSplitOperator.IsNumber(data.Position))
            {
                var item=
                {
                    Title:g_JSChartLocalization.GetText('DivTooltip-Position',this.LanguageID),
                    Text:`${data.Position}`,
                    Color:this.PositionColor
                }
            }

            //叠加股票
            if (this.Value.ChartPaint.Name=="Overlay-KLine")
            {
                result.Name=this.Value.ChartPaint.Title;
            }

            result.AryText=aryText;
        }


        return result;
    }

    this.GetColor=function(price,yclse)
    {
        if(price>yclse) return this.UpColor;
        else if (price<yclse) return this.DownColor;
        else return this.UnchagneColor;
    }

    this.GetPriceColor=function(titleName, price, yClose, item, event)
    {
        var color=this.GetColor(price, yClose);
        if (price==yClose && event && event.Callback)
        {
            var sendData={ Item:item, TitleName:titleName, DefaultColor:color, TitleColor:null, ClassName:this.ClassName };
            event.Callback(event, sendData);
            if (sendData.TitleColor)    color=sendData.TitleColor;
        }


        return color;
    }
}

//K线信息地雷提示信息格式
function KLineInfoDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.UpColor=g_JSChartResource.UpTextColor;
    this.DownColor=g_JSChartResource.DownTextColor;
    this.UnchagneColor=g_JSChartResource.UnchagneTextColor;
    this.Width=500;

    this.Operator=function()
    {
        if (!this.Value) return false;

        var infoList=this.Value.Data.Data;  //数据
        var infoType=this.Value.Data.Type;  //类型
        var strText='';

        for(var i in infoList)
        {
            var item=infoList[i];
            var tempText='';
            switch(infoType)
            {
                case KLINE_INFO_TYPE.BLOCKTRADING:
                    tempText=this.BlockTradingFormat(item);
                    break;
                case KLINE_INFO_TYPE.TRADEDETAIL:
                    tempText=this.TradeDetailFormat(item);
                    break;
                case KLINE_INFO_TYPE.RESEARCH:
                    tempText=this.ResearchFormat(item);
                    break;
                case KLINE_INFO_TYPE.PFORECAST:
                    tempText=this.PerformanceForecastFormat(item);
                    break;
                default:
                    tempText=this.DefaultFormat(item);
                    break;
            }

            strText+=tempText;
        }

        var html="<div class='title-length'>"+strText+"</div>";

        if(infoList.length > 8)
        {
            var strBox="<div class='total-list'>共"+infoList.length+"条</div>";
            html+=strBox;
        }

        this.Text=html;
        return true;
    }

    this.DefaultFormat=function(item)
    {
        var strDate=IFrameSplitOperator.FormatDateString(item.Date);
        if (IFrameSplitOperator.IsNumber(item.Time)) 
        {
            var strTime=IFrameSplitOperator.FormatTimeString(item.Time);
            strDate+=" "+strTime;
        }
        var strText=`<span>${strDate}&nbsp;&nbsp;&nbsp;${item.Title}</span>`;
        return strText;
    }

    //大宗交易
    this.BlockTradingFormat=function(item)
    {
        var showPriceInfo = item.ExtendData;
        var strDate=IFrameSplitOperator.FormatDateString(item.Date);
        var strText="<span><i class='date-tipbox'>"+strDate+"</i>&nbsp;&nbsp;<i class='tipBoxTitle'>成交价:&nbsp;"+showPriceInfo.Price.toFixed(2)+"</i><i class='tipBoxTitle'>收盘价:&nbsp;"+showPriceInfo.ClosePrice.toFixed(2)+
            "</i><br/><i class='rate-discount tipBoxTitle'>溢折价率:&nbsp;<strong style='color:"+ this.GetColor(showPriceInfo.Premium.toFixed(2))+"'>"+
            showPriceInfo.Premium.toFixed(2)+"%</strong></i><i class='tipBoxTitle'>成交量(万股):&nbsp;"+showPriceInfo.Vol.toFixed(2)+"</i></span>";

        return strText;
    }

    //龙虎榜
    this.TradeDetailFormat=function(item)
    {
        /*var detail=
            [
                "日价格涨幅偏离值达到9.89%",
                "日价格涨幅偏离值达格涨幅偏离值达格涨幅偏离值达到9.89%"
            ]
        */

        var detail=item.ExtendData.Detail;
        //格式：日期 上榜原因:  detail[0].TypeExplain
        //                    detail[1].TypeExplain
        //      一周后涨幅: xx 四周后涨幅: xx
        var strDate=IFrameSplitOperator.FormatDateString(item.Date);
        var reasons = [];
        for(var i in detail)
        {
            reasons += "<i>"+detail[i].TypeExplain+"</i><br/>"
            // reasons += detail[i] + "<br/>"
        }

        var strText= "<span><i class='trade-time'>"+strDate+"&nbsp;&nbsp;&nbsp;上榜原因:&nbsp;&nbsp;</i><i class='reason-list'>"+reasons+"</i><br/><i class='trade-detall'>一周后涨幅:&nbsp;<strong style='color:"+
            this.GetColor(item.ExtendData.FWeek.Week1.toFixed(2))+"'>"+ item.ExtendData.FWeek.Week1.toFixed(2)+
            "%</strong>&nbsp;&nbsp;&nbsp;四周后涨幅:&nbsp;<strong style='color:"+this.GetColor(item.ExtendData.FWeek.Week4.toFixed(2))+";'>"+
            item.ExtendData.FWeek.Week4.toFixed(2)+"%</strong></i></span>";

        return strText;
    }

    //调研
    this.ResearchFormat=function(item)
    {
        var levels=item.ExtendData.Level;
        var recPerson='';
        if(levels.length==0)
        {
            recPerson = "<i>一般调研</i>"
        }
        else
        {
            for(var j in levels)
            {
                if(levels[j]==0) recPerson+="<i style='color:#00a0e9'>证券代表&nbsp;&nbsp;&nbsp;</i>";
                else if(levels[j]==1) recPerson+="<i>董秘&nbsp;&nbsp;&nbsp;</i>";
                else if(levels[j]==2) recPerson+="<i style='color:#00a0e9'>总经理&nbsp;&nbsp;&nbsp;</i>";
                else if(levels[j]==3) recPerson+="<i style='color:#00a0e9'>董事长&nbsp;&nbsp;&nbsp;</i>";
            }

            recPerson='接待:&nbsp;&nbsp;&nbsp;'+recPerson;
        }

        var researchType='';
        if (item.ExtendData.Type && item.ExtendData.Type!='其他')
        {
            researchType='&nbsp;&nbsp;&nbsp;'+'<i>'+item.ExtendData.Type+'</i>';
            if (levels.length==0) recPerson='';
        }

        var strDate=IFrameSplitOperator.FormatDateString(item.Date);
        var strText="<span>"+strDate+"&nbsp;&nbsp;&nbsp;"+researchType+recPerson+"</span>";
        return strText;
    }

    //业绩预测
    this.PerformanceForecastFormat=function(item)
    {
        var reportDate=item.ExtendData.ReportDate;
        var year=parseInt(reportDate/10000);  //年份
        var day=reportDate%10000;   //比较 这个去掉年份的日期
        var reportType;
        if(day == 1231){
            reportType = "年报"
        }else if(day == 331){
            reportType = "一季度报"
        }else if(day == 630){
            reportType = "半年度报"
        }else if(day == 930){
            reportType = "三季度报"
        }

        var weekData="";
        if (item.ExtendData.FWeek)
        {
            if (item.ExtendData.FWeek.Week1!=null) weekData+="一周后涨幅:<i class='increase' style='color:"+this.GetColor(item.ExtendData.FWeek.Week1.toFixed(2))+"'>"+ item.ExtendData.FWeek.Week1.toFixed(2)+"%</i>";
            if (item.ExtendData.FWeek.Week4!=null) weekData+="&nbsp;四周后涨幅:<i class='increase' style='color:"+this.GetColor(item.ExtendData.FWeek.Week4.toFixed(2))+"'>"+ item.ExtendData.FWeek.Week4.toFixed(2)+"%</i>";
            if (weekData.length>0) weekData="<br/>&nbsp;&nbsp;<i class='prorecast-week'>"+weekData+"</i>";
        }
        var strDate=IFrameSplitOperator.FormatDateString(item.Date);
        var strText="<span>"+strDate+"&nbsp;&nbsp;"+year+reportType+item.Title+"&nbsp;"+weekData+"</span>";
        return strText;
    }

    this.GetColor=function(price)
    {
        if(price>0) return this.UpColor;
        else if (price<0) return this.DownColor;
        else return this.UnchagneColor;
    }
}

//交易信息提示信息格式
function KLineTradeDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Width=120;
    this.Operator=function()
    {
        var data=this.Value.Data;
        if (!data) return false;

        var item=data.Data;
        var title=`<span class='tooltip-index-name'>${item.Name}${item.Param}:</span>`;
        var content;
        if (item.Type==1) content=`<span class='tooltip-index-buy'>买入</span>`;
        else content=`<span class='tooltip-index-sell'>卖出</span>`;

        this.Text=title+content;
        return true;
    }
}

//分时图异动信息格式化
function MinuteInfoDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Width=200;
    this.Operator=function()
    {
        var data=this.Value.Data;
        if (!data) return false;

        var item=data.Data.Item;
        var strTime=IFrameSplitOperator.FormatTimeString(item.Time);
        var time=`<span class='tooltip-minuteinfo-time'>${strTime} </span>`;
        var content=`<span class='tooltip-minuteinfo-content'>${item.Title}</span>`;
        if (item.Content) content=`<span class='tooltip-minuteinfo-content'>${item.Content}</span>`;

        this.Text=time+content;
        return true;
    }
}

function IconDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Width=200;
    this.Operator=function()
    {
        if (!this.Value || !this.Value.Data) return false;
        var data=this.Value.Data;
        if (!data.Item) return false;
        if (!data.Item.Text) return false;
        
        this.Text=data.Item.Text;
        return true;
    }
}

function ChartDrawSVGDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Width=200;
    this.Operator=function()
    {
        if (!this.Value || !this.Value.Data) return false;
        var data=this.Value.Data;
        if (!data.Item) return false;
        if (!data.Item.Tooltip || !data.Item.Tooltip.Text) return false;
        
        this.Text=data.Item.Tooltip.Text;
        return true;
    }
}

//分时图异动信息格式化
function ChartOXDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Width=200;
    this.Period=0;
    this.Operator=function()
    {
        var data=this.Value.Data;
        if (!data || !data.Data) return false;

        if (ChartData.IsDayPeriod(this.Period, true))
        {
            var strStartDate=IFrameSplitOperator.FormatDateString(data.Data.Start.Date);
            var strEndDate=IFrameSplitOperator.FormatDateString(data.Data.End.Date);

            if (strStartDate==strEndDate)
            {
                this.Text=`<span class='tooltip-minuteinfo-content'>${strStartDate}</span>`;
                return true;
            }

            var content=`<span class='tooltip-minuteinfo-content'>起始时间:${strStartDate}</span>`;
            var content2=`<span class='tooltip-minuteinfo-content'>结束时间:${strEndDate}</span>`;

            this.Text=content+"<br>"+content2;
            return true;
        }
        else if (ChartData.IsMinutePeriod(this.Period, true))
        {
            var strStartDate=IFrameSplitOperator.FormatDateString(data.Data.Start.Date);
            var strStartTime=IFrameSplitOperator.FormatTimeString(data.Data.Start.Time,"HH:MM");

            var strEndDate=IFrameSplitOperator.FormatDateString(data.Data.End.Date);
            var strEndTime=IFrameSplitOperator.FormatTimeString(data.Data.End.Time,"HH:MM");

            var content=`<span class='tooltip-minuteinfo-content'>起始时间:${strStartDate} ${strStartTime}</span>`;
            var content2=`<span class='tooltip-minuteinfo-content'>结束时间:${strEndDate} ${strEndTime}</span>`;

            this.Text=content+"<br>"+content2;
            return true;
        }

        return false;
    }
}

function ScatterPlotDataStringFormat()
{
    this.newMethod=IChangeStringFormat;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Width=200;

    this.Operator=function()
    {
        var data=this.Value.Data;
        if (!data || !data.Data) return false;
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Data.Tooltip)) return false;

        this.Text="";
        for(var i=0;i<data.Data.Tooltip.length;++i)
        {
            var item=data.Data.Tooltip[i];

            var content=`<span class='tooltip-minuteinfo-content'>${item}</span>`;
            this.Text+=content+"<br>";
        }

        return true;
    }
}

function DivTooltipDataForamt()
{
    this.DataMap=new Map(
        [
            ["KLineTradeDataStringFormat",      { Create:function() { return new KLineTradeDataStringFormat(); }  }],
            ["MinuteInfoDataStringFormat",      { Create:function() { return new MinuteInfoDataStringFormat(); }  }],
            ["HistoryDataStringFormat",         { Create:function() { return new HistoryDataStringFormat(); }  }],
            ["KLineInfoDataStringFormat",       { Create:function() { return new KLineInfoDataStringFormat(); }  }],
            ["IconDataStringFormat",            { Create:function() { return new IconDataStringFormat(); } }],
            ["ChartOXDataStringFormat",         { Create:function() { return new ChartOXDataStringFormat(); } }],
            ["ScatterPlotDataStringFormat", { Create:function() { return new ScatterPlotDataStringFormat(); }}],
            ["ChartDrawSVGDataStringFormat", { Create:function() { return new ChartDrawSVGDataStringFormat(); }}],

            ["CorssCursor_XStringFormat", { Create:function() { return new HQDateStringFormat(); } }],
            ["CorssCursor_YStringFormat", { Create:function() { return new HQPriceStringFormat(); } }],

            ["CorssCursor_Minute_XStringFormat", { Create:function() { return new HQMinuteTimeStringFormat(); }} ]
        ]
    );

    this.Create=function(name)
    {
        if (!this.DataMap.has(name)) return null;

        var item=this.DataMap.get(name);
        return item.Create();
    }
}

var g_DivTooltipDataForamt=new DivTooltipDataForamt();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                      标题
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function IChartTitlePainting()
{
    this.Frame;
    this.Data=new Array();
    this.Canvas;                        //画布
    this.IsDynamic=false;               //是否是动态标题
    this.Position=0;                    //标题显示位置 0 框架里的标题  1 框架上面
    this.CursorIndex;                   //数据索引
    this.LastPoint;                     //鼠标位置
    this.Font=g_JSChartResource.TitleFont;
    this.Title;                         //固定标题(可以为空)
    this.TitleColor=g_JSChartResource.DefaultTextColor;
    this.ClassName='IChartTitlePainting';
    this.DrawStatus;
    this.GetEventCallback;
    this.GlobalOption;

    this.ReloadResource=function()
    {
        this.Font=g_JSChartResource.TitleFont;
        this.TitleColor=g_JSChartResource.DefaultTextColor;
    }
}

//var PERIOD_NAME=["日线","周线","月线","年线","1分","5分","15分","30分","60分","季线","分笔", "2小时","4小时","双周","",""];
var RIGHT_NAME=['不复权','前复权','后复权'];

function DynamicKLineTitlePainting()
{
    this.newMethod=IChartTitlePainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='DynamicKLineTitlePainting';
    this.IsDynamic=true;
    this.IsShow=true;       //是否显示
    this.Period;            //周期

    this.UpColor=g_JSChartResource.UpTextColor;
    this.DownColor=g_JSChartResource.DownTextColor;
    this.UnchagneColor=g_JSChartResource.UnchagneTextColor;

    this.VolColor=g_JSChartResource.Title.VolColor;
    this.AmountColor=g_JSChartResource.Title.AmountColor;
    this.DateTimeColor=g_JSChartResource.Title.DateTimeColor;
    this.NameColor = g_JSChartResource.Title.NameColor;
    this.SettingColor=g_JSChartResource.Title.SettingColor;   //周期 复权
    this.TurnoverRateColor=g_JSChartResource.Title.TurnoverRateColor;   //换手率
    this.PositionColor=g_JSChartResource.Title.PositionColor;   //持仓

    this.Symbol;
    this.Name;

    this.SpaceWidth=2*GetDevicePixelRatio(); //获取设备的分辨率;
    this.OverlayChartPaint;         //叠加画法

    this.IsShowName=true;           //是否显示股票名称
    this.IsShowSettingInfo=true;    //是否显示设置信息(周期 复权)
    this.IsShowDateTime=true;       //是否显示日期
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.OnDrawEvent;
    this.OnMouseMoveEvent;
    this.HQChart;

    this.ReloadResource=function()
    {
        this.Font=g_JSChartResource.TitleFont;

        this.TitleColor=g_JSChartResource.DefaultTextColor;

        this.UpColor=g_JSChartResource.UpTextColor;
        this.DownColor=g_JSChartResource.DownTextColor;
        this.UnchagneColor=g_JSChartResource.UnchagneTextColor;

        this.VolColor=g_JSChartResource.Title.VolColor;
        this.AmountColor=g_JSChartResource.Title.AmountColor;
        this.DateTimeColor=g_JSChartResource.Title.DateTimeColor;
        this.NameColor = g_JSChartResource.Title.NameColor;
        this.SettingColor=g_JSChartResource.Title.SettingColor;
        this.TurnoverRateColor=g_JSChartResource.Title.TurnoverRateColor;   //换手率
        this.PositionColor=g_JSChartResource.Title.PositionColor;   //持仓
    }

    this.GetCurrentKLineData=function() //获取当天鼠标位置所在的K线数据
    {
        if (this.CursorIndex==null || !this.Data) return null;
        if (this.Data.length<=0) return null;

        var index=this.CursorIndex;
        index=parseInt(index.toFixed(0));
        var dataIndex=this.Data.DataOffset+index;
        if (dataIndex>=this.Data.Data.length) dataIndex=this.Data.Data.length-1;
        if (dataIndex<0) return null;

        var item=this.Data.Data[dataIndex];
        return item;
    }

    this.GetFormatTitle=function(data)
    {
        if (!data || !data.Data) return;

        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数
        var upperSymbol=this.Symbol.toUpperCase();
        var item=data.Data;
        var aryText=[];
        var result={ AryText:aryText };

        if (this.IsShowName) aryText.push({ Text:this.Name, Color:this.NameColor });

        if (this.IsShowSettingInfo)
        {
            var periodName='';
            if (this.Data.Period>CUSTOM_MINUTE_PERIOD_START && this.Data.Period<=CUSTOM_MINUTE_PERIOD_END) 
                periodName=(this.Data.Period-CUSTOM_MINUTE_PERIOD_START)+g_JSChartLocalization.GetText('自定义分钟',this.LanguageID);
            else if (this.Data.Period>CUSTOM_DAY_PERIOD_START && this.Data.Period<=CUSTOM_DAY_PERIOD_END)
                periodName=(this.Data.Period-CUSTOM_DAY_PERIOD_START)+g_JSChartLocalization.GetText('自定义日线',this.LanguageID);
            else if (this.Data.Period>CUSTOM_SECOND_PERIOD_START && this.Data.Period<=CUSTOM_SECOND_PERIOD_END)
                periodName=(this.Data.Period-CUSTOM_SECOND_PERIOD_START)+g_JSChartLocalization.GetText('自定义秒',this.LanguageID);
            else if (this.Data.Period>CUSTOM_MILLISECOND_PERIOD_START&& this.Data.Period<=CUSTOM_MILLISECOND_PERIOD_END)
                periodName=(this.Data.Period-CUSTOM_MILLISECOND_PERIOD_START)+g_JSChartLocalization.GetText('自定义毫秒',this.LanguageID);
            else 
                periodName=g_JSChartLocalization.GetText(ChartData.GetPeriodName(this.Data.Period),this.LanguageID);
            var rightName=g_JSChartLocalization.GetText(RIGHT_NAME[this.Data.Right],this.LanguageID);
            var text="("+periodName+" "+rightName+")";

            if (!MARKET_SUFFIX_NAME.IsEnableRight(this.Data.Period, this.Symbol, this.HQChart.RightFormula)) text="("+periodName+")";
            aryText.push({ Text:text, Color:this.SettingColor });
        }

        var text=this.GetKLineCalculateTitle();
        if (text) aryText.push({ Text:text, Color:this.NameColor });

        if (this.IsShowDateTime)    //是否显示日期
        {
            var text=IFrameSplitOperator.FormatDateString(item.Date);
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }

        var isTickPeriod=ChartData.IsTickPeriod(this.Period);
        if (ChartData.IsMinutePeriod(this.Period,true) && IFrameSplitOperator.IsNumber(item.Time))
        {
            var text=IFrameSplitOperator.FormatTimeString(item.Time);
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }
        else if (ChartData.IsSecondPeriod(this.Period) && IFrameSplitOperator.IsNumber(item.Time))
        {
            var text=IFrameSplitOperator.FormatTimeString(item.Time, "HH:MM:SS");
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }
        else if (ChartData.IsMilliSecondPeriod(this.Period) && IFrameSplitOperator.IsNumber(item.Time))
        {
            var text=IFrameSplitOperator.FormatTimeString(item.Time, "HH:MM:SS.fff");
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }
        else if (isTickPeriod)
        {
            var text=IFrameSplitOperator.FormatTimeString(item.Time, "HH:MM:SS");
            aryText.push({ Text:text, Color:this.DateTimeColor });
        }

        if (isTickPeriod)
        {
            var color=this.GetColor(item.Open,item.YClose);
            var text=g_JSChartLocalization.GetText('KTitle-Price',this.LanguageID)+item.Open.toFixed(defaultfloatPrecision);
            aryText.push({ Text:text, Color:color});

            if (IFrameSplitOperator.IsNumber(item.YClose) && item.YClose!=0)
            {
                var value=(item.Close-item.YClose)/item.YClose*100;
                var color = this.GetColor(value, 0);
                var text = g_JSChartLocalization.GetText('KTitle-Increase',this.LanguageID) + value.toFixed(2)+'%';
                aryText.push({ Text:text, Color:color});
            }

            return result;
        }

        if (item.IsNonTrade) return result;    //非交易日 没数据 不显示

        var eventUnchangeKLine=null;    //定制平盘K线颜色事件
        if (this.GetEventCallback) eventUnchangeKLine=this.GetEventCallback(JSCHART_EVENT_ID.ON_CUSTOM_UNCHANGE_KLINE_TITLE_COLOR);

        if (IFrameSplitOperator.IsNumber(item.Open))
        {
            var color=this.GetColor(item.Open,item.YClose);
            var text=g_JSChartLocalization.GetText('KTitle-Open',this.LanguageID)+item.Open.toFixed(defaultfloatPrecision);
            if (item.Open==item.YClose && eventUnchangeKLine)
            {
                var sendData={ Item:item, TitleName:"KTitle-Open", DefaultColor:color, TitleColor:null };
                if (this.OnUnchangeTitleColor(eventUnchangeKLine, sendData)) color=sendData.TitleColor;
            }

            aryText.push({ Text:text, Color:color});
        }
       
        if (IFrameSplitOperator.IsNumber(item.High))
        {
            var color=this.GetColor(item.High,item.YClose);
            var text=g_JSChartLocalization.GetText('KTitle-High',this.LanguageID)+item.High.toFixed(defaultfloatPrecision);
            if (item.High==item.YClose && eventUnchangeKLine)
            {
                var sendData={ Item:item, TitleName:"KTitle-High", DefaultColor:color, TitleColor:null };
                if (this.OnUnchangeTitleColor(eventUnchangeKLine, sendData)) color=sendData.TitleColor;
            }
            aryText.push({ Text:text, Color:color});
        }
        
        if (IFrameSplitOperator.IsNumber(item.Low))
        {
            var color=this.GetColor(item.Low,item.YClose);
            var text=g_JSChartLocalization.GetText('KTitle-Low',this.LanguageID)+item.Low.toFixed(defaultfloatPrecision);
            if (item.Low==item.YClose && eventUnchangeKLine)
            {
                var sendData={ Item:item, TitleName:"KTitle-Low", DefaultColor:color, TitleColor:null };
                if (this.OnUnchangeTitleColor(eventUnchangeKLine, sendData)) color=sendData.TitleColor;
            }
            aryText.push({ Text:text, Color:color});
        }
        
        if (IFrameSplitOperator.IsNumber(item.Close))
        {
            var color=this.GetColor(item.Close,item.YClose);
            var text=g_JSChartLocalization.GetText('KTitle-Close',this.LanguageID)+item.Close.toFixed(defaultfloatPrecision);
            if (item.Close==item.YClose && eventUnchangeKLine)
            {
                var sendData={ Item:item, TitleName:"KTitle-Close", DefaultColor:color, TitleColor:null };
                if (this.OnUnchangeTitleColor(eventUnchangeKLine, sendData)) color=sendData.TitleColor;
            }
            aryText.push({ Text:text, Color:color});
        }
        
        //涨幅
        if (item.YFClose>0 && MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol))
        {
            var value=(item.Close-item.YFClose)/item.YFClose*100;
            var color = this.GetColor(value, 0);
            var text = g_JSChartLocalization.GetText('KTitle-Increase',this.LanguageID) + value.toFixed(2)+'%';
            aryText.push({ Text:text, Color:color});
        }
        else if (item.YClose>0)
        {
            var value=(item.Close-item.YClose)/item.YClose*100;
            var color = this.GetColor(value, 0);
            var text = g_JSChartLocalization.GetText('KTitle-Increase',this.LanguageID) + value.toFixed(2)+'%';
            aryText.push({ Text:text, Color:color});
        }

        if (IFrameSplitOperator.IsNumber(item.Vol)) //成交量
        {
            var vol=item.Vol;
            if (upperSymbol && MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) vol/=100;   //A股原始单位股, 转成股
            var text=g_JSChartLocalization.GetText('KTitle-Vol',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID);
            aryText.push({ Text:text, Color:this.VolColor});
        }
       
        if (IFrameSplitOperator.IsNumber(item.Amount))  //成交金额
        {
            var text=g_JSChartLocalization.GetText('KTitle-Amount',this.LanguageID)+IFrameSplitOperator.FormatValueString(item.Amount,2,this.LanguageID);
            aryText.push({ Text:text, Color:this.AmountColor});
        }

        if (MARKET_SUFFIX_NAME.IsSHSZStockA(this.Symbol) && item.FlowCapital>0)   //A股有换手率
        {
            var value=item.Vol/item.FlowCapital*100;    //成交量/流通A股*100
            var text=g_JSChartLocalization.GetText('KTitle-Exchange',this.LanguageID)+IFrameSplitOperator.FormatValueString(value,2,this.LanguageID)+'%';
            aryText.push({ Text:text, Color:this.TurnoverRateColor});
        }

        if (MARKET_SUFFIX_NAME.IsFutures(upperSymbol) && IFrameSplitOperator.IsNumber(item.Position))  //持仓量
        {
            var text=g_JSChartLocalization.GetText('KTitle-Position',this.LanguageID)+item.Position;
            aryText.push({ Text:text, Color:this.PositionColor});
        }

        //叠加股票的名字
        if (IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint))
        {
            for(var i=0;i<this.OverlayChartPaint.length;++i)
            {
                var item=this.OverlayChartPaint[i];
                if (!item.Symbol || !item.Title) continue;
            
                var clrText=item.Color;
                var text=`[${item.Title}]`;
                aryText.push({ Text:text, Color:clrText});
            }
        }

        return result;
    }

    this.DrawItem=function(item)
    {
        var isHScreen=this.Frame.IsHScreen===true;
        var left=this.Frame.ChartBorder.GetLeft();
        var bottom=this.Frame.ChartBorder.GetTop()-this.Frame.ChartBorder.Top/2;
        var right=this.Frame.ChartBorder.GetRight();
        //var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数
        //var upperSymbol=this.Symbol.toUpperCase();
        var pixelRatio=GetDevicePixelRatio();
        if (isHScreen)
        {
            if (this.Frame.ChartBorder.Right<5*pixelRatio) return;
            var left=2;
            var bottom=this.Frame.ChartBorder.Right/2;    //上下居中显示
            var right=this.Frame.ChartBorder.GetHeight();
            var xText=this.Frame.ChartBorder.GetChartWidth();
            var yText=this.Frame.ChartBorder.GetTop();
            this.Canvas.translate(xText, yText);
            this.Canvas.rotate(90 * Math.PI / 180);
        }
        else
        {
            if (this.Frame.ChartBorder.Top<5*pixelRatio) return;
        }

        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.font=this.Font;
        var position = { Left: left, Bottom: bottom, IsHScreen: isHScreen };
        var titleData=this.GetFormatTitle({ Data:item });

        if (titleData && IFrameSplitOperator.IsNonEmptyArray(titleData.AryText))
        {
            for(var i=0;i<titleData.AryText.length;++i)
            {
                var item=titleData.AryText[i];
                if (!this.DrawText(item.Text,item.Color,position)) break;
            }
        }
    }

    this.Draw=function()
    {
        if (!this.IsShow) return;
        if (this.CursorIndex==null || !this.Data || this.Data.length<=0) 
        {
            this.OnDrawEventCallback(null);
            return;
        }

        this.Canvas.font=this.Font;
        this.SpaceWidth = this.Canvas.measureText('0').width;

        var index=this.CursorIndex;
        index=parseInt(index.toFixed(0));
        var dataIndex=this.Data.DataOffset+index;
        if (dataIndex>=this.Data.Data.length) dataIndex=this.Data.Data.length-1;
        if (dataIndex<0) 
        {
            this.OnDrawEventCallback(null);
            return;
        }

        if (this.IsShowLastData())  //鼠标不在图形上 显示最后一条数据
        {
            dataIndex=this.Data.Data.length-1;
        }
            

        var item=this.Data.Data[dataIndex];
        this.OnDrawEventCallback(item);
        this.Canvas.save();
        this.DrawItem(item);
        this.Canvas.restore();
    }

    this.OnDrawEventCallback=function(drawData)
    {
        var bDrawEvent=(this.OnDrawEvent && this.OnDrawEvent.Callback);
        var bMouseMoveEvent= (this.OnMouseMoveEvent && this.OnMouseMoveEvent.Callback);
        if (!bDrawEvent && !bMouseMoveEvent) return;

        var data={ Draw: drawData, Name:this.ClassName};
        if (this.Data && this.Data.Data)
        {
            var index=Math.abs(this.CursorIndex);
            index=parseInt(index.toFixed(0));
            var dataIndex=this.Data.DataOffset+index;
            var dataCount=this.Data.Data.length;

            data.DataIndex=dataIndex;
            data.DataCount=dataCount;
        }

        //叠加股票
        if (IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint))
        {
            data.OverlayStock=[];
            for(var i=0; i<this.OverlayChartPaint.length; ++i)
            {
                var item=this.OverlayChartPaint[i];
                if (!item.Symbol || !item.Title) continue;
            
                data.OverlayStock.push({ Symbol:item.Symbol, Name:item.Title, Data:item.Data, Color:item.Color });
            }
        }
        
        if (bDrawEvent)
            this.OnDrawEvent.Callback(this.OnDrawEvent,data,this);

        if (bMouseMoveEvent)
            this.OnMouseMoveEvent.Callback(this.OnMouseMoveEvent,data,this);
    }

    this.GetColor=function(price,yclse)
    {
        if(price>yclse) return this.UpColor;
        else if (price<yclse) return this.DownColor;
        else return this.UnchagneColor;
    }

    this.OnUnchangeTitleColor=function(event, sendData)
    {
        if (!event || !event.Callback) return false;
        sendData.ClassName=this.ClassName;
        event.Callback(event, sendData, this);

        if (sendData && sendData.TitleColor) return true;

        return false;
    }

    this.DrawText=function(title,color,position)
    {
        if (!title) return true;

        var isHScreen=this.Frame.IsHScreen===true;
        var right = this.Frame.ChartBorder.GetRight();
        if (isHScreen) right=this.Frame.ChartBorder.GetHeight();

        this.Canvas.fillStyle = color;
        var textWidth = this.Canvas.measureText(title).width;
        if (position.Left + textWidth > right) return false;

        if (this.IsShow) this.Canvas.fillText(title, position.Left, position.Bottom, textWidth);

        position.Left += textWidth + this.SpaceWidth;
        return true;
    }

    //计算K线指标标题信息
    this.GetKLineCalculateTitle=function()
    {
        if (!this.HQChart) return null;
        var klineCalulate=this.HQChart.GetKLineCalulate();
        if (!klineCalulate || !klineCalulate.GetTitle) return null;
        
        return klineCalulate.GetTitle();
    }

    this.IsShowLastData=function()
    {
        var isShow=false;
        if (this.DrawStatus && this.DrawStatus.IsTitleShowLatestData)
        {
            var status=this.DrawStatus;
            if (!IFrameSplitOperator.IsNumber(status.FrameID) || status.FrameID<0)
                isShow=true;
            else if (status.CorssCursorTouchEnd && status.IsOnTouch==false)
                isShow=true;
        }

        return isShow;
    }

}

function DynamicMinuteTitlePainting()
{
    this.newMethod=DynamicKLineTitlePainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='DynamicMinuteTitlePainting';

    this.SpaceWidth=1*GetDevicePixelRatio();
    this.YClose;
    this.IsShowDate=false;  //标题是否显示日期
    this.IsShowTime=true;   //标题是否显示时间
    this.IsShowName=true;   //标题是否显示股票名字
    this.IsShowAveragePrice=true;   //是否显示均线价格
    this.OverlayChartPaint; //叠加画法
    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.LastShowData;  //保存最后显示的数据 给tooltip用
    this.OnDrawEvent;
    this.PointInfo=null;
    this.IsAlwaysShowLastData=false;    //始终显示最后一个数据
    this.ShowLastDataFormat=0;          //0=默认  1=更新时间替换时间

    this.MultiDayBeforeOpenData;    //多日分时图 盘前数据
    this.MultiDayAfterCloseData;    //多日分时图 收盘数据
    this.TitleBaseLine=1;           //0=top 1=middle 2=bottom

    this.TimeFormat;                //显示时间格式 "HH:MM:SS", "hh:MM", "HH:MM:SS.fff"
    

    this.CallAuctionShowTitle=new Set(
        [
            "MTitle-AC-Price",
            "MTitle-AC-Vol",
            "MTitle-AC-NotMatchVol",
            "MTitle-AC-Increase",
            "MTitle-AC-AvPrice"
        ]);

    this.GetCurrentKLineData=function() //获取当天鼠标位置所在的K线数据
    {
        if (this.LastShowData) return this.LastShowData;

        if (this.CursorIndex==null || !this.Data) return null;
        if (this.Data.length<=0) return null;

        var index=Math.abs(this.CursorIndex);
        index=parseInt(index.toFixed(0));
        var dataIndex=this.Data.DataOffset+index;
        if (dataIndex>=this.Data.Data.length) dataIndex=this.Data.Data.length-1;
        if (dataIndex<0) return null;

        var item=this.Data.Data[dataIndex];
        return item;
    }

    this.GetCurrentAuctionData=function()   //获取当前鼠标所在位置的盘前盘后数据
    {
        var isHScreen=this.Frame.IsHScreen===true;
        //空数据 返回坐标信息
        var emptyData={ ClientPos:this.PointInfo.ClientPos, X:this.PointInfo.Point.X, Y:this.PointInfo.Point.Y };

        if (this.PointInfo.ClientPos==2)
        {
            if (!this.BeforeOpenData) return emptyData;
            if (!this.CallAcutionXOperator) return emptyData;

            this.CallAcutionXOperator.Value=isHScreen?this.PointInfo.Point.Y:this.PointInfo.Point.X;
            this.CallAcutionXOperator.Point={X:this.PointInfo.Point.X, Y:this.PointInfo.Point.Y};
            this.CallAcutionXOperator.ClientPos=this.PointInfo.ClientPos;
            if (!this.CallAcutionXOperator.Operator()) return emptyData;
            
            var callbackData={Explain:"BeforeOpen", Data:null, DataIndex:null, DataTotalCount:this.BeforeOpenData.TotalCount };
            callbackData.DataIndex=this.CallAcutionXOperator.DataIndex;
            callbackData.Data=this.CallAcutionXOperator.Item;
            callbackData.Ver=this.BeforeOpenData.Ver;
            return callbackData;
        }
        else if (this.PointInfo.ClientPos==3)
        {
            if (!this.AfterCloseData) return emptyData;
            if (!this.CallAcutionXOperator) return emptyData;
            
            this.CallAcutionXOperator.Value=isHScreen?this.PointInfo.Point.Y:this.PointInfo.Point.X;
            this.CallAcutionXOperator.Point={X:this.PointInfo.Point.X, Y:this.PointInfo.Point.Y};
            this.CallAcutionXOperator.ClientPos=this.PointInfo.ClientPos;
            if (!this.CallAcutionXOperator.Operator()) return emptyData;

            var callbackData={Explain:"AfterClose", Data:null, DataIndex:null, DataTotalCount:this.AfterCloseData.TotalCount };
            callbackData.DataIndex=this.CallAcutionXOperator.DataIndex;
            callbackData.Data=this.CallAcutionXOperator.Item;
            callbackData.Ver=this.AfterCloseData.Ver;
            return callbackData;
        }
        else if (this.PointInfo.ClientPos>=200 && this.PointInfo.ClientPos<=299)
        {
            if (!this.MultiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData) ) return emptyData;

            var x=this.Frame.IsHScreen==true?this.PointInfo.Point.Y:this.PointInfo.Point.X;
            this.CallAcutionXOperator.Value=x;
            this.CallAcutionXOperator.Point={X:this.PointInfo.Point.X, Y:this.PointInfo.Point.Y};
            this.CallAcutionXOperator.ClientPos=this.PointInfo.ClientPos;
            if (!this.CallAcutionXOperator.Operator()) return emptyData;

            var dayItem=this.MultiDayBeforeOpenData[this.CallAcutionXOperator.DayIndex];
            var callbackData={Explain:"MultiDayBeforeOpen", Data:null, DataIndex:null };
            callbackData.DataIndex=this.CallAcutionXOperator.DataIndex;
            callbackData.DayIndex=this.CallAcutionXOperator.DayIndex;
            callbackData.Data=this.CallAcutionXOperator.Item;
            callbackData.Ver=dayItem.Ver;
            return callbackData;
        }
        else if (this.PointInfo.ClientPos>=300 && this.PointInfo.ClientPos<=399)
        {
            if (!this.MultiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData) ) return emptyData;

            var x=this.Frame.IsHScreen==true?this.PointInfo.Point.Y:this.PointInfo.Point.X;
            this.CallAcutionXOperator.Value=x;
            this.CallAcutionXOperator.Point={X:this.PointInfo.Point.X, Y:this.PointInfo.Point.Y};
            this.CallAcutionXOperator.ClientPos=this.PointInfo.ClientPos;
            if (!this.CallAcutionXOperator.Operator()) return emptyData;

            var dayItem=this.MultiDayAfterCloseData[this.CallAcutionXOperator.DayIndex];
            var callbackData={Explain:"MultiDayAfterClose", Data:null, DataIndex:null };
            callbackData.DataIndex=this.CallAcutionXOperator.DataIndex;
            callbackData.DayIndex=this.CallAcutionXOperator.DayIndex;
            callbackData.Data=this.CallAcutionXOperator.Item;
            callbackData.Ver=dayItem.Ver;
            return callbackData;
        }

        return emptyData;
    }

    this.GetLatestKLineData=function(bCallAuction)  //获取最新一个K线数据 bCallAuction=是否包含集合竞价数据
    {
        var beforeItem=null;
        var beforeDataVer=1;
        var beforeExplain;
        if (IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData))
        {
            var item=this.MultiDayBeforeOpenData[this.MultiDayBeforeOpenData.length-1];
            if (item && IFrameSplitOperator.IsNonEmptyArray(item.Data))
            {
                beforeDataVer=item.Ver;
                beforeItem=item.Data[item.Data.length-1];
                beforeExplain="MultiDayBeforeOpen";
            }  
        }
        else if (this.BeforeOpenData && IFrameSplitOperator.IsNonEmptyArray(this.BeforeOpenData.Data))
        {
            beforeItem=this.BeforeOpenData.Data[this.BeforeOpenData.Data.length-1];
            beforeDataVer=this.BeforeOpenData.Ver;
            beforeExplain="BeforeOpen";
        }

        var afterItem=null;
        var afterDataVer=1;
        var afterExplain
        if (IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData))
        {
            var item=this.MultiDayAfterCloseData[this.MultiDayAfterCloseData.length-1];
            if (item && IFrameSplitOperator.IsNonEmptyArray(item.Data))
            {
                afterDataVer=item.Ver;
                afterItem=item.Data[item.Data.length-1];
                afterExplain="MultiDayAfterClose";
                if (item.Data.length==item.TotalCount) afterItem=null;  //收盘以后，显示最后的1分钟价格就可以
            }
        }
        else if (this.AfterOpenData && IFrameSplitOperator.IsNonEmptyArray(this.AfterOpenData.Data))
        {
            afterItem=this.AfterOpenData.Data[this.AfterOpenData.Data.length-1];
            afterDataVer=this.AfterOpenData.Ver;
            afterExplain="AfterClose"
        }

        var dataItem=null;
        if (this.Data && IFrameSplitOperator.IsNonEmptyArray(this.Data.Data))
        {
            var count=this.Data.Data.length;
            dataItem=this.Data.Data[count-1];
        }

        if (!beforeItem && !afterItem && !dataItem) return null;

        if (!bCallAuction) return { Type:0, Data:dataItem };

        if (!dataItem) return { Type:1 , Data:beforeItem ,Ver: beforeDataVer, Explain:beforeExplain };

        if (beforeItem && dataItem) //盘前数据
        {
            if (beforeItem.Date>dataItem.Date || (beforeItem.Date==dataItem.Date && beforeItem.Time>dataItem.Time && beforeDataVer==1.0) 
                || (beforeItem.Date==dataItem.Date && parseInt(beforeItem.Time>dataItem.Time) && beforeDataVer==2.0)) 
                return { Type:2, Data:beforeItem, Ver: beforeDataVer,  Explain:beforeExplain};
        }

        if (afterItem && dataItem)  //盘后数据
        {
            if (afterItem.Date>=dataItem.Date) return { Type:1, Data:afterItem, Ver:afterDataVer, Explain:afterExplain };
        }


        return { Type:0 ,Data:dataItem };
    }

    this.GetFormatTitle=function(data) //{ Data:, IsLastOne: }
    {
        if (!data || !data.Data) return;

        var upperSymbol=this.Symbol.toUpperCase();
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);   //价格小数位数
        var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //国内期货, 纽约期货交易所
        
        var item=data.Data;
        var isLastOne=data.IsLastOne;
        var aryText=[]; //{Color:, Text: }

        if(this.IsShowName) aryText.push({Text:this.Name, Color:this.NameColor});

        if (this.IsShowDate || this.IsShowTime)
        {
            var bShowUpdateTime=false;  //是否显示了更新时间
            if (isLastOne && this.ShowLastDataFormat==1)
            {
                if (this.Data && this.Data.UpdateTime && IFrameSplitOperator.IsNumber(this.Data.UpdateTime.Date) && IFrameSplitOperator.IsNumber(this.Data.UpdateTime.Time))
                {
                    var text=IFrameSplitOperator.FormatTimeString(this.Data.UpdateTime.Time, "HH:MM:SS");
                    aryText.push({Text:text, Color:this.DateTimeColor});
                    bShowUpdateTime=true;
                }
            }
            
            if (!bShowUpdateTime)
            {
                if (this.TimeFormat)    //指定时间格式
                {
                    var strDate=null, strTime=null, text=null;
                    if (this.IsShowDate) strDate=IFrameSplitOperator.FormatDateString("YYYY-MM-DD", item.Date);
                    if (this.IsShowTime) strTime=IFrameSplitOperator.FormatTimeString(item.Time,this.TimeFormat);
                    if (strDate && strTime) text=`${strDate} ${strTime}`;
                    else if (strDate) text=strDate;
                    else if (strTime) text=strTime;
                    if (text) aryText.push({Text:text, Color:this.DateTimeColor});
                }
                else
                {
                    var text=IFrameSplitOperator.FormatDateTimeString(item.DateTime,this.IsShowDate, this.IsShowTime);
                    aryText.push({Text:text, Color:this.DateTimeColor});
                }
            }
        }

        var close=item.Close;
        var increase=item.Increase;
        var vol=item.Vol;
        var amount=item.Amount;
        var yClose=item.YClose;
        if (!IFrameSplitOperator.IsNumber(yClose)) yClose=this.YClose;
        if (isFutures && IFrameSplitOperator.IsNumber(item.YClearing)) yClose=item.YClearing;     //期货使用昨结算
        

        if (IFrameSplitOperator.IsNumber(close))
        {
            var color=this.GetColor(close,yClose);
            var text=g_JSChartLocalization.GetText('MTitle-Close',this.LanguageID)+close.toFixed(defaultfloatPrecision);
            aryText.push({Text:text, Color:color});
        }

        if (IFrameSplitOperator.IsNumber(increase))
        {
            var color=this.GetColor(increase,0);
            var text=g_JSChartLocalization.GetText('MTitle-Increase',this.LanguageID)+increase.toFixed(2)+'%';
            aryText.push({Text:text, Color:color});
        }

        var isShowAvPrice=true;
        var upperSymbol=this.Symbol.toUpperCase();
        if (MARKET_SUFFIX_NAME.IsET(upperSymbol) && !MARKET_SUFFIX_NAME.IsETShowAvPrice(upperSymbol)) isShowAvPrice=false;
        else if (MARKET_SUFFIX_NAME.IsShowAvPrice && !MARKET_SUFFIX_NAME.IsShowAvPrice(upperSymbol)) isShowAvPrice=false;

        if (IFrameSplitOperator.IsNumber(item.AvPrice) && isShowAvPrice && this.IsShowAveragePrice)
        {
            var color=this.GetColor(item.AvPrice,yClose);
            var text=g_JSChartLocalization.GetText('MTitle-AvPrice',this.LanguageID)+item.AvPrice.toFixed(defaultfloatPrecision);
            aryText.push({Text:text, Color:color});
        }

        if (IFrameSplitOperator.IsNumber(vol))
        {
            var text=g_JSChartLocalization.GetText('MTitle-Vol',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(vol,2,this.LanguageID);
            aryText.push({Text:text, Color:this.VolColor});
        }

        if (IFrameSplitOperator.IsNumber(amount))
        {
            var text=g_JSChartLocalization.GetText('MTitle-Amount',this.LanguageID)+IFrameSplitOperator.FormatValueString(amount,2,this.LanguageID);
            aryText.push({Text:text, Color:this.AmountColor});
        }

        if (IFrameSplitOperator.IsNumber(item.Position))
        {
            var text=g_JSChartLocalization.GetText('MTitle-Position',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(item.Position,2,this.LanguageID);
            aryText.push({Text:text, Color:this.VolColor});
        }

        if (isLastOne && this.ShowLastDataFormat==0)  //显示数据最后的更新时间
        {
            if (this.Data && this.Data.UpdateTime && IFrameSplitOperator.IsNumber(this.Data.UpdateTime.Date) && IFrameSplitOperator.IsNumber(this.Data.UpdateTime.Time))
            {
                var text=g_JSChartLocalization.GetText('MTitle-UpdateTime',this.LanguageID)+IFrameSplitOperator.FormatTimeString(this.Data.UpdateTime.Time, "HH:MM:SS");
                aryText.push({Text:text, Color:this.DateTimeColor});
            }
        }

        //叠加股票的名字
        if (IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint))
        {
            for(var i=0; i<this.OverlayChartPaint.length; ++i)
            {
                var item=this.OverlayChartPaint[i];
                if (!item.Symbol || !item.Title) continue;

                var clrText=item.Color;
                var text=`[${item.Title}]`;

                aryText.push({Text:text, Color:clrText});
            }
        }
       

        return { AryText:aryText };
    }

    this.DrawItem=function(item, isLastOne)    //isLastOne 是否是最后一个数据
    {
        if (!item) return;

        var pixelRatio=GetDevicePixelRatio();
        var isHScreen=this.Frame.IsHScreen===true;
        var border=this.Frame.GetBorder();
        var left=border.Left;
        var bottom=border.Top-this.Frame.ChartBorder.Top/2;
        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数
        this.Canvas.font=this.Font;

        if (isHScreen)
        {
            if (this.Frame.ChartBorder.Right<5*pixelRatio) return;
            var left=2;
            var bottom=this.Frame.ChartBorder.Right/2;    //上下居中显示
            var xText=border.ChartWidth;
            var yText=border.Top;
            this.Canvas.translate(xText, yText);
            this.Canvas.rotate(90 * Math.PI / 180);
        }
        else
        {
            if (this.Frame.ChartBorder.Top<5*pixelRatio) return;
        }

        this.Canvas.textAlign="left";
        if (this.TitleBaseLine==0)  //上
        {
            this.Canvas.textBaseline="top";
            bottom=2*pixelRatio;
        }
        else if (this.TitleBaseLine==2) //下
        {
            this.Canvas.textBaseline="bottom";
            var bottom=border.Top
        }
        else    //中
        {
            this.Canvas.textBaseline="middle";
        }
        
        var position = { Left: left, Bottom: bottom, IsHScreen: isHScreen };
        var titleData=this.GetFormatTitle({ Data:item, IsLastOne:isLastOne });

        if (titleData && IFrameSplitOperator.IsNonEmptyArray(titleData.AryText))
        {
            for(var i=0;i<titleData.AryText.length;++i)
            {
                var item=titleData.AryText[i];
                if (!this.DrawText(item.Text,item.Color,position)) break;
            }
        }

    }

    //盘前 盘后数据格式化
    this.FormatCallAuctionTitle=function(data)
    {
        var aryText=[] //{ Color: Text: }

        var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数

        //股票名称
        if (this.IsShowName) aryText.push({Text:this.Name, Color:this.NameColor});

        if (data && data.Data)
        {
            var item=data.Data;
            var text, strTime, strDate;
            strDate=IFrameSplitOperator.FormatDateString(item.Date);
            var yClose=item.YClose;

            //时间
            if (data.Ver==1.0) strTime=IFrameSplitOperator.FormatTimeString(item.Time,"HH:MM");
            else strTime=IFrameSplitOperator.FormatTimeString(item.Time,"HH:MM:SS");
            if (data.Explain=="MultiDayBeforeOpen"|| data.Explain=="MultiDayAfterClose") text=`${strDate} ${strTime}`;
            else text=strTime;
            aryText.push({Text:text, Color:this.DateTimeColor});

            //匹配价
            if(IFrameSplitOperator.IsNumber(item.Price) && this.CallAuctionShowTitle.has("MTitle-AC-Price"))
            {
                var color=this.GetColor(item.Price,yClose);
                var filedName='MTitle-AC-Price';
                if (data.Ver==1.0) filedName="MTitle-Close";
                var text=g_JSChartLocalization.GetText(filedName,this.LanguageID)+item.Price.toFixed(defaultfloatPrecision);
                aryText.push({Text:text, Color:color});
            }

            //竞价涨幅
            if (IFrameSplitOperator.IsPlusNumber(yClose) && IFrameSplitOperator.IsNumber(item.Price) && this.CallAuctionShowTitle.has("MTitle-AC-Increase"))
            {
                var value=(item.Price-yClose)/yClose*100;
                var color=this.GetColor(value,0);
                var filedName='MTitle-AC-Increase';
                if (data.Ver==1.0) filedName="MTitle-Increase";
                var text=g_JSChartLocalization.GetText(filedName,this.LanguageID)+value.toFixed(2)+"%";
                aryText.push({Text:text, Color:color});
            }

            //均价
            if (IFrameSplitOperator.IsNumber(item.AvPrice) && this.CallAuctionShowTitle.has("MTitle-AC-AvPrice"))
            {
                var color=this.GetColor(item.AvPrice,yClose);
                var text=g_JSChartLocalization.GetText('MTitle-AC-AvPrice',this.LanguageID)+item.AvPrice.toFixed(defaultfloatPrecision);
                aryText.push({Text:text, Color:color});
            }

             //匹配量
            if (IFrameSplitOperator.IsNumber(item.Vol[0]) && this.CallAuctionShowTitle.has("MTitle-AC-Vol"))
            {
                var filedName='MTitle-AC-Vol';
                if (data.Ver==1.0) filedName="MTitle-Vol";
                var text=g_JSChartLocalization.GetText(filedName,this.LanguageID)+IFrameSplitOperator.FromatIntegerString(item.Vol[0],2);
                aryText.push({Text:text, Color:this.VolColor});
            }
            
            //未匹配量
            if (IFrameSplitOperator.IsNumber(item.Vol[1]) && this.CallAuctionShowTitle.has("MTitle-AC-NotMatchVol"))
            {
                var text=g_JSChartLocalization.GetText('MTitle-AC-NotMatchVol',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(item.Vol[1],2);
                aryText.push({Text:text, Color:this.VolColor});
            }

            if (item.ExtendData && IFrameSplitOperator.IsNonEmptyArray(item.ExtendData.Amount))
            {
                var aryAmount=item.ExtendData.Amount;
                if (IFrameSplitOperator.IsNumber(aryAmount[0]) && this.CallAuctionShowTitle.has("MTitle-AC-Amount"))  //匹配量金额
                {
                    var text=g_JSChartLocalization.GetText('MTitle-AC-Amount',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(aryAmount[0],2);
                    aryText.push({Text:text, Color:this.AmountColor});
                }

                if (IFrameSplitOperator.IsNumber(aryAmount[1]) && this.CallAuctionShowTitle.has("MTitle-AC-NotMatchAmount")) //未匹配量金额
                {
                    var text=g_JSChartLocalization.GetText('MTitle-AC-NotMatchAmount',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(aryAmount[1],2);
                    aryText.push({Text:text, Color:this.AmountColor});
                }
            }
        }

        return { AryText:aryText };
    }

    this.DrawCallAuction=function() //集合竞价标题
    {
        var isHScreen=this.Frame.IsHScreen===true;
        var border=this.Frame.GetBorder();
        var pixelRatio=GetDevicePixelRatio();
        var left=border.Left;
        var bottom=border.Top-this.Frame.ChartBorder.Top/2;
        var bDraw=true;
        if (isHScreen) 
        {
            if (this.Frame.ChartBorder.Right<5*pixelRatio) return;
            var left=2;
            var bottom=this.Frame.ChartBorder.Right/2;    //上下居中显示
            var xText=border.ChartWidth;
            var yText=border.Top;
            this.Canvas.translate(xText, yText);
            this.Canvas.rotate(90 * Math.PI / 180);
        }
        else
        {
            if (this.Frame.ChartBorder.Top<5) bDraw=false;
        }

        this.Canvas.textAlign="left";
        this.Canvas.font=this.Font;

        if (this.TitleBaseLine==0)  //上
        {
            this.Canvas.textBaseline="top";
            bottom=2*pixelRatio;
        }
        else if (this.TitleBaseLine==2) //下
        {
            this.Canvas.textBaseline="bottom";
            var bottom=border.Top
        }
        else    //中
        {
            this.Canvas.textBaseline="middle";
        }

        var position = { Left: left, Bottom: bottom, IsHScreen: isHScreen };
        var auctionData=this.GetCurrentAuctionData();
        var titleData=this.FormatCallAuctionTitle(auctionData);

        if (bDraw && titleData && IFrameSplitOperator.IsNonEmptyArray(titleData.AryText))
        {
            for(var i=0;i<titleData.AryText.length;++i)
            {
                var item=titleData.AryText[i];
                if (!this.DrawText(item.Text,item.Color,position)) break;
            }
        }

        this.OnDrawCallAuctionEventCallback(auctionData);
    }

    this.OnDrawCallAuctionEventCallback=function(drawData)
    {
        if (this.OnDrawEvent && this.OnDrawEvent.Callback)
        {
            var data={ Draw: drawData, Name:this.ClassName };
            this.OnDrawEvent.Callback(this.OnDrawEvent,data,this);
        }

        if (this.OnMouseMoveEvent && this.OnMouseMoveEvent.Callback)
        {
            var data={ Draw: drawData, Name:this.ClassName };
            this.OnMouseMoveEvent.Callback(this.OnDrawEvent,data,this);
        }
    }

    this.DrawNone=function()
    {
        this.OnDrawEventCallback(null);

        if (this.IsAlwaysShowLastData) 
        {
            this.Canvas.save();
            this.DrawLastDataItem();
            this.Canvas.restore();
        }
    }

    this.Draw=function()
    {
        this.LastShowData=null;
        this.GlobalOption=this.Frame.GlobalOption;

        if (!this.IsShow)
        {   //隐藏标题 并且没有回调事件
            var bEvent=(this.OnDrawEvent && this.OnDrawEvent.Callback) || (this.OnMouseMoveEvent && this.OnMouseMoveEvent.Callback);
            if (!bEvent) return;
        } 

        if (this.PointInfo && 
            ( this.PointInfo.ClientPos==2 || this.PointInfo.ClientPos==3 || 
              (this.PointInfo.ClientPos>=200&& this.PointInfo.ClientPos<=299) ||
              (this.PointInfo.ClientPos>=300&& this.PointInfo.ClientPos<=399) ) )
        {   //集合竞价区域
            this.Canvas.save();
            this.DrawCallAuction();
            this.Canvas.restore();
            return;
        }

        if (!this.Data || !this.Data.Data || this.Data.Data.length<=0)
        {
            this.DrawNone();
            return;
        }

        if (this.CursorIndex==null && !(this.GlobalOption && this.GlobalOption.IsDisplayLatest))
        {
            this.DrawNone();
            return;
        }

        this.Canvas.font=this.Font;
        this.SpaceWidth = this.Canvas.measureText('0').width;

        var isShowLastData=false;
        if (this.DrawStatus && this.DrawStatus.IsTitleShowLatestData)
        {
            var status=this.DrawStatus;
            if (!IFrameSplitOperator.IsNumber(status.FrameID) || status.FrameID<0)
                isShowLastData=true;
            else if (status.CorssCursorTouchEnd && status.IsOnTouch==false)
                isShowLastData=true;
        }
        else if (this.GlobalOption && this.GlobalOption.IsDisplayLatest)
        {
            isShowLastData=true;
        }

        var isLastOne=false;
        if (isShowLastData)
        {
            var item=null;
            var lastItem=this.GetLatestKLineData(true);
            if (lastItem && lastItem.Type==0) item=lastItem.Data;

            isLastOne=true;
        }
        else
        {
            //var index=Math.abs(this.CursorIndex-0.5);
            var index=this.CursorIndex;
            index=parseInt(index.toFixed(0));
            var dataIndex=index+this.Data.DataOffset;
            if (dataIndex>=this.Data.Data.length) dataIndex=this.Data.Data.length-1;
            var item=this.Data.Data[dataIndex];

            if (dataIndex==this.Data.Data.length-1) isLastOne=true;
        }
        
        this.LastShowData=item;

        this.Canvas.save();
        this.OnDrawEventCallback(item);

        if (this.IsAlwaysShowLastData) 
        {
            this.DrawLastDataItem();
        }
        else
        {
            this.DrawItem(item,isLastOne);
        }
        
        this.Canvas.restore();
    }

    this.DrawCallAuctionItem=function(callAuctionItem, isLastOne)
    {
        if (!callAuctionItem) return;

        var item=callAuctionItem.Data;
        var dataVersion=callAuctionItem.Ver;

        var isHScreen=this.Frame.IsHScreen===true;
        var border=this.Frame.GetBorder();

        var left=border.Left;
        var bottom=border.Top-this.Frame.ChartBorder.Top/2;
        //var defaultfloatPrecision=GetfloatPrecision(this.Symbol);//价格小数位数
        var bDraw=true;
        if (isHScreen) 
        {
            var left=2;
            var bottom=this.Frame.ChartBorder.Right/2;    //上下居中显示
            var xText=border.ChartWidth;
            var yText=border.Top;
            this.Canvas.translate(xText, yText);
            this.Canvas.rotate(90 * Math.PI / 180);
        }
        else
        {
            if (this.Frame.ChartBorder.Top<5) bDraw=false;
        }

        this.Canvas.textAlign="left";
        this.Canvas.font=this.Font;

        if (this.TitleBaseLine==0)  //上
        {
            this.Canvas.textBaseline="top";
            bottom=2*GetDevicePixelRatio();
        }
        else if (this.TitleBaseLine==2) //下
        {
            this.Canvas.textBaseline="bottom";
            var bottom=border.Top
        }
        else    //中
        {
            this.Canvas.textBaseline="middle";
        }

        var position = { Left: left, Bottom: bottom, IsHScreen: isHScreen };
        var titleData=this.FormatCallAuctionTitle(callAuctionItem);

        if (bDraw && titleData && IFrameSplitOperator.IsNonEmptyArray(titleData.AryText))
        {
            for(var i=0;i<titleData.AryText.length;++i)
            {
                var item=titleData.AryText[i];
                if (!this.DrawText(item.Text,item.Color,position)) break;
            }
        }

        /*
        if(bDraw && this.IsShowName)
        {
            if (!this.DrawText(this.Name,this.NameColor,position)) return;
        }

        var time=item.Time;
        var strTime;
        if (dataVersion==1.0) strTime=IFrameSplitOperator.FormatTimeString(time,"HH:MM");
        else strTime=IFrameSplitOperator.FormatTimeString(time,"HH:MM:SS");
        var strDate=IFrameSplitOperator.FormatDateString(item.Date);
        strTime=`${strDate} ${strTime}`;
        
        if (bDraw && this.IsShowTime && strTime )
        {
            if (!this.DrawText(strTime,this.DateTimeColor,position)) return;
        }

        //匹配价
        if (bDraw && item && IFrameSplitOperator.IsNumber(item.Price) && this.CallAuctionShowTitle.has("MTitle-AC-Price"))
        {
            var color=this.GetColor(item.Price,this.YClose);
            var filedName='MTitle-AC-Price';
            if (this.BeforeOpenData && this.BeforeOpenData.Ver==1.0) filedName="MTitle-Close";
            var text=g_JSChartLocalization.GetText(filedName,this.LanguageID)+item.Price.toFixed(defaultfloatPrecision);
            if (!this.DrawText(text,color,position)) return;
        }

        //竞价涨幅
        if (bDraw && item && IFrameSplitOperator.IsPlusNumber(this.YClose) && IFrameSplitOperator.IsNumber(item.Price) && this.CallAuctionShowTitle.has("MTitle-AC-Increase"))
        {
            var value=(item.Price-this.YClose)/this.YClose*100;
            var color=this.GetColor(value,0);
            var filedName='MTitle-AC-Increase';
            if (this.BeforeOpenData && this.BeforeOpenData.Ver==1.0) filedName="MTitle-Increase";
            var text=g_JSChartLocalization.GetText(filedName,this.LanguageID)+value.toFixed(2)+"%";
            if (!this.DrawText(text,color,position)) return;
        }

        if (dataVersion==3.0)
        {
            if (bDraw && item && IFrameSplitOperator.IsNumber(item.AvPrice) && this.CallAuctionShowTitle.has("MTitle-AC-AvPrice"))
            {
                var color=this.GetColor(item.Price,this.YClose);
                var text=g_JSChartLocalization.GetText('MTitle-AC-AvPrice',this.LanguageID)+item.AvPrice.toFixed(defaultfloatPrecision);
                if (!this.DrawText(text,color,position)) return;
            }
        }

        //匹配量
        if (bDraw && IFrameSplitOperator.IsNumber(item.Vol[0]) && this.CallAuctionShowTitle.has("MTitle-AC-Vol"))
        {
            var filedName='MTitle-AC-Vol';
            if (this.BeforeOpenData && this.BeforeOpenData.Ver==1.0) filedName="MTitle-Vol";
            var text=g_JSChartLocalization.GetText(filedName,this.LanguageID)+IFrameSplitOperator.FromatIntegerString(item.Vol[0],2);
            if (!this.DrawText(text,this.VolColor,position)) return;
        }
        
        //未匹配量
        if (bDraw && IFrameSplitOperator.IsNumber(item.Vol[1]) && this.CallAuctionShowTitle.has("MTitle-AC-NotMatchVol"))
        {
            var text=g_JSChartLocalization.GetText('MTitle-AC-NotMatchVol',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(item.Vol[1],2);
            if (!this.DrawText(text,this.VolColor,position)) return;
        }

        if (bDraw)
        {
            if (item.ExtendData && IFrameSplitOperator.IsNonEmptyArray(item.ExtendData.Amount))
            {
                var aryAmount=item.ExtendData.Amount;
                if (IFrameSplitOperator.IsNumber(aryAmount[0]) && this.CallAuctionShowTitle.has("MTitle-AC-Amount"))  //匹配量金额
                {
                    var text=g_JSChartLocalization.GetText('MTitle-AC-Amount',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(aryAmount[0],2);
                    if (!this.DrawText(text,this.AmountColor,position)) return;
                }

                if (IFrameSplitOperator.IsNumber(aryAmount[1]) && this.CallAuctionShowTitle.has("MTitle-AC-NotMatchAmount")) //未匹配量金额
                {
                    var text=g_JSChartLocalization.GetText('MTitle-AC-NotMatchAmount',this.LanguageID)+IFrameSplitOperator.FromatIntegerString(aryAmount[1],2);
                    if (!this.DrawText(text,this.AmountColor,position)) return;
                }
            }
        }
        */
    }

    this.DrawLastDataItem=function()
    {
        var lastItem=this.GetLatestKLineData(true);
        if (lastItem)
        {
            if (lastItem.Type==0)
                this.DrawItem(lastItem.Data, true);
            else if (lastItem.Type==1 || lastItem.Type==2)
                this.DrawCallAuctionItem(lastItem, true);
        }
    }
}

//字符串输出格式
var STRING_FORMAT_TYPE =
{
    DEFAULT: 1,     //默认 2位小数 单位自动转化 (万 亿)
    ORIGINAL:2,     //原始数据
    INTEGER:3,      //整形数据输出 如果不是整形使用 DEFAULT
    THOUSANDS:21,   //千分位分割
};

function DynamicTitleData(data,name,color)
{
    this.Data=data;
    this.Name=name;
    this.Color=color;   //字体颜色
    this.DataType;      //数据类型
    this.ChartClassName;     //图形类名
    this.StringFormat=STRING_FORMAT_TYPE.DEFAULT;   //字符串格式
    this.FloatPrecision=2;                          //小数位数
    this.IsShow=true;   //是否显示
    this.Callback;      //绘制标题回调
    this.ExtendData;    //扩展数据
}

function DynamicChartTitlePainting()
{
    this.newMethod=IChartTitlePainting;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='DynamicChartTitlePainting';

    this.IsDynamic=true;
    this.Data=[];
    this.Explain;

    this.ColorIndex;    //五彩K线名字 {Name:'名字'}
    this.IsShowColorIndexTitle=true;
    this.IsShowUpDownArrow=true;   //指标数据是否显示 上涨下跌箭头
    this.TitleArrowType=0;         //指标数据上涨下跌箭头类型 0=独立颜色 1=跟指标颜色一致
    this.IsShowIndexName=true;     //是否显示指标名字
    this.IsShowIndexTitle=true;    //是否显示指标标题信息
    this.IsShowNameArrow=false;
    this.NameArrowConfig=CloneData(g_JSChartResource.IndexTitle.NameArrow);

    this.TradeIndex;    //专家系统名字{Name:'名字', Param:'参数'}
    this.IsShowTradeIndexTitle=true;

    this.OverlayIndex=new Map();        //叠加指标 key=Identify value={ Data:数据, Title:标题, Identify:标识}
    this.IsShowOverlayIndexName=true;   //是否显示叠加指标名字
    this.OverlayIndexType={ Position:0, LineSpace:5, BGColor:g_JSChartResource.OverlayIndexTitleBGColor };        //Position 0=主图指标后面显示 1=叠加指标单行显示
                                                                                               //LineSpace 行间距

    this.LanguageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
    this.TitleRect;              //指标名字显示区域
    this.IsDrawTitleBG=false;    //是否绘制指标名字背景色
    this.BGColor=g_JSChartResource.IndexTitleBGColor;
    this.BGBorderColor=g_JSChartResource.IndexTitleBorderColor;
    this.BGBorderMoveOnColor=g_JSChartResource.IndexTitleBorderMoveOnColor;
    this.BorderRoundRadius=2;   //圆角矩形角度
    this.NameButtonStyle=g_JSChartResource.IndexTitleBorderStyle,

    this.OnDrawEvent;
    this.ParamSpace=2;              //参数显示的间距
    this.TitleSpace=2;              //指标名字和参数之间的间距
    this.TitleColor=g_JSChartResource.IndexTitleColor;   //指标名字颜色
    this.SelectedColor=g_JSChartResource.IndexTitleSelectedColor;

    this.IsKLineFrame=false;    //是否是K线框架标题
    this.IsMinuteFrame=false;
    this.Identify;              //指标ID
    this.SelectedChart;         //选中的图形
    this.ArgumentsText;         //参数信息

    this.MerginLeft=g_JSChartResource.IndexTitleMerginLeft;          //标题输出左边间距

    this.Buttons=[];  //按钮

    this.UpDownArrowConfig=
    {
        UpColor:g_JSChartResource.IndexTitle.UpDownArrow.UpColor,
        DownColor:g_JSChartResource.IndexTitle.UpDownArrow.DownColor,
        UnchangeColor:g_JSChartResource.IndexTitle.UpDownArrow.UnchangeColor
    };
    

    //动态标题
    //动态标题
    this.DynamicTitle={ OutName:null, OutValue:null };
    this.OverlayDynamicTitle=new Map();  //key , value={ OutName, OutValue }

    this.IsShowMainIndexTitle=true; //是否显示主图指标标题
    this.MainTitlePaint=null;       //主标题

    this.ReloadResource=function()
    {
        this.Font=g_JSChartResource.TitleFont;
        this.TitleColor=g_JSChartResource.DefaultTextColor;
        this.OverlayIndexType.BGColor=g_JSChartResource.OverlayIndexTitleBGColor;
    }

    this.SetDynamicTitleData=function(outName, args, data)
    {
        if (!data.OutName) data.OutName=new Map();
        else data.OutName.clear();

        if (!data.OutValue) data.OutValue=new Map();
        else data.OutValue.clear();

        var mapArgs=new Map();
        for(var i in args)
        {
            var item=args[i];
            mapArgs.set(`{${item.Name}}`, item);
        }

        for(var i in outName)
        {
            var item=outName[i];
            if (item.DynamicName)
            {
                var aryFond = item.DynamicName.match(/{\w*}/i);
                if (!aryFond || aryFond.length<=0) 
                {
                    data.OutName.set(item.Name, item.DynamicName);
                }
                else
                {
                    var dyName=item.DynamicName;
                    var bFind=true;
                    for(var j=0;j<aryFond.length;++j)
                    {
                        var findItem=aryFond[j];
                        if (mapArgs.has(findItem))
                        {
                            var value=mapArgs.get(findItem).Value;
                            dyName=dyName.replace(findItem,value.toString());
                        }
                        else
                        {
                            bFind=false;
                            break;
                        }
                    }
    
                    if (bFind) data.OutName.set(item.Name, dyName);
                }
    
            }

            if (item.DynamicValue)
            {
                data.OutValue.set(item.Name, item.DynamicValue);
            }
        }
    }

    this.SetDynamicTitle=function(outName, args, overlayID)
    {
        if (IFrameSplitOperator.IsString(overlayID))
        {
            var dynamicTitle=null;
            if (this.OverlayDynamicTitle.has(overlayID)) 
            {
                dynamicTitle=this.OverlayDynamicTitle.get(overlayID);
            }
            else
            {
                dynamicTitle={ OutName:null, OutValue:null };
                this.OverlayDynamicTitle.set(overlayID, dynamicTitle);
            }

            this.SetDynamicTitleData(outName, args, dynamicTitle); 
        }
        else
        {
            this.SetDynamicTitleData(outName, args, this.DynamicTitle);    
        }
    }

    this.GetDynamicOutName=function(key, overlayID)
    {
        if (IFrameSplitOperator.IsString(overlayID))
        {
            if (!this.OverlayDynamicTitle.has(overlayID)) return null;
            var dynamicTitle=this.OverlayDynamicTitle.get(overlayID);
            var outName=dynamicTitle.OutName;
        }
        else
        {
            var outName=this.DynamicTitle.OutName;
        }

        if (!outName || outName.size<=0) return null;
        if (!outName.has(key)) return null;

        return outName.get(key);
    }

    this.GetDynamicOutValue=function(key, value)
    {
        var outValue=this.DynamicTitle.OutValue;

        if (!outValue || outValue.size<=0) return null;
        if (!outValue.has(key)) return null;

        var strFormat=outValue.get(key);
        strFormat=strFormat.replace('{Value}',value);
        return strFormat;
    }

    this.IsClickTitle=function(x,y) //是否点击了指标标题
    {
        if (!this.TitleRect) return false;

        if (x>this.TitleRect.Left && x<this.TitleRect.Left+this.TitleRect.Width && y>this.TitleRect.Top && y<this.TitleRect.Top+this.TitleRect.Height)
        {
            return true;
        }

        return false;
    }

    this.FormatValue=function(value,item)
    {
        if (item.StringFormat==STRING_FORMAT_TYPE.DEFAULT)
            return IFrameSplitOperator.FormatValueString(value,item.FloatPrecision,this.LanguageID);
        else if (item.StringFormat==STRING_FORMAT_TYPE.THOUSANDS)
            return IFrameSplitOperator.FormatValueThousandsString(value,item.FloatPrecision);
        else if (item.StringFormat==STRING_FORMAT_TYPE.ORIGINAL) 
            return value.toFixed(item.FloatPrecision).toString();
        else if (item.StringFormat==STRING_FORMAT_TYPE.INTEGER)
            return IFrameSplitOperator.FromatIntegerString(value,item.FloatPrecision,this.LanguageID);
    }

    this.FormatMultiReport=function(data,format)
    {
        var text="";
        for(var i in data)
        {
            var item = data[i];
            let quarter=item.Quarter;
            let year=item.Year;
            let value=item.Value;

            if (text.length>0) text+=',';

            text+=year.toString();
            switch(quarter)
            {
                case 1:
                    text+='一季报 ';
                    break;
                case 2:
                    text+='半年报 ';
                    break;
                case 3:
                    text+='三季报 ';
                    break;
                case 4:
                    text+='年报 ';
                    break;
            }

            text+=this.FormatValue(value,format);
        }

        return text;
    }

    this.FromatMultiDataLine=function(value, dataInfo)
    {
        var text="";
        if (Array.isArray(value))
        {
            for(var i=0;i<value.length;++i)
            {
                var item=value[i];
                if (item.Type==0) continue;
                if (!IFrameSplitOperator.IsNumber(item.Value)) continue;
                var strValue=this.FormatValue(item.Value,dataInfo);
                if (text.length>0) text+=',';
                text+=strValue;
            }
        }
        else
        {
            if (value.Type!=0 && IFrameSplitOperator.IsNumber(value.Value))
            {
                text=this.FormatValue(value.Value,dataInfo);
            }
        }

        if (text.length<=0) return null;

        return text;
    }

    //多变量输出
    this.FromatStackedBarTitle=function(aryBar, dataInfo)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryBar)) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(dataInfo.Color)) return null;

        var aryText=[];
        for(var i=0;i<aryBar.length;++i)
        {
            var value=aryBar[i];
            if (!IFrameSplitOperator.IsNumber(value)) continue;

            var item={ Text:value.toFixed(2) };
            if (dataInfo.Name && dataInfo.Name[i]) item.Name=dataInfo.Name[i];
            item.Color=dataInfo.Color[i];

            aryText.push(item);
        }

        if (aryText.length<=0) return null;

        return aryText;
    }

    this.ForamtMultiLineTitle=function(dataIndex, dataInfo)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(dataInfo.Lines)) return null;

        var aryText=[];
        for(var i=0;i<dataInfo.Lines.length;++i)
        {
            var line=dataInfo.Lines[i];
            for(var j=0;j<line.Point.length;++j)
            {
                var item=line.Point[j];
                if (item.Index==dataIndex)
                {
                    var item={ Text:item.Value.toFixed(2)};
                    if (aryText.length==0) item.Name=dataInfo.Name;
                    item.Color=line.Color;
                    aryText.push(item);
                    break;
                }
            }
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(aryText)) return null;

        return aryText;
    }

    this.ForamtMultiPointTitle=function(dataIndex, dataInfo)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(dataInfo.PointGroup)) return null;

        var aryText=[];
        for(var i=0;i<dataInfo.PointGroup.length;++i)
        {
            var groupItem=dataInfo.PointGroup[i];
            for(var j=0;j<groupItem.Point.length;++j)
            {
                var item=groupItem.Point[j];
                if (item.Index==dataIndex)
                {
                    var item={ Text:item.Value.toFixed(2)};
                    if (aryText.length==0) item.Name=dataInfo.Name;
                    item.Color=groupItem.BGColor;
                    aryText.push(item);
                    break;
                }
            }
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(aryText)) return null;

        return aryText;
    }

    this.FormatVPVRTitle=function(pt, dataInfo)
    {
        var chart=dataInfo.Chart;
        var aryText=[];

        if (chart.VolType==0) 
        {
            var item={ Text:" Up/Down ", Color:this.TitleColor };
            aryText.push(item);
        }
        else
        {
            var item={ Text:" Total ",Color:this.TitleColor };
            aryText.push(item);
        }

        if (!IFrameSplitOperator.IsNumber(pt.Y)) return aryText;
        var top=this.Frame.ChartBorder.GetTopEx();
        var bottom=this.Frame.ChartBorder.GetBottomEx();
        if (pt.Y<top || pt.Y>bottom) return aryText;
        var yPrice=this.Frame.GetYData(pt.Y);

        var find=null;
        for(var i=0; i<dataInfo.Data.Data.length; ++i)
        {
            var item=dataInfo.Data.Data[i];
            if (yPrice>=item.Price-dataInfo.Data.PriceOffset/2 && yPrice<item.Price+dataInfo.Data.PriceOffset/2)
            {
                find=item;
                break;
            }
        }

        if (!find) return null;

        if (chart.VolType==0)
        {
            var total=0;
            for(var i=0;i<find.Vol.length;++i)
            {
                var volItem=find.Vol[i];
                if (!IFrameSplitOperator.IsNumber(volItem.Value)) continue;

                var item={ Text:IFrameSplitOperator.FormatVolString(volItem.Value,this.LanguageID) };

                total+=volItem.Value;

                if (IFrameSplitOperator.IsNumber(volItem.ColorID)) item.Color=chart.BarColor[volItem.ColorID];
                else if (volItem.Color) item.Color=volItem.Color;

                aryText.push(item);
            }

            var item={Text:IFrameSplitOperator.FormatVolString(total,this.LanguageID),Color:this.TitleColor};
            aryText.push(item);
        }
        else
        {
            if (find.TotalVol && IFrameSplitOperator.IsNumber(find.TotalVol.Value))
            {
                var item={Text:IFrameSplitOperator.FormatVolString(find.TotalVol.Value,this.LanguageID) };
                if (IFrameSplitOperator.IsNumber(find.TotalVol.ColorID)) item.Color=chart.BarColor[find.TotalVol.ColorID];
                else if (find.TotalVol.Color) item.Color=find.TotalVol.Color;

                aryText.push(item);
            }
        }


        return aryText;
    }

    this.IsShowLastData=function()
    {
        var isShowLastData=false;
        if (this.DrawStatus && this.DrawStatus.IsTitleShowLatestData)
        {
            var status=this.DrawStatus;
            if (!IFrameSplitOperator.IsNumber(status.FrameID) || status.FrameID<0)
                isShowLastData=true;
            else if (status.CorssCursorTouchEnd && status.IsOnTouch==false)
                isShowLastData=true;
        }
        else if (this.GlobalOption && this.GlobalOption.IsDisplayLatest)
        {
            isShowLastData=true;
        }

        return isShowLastData;
    }

    this.OnDrawTitleEvent=function()
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_INDEXTITLE_DRAW);
        if (!event) return;
        
        var data={ Index:null, Data:this.Data ,Title:this.Title, Script:this.Script, FrameID:this.Frame.Identify, OverlayIndex:this.OverlayIndex, IsShowTitleOnly:false };
        if (this.ArgumentsText) data.ArgumentsText=this.ArgumentsText;
        if (this.Frame && this.Frame.ChartBorder) data.IsShowTitleOnly=this.Frame.ChartBorder.IsShowTitleOnly;
        
        if (IFrameSplitOperator.IsNumber(this.CursorIndex))
        {
            var index=Math.abs(this.CursorIndex);
            index=parseInt(index.toFixed(0));
            data.Index=index;   //当前屏数据索引
        }

        var pixelTatio = GetDevicePixelRatio();
        var border=this.Frame.GetBorder();
        data.Left=border.LeftEx/pixelTatio;
        data.Top=border.Top/pixelTatio;
        data.Right=border.RightEx/pixelTatio;

        event.Callback(event,data,this);
        
    }

    this.IsSelectedChart=function(id)
    {
        if (!id) return false;
        if (!this.SelectedChart) return false
        if (!this.SelectedChart.Selected) return false

        return this.SelectedChart.Selected.Identify==id;
    }

    this.Draw=function(moveonPoint, mouseStatus)
    {
        this.Buttons=[];
        if (this.Frame.IsMinSize) return;

        this.IsKLineFrame= this.Frame.IsKLineFrame(false);
        this.IsMinuteFrame=this.Frame.IsMinuteFrame(false);
        this.IsDrawTitleBG=this.Frame.IsDrawTitleBG;
        this.IsShowNameArrow=this.Frame.IsShowNameArrow;
        this.IsShowUpDownArrow=this.Frame.IsShowTitleArrow;
        this.TitleArrowType=this.Frame.TitleArrowType;
        this.IsShowIndexName=this.Frame.IsShowIndexName;
        this.IsShowOverlayIndexName=this.Frame.IsShowOverlayIndexName;
        this.OverlayIndexType.Position=this.Frame.OverlayIndexType.Position;
        this.OverlayIndexType.LineSpace=this.Frame.OverlayIndexType.LineSpace;
        this.ParamSpace=this.Frame.IndexParamSpace;
        this.TitleSpace=this.Frame.IndexTitleSpace;
        this.TitleRect=null;
        this.GlobalOption=this.Frame.GlobalOption;

        this.OnDrawTitleEvent();

        if (this.Frame.IsShowIndexTitle==false) return;
        if (g_JSChartResource.IsDOMFrameTitle===true) return;
        if (!this.Data) return;
        if (this.Frame.ChartBorder.TitleHeight<5) return;
        if (this.CursorIndex==null && !(this.GlobalOption && this.GlobalOption.IsDisplayLatest)) return;

        if (this.Frame.IsHScreen===true)
        {
            this.Canvas.save();
            this.HScreenDraw();
            this.Canvas.restore();

            /* 测试用
            if (this.TitleRect)
            {
                this.Canvas.strokeStyle='rgba(200,0,50,0.5)';
                this.Canvas.strokeRect(ToFixedPoint(this.TitleRect.Left),ToFixedPoint(this.TitleRect.Top),ToFixedRect(this.TitleRect.Width),ToFixedRect(this.TitleRect.Height));
            }
            */

            return;
        }

        var left=this.Frame.ChartBorder.GetLeft()+this.MerginLeft;
        var bottom=this.Frame.ChartBorder.GetTop()+this.Frame.ChartBorder.TitleHeight/2;    //上下居中显示
        var right=this.Frame.ChartBorder.GetRight();

        var toolbarInfo={ Width:0, YCenter:bottom };
        this.DrawToolbar(toolbarInfo,moveonPoint, mouseStatus);
        left+=toolbarInfo.Width;

        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.font=this.Font;
        var pixelRatio=GetDevicePixelRatio();
        if (this.Title && this.IsShowIndexName && this.IsShowMainIndexTitle)
        {
            if (this.IsDrawTitleBG)
            {
                var rtButton={ Left:left, YCenter:bottom, Width:0 };
                this.DrawNameButton(rtButton, moveonPoint, mouseStatus);

                this.Buttons.push({ ID:JSCHART_BUTTON_ID.INDEX_NAME_BUTTON, Rect:rtButton, FrameID:this.Frame.Identify, Type:2 });  //Type 0=主图按钮 1=附图按钮 2=主图指标名字按钮

                if (this.IsSelectedChart(this.Identify)) 
                    this.DrawSelectedLine(left, bottom, textWidth);

                this.TitleRect=rtButton;
                left+=rtButton.Width+3*pixelRatio;
                left+=this.TitleSpace;
            }
            else
            {
                var textWidth=this.Canvas.measureText(this.Title).width+2;
                this.Canvas.fillStyle=this.TitleColor;
                this.Canvas.fillText(this.Title,left,bottom,textWidth);
                if (this.IsSelectedChart(this.Identify)) 
                    this.DrawSelectedLine(left, bottom, textWidth);
                
                left+=textWidth;
                left+=this.TitleSpace;
            }
        }

        if (this.ArgumentsText && this.IsShowIndexName && this.IsShowMainIndexTitle)
        {
            var textWidth=this.Canvas.measureText(this.ArgumentsText).width+2;
            this.Canvas.fillStyle=this.TitleColor;
            this.Canvas.fillText(this.ArgumentsText,left,bottom,textWidth);
            left+=textWidth;
            left+=this.TitleSpace;
        }

        var isShowLastData=this.IsShowLastData();
        var lockRect=this.Frame.GetLockRect();
        if (lockRect)   //指标上锁区域不显示动态标题
        {
            var index=Math.abs(this.CursorIndex);
            if (this.IsKLineFrame) index=this.CursorIndex;
            var x=this.Frame.GetXFromIndex(index.toFixed(0));
            if (x>=lockRect.Left) return;
            if (isShowLastData) return;
        }

        var rtText={ Left:left, Right:left };
        if (this.IsMinuteFrame && this.PointInfo &&  ( this.PointInfo.ClientPos==2 || this.PointInfo.ClientPos==3 ||  (this.PointInfo.ClientPos>=200&& this.PointInfo.ClientPos<=299) || (this.PointInfo.ClientPos>=300&& this.PointInfo.ClientPos<=399) ))
        {
            var result={ PreventDefault:false }
            this.DrawMainCallAuction({ Left:left, Right:right, Bottom:bottom }, rtText, result);
            if (result.PreventDefault===false) this.DrawMainIndexTitle({ Left:left, Right:right, Bottom:bottom }, isShowLastData, rtText);
        }
        else
        {
            this.DrawMainIndexTitle({ Left:left, Right:right, Bottom:bottom }, isShowLastData, rtText);
        }
        
        left=rtText.Left;

        if (this.Explain)   //说明信息
        {
            this.Canvas.fillStyle=this.TitleColor;
            var text="说明:"+this.Explain;
            var textWidth=this.Canvas.measureText(text).width+2;
            if (left+textWidth<right)
            {
                this.Canvas.fillText(text,left,bottom,textWidth);
                left+=textWidth;
            }
        }

        if (this.ColorIndex && this.IsShowColorIndexTitle)
        {
            this.Canvas.fillStyle=g_JSChartResource.Title.ColorIndexColor;
            var tradeName=this.ColorIndex.Name+this.ColorIndex.Param;
            var textWidth=this.Canvas.measureText(tradeName).width+2;    //后空2个像素
            this.Canvas.fillText(tradeName,left,bottom,textWidth);
            left+=textWidth;
        }

        if (this.TradeIndex && this.IsShowTradeIndexTitle)
        {
            this.Canvas.fillStyle=g_JSChartResource.Title.TradeIndexColor;
            var tradeName=this.TradeIndex.Name+this.TradeIndex.Param;
            var textWidth=this.Canvas.measureText(tradeName).width+2;    //后空2个像素
            this.Canvas.fillText(tradeName,left,bottom,textWidth);
            left+=textWidth;
        }

        if (this.OverlayIndexType.Position==1) 
        {
            if (!this.Frame.ChartBorder.IsShowTitleOnly)
                this.DrawOverlayIndexSingleLine(moveonPoint, mouseStatus);
        }
        else 
        {
            var xOffset=10*GetDevicePixelRatio();   //主指标区分开 间距多空点 
            if (!this.IsShowMainIndexTitle) xOffset=0;
            this.DrawOverlayIndex(left+xOffset);   
        }
    }

    this.GetTitleItem=function(item, isShowLastData, titleIndex)
    {
        if (!item || !item.Data || !item.Data.Data) return null;;
        if (Array.isArray(item.Data.Data) && item.Data.Data.length<=0) return null;
        if (item.IsShow===false) return null;
        if (item.IsVisible===false) return null;

        var valueText=null; //单值
        var aryText=null;   //多值

        var value=null;
        var preVaildItem=null;
        if (item.DataType=="StraightLine")  //直线只有1个数据
        {
            value=item.Data.Data[0];
            valueText=this.FormatValue(value,item);
        }
        else if (item.ChartClassName=="ChartVolProfileVisibleRange")
        {
            aryText=this.FormatVPVRTitle(this.LastPoint, item);
            if (!aryText) return null;
            return { Text:null, ArrayText:aryText };
        }
        else
        {
            if (isShowLastData)
            {
                var dataIndex=item.Data.Data.length-1;  //显示最后一个数据
            }
            else
            {
                var index=Math.abs(this.CursorIndex);
                index=parseInt(index.toFixed(0));
                if (this.IsKLineFrame) index=this.CursorIndex;
                var dataIndex=item.Data.DataOffset+index;
                if (dataIndex>=item.Data.Data.length) dataIndex=item.Data.Data.length-1;
                if (dataIndex<0) return null;
            }

            if (item.DataType=="ChartMultiLine")   //多线段数据
            {
                aryText=this.ForamtMultiLineTitle(dataIndex, item);
                if (!aryText) return null;
                return { Text:null, ArrayText:aryText };
            }
            else if (item.DataType=="ChartMultiPoint")
            {
                aryText=this.ForamtMultiPointTitle(dataIndex, item);
                if (!aryText) return null;
                return { Text:null, ArrayText:aryText };
            }

            value=item.Data.Data[dataIndex];
            
            if (value==null && item.ChartClassName=="ChartStepLine") //当前值无效,上一个值延续
            {
                preVaildItem=this.GetPreVaildItem(item.Data.Data, dataIndex);
                if (!preVaildItem) return null;

                preText=this.FormatValue(preVaildItem.Item,item);
                if (item.Name) 
                {
                    var dyValue=this.GetDynamicOutValue(item.Name, preText);
                    if (dyValue) preText=dyValue;
                }

                valueText=`--(${preText})`;

                return { Text:valueText, ArrayText:aryText };
            }

            if (value==null) return null;

            if (item.DataType=="HistoryData-Vol")
            {
                value=value.Vol;
                valueText=this.FormatValue(value,item);
            }
            else if (item.DataType=="MultiReport")
            {
                valueText=this.FormatMultiReport(value,item);
            }
            else if (item.DataType=="MULTI_POINT_LINE")
            {
                valueText=this.FromatMultiDataLine(value, item);
                if (!valueText) return null;
            }
            else if (item.DataType=="ChartStackedBar")
            {
                aryText=this.FromatStackedBarTitle(value, item);
                if (!aryText) return null;
                return { Text:null, ArrayText:aryText };
            }
            else if (g_ScriptIndexChartFactory.Has(item.DataType)) //外部挂接
            {
                var find=g_ScriptIndexChartFactory.Get(item.DataType);
                if (find && find.FormatTitleCallback)
                return find.FormatTitleCallback(value, item, dataIndex);
            }
            else
            {
                if (this.GetEventCallback)
                {
                    var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_INDEX_OUT_TEXT);
                    if (event)
                    {
                        var data=
                        { 
                            Item:item, Index:titleIndex, Data:this.Data, FrameID:this.Frame.Identify,
                            DataIndex:dataIndex, Value:value,
                            Out:null
                         };
                        event.Callback(event,data,this);
                        if (data.Out) return data.Out;
                    }
                }
                
                if (item.DataType=="ChartBand") //默认不输出
                    return null;
                

                var arrowSuper=null;    //独立颜色
                
                if (this.IsShowUpDownArrow)
                {
                    var preValue=null;
                    if (dataIndex-1>=0) preValue=item.Data.Data[dataIndex-1];
                    if (IFrameSplitOperator.IsNumber(preValue))
                    {
                        if (preValue>value) arrowSuper={ Text:'↓', TextColor:this.UpDownArrowConfig.DownColor };
                        else if (preValue<value) arrowSuper={ Text:'↑', TextColor:this.UpDownArrowConfig.UpColor};
                        else arrowSuper={ Text:'→', TextColor:this.UpDownArrowConfig.UnchangeColor };

                        if (this.TitleArrowType==1) arrowSuper.TextColor=item.Color;
                    }
                }
            
                valueText=this.FormatValue(value,item);
                if (item.Name) 
                {
                    var dyValue=this.GetDynamicOutValue(item.Name, valueText);
                    if (dyValue) valueText=dyValue;
                }

                if (arrowSuper)
                {
                    var outItem={ Name:null, Text:valueText, Color:item.Color, TextEx:[arrowSuper] };
                    if (item.Name) 
                    {
                        var text=item.Name;
                        var dyTitle=this.GetDynamicOutName(item.Name);  //动态标题
                        if (dyTitle) text=dyTitle;
                        outItem.Name=text;
                    }
                    //outItem.BG='rgb(100,100,100)';

                    aryText=[outItem];
                    valueText=null;
                }
            }
        }

        return { Text:valueText, ArrayText:aryText };
    }

    //绘制主图指标  rtText 返回画完以后的区域
    this.DrawMainIndexTitle=function(positionInfo, isShowLastData, rtText)
    {
        if (!this.IsShowMainIndexTitle) return;

        var left=positionInfo.Left;
        var right=positionInfo.Right;
        var bottom=positionInfo.Bottom;

        for(var i=0; i<this.Data.length; ++i)
        {
            var item=this.Data[i];
            var outText=this.GetTitleItem(item, isShowLastData, i);
            if (!outText) continue;

            var valueText=outText.Text;
            var aryText=outText.ArrayText;

            if (aryText)    //多变量输出
            {
                var text;
                for(var k=0;k<aryText.length;++k)
                {
                    var titleItem=aryText[k];
                    if (titleItem.Name) text=titleItem.Name+":"+titleItem.Text;
                    else text=titleItem.Text;

                    var space=this.ParamSpace*GetDevicePixelRatio();
                    var indexTextWidth=this.Canvas.measureText(text).width;  //标题+数值长度
                    var textWidth=indexTextWidth;

                    if (IFrameSplitOperator.IsNonEmptyArray(titleItem.TextEx))
                    {
                        var xLeft=left;
                        for(var n=0; n<titleItem.TextEx.length; ++n)
                        {
                            var outItem=titleItem.TextEx[n];
                            var outTextWidth=this.Canvas.measureText(outItem.Text).width+2;
                            outItem.Width=outTextWidth;
                            outItem.Left=xLeft;

                            textWidth+=outTextWidth;
                            xLeft+=outTextWidth;
                        }
                    }

                    if ((left+textWidth+space)>right) break;
                    
                    if (titleItem.BG)   //背景
                    {
                        var textHeight=this.Canvas.measureText("擎").width+2;
                        var rtBG={ Left:left, Top:bottom-textHeight/2, Width:textWidth, Height:textHeight };
                        this.Canvas.fillStyle=titleItem.BG;
                        this.Canvas.fillRect(rtBG.Left,rtBG.Top-1, rtBG.Width, rtBG.Height);

                        this.Canvas.fillStyle=titleItem.Color;
                        this.Canvas.fillText(text,rtBG.Left+1,bottom,indexTextWidth);
                        left+=indexTextWidth;

                        if (IFrameSplitOperator.IsNonEmptyArray(titleItem.TextEx))
                        {
                            for(var n=0; n<titleItem.TextEx.length; ++n)
                            {
                                var outItem=titleItem.TextEx[n];
                                this.Canvas.fillStyle=outItem.TextColor;
                                this.Canvas.fillText(outItem.Text,left,bottom,outItem.Width);
                                left+=outItem.Width;
                            }
                        }

                        left+=space;
                    }
                    else
                    {
                        this.Canvas.fillStyle=titleItem.Color;
                        this.Canvas.fillText(text,left,bottom,indexTextWidth);
                        left+=indexTextWidth;

                        if (IFrameSplitOperator.IsNonEmptyArray(titleItem.TextEx))
                        {
                            for(var n=0; n<titleItem.TextEx.length; ++n)
                            {
                                var outItem=titleItem.TextEx[n];
                                this.Canvas.fillStyle=outItem.TextColor;
                                this.Canvas.fillText(outItem.Text,left,bottom,outItem.Width);
                                left+=outItem.Width;
                            }
                        }

                        left+=space;
                    }
                }
            }
            else
            {
                this.Canvas.fillStyle=item.Color;
                var text=valueText;
                if (item.Name) 
                {
                    var dyTitle=this.GetDynamicOutName(item.Name);
                    if (dyTitle) text=dyTitle+":"+valueText;
                    else text=item.Name+":"+valueText;
                }
                var space=this.ParamSpace*GetDevicePixelRatio();
                var textWidth=this.Canvas.measureText(text).width+space;
                if ((left+textWidth)>right) break;
    
                this.Canvas.fillText(text,left,bottom,textWidth);
                left+=textWidth;
            }
        }

        rtText.Left=left;
    }

    //集合竞价
    this.DrawMainCallAuction=function(positionInfo, rtText, result)
    {
        if (!this.IsShowMainIndexTitle) return;
        if (!this.MainTitlePaint) return;
        var auctionData=this.MainTitlePaint.GetCurrentAuctionData();    //集合竞价分时数据
        if (!auctionData || !auctionData.Data) return;
        if (!this.GetEventCallback) return;
        
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_FORMAT_CALL_AUCTION_INDEX_TITLE);
        if (!event) return;

        var data={ AuctionData:auctionData, Data:this.Data, FrameID:this.Frame.Identify, Out:null, PreventDefault:false };
        event.Callback(event,data,this);
        result.PreventDefault=data.PreventDefault;

        if (!IFrameSplitOperator.IsNonEmptyArray(data.Out)) return;

        var left=positionInfo.Left;
        var right=positionInfo.Right;
        var bottom=positionInfo.Bottom;
        var pixelRatio=GetDevicePixelRatio();
        
        var aryText=data.Out;   //[{Text:, Color, Space:间距 }]
        for(var i=0; i<aryText.length; ++i)
        {
            var item=aryText[i];
            if (!item.Text) continue;
            var textWidth=this.Canvas.measureText(item.Text).width+2;
            if (left+textWidth>right) break;

            if (item.BGColor)   //背景
            {
                var textHeight=this.Canvas.measureText("擎").width+2;
                var rtBG={ Left:left, Top:bottom-textHeight/2, Width:textWidth, Height:textHeight };
                this.Canvas.fillStyle=item.BGColor;
                this.Canvas.fillRect(rtBG.Left,rtBG.Top-1, rtBG.Width, rtBG.Height);
                left+=1;
            }

            this.Canvas.fillStyle=item.Color;
            this.Canvas.fillText(item.Text,left,bottom,textWidth);
            left+=textWidth;

            if (IFrameSplitOperator.IsPlusNumber(item.Space)) left+=item.Space*pixelRatio;
        }

        rtText.Left=left;
    }

    this.GetCallAuctionTitleItem=function(item, titleIndex, auctionData)
    {
        if (item.IsShow===false) return null;
        if (item.IsVisible===false) return null;
        if (!item || !item.Data || !item.Data.Data) return null;

        if (g_ScriptIndexChartFactory.Has(item.DataType)) //外部挂接
        {
            var find=g_ScriptIndexChartFactory.Get(item.DataType);
            if (find && find.FormatTitleCallback)
            return find.FormatTitleCallback(value, item, dataIndex);
        }
    }

    //获取上一个有效数据
    this.GetPreVaildItem=function(data, start)
    {
        for(var i=start; i>=0;--i)
        {
            var item=data[i];
            if (item) return { Item:item, Index:i };
        }

        return null;
    }

    this.DrawSelectedLine=function(left, bottom, textWidth)
    {
        this.Canvas.save();
        var fontHeight=this.GetFontHeight();
        this.Canvas.strokeStyle=this.SelectedColor;
        var lineWidth=4;
        var lineBottom=ToFixedPoint2(lineWidth, (bottom+fontHeight/2));
        this.Canvas.lineWidth=lineWidth;
        this.Canvas.beginPath();
        this.Canvas.moveTo(left,lineBottom);
        this.Canvas.lineTo(left+textWidth,lineBottom);
        this.Canvas.stroke();
        this.Canvas.restore();
    }

    this.DrawOverlayIndexSingleLine=function(moveonPoint, mouseStatus)   //叠加指标1个指标一行
    {
        var pixelRatio=GetDevicePixelRatio();
        var border=this.Frame.GetBorder();
        if (this.Frame.IsHScreen===true) 
        {
            var left=1;
            var top=2*pixelRatio;
            var right=this.Frame.ChartBorder.GetHeight();
            var bottom=this.Frame.ChartBorder.GetWidthEx();
        }
        else
        {
            var top=border.TopTitle+2*pixelRatio;
            if (!this.IsShowMainIndexTitle) top=this.Frame.ChartBorder.GetTop()+2*pixelRatio;
            var left=this.Frame.ChartBorder.GetLeft()+this.MerginLeft;
            var right=border.Right;
            var bottom=border.Bottom;
        }
        

        var lineSpace=this.OverlayIndexType.LineSpace*pixelRatio; 
        var x=left, y=top;
        var fontHeight=GetFontHeight(this.Canvas,this.Font,"擎");
        y=top+fontHeight/2;
        for(item of this.OverlayIndex)
        {
            var overlayItem=item[1];
            var overlayID=item[0];
            var toolbarInfo={ Width:0, YCenter:y, ID:overlayID };
            this.DrawOverlayToolbar(overlayItem,toolbarInfo,moveonPoint, mouseStatus);

            if (!overlayItem.IsShowIndexTitle) continue;
            if (!overlayItem.Frame.IsShowIndexTitle) continue;

            x=left+toolbarInfo.Width;
            this.Canvas.font=this.Font;
            this.Canvas.textAlign="left";
            this.Canvas.textBaseline="middle";
            if (overlayItem.Title && this.IsShowOverlayIndexName)
            {
                var textWidth=this.Canvas.measureText(overlayItem.Title).width+2;
                if ((x+textWidth)<right) 
                {
                    if (this.OverlayIndexType.BGColor)
                    {
                        this.Canvas.fillStyle=this.OverlayIndexType.BGColor;
                        var rtBG={Left:x, Top:y-fontHeight/2, Width:textWidth, Height: fontHeight+lineSpace };    //保存下标题的坐标
                        this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
                    } 

                    if (this.IsSelectedChart(overlayID)) this.DrawSelectedLine(x, y,textWidth, overlayItem.Title );

                    this.Canvas.fillStyle=this.TitleColor;
                    this.Canvas.fillText(overlayItem.Title,x,y,textWidth);
                }
                x+=textWidth;
            }

            for(var i=0; i<overlayItem.Data.length; ++i)
            {
                var item=overlayItem.Data[i];
                if (!item || !item.Data || !item.Data.Data || !item.Name) continue;
                if (item.IsVisible===false) continue;
                if (item.Data.Data.length<=0) continue;

                var value=null;
                var valueText=null;
                var aryText=null;
                if (item.DataType=="StraightLine")  //直线只有1个数据
                {
                    value=item.Data.Data[0];
                    valueText=this.FormatValue(value,item);
                }
                else
                {
                    var index=Math.abs(this.CursorIndex-0.5);
                    index=parseInt(index.toFixed(0));
                    if (this.IsKLineFrame) index=this.CursorIndex;
                    var dataIndex=item.Data.DataOffset+index;
                    if (dataIndex>=item.Data.Data.length) dataIndex=item.Data.Data.length-1;
                    if (dataIndex<0) continue;

                    value=item.Data.Data[dataIndex];
                    if (value==null) continue;

                    if (item.DataType=="HistoryData-Vol")
                    {
                        value=value.Vol;
                        valueText=this.FormatValue(value,item);
                    }
                    else if (item.DataType=="MultiReport")
                    {
                        valueText=this.FormatMultiReport(value,item);
                    }
                    else if (item.DataType=="ChartStackedBar")
                    {
                        aryText=this.FromatStackedBarTitle(value, item);
                        if (!aryText) continue;
                    }
                    else
                    {
                        valueText=this.FormatValue(value,item);
                    }
                }

                if (aryText)
                {
                    var text;
                    for(var k=0;k<aryText.length;++k)
                    {
                        var titleItem=aryText[k];
                        if (titleItem.Name) text=titleItem.Name+":"+titleItem.Text;
                        else text=titleItem.Text;
                        var textWidth=this.Canvas.measureText(text).width+2;    //后空2个像素
                        if ((x+textWidth)>right) break;

                        if (this.OverlayIndexType.BGColor)
                        {
                            this.Canvas.fillStyle=this.OverlayIndexType.BGColor;
                            var rtBG={Left:x, Top:y-fontHeight/2, Width:textWidth, Height: fontHeight+lineSpace };    //保存下标题的坐标
                            this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
                        }

                        this.Canvas.fillStyle=titleItem.Color;
                        this.Canvas.fillText(text,x,y,textWidth);
                        x+=textWidth;
                    }
                }
                else
                {
                    var text=valueText;
                    if (item.Name) 
                    {
                        var dyTitle=this.GetDynamicOutName(item.Name,overlayID);
                        if (dyTitle) text=dyTitle+":"+valueText;
                        else text=item.Name+":"+valueText;
                    }
    
                    var textWidth=this.Canvas.measureText(text).width+2;    //后空2个像素
                    if ((x+textWidth)>right) break;
                    if (this.OverlayIndexType.BGColor)
                    {
                        this.Canvas.fillStyle=this.OverlayIndexType.BGColor;
                        var rtBG={Left:x, Top:y-fontHeight/2, Width:textWidth, Height: fontHeight+lineSpace };    //保存下标题的坐标
                        this.Canvas.fillRect(rtBG.Left,rtBG.Top,rtBG.Width,rtBG.Height);
                    }
    
                    this.Canvas.fillStyle=item.Color;
                    this.Canvas.fillText(text,x,y,textWidth);
                    x+=textWidth;
                }
            }

            y+=fontHeight+lineSpace;
            if ((y+fontHeight+lineSpace)>=bottom) break;
        }
    }

    this.DrawOverlayIndex=function(left)    //叠加指标标题
    {
        var bottom=this.Frame.ChartBorder.GetTop()+this.Frame.ChartBorder.TitleHeight/2;    //上下居中显示
        var right=this.Frame.ChartBorder.GetRight();
        if (this.Frame.IsHScreen===true) 
        {
            bottom=-this.Frame.ChartBorder.TitleHeight/2;
            right=this.Frame.ChartBorder.GetHeight();
        }
        if (left>right) return;

        var spaceWidth=5*GetDevicePixelRatio();
        var drawLeft=left;
        var indexCount=0;
        for(item of this.OverlayIndex)
        {
            if (indexCount>0) left+=spaceWidth;
            var overlayItem=item[1];
            var overlayID=item[0];
            if (overlayItem.Title && this.IsShowOverlayIndexName)
            {
                this.Canvas.fillStyle=this.TitleColor;
                var textWidth=this.Canvas.measureText(overlayItem.Title).width+2;
                drawLeft=left;
                left+=textWidth;
                if (left>right) break;
                this.Canvas.fillText(overlayItem.Title,drawLeft,bottom,textWidth);

                if (this.IsSelectedChart(overlayID)) this.DrawSelectedLine(drawLeft, bottom, textWidth);
            }

            for(var i in overlayItem.Data)
            {
                var item=overlayItem.Data[i];
                if (!item || !item.Data || !item.Data.Data || !item.Name) continue;
                if (item.Data.Data.length<=0) continue;

                var value=null;
                var valueText=null;
                if (item.DataType=="StraightLine")  //直线只有1个数据
                {
                    value=item.Data.Data[0];
                    valueText=this.FormatValue(value,item);
                }
                else
                {
                    var index=Math.abs(this.CursorIndex-0.5);
                    index=parseInt(index.toFixed(0));
                    if (this.IsKLineFrame) index=this.CursorIndex;
                    var dataIndex=item.Data.DataOffset+index;
                    if (dataIndex>=item.Data.Data.length) dataIndex=item.Data.Data.length-1;
                    if (dataIndex<0) continue;

                    value=item.Data.Data[dataIndex];
                    if (value==null) continue;

                    if (item.DataType=="HistoryData-Vol")
                    {
                        value=value.Vol;
                        valueText=this.FormatValue(value,item);
                    }
                    else if (item.DataType=="MultiReport")
                    {
                        valueText=this.FormatMultiReport(value,item);
                    }
                    else
                    {
                        valueText=this.FormatValue(value,item);
                    }
                }

                this.Canvas.fillStyle=item.Color;

                var text=item.Name+":"+valueText;
                var textWidth=this.Canvas.measureText(text).width+2;    //后空2个像素
                drawLeft=left;
                left+=textWidth;
                if (left>right) break;
                this.Canvas.fillText(text,drawLeft,bottom,textWidth);
            }

            if (left>right) break;

            ++indexCount;
        }
    }

    this.HScreenDraw=function()
    {
        var border=this.Frame.ChartBorder.GetHScreenBorder();
        var xText=this.Frame.ChartBorder.GetRightTitle();
        var yText=border.TopEx;
        this.Canvas.translate(xText, yText);
        this.Canvas.rotate(90 * Math.PI / 180);

        var left=1;
        var bottom=-this.Frame.ChartBorder.TitleHeight/2;    //上下居中显示
        var right=this.Frame.ChartBorder.GetHeight();

        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.font=this.Font;
        var pixelRatio=GetDevicePixelRatio();

        if (this.Title && this.IsShowIndexName)
        {
            var textWidth=this.Canvas.measureText(this.Title).width+2;

            if (this.IsDrawTitleBG)
            {
                var title=this.Title;
                var textWidth=this.Canvas.measureText(title).width;
                var arrowWidth=0;
                if (this.IsShowNameArrow && this.NameArrowConfig)
                {
                    arrowWidth=this.Canvas.measureText(this.NameArrowConfig.Symbol).width;
                    if (IFrameSplitOperator.IsNumber(this.NameArrowConfig.Space)) arrowWidth+=this.NameArrowConfig.Space;
                }

                var bgHeight=this.Canvas.measureText("擎").width+4*pixelRatio;
                var bgWidth=textWidth+arrowWidth+4*pixelRatio;
                
                this.TitleRect= 
                {
                    Top:border.Top,
                    Left:this.Frame.ChartBorder.GetRightTitle()+this.Frame.ChartBorder.TitleHeight/2-bgHeight/2,
                    Width:bgHeight,
                    Height:bgWidth
                };   //保存下标题的坐标

                this.Canvas.fillStyle=this.BGColor;
                var drawRect={ Left:left, Top:bottom-bgHeight/2, Width:bgWidth, Height:bgHeight };
                this.Canvas.fillRect(drawRect.Left,drawRect.Top,drawRect.Width,drawRect.Height);

                if (this.BGBorderColor)
                {
                    this.Canvas.strokeStyle=this.BGBorderColor;
                    this.Canvas.strokeRect(ToFixedPoint(drawRect.Left),ToFixedPoint(drawRect.Top),ToFixedRect(drawRect.Width),ToFixedRect(drawRect.Height));
                }

                var xText=left+2*pixelRatio;
                this.Canvas.fillStyle=this.TitleColor;
                this.Canvas.fillText(title,xText,bottom);
                xText+=textWidth;
                if (this.IsShowNameArrow && this.NameArrowConfig)
                {
                    if (IFrameSplitOperator.IsNumber(this.NameArrowConfig.Space)) xText+=this.NameArrowConfig.Space;
                    this.Canvas.fillStyle=this.NameArrowConfig.Color;
                    this.Canvas.fillText(this.NameArrowConfig.Symbol,xText,bottom);
                }

                left+=bgWidth+2*pixelRatio;
                left+=this.TitleSpace;
            }
            else
            {
                this.Canvas.fillStyle=this.TitleColor;
                this.Canvas.fillText(this.Title,left,bottom);
                left+=textWidth;
                left+=this.TitleSpace;
            }
        }

        if (this.ArgumentsText && this.IsShowIndexName)
        {
            var textWidth=this.Canvas.measureText(this.ArgumentsText).width+2;
            this.Canvas.fillStyle=this.TitleColor;
            this.Canvas.fillText(this.ArgumentsText,left,bottom,textWidth);
            left+=textWidth;
            left+=this.TitleSpace;
        }

        var isShowLastData=this.IsShowLastData();
        var lockRect=this.Frame.GetLockRect();
        if (lockRect)   //指标上锁区域不显示动态标题
        {
            var index=Math.abs(this.CursorIndex-0.5);
            if (this.IsKLineFrame) index=this.CursorIndex;
            var x=this.Frame.GetXFromIndex(index.toFixed(0));
            if (x>=lockRect.Top) return;
            if (isShowLastData) return;
        }

        for(var i in this.Data)
        {
            var item=this.Data[i];
            var outText=this.GetTitleItem(item, isShowLastData);
            if (!outText) continue;

            var valueText=outText.Text;
            var aryText=outText.ArrayText;

            if (aryText)
            {
                var text;
                for(var k=0;k<aryText.length;++k)
                {
                    var titleItem=aryText[k];
                    if (titleItem.Name) text=titleItem.Name+":"+titleItem.Text;
                    else text=titleItem.Text;

                    var space=this.ParamSpace*GetDevicePixelRatio();
                    var textWidth=this.Canvas.measureText(text).width+space; 
                    if ((left+textWidth)>right) break;

                    this.Canvas.fillStyle=titleItem.Color;
                    this.Canvas.fillText(text,left,bottom,textWidth);
                    left+=textWidth;
                }
            }
            else
            {
                this.Canvas.fillStyle=item.Color;
                var text=valueText;
                if (item.Name) 
                {
                    var dyTitle=this.GetDynamicOutName(item.Name);
                    if (dyTitle) text=dyTitle+":"+valueText;
                    else text=item.Name+":"+valueText;
                }

                var space=this.ParamSpace*GetDevicePixelRatio();
                var textWidth=this.Canvas.measureText(text).width+space;    //后空2个像素
                if ((left+textWidth)>right) break;
    
                this.Canvas.fillText(text,left,bottom,textWidth);
                left+=textWidth;
            }
        }

        if (this.Explain)   //说明信息
        {
            this.Canvas.fillStyle=this.TitleColor;
            var text="说明:"+this.Explain;
            var textWidth=this.Canvas.measureText(text).width+2;
            if (left+textWidth<right)
            {
                this.Canvas.fillText(text,left,bottom,textWidth);
                left+=textWidth;
            }
        }

        if (this.OverlayIndexType.Position==1) 
        {
            if (!this.Frame.ChartBorder.IsShowTitleOnly)
                this.DrawOverlayIndexSingleLine();
        }
        else 
        {
            this.DrawOverlayIndex(left+5*GetDevicePixelRatio());   //间距都空点 和主指标区分开
        }
    }

    this.OnDrawEventCallback=function(drawData)
    {
        if (!this.OnDrawEvent || !this.OnDrawEvent.Callback) return;
        var data={ Draw: drawData, Name:'DynamicChartTitlePainting'};
        this.OnDrawEvent.Callback(this.OnDrawEvent,data,this);
    }

    this.GetFontHeight=function(font)
    {
        return GetFontHeight(this.Canvas, font, "擎");
    }

    //指标名字按钮
    this.DrawNameButton=function(rtButton, moveonPoint, mouseStatus)
    {
        var pixelRatio=GetDevicePixelRatio();
        var title=this.Title;
        var textWidth=this.Canvas.measureText(title).width;
        var arrowWidth=0;
        if (this.IsShowNameArrow && this.NameArrowConfig)
        {
            arrowWidth=this.Canvas.measureText(this.NameArrowConfig.Symbol).width;
            if (IFrameSplitOperator.IsNumber(this.NameArrowConfig.Space)) arrowWidth+=this.NameArrowConfig.Space;
        }

        var bgHeight=this.Canvas.measureText("擎").width+4*pixelRatio;
        var roundRadius=this.BorderRoundRadius*pixelRatio;
        var bgWidth=textWidth+arrowWidth+4*pixelRatio+roundRadius*2;
       
        rtButton.Top=rtButton.YCenter-bgHeight/2-1,
        rtButton.Width=bgWidth;
        rtButton.Height=bgHeight;
        rtButton.Right=rtButton.Left+rtButton.Width;
        rtButton.Bottom=rtButton.Top+rtButton.Height;

        var borderColor=this.BGBorderColor;
        if (moveonPoint && (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
        {
            if (this.BGBorderMoveOnColor) borderColor=this.BGBorderMoveOnColor;
            if (mouseStatus)
            {
                var btnItem={ ID:JSCHART_BUTTON_ID.INDEX_NAME_BUTTON };
                mouseStatus.MouseOnToolbar={  ID:"IndexNameButton", Rect:rtButton, Item:btnItem, Frame:this.Frame, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
            }
        }

        if (this.Canvas.roundRect && this.NameButtonStyle==1)   //判断下是否支持roundRect
        {
            this.Canvas.beginPath();
            this.Canvas.roundRect(ToFixedPoint(rtButton.Left), ToFixedPoint(rtButton.Top), ToFixedRect(rtButton.Width), ToFixedRect(rtButton.Height), [roundRadius]);
            this.Canvas.closePath();

            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fill();

            if (borderColor)
            {
                this.Canvas.strokeStyle=borderColor;
                this.Canvas.stroke();
            }
        }
        else
        {
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtButton.Left, rtButton.Top, rtButton.Width, rtButton.Height);
    
            if (borderColor)
            {
                this.Canvas.strokeStyle=borderColor;
                this.Canvas.strokeRect(ToFixedPoint(rtButton.Left), ToFixedPoint(rtButton.Top), ToFixedRect(rtButton.Width), ToFixedRect(rtButton.Height), [roundRadius]);
            }
        }
        
        var xText=rtButton.Left+roundRadius+2*pixelRatio;
        this.Canvas.fillStyle=this.TitleColor;
        this.Canvas.fillText(title,xText,rtButton.YCenter);
        xText+=textWidth;
        if (this.IsShowNameArrow && this.NameArrowConfig)
        {
            if (IFrameSplitOperator.IsNumber(this.NameArrowConfig.Space)) xText+=this.NameArrowConfig.Space;
            this.Canvas.fillStyle=this.NameArrowConfig.Color;
            this.Canvas.fillText(this.NameArrowConfig.Symbol,xText,rtButton.YCenter);
        }
    }

    //绘制按钮
    this.DrawButton=function(item, rtButton, moveonPoint, mouseStatus)
    {
        var size=item.Style.Size;
        if (IFrameSplitOperator.IsNumber(item.Style.YMoveOffset)) rtButton.YCenter+=item.Style.YMoveOffset;

        var font=`${size}px ${item.Style.Family}`;

        rtButton.Top=rtButton.YCenter-size/2;
        rtButton.Width=size+item.Style.MerginLeft;
        rtButton.Height=size;
        rtButton.Bottom=rtButton.Top+rtButton.Height;
        rtButton.Right=rtButton.Left+rtButton.Width;

        var color=item.Style.Color;
        if (moveonPoint && (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom))
        {
            color=item.Style.MoveOnColor;
            if (mouseStatus)
                mouseStatus.MouseOnToolbar={  ID:"TitleButton", Rect:rtButton, Item:item, Frame:this.Frame, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
        }

        this.Canvas.fillStyle=color;
        this.Canvas.font=font;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.fillText(item.Style.Text, rtButton.Left, rtButton.YCenter);

        return true;
    }

    this.DrawToolbar=function(toolbarInfo, moveonPoint, mouseStatus)
    {
        toolbarInfo.Width=0;
        if (!this.Frame || !this.Frame.GetLeftToolbar) return;

        var aryButton=this.Frame.GetLeftToolbar();
        if (!IFrameSplitOperator.IsNonEmptyArray(aryButton)) return;

        if (this.Frame.IsHScreen===true)
        {


        }
        else
        {
            var border=this.Frame.GetBorder();
            var right=border.Right-3;
            var left=border.Left+3;
            var yCenter=toolbarInfo.YCenter;

            for(var i=0;i<aryButton.length;++i)
            {
                var item=aryButton[i];
                var rtButton={ Left:left, YCenter:yCenter };
                this.DrawButton(item, rtButton, moveonPoint, mouseStatus);
                
                this.Buttons.push({ ID:item.ID, Rect:rtButton, FrameID:this.Frame.Identify, Type:0, Data:item.Data });  //Type 0=主图按钮 1=附图按钮 2=主图指标名字按钮

                left=rtButton.Right;

                toolbarInfo.Width+=rtButton.Width;
            }

            if (toolbarInfo.Width>0) toolbarInfo.Width+=3;
        }
    }

    this.DrawOverlayToolbar=function(overlayItem, toolbarInfo, moveonPoint, mouseStatus)
    {
        toolbarInfo.Width=0;
        if (!overlayItem || !overlayItem.Frame || !overlayItem.Frame.GetLeftToolbar) return;

        var frame=overlayItem.Frame;
        var aryButton=frame.GetLeftToolbar({ Overlay:overlayItem, OverlayID:toolbarInfo.ID });
        if (!IFrameSplitOperator.IsNonEmptyArray(aryButton)) return;

        if (this.Frame.IsHScreen===true)
        {


        }
        else
        {
            var border=frame.GetBorder();
            var right=border.Right-3;
            var left=border.Left+3;
            var yCenter=toolbarInfo.YCenter;

            for(var i=0;i<aryButton.length;++i)
            {
                var item=aryButton[i];

                var rtButton={ Left:left, YCenter:yCenter };
                this.DrawButton(item, rtButton, moveonPoint, mouseStatus);

                this.Buttons.push({ ID:item.ID, Rect:rtButton, FrameID:this.Frame.Identify, Type:1, OverlayID:toolbarInfo.ID, Title:overlayItem.Title, Data:item.Data  });

                left=rtButton.Right;

                toolbarInfo.Width+=rtButton.Width;
            }

            if (toolbarInfo.Width>0) toolbarInfo.Width+=3;
        }
    }


    this.PtInButtons=function(x,y)
    {
        for(var i=0;i<this.Buttons.length;++i)
        {
            var item=this.Buttons[i];
            if (!item.Rect) continue;

            var rect=item.Rect;
            if (x>rect.Left && x<rect.Right && y>rect.Top && y<rect.Bottom)
            {
                var result= { ID:item.ID, Rect:rect, FrameID:item.FrameID, Type:item.Type, Data:item.Data };
                if (item.Type==1)
                {
                    result.Title=item.Title;
                    result.OverlayID=item.OverlayID;
                }

                return result;
            }
        }

        return null;
    }
}

//画图工具
function IChartDrawPicture()
{
    this.Frame;
    this.Canvas;
    this.Point=new Array()                      //画图的点
    this.Value=new Array();                     //XValue,YValue
    this.LinePoint=[];
    this.PointCount=2;                          //画点的个数
    this.Status=0;                              //0=开始画 1=完成第1个点  2=完成第2个点 3=完成第3个点  10=完成 20=移动
    this.PointStatus=0;                         //2=第2个点完成
    this.MovePointIndex=null;                   //移动哪个点 0-10 对应Point索引  100 整体移动
    this.ClassName='IChartDrawPicture';
    this.FinishedCallback;                      //画图完成回调通知
    this.Guid=Guid();                            //ID标识
    this.Symbol;        //对应的股票
    this.Period;        //对应的周期
    this.Right;         //对应的复权
    this.IsSelected=false;  //是否选中
    this.Option;        //全局配置 对应外部 ChartDrawOption
    this.EnableMove=true;   //是否可以移动
    this.EnableSave=true;   //是否允许保存
    this.EnableCtrlMove=false;  //是否按住Ctrl才能移动
    this.OnlyMoveXIndex=false;  //只能在X轴刻度上移动
    this.IsSupportMagnet=false; //是否支持磁吸
    this.EnableMoveCheck=true;  //允许移动时监测是否超出边界

    this.IsDrawFirst=false;
    this.IsShowYCoordinate=false;    //是否在Y轴显示点的刻度
    this.IsShow=true;                //是否显示

    this.LineColor=g_JSChartResource.DrawPicture.LineColor[0];                            //线段颜色
    //this.LineColor="#1e90ff";      //线段颜色，input type="color" 不支持rgb和rgba 的格式
    this.LineWidth=2;              //线段宽度
    this.BackupLineWidth=null;
    this.AreaColor='rgba(25,25,25,0.4)';    //面积颜色
    this.PointColor=g_JSChartResource.DrawPicture.PointColor[0];
    this.MoveOnPointColor=g_JSChartResource.DrawPicture.PointColor[1];
    this.PointBGColor=g_JSChartResource.DrawPicture.PointColor[2];
    this.PointRadius=5;  //圆点半径
    this.SquareSize=8;   //方框点大小
    this.PointType=g_JSChartResource.DrawPicture.PointType;         // 0=圆点  1=方框 2= 空心圆
    this.IsShowPoint=g_JSChartResource.DrawPicture.IsShowPoint;     //是否始终显示点
    this.LimitFrameID;   //限制在指定窗口绘图
    

    //接口函数
    this.SetLastPoint=null; //this.SetLastPoint=function(obj)  obj={X:,Y:}
    this.Update=null;       //更新数据回调
    this.GetActiveDrawPicture=null;
    this.GetYCoordinatePoint=null;    

    this.Draw=function()
    {

    }

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.LineColor) this.LineColor=option.LineColor;
        if (option.LineWidth>0) this.LineWidth=option.LineWidth;
        if (option.AreaColor) this.AreaColor=option.AreaColor;
        if (option.PointColor) this.PointColor=option.PointColor;
        if (option.MoveOnPointColor) this.MoveOnPointColor=option.MoveOnPointColor;
        if (option.PointRadius) this.PointRadius=option.PointRadius;
        if (IFrameSplitOperator.IsNumber(option.SquareSize)) this.SquareSize=option.SquareSize;
        if (IFrameSplitOperator.IsBool(option.IsShowPoint)) this.IsShowPoint=option.IsShowPoint;
        if (IFrameSplitOperator.IsNumber(option.LimitFrameID)) this.LimitFrameID=option.LimitFrameID;
        if (IFrameSplitOperator.IsBool(option.EnableCtrlMove)) this.EnableCtrlMove=option.EnableCtrlMove;
        if (IFrameSplitOperator.IsBool(option.IsShowYCoordinate)) this.IsShowYCoordinate=option.IsShowYCoordinate;
    }

    this.ReloadResource=function(resource)
    {
        if (!resource)
        {
            this.PointColor=g_JSChartResource.DrawPicture.PointColor[0];
            this.MoveOnPointColor=g_JSChartResource.DrawPicture.PointColor[1];
            this.PointBGColor=g_JSChartResource.DrawPicture.PointColor[2];
        }
    }

    this.SetLineWidth=function()
    {
        this.BackupLineWidth=null;
        if (this.LineWidth>0)
        {
            this.BackupLineWidth=this.Canvas.lineWidth;
            this.Canvas.lineWidth=this.LineWidth*GetDevicePixelRatio();
        }
    }

    this.GetFontHeight=function(font)
    {
        return GetFontHeight(this.Canvas, font, "擎");
    }

    this.RestoreLineWidth=function()
    {
        if (this.BackupLineWidth!=null)
        {
            this.Canvas.lineWidth=this.BackupLineWidth;
        }
    }

    //磁吸K线
    this.PointMagnetKLine=function()
    {
        if (!this.IsSupportMagnet) return false;
        if (!this.Frame) return false;
        if (this.Frame.ClassName=="MinuteFrame" || this.Frame.Class=="MinuteHScreenFrame") return false;
        if (this.Frame.Identify!=0) return false;

        var pointIndex=-1;
        if (this.Status==2) pointIndex=1;
        else if (this.Status==1) pointIndex=0;
        else if (IFrameSplitOperator.IsNumber(this.MovePointIndex)) pointIndex=this.MovePointIndex;
        if (pointIndex<0) return false;

        if (this.Option && this.Option.Magnet && this.Option.Magnet.Enable)
        {
            var option= 
            { 
                IsFixedX:false, 
                Magnet:
                {
                    Enable:true,
                    PointIndex:pointIndex,
                    Distance:this.Option.Magnet.Distance,
                    Type:this.Option.Magnet.Type
                }
            }

            return this.AdjustPoint(this.Point,option)
        }
          
        return false;
    }

    //Point => Value
    this.PointToValue=function()
    {
        if (!this.Frame) return false;

        if (this.Frame.ClassName=="MinuteFrame" || this.Frame.Class=="MinuteHScreenFrame")
        {
            return this.PointToValue_Minute();
        }
        else
        {
            return this.PointToValue_KLine();
        }
    }

    this.PointToKLine=function(aryPoint)
    {
        if (!this.Frame) return null;
        var data=this.Frame.Data;
        if (!data) return null;
        
        var kLine=[];
        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            for(var i in aryPoint)
            {
                var item=aryPoint[i];
                var xValue=parseInt(this.Frame.GetXData(item.Y))+data.DataOffset;
                var yValue=this.Frame.GetYData(item.X);

                var valueItem={ XValue:xValue, YValue:yValue };
                var kline=data.Data[xValue];
                valueItem.DateTime={ Date:kline.Date };
                if (IFrameSplitOperator.IsNumber(kline.Time)) valueItem.DateTime.Time=kline.Time;

                kLine[i]=valueItem;
            }
        }
        else
        {
            for(var i in aryPoint)
            {
                var item=aryPoint[i];
                var index=parseInt(this.Frame.GetXData(item.X,false));
                var xValue=index+data.DataOffset;
                if (xValue<0) xValue=0;
                else if (xValue>=data.Data.length) 
                {
                    xValue=data.Data.length-1;
                    index=xValue-data.DataOffset;
                }
                var yValue=this.Frame.GetYData(item.Y,false);

                var valueItem={ XValue:xValue, YValue:yValue, XIndex:index };
                var kline=data.Data[xValue];
                valueItem.DateTime={ Date:kline.Date };
                if (IFrameSplitOperator.IsNumber(kline.Time)) valueItem.DateTime.Time=kline.Time;

                kLine[i]=valueItem;
            }
        }

        return kLine;
    }

    this.PointToValue_KLine=function()
    {
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;

        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            for(var i=0; i<this.Point.length; ++i)
            {
                var item=this.Point[i];
                var xValue=parseInt(this.Frame.GetXData(item.Y,false))+data.DataOffset;
                var yValue=this.Frame.GetYData(item.X,false);

                var valueItem={ XValue:xValue, YValue:yValue };
                var kline=data.Data[xValue];
                valueItem.DateTime={ Date:kline.Date };
                if (IFrameSplitOperator.IsNumber(kline.Time)) valueItem.DateTime.Time=kline.Time;

                this.Value[i]=valueItem;
            }
        }
        else
        {
            for(var i=0; i<this.Point.length; ++i)
            {
                var item=this.Point[i];
                var xValue=parseInt(this.Frame.GetXData(item.X,false))+data.DataOffset;
                if (xValue<0) xValue=0;
                else if (xValue>=data.Data.length) xValue=data.Data.length-1;
                var yValue=this.Frame.GetYData(item.Y,false);

                var valueItem={ XValue:xValue, YValue:yValue };
                var kline=data.Data[xValue];
                valueItem.DateTime={ Date:kline.Date };
                if (IFrameSplitOperator.IsNumber(kline.Time)) valueItem.DateTime.Time=kline.Time;

                this.Value[i]=valueItem;
            }
        }

        return true;
    }

    this.PointToValue_Minute=function()
    {
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;

        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            for(var i=0; i<this.Point.length; ++i)
            {
                var item=this.Point[i];
                var xValue=parseInt(this.Frame.GetXData(item.Y,false));
                var yValue=this.Frame.GetYData(item.X,false);

                var valueItem={ XValue:xValue, YValue:yValue };
                var minuteItem=data.Data[xValue];
                valueItem.DateTime={ Date:minuteItem.Date ,Time:minuteItem.Time};
                this.Value[i]=valueItem;
            }
        }
        else
        {
            var xDatetime=g_MinuteTimeStringData.GetTimeData(this.Symbol);
            for(var i=0; i<this.Point.length; ++i)
            {
                var item=this.Point[i];
                var xValue=parseInt(this.Frame.GetXData(item.X,false));
                var yValue=this.Frame.GetYData(item.Y,false);

                if (xValue>=data.Data.length) //超过当前数据,直接读固定时间
                {
                    var index=xValue%xDatetime.length;
                    var dataIndex=data.Data.length-1;
                    var valueItem={ XValue:xValue, YValue:yValue };
                    var minuteItem=data.Data[dataIndex];
                    var timeItem=xDatetime[index];
                    valueItem.DateTime={ Date:minuteItem.Date, Time:timeItem };
                    this.Value[i]=valueItem;
                }
                else
                {
                    var valueItem={ XValue:xValue, YValue:yValue };
                    var minuteItem=data.Data[xValue];
                    valueItem.DateTime={ Date:minuteItem.Date, Time:minuteItem.Time };
                    this.Value[i]=valueItem;
                }
            }
        }

        return true;
    }

    this.IsPointIn=function(x, y, option)
    {
        return false;
    }

    //Value => Point
    this.ValueToPoint=function()
    {
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;

        //this.UpdateXValue();
        var isHScreen=this.Frame.IsHScreen;
        this.Point=[];
        for(var i=0; i<this.Value.length; ++i)
        {
            var item=this.Value[i];
            var pt=new Point();
            if (isHScreen)
            {
                pt.Y=this.Frame.GetXFromIndex(item.XValue-data.DataOffset,false);
                pt.X=this.Frame.GetYFromData(item.YValue,false);
            }
            else
            {
                pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset, false);
                pt.Y=this.Frame.GetYFromData(item.YValue,false);
            }
            this.Point[i]=pt;
        }
    }

    this.UpdateXValue=function()    //通过datetime更新x的索引
    {
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;

        var aryDateTime=[];
        for(var i=0; i<this.Value.length; ++i)
        {
            var item=this.Value[i];
            if (!item.DateTime) break;
            var dateTime={ Date:item.DateTime.Date };
            if (IFrameSplitOperator.IsNumber(item.DateTime.Time)) dateTime.Time=item.DateTime.Time;
            aryDateTime[i]=dateTime;
        }

        data.FindDataIndexByDateTime(aryDateTime);
        for(var i=0; i<aryDateTime.length; ++i)
        {
            var findItem=aryDateTime[i];
            var valueItem=this.Value[i];
            if (findItem.Index>=0) valueItem.XValue=findItem.Index;
        }
    }

    //重置X索引数据
    this.ResetXValue=function()
    {
        for(var i=0; i<this.Value.length; ++i)
        {
            var item=this.Value[i];
            item.XValue=null;
        }
        return true;
    }

    //xStep,yStep 移动的偏移量
    this.Move=function(xStep,yStep)
    {
        if (this.Status!=20) return false;
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;
        if (this.MovePointIndex==null) return false;

        var index=parseInt(this.MovePointIndex);
        if (index===100)    //整体移动
        {
            if (this.IsMoveOutOfBounds(this.Point, xStep, yStep)) return false;

            for(var i in this.Point)
            {
                this.Point[i].X+=xStep;
                this.Point[i].Y+=yStep;
            }
        }
        else if (index===0 || index===1 || index===2 || index===3 || index===4 || index===5)
        {
            if (index<this.Point.length)
            {
                this.Point[index].X+=xStep;
                this.Point[index].Y+=yStep;
            }
        }
        else
        {
            return false;
        }
    }

    //是否超出边界了
    this.IsMoveOutOfBounds=function(aryPoint,xStep,yStep)
    {
        if (!this.EnableMoveCheck) return false;

        if (!this.Frame) return false;

        if (this.Frame.ClassName=="MinuteFrame" || this.Frame.Class=="MinuteHScreenFrame")
            return false;

        
        var data=this.Frame.Data;
        if (!data) return false;
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Data)) return false;
        if (!IFrameSplitOperator.IsNonEmptyArray(aryPoint)) return false;
        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen) 
        {
            //TODO:横屏以后再做
            return false;
        }
        else
        {
            var offset=data.DataOffset;
            var startIndex=0-offset;
            var endIndex=data.Data.length-offset;

            if (xStep>0)
            {
                var xEnd=this.Frame.GetXFromIndex(endIndex-1,false);
                for(var i=0;i<aryPoint.length;++i)
                {
                    var item=aryPoint[i];
                    if (item.X+xStep>xEnd) return true;
                }
            }
            else if (xStep<0)
            {
                var xStart=this.Frame.GetXFromIndex(startIndex,false);
                for(var i=0;i<aryPoint.length;++i)
                {
                    var item=aryPoint[i];
                    if (item.X+xStep<xStart) return true;
                }
            }

            return false;
        }
    }

    this.ClipFrame=function()
    {
        if (this.Frame.IsHScreen)
        {
            var left=this.Frame.ChartBorder.GetLeftEx();
            var top=this.Frame.ChartBorder.GetTop();
            var width=this.Frame.ChartBorder.GetWidthEx();
            var height=this.Frame.ChartBorder.GetHeight();
        }
        else
        {
            var left=this.Frame.ChartBorder.GetLeft();
            var top=this.Frame.ChartBorder.GetTopEx();
            var width=this.Frame.ChartBorder.GetWidth();
            var height=this.Frame.ChartBorder.GetHeightEx();
        }

        this.Canvas.save();
        this.Canvas.beginPath();
        this.Canvas.rect(left,top,width,height);
        this.Canvas.clip();
    }

    //计算需要画的点的坐标option:{IsCheckX:是否检测X值, IsCheckY:是否检测Y值}
    this.CalculateDrawPoint=function(option)
    {
        if (this.Status<2) return null;
        if(!this.Point.length || !this.Frame) return null;

        var drawPoint=[];
        if (this.Status==10)
        {
            var data=this.Frame.Data;
            if (!data) return null;

            var showCount=this.Frame.XPointCount;
            var invaildX=0; //超出范围的x点个数
            var isHScreen=this.Frame.IsHScreen;
            for(var i=0; i<this.Value.length; ++i)
            {
                var item=this.Value[i];
                if (!IFrameSplitOperator.IsNumber(item.XValue)) return null;    //无效索引 不显示

                var dataIndex=item.XValue-data.DataOffset;
                if (dataIndex<0 || dataIndex>=showCount) ++invaildX;
            
                var pt=new Point();
                if (isHScreen)  //横屏X,Y对调
                {
                    pt.Y=this.Frame.GetXFromIndex(item.XValue-data.DataOffset,false);
                    pt.X=this.Frame.GetYFromData(item.YValue,false);
                }
                else
                {
                    pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset,false);
                    pt.Y=this.Frame.GetYFromData(item.YValue,false);
                }
                drawPoint.push(pt);
            }

            if (option && option.IsCheckX===true)
            {
                if (invaildX==this.Value.length) return null;
            }
        }
        else    //移动中
        {
            for(var i=0;i<this.Point.length;++i)
            {
                var item=this.Point[i];
                drawPoint.push({ X:item.X, Y:item.Y });
            }

            if (this.OnlyMoveXIndex)
            {
                var option= { IsFixedX:this.OnlyMoveXIndex };
                JSConsole.Chart.Log(`[IChartDrawPicture::CalculateDrawPoint] Status=${this.Status} MovePointIndex=${this.MovePointIndex} Identify=${this.Frame.Identify}`);

                //磁吸功能
                if (this.Option && this.Option.Magnet && this.Option.Magnet.Enable && this.IsSupportMagnet  && this.Frame.Identify==0)
                {
                    var pointIndex=-1;
                    if (this.Status==2) pointIndex=1;   //创建第2个点
                    if (IFrameSplitOperator.IsNumber(this.MovePointIndex)) pointIndex=this.MovePointIndex;
                        
                    if (pointIndex>=0)
                    {
                        option.Magnet=
                        {
                            Enable:true,
                            PointIndex:pointIndex,
                            Distance:this.Option.Magnet.Distance,
                            Type:this.Option.Magnet.Type
                        }
                    }
                }
                
                this.AdjustPoint(drawPoint,option)
            }
        }

        return drawPoint;
    }

    //修正X, Y轴坐标
    this.AdjustPoint=function(aryPoint, option)
    {
        if (!this.Frame) return false;

        if (this.Frame.ClassName=="MinuteFrame" || this.Frame.Class=="MinuteHScreenFrame")
            return false;
        

        return this.AdjustPoint_KLine(aryPoint, option);
    }

    this.AdjustPoint_KLine=function(aryPoint, option)
    {
        if (!option) return false;
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;
        
        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            for(var i=0; i<aryPoint.length; ++i)
            {
                var item=aryPoint[i];
                var xValue=parseInt(this.Frame.GetXData(item.Y))+data.DataOffset;
            }
        }
        else
        {
            for(var i=0; i<aryPoint.length; ++i)
            {
                var item=aryPoint[i];
                var index=parseInt(this.Frame.GetXData(item.X,false));
                var xValue=index+data.DataOffset;
                if (xValue<0) xValue=0;
                else if (xValue>=data.Data.length) xValue=data.Data.length-1;

                if (option.IsFixedX)
                {
                    index=xValue-data.DataOffset;
                    item.X=this.Frame.GetXFromIndex(index,false);
                }

                //磁吸
                if (option.Magnet && option.Magnet.Enable && i==option.Magnet.PointIndex)
                {
                    var kline=data.Data[xValue];
                    var aryKValue=[kline.Open, kline.High, kline.Low, kline.Close];
                    var yMinDistance=null, yKLine=null;
                    for(var j=0; j<aryKValue.length; ++j)
                    {
                        var yPrice=this.Frame.GetYFromData(aryKValue[j]);
                        var value=Math.abs(item.Y-yPrice);
                        if (!IFrameSplitOperator.IsNumber(yMinDistance) || yMinDistance>value) 
                        {
                            yMinDistance=value;
                            yKLine=yPrice;
                        }
                    }

                    if (option.Magnet.Type==1)  //只能在K线上
                    {
                        if (IFrameSplitOperator.IsNumber(yKLine)) 
                            item.Y=yKLine;
                    }
                    else
                    {
                        if (yMinDistance<option.Magnet.Distance && IFrameSplitOperator.IsNumber(yKLine))
                            item.Y=yKLine;
                    }
                }
            }
        }
    }

    this.IsYValueInFrame=function(yValue)
    {
        if (!this.Frame) return false;

        if (yValue>this.Frame.HorizontalMax || yValue<this.Frame.HorizontalMin) return false;

        return true;
    }

    this.DrawPoint=function(aryPoint)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryPoint)) return;

        var color=this.PointColor;
        var isMoveOn=false;
        if (this.IsShowPoint)
        {

        }
        else
        {
            if (this.GetActiveDrawPicture)
            {
                var active=this.GetActiveDrawPicture();
                if (active.Move.Guid!=this.Guid && active.Select.Guid!=this.Guid && active.MoveOn.Guid!=this.Guid) 
                    return;
                
                if (active.Select.Guid!=this.Guid && active.MoveOn.Guid==this.Guid)
                {
                    isMoveOn=true;
                    color=this.MoveOnPointColor;
                }
            }
        }
        
        //画点
        this.ClipFrame();
        var pixel=GetDevicePixelRatio();
        this.Canvas.fillStyle=color;      //填充颜色

        if (this.PointType==2)
        {
            this.Canvas.fillStyle=this.PointBGColor;      //背景填充颜色
            this.Canvas.strokeStyle=this.PointColor;

            if (isMoveOn) this.Canvas.lineWidth=1*pixel;
            else this.Canvas.lineWidth=2*pixel;
        }

        for(var i=0; i<aryPoint.length; ++i)
        {
            var item=aryPoint[i];

            if (this.PointType==1)  //正方形
            {
                var value=this.SquareSize*pixel;
                var x=item.X-value/2;
                var y=item.Y-value/2;
                this.Canvas.fillRect(x,y,value,value);   //画一个背景色, 不然是一个黑的背景
            }
            else if (this.PointType==2) //空心圆
            {
                var path=new Path2D();
                path.arc(item.X,item.Y,this.PointRadius*pixel,0,360,false);
                this.Canvas.fill(path); 
                this.Canvas.stroke(path);
            }
            else    //实心圆
            {
                this.Canvas.beginPath();
                this.Canvas.arc(item.X,item.Y,this.PointRadius*pixel,0,360,false);
                this.Canvas.fill();                         //画实心圆
                this.Canvas.closePath();
            }
            
        }

        this.Canvas.restore();
    }

    this.DrawArrow=function(ptStart,ptEnd)
    {
        //计算箭头
        var theta=35;       //三角斜边一直线夹角
        var headlen=10;    //三角斜边长度
        var angle = Math.atan2(ptStart.Y - ptEnd.Y, ptStart.X - ptEnd.X) * 180 / Math.PI,
        angle1 = (angle + theta) * Math.PI / 180,
        angle2 = (angle - theta) * Math.PI / 180,
        topX = headlen * Math.cos(angle1),
        topY = headlen * Math.sin(angle1),
        botX = headlen * Math.cos(angle2),
        botY = headlen * Math.sin(angle2);

        this.Canvas.beginPath();
        var arrowX = ptEnd.X + topX;
        var arrowY = ptEnd.Y + topY;
        this.Canvas.moveTo(arrowX,arrowY);

        this.Canvas.lineTo(ptEnd.X, ptEnd.Y);

        arrowX = ptEnd.X + botX;
        arrowY = ptEnd.Y + botY;
        this.Canvas.lineTo(arrowX,arrowY);
        this.Canvas.stroke();
    }

    //计算2个点线的,左右的延长线的点
    this.CalculateExtendLinePoint=function(ptStart,ptEnd)
    {
        var result={};

        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var top=this.Frame.ChartBorder.GetTopEx();
        var bottom=this.Frame.ChartBorder.GetBottom();

        var a=ptEnd.X-ptStart.X;
        var b=ptEnd.Y-ptStart.Y;

        if (a>0)
        {
            var b2=bottom-ptStart.Y;
            var a2=a*b2/b;

            var pt=new Point();
            pt.X=ptStart.X+a2;
            pt.Y=bottom;
            result.End=pt;


            var b2=ptEnd.Y-top;
            var a2=a*b2/b;
            var pt2=new Point();
            pt2.Y=top;
            pt2.X=ptEnd.X-a2;
            result.Start=pt2;
        }
        else
        {
            var b2=bottom-ptStart.Y;
            var a2=Math.abs(a)*b2/b;

            var pt=new Point();
            pt.X=ptStart.X-a2;;
            pt.Y=bottom;
            result.End=pt;

            var b2=ptEnd.Y-top;
            var a2=Math.abs(a)*b2/b;
            var pt2=new Point();
            pt2.Y=top;
            pt2.X=ptEnd.X+a2;
            result.Start=pt2;
        }

        return result;
    }

    //计算2个点线的,点0->点1->延长线的点
    this.CalculateExtendLineEndPoint=function(aryPoint)
    {
        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var bottom=this.Frame.ChartBorder.GetBottomEx();
        var top=this.Frame.ChartBorder.GetTopEx();

        var a=aryPoint[1].X-aryPoint[0].X;
        var b=aryPoint[1].Y-aryPoint[0].Y;

        if (a>0)
        {
            var a1=right-aryPoint[0].X;
            var b1=a1*b/a;
            var y=b1+aryPoint[0].Y;

            if (y>=top && y<=bottom)
            {
                var pt=new Point();
                pt.X=right;
                pt.Y=y;
                return pt;
            }

            if (b>0)
            {
                var b2=bottom-aryPoint[0].Y;
                var a2=a*b2/b;
                var x=a2+aryPoint[0].X;
    
                var pt2=new Point();
                pt2.X=x;
                pt2.Y=bottom;
                return pt2;
            }
            else if (b==0)
            {
                var pt2=new Point();
                pt2.X=right;
                pt2.Y=aryPoint[0].Y;
                return pt2;
            }
            else
            {
                var b2=top-aryPoint[0].Y;
                var a2=a*b2/b;
                var x=a2+aryPoint[0].X;

                var pt2=new Point();
                pt2.X=x;
                pt2.Y=top;
                return pt2;
            }
        }
        else
        {
            var a1=aryPoint[0].X-left;
            var b1=a1*b/Math.abs(a);
            var y=b1+aryPoint[0].Y;

            if (y>=top && y<=bottom)
            {
                var pt=new Point();
                pt.X=left;
                pt.Y=y;
                return pt;
            }

            if (b>0)
            {
                var b2=bottom-aryPoint[0].Y;
                var a2=a*b2/b;
                var x=a2+aryPoint[0].X;
    
                var pt2=new Point();
                pt2.X=x;
                pt2.Y=bottom;
                return pt2;
            }
            else if (b==0)
            {
                var pt2=new Point();
                pt2.X=left;
                pt2.Y=aryPoint[0].Y;
                return pt2;
            }
            else
            {
                var b2=top-aryPoint[0].Y;
                var a2=a*b2/b;
                var x=a2+aryPoint[0].X;

                var pt2=new Point();
                pt2.X=x;
                pt2.Y=top;
                return pt2;
            }
        }
    }

    //坐标是否在点上 返回在第几个点上
    this.IsPointInXYValue=function(x, y, option)
    {
        if (!this.Frame) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;
        if (!this.Value) return -1;

        var radius=5;
        if (option && IFrameSplitOperator.IsNumber(option.Zoom)) radius+=option.Zoom;
        else if (this.Option && IFrameSplitOperator.IsNumber(this.Option.Zoom)) radius+=this.Option.Zoom;

        var isHScreen=this.Frame.IsHScreen;
        radius*=GetDevicePixelRatio();
        for(var i=0;i<this.Value.length; ++i)   //是否在点上
        {
            var item=this.Value[i];
            var pt=new Point();
            if (isHScreen)
            {
                pt.Y=this.Frame.GetXFromIndex(item.XValue-data.DataOffset);
                pt.X=this.Frame.GetYFromData(item.YValue);
            }
            else
            {
                pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset);
                pt.Y=this.Frame.GetYFromData(item.YValue);
            }
            this.Canvas.beginPath();
            this.Canvas.arc(pt.X,pt.Y,radius,0,360);
            if (this.Canvas.isPointInPath(x,y))  return i;
        }

        return -1;
    }

    //坐标是否在线段上 返回在第几个线段上
    this.IsPointInLine=function(x, y, option)
    {
        if (!this.LinePoint) return -1;

        var lineWidth=5;
        if (option && IFrameSplitOperator.IsNumber(option.Zoom)) lineWidth+=option.Zoom;
        else if (this.Option && IFrameSplitOperator.IsNumber(this.Option.Zoom)) lineWidth+=this.Option.Zoom;

        var pixel=GetDevicePixelRatio();
        lineWidth*=pixel;
        for(var i=0;i<this.LinePoint.length; ++i)
        {
            var item=this.LinePoint[i];
            var ptStart=item.Start;
            var ptEnd=item.End;
            this.Canvas.beginPath();
            if (ptStart.X==ptEnd.X) //竖线
            {
                this.Canvas.moveTo(ptStart.X-lineWidth,ptStart.Y);
                this.Canvas.lineTo(ptStart.X+lineWidth,ptStart.Y);
                this.Canvas.lineTo(ptEnd.X+lineWidth,ptEnd.Y);
                this.Canvas.lineTo(ptEnd.X-lineWidth,ptEnd.Y);
            }
            else
            {
                this.Canvas.moveTo(ptStart.X,ptStart.Y+lineWidth);
                this.Canvas.lineTo(ptStart.X,ptStart.Y-lineWidth);
                this.Canvas.lineTo(ptEnd.X,ptEnd.Y-lineWidth);
                this.Canvas.lineTo(ptEnd.X,ptEnd.Y+lineWidth);
            }
            this.Canvas.closePath();

            //this.Canvas.fillStyle='RGB(22,100,100)';
            //this.Canvas.fill();
            if (this.Canvas.isPointInPath(x,y))
                return i;
        }

        return -1;
    }

    //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
    this.IsPointIn_XYValue_Line=function(x, y, option)
    {
        if (this.Status!=10) return -1;

        var value=this.IsPointInXYValue(x,y,option);
        if (value>=0) return value;

        value=this.IsPointInLine(x,y,option);
        if (value>=0) return 100;

        return -1;
    }

    this.DrawLine=function(ptStart,ptEnd,isDottedline)
    {
        if (isDottedline) this.Canvas.setLineDash([5,10]);

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();

        if (isDottedline) this.Canvas.setLineDash([]);
    }

    this.CreateLineData=function(ptStart,ptEnd)
    {
        var line={Start:new Point(), End:new Point()};
        line.Start.Y=ptStart.Y;
        line.Start.X=ptStart.X;
        line.End.Y=ptEnd.Y;
        line.End.X=ptEnd.X;

        return line;
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=
        { 
            ClassName:this.ClassName, 
            Symbol:this.Symbol, Guid:this.Guid, Period:this.Period,Value:[] ,
            FrameID:this.Frame.Identify, LineColor:this.LineColor, AreaColor:this.AreaColor,
            LineWidth:this.LineWidth, Right:this.Right, EnableSave:this.EnableSave,
            IsShowYCoordinate:this.IsShowYCoordinate
        };

        for(var i=0; i<this.Value.length; ++i)
        {
            var item=this.Value[i];
            storageData.Value.push({ XValue:item.XValue, YValue:item.YValue, DateTime:item.DateTime });
        }

        if (this.Text) storageData.Text=this.Text;  //如果有文本, 也导出
        if (this.FontOption) storageData.FontOption=this.FontOption;    //字体也导出

        return storageData;
    }

    //导出基础的配置 不包含点
    this.ExportBaseData=function()
    {
        var data=
        { 
            ClassName:this.ClassName, Guid:this.Guid, FrameID:this.Frame.Identify, 
            Symbol:this.Symbol,  Period:this.Period,Right:this.Right,
            LineColor:this.LineColor, 
            LineWidth:this.LineWidth,  
            EnableSave:this.EnableSave, IsShowYCoordinate:this.IsShowYCoordinate
        };

        if (this.AreaColor) data.AreaColor=this.AreaColor;
        if (this.Text) data.Text=this.Text;  //如果有文本, 也导出
        if (this.FontOption) 
        {
            data.FontOption={};
            this.SetFont(data.FontOption, this.FontOption); //字体也导出
        }

        return data;
    }

    this.IsFrameMinSize=function()   //框架是否是最小化模式
    {
        return this.Frame && this.Frame.IsMinSize;
    }


    this.PointRange=function(aryPoint)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryPoint)) return null;
        if (aryPoint.length==1) 
        {
            var data=
            { 
                Points:[ { X:aryPoint[0].X, Y:aryPoint[0].Y } ]
            };

            return data;
        }
        else
        {
            var xMax=aryPoint[0].X;
            var xMin=xMax;
    
            var yMax=aryPoint[0].Y;
            var yMin=yMax;
            var aryData=[{ X:aryPoint[0].X, Y:aryPoint[0].Y }];
            for(var i=1;i<aryPoint.length;++i)
            {
                if (xMax<aryPoint[i].X) xMax=aryPoint[i].X;
                if (xMin>aryPoint[i].X) xMin=aryPoint[i].X;
    
                if (yMax<aryPoint[i].Y) yMax=aryPoint[i].Y;
                if (yMin>aryPoint[i].Y) yMin=aryPoint[i].Y;
    
                aryData.push({X:aryPoint[i].X, Y:aryPoint[i].Y});
            }

            var data=
            { 
                X: { Max: { X:xMax }, Min: { X:xMin} }, 
                Y: { Max: { Y:yMax},  Min: { Y:yMin} },
                Points: aryData //所有的点
            };

            return data;
        }        
    }

    this.GetXYCoordinate_default=function()
    {
        if (this.IsFrameMinSize()) return null;
        if (!this.IsShow) return null;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );

        return this.PointRange(drawPoint);
    }

    this.GetXYCoordinate=function()
    {
        return null;
    }

    this.CopyData_default=function()
    {
        if (!this.Frame) return null;

        var data=this.ExportStorageData();
        if (!data) return null;

        var dataOffset=0;
        if (this.Frame.ClassName=="MinuteFrame" || this.Frame.Class=="MinuteHScreenFrame")
        {
            
        }
        else
        {
            var kData=this.Frame.Data;
            if (!kData) return null;

            dataOffset=kData.DataOffset;
        }

        var height=this.Frame.ChartBorder.GetHeight();
        var yFirst=this.Frame.ChartBorder.GetBottomEx()-this.Point[0].Y;

        for(var i=0;i<data.Value.length; ++i)
        {
            var item=data.Value[i];
            var itemPoint=this.Point[i];

            item.XIndex=item.XValue-dataOffset+1;

            if (i==0) 
            {
                item.XOffset=0;
                item.YOffset=0;
            }
            else
            {
                var preItem=data.Value[i-1];
                var prePoint=this.Point[i-1];
                item.XOffset=item.XValue-preItem.XValue;
                item.YOffset=itemPoint.Y-prePoint.Y;
            }
        }

        data.DataOffset=dataOffset;
        data.YFristScale=yFirst/height;
        data.Height=height; //Y轴最大-最小差值

        return data;
    }

    this.SetFont=function(destFont, srcFont)
    {
        if (!srcFont) return;
        if (!destFont) return;
       
        if (srcFont.Family) destFont.Family=srcFont.Family;
        if (srcFont.Weight) destFont.Weight=srcFont.Weight;
        if (srcFont.Style) destFont.Style=srcFont.Style;
        if (IFrameSplitOperator.IsNumber(srcFont.Size)) destFont.Size=srcFont.Size;
    }

    this.GetFontString=function(fontOption)
    {
        const defaultFont=16*GetDevicePixelRatio() +"px 微软雅黑";
        if (!fontOption || !fontOption.Family || !IFrameSplitOperator.IsPlusNumber(fontOption.Size)) return defaultFont;

        var font='';
        if (fontOption.Color) font+=fontOption.Color+' ';
        if (fontOption.Style) font+=fontOption.Style+' ';
        if (fontOption.Weight) font+=fontOption.Weight+' ';

        font+=fontOption.Size*GetDevicePixelRatio()+'px ';
        font+=fontOption.Family;

        return font;
    }

    //获得多行文本
    this.GetMultiLineText=function(text, maxWidth, font , option)
    {
        if (font) this.Canvas.font=font;
        
        var textWidth=this.Canvas.measureText(text).width;
        if (textWidth<=maxWidth) return { AryText:[{Text:text }] };

        var singleWidth=this.Canvas.measureText("擎").width;
        var estimateCount=parseInt(maxWidth/singleWidth);    //预估个数
        var endPos=0;

        var aryText=[];
        while(endPos<text.length-1)
        {
            var count=estimateCount;
            var pos=endPos+count;
            if (pos>=text.length) 
            {
                pos=text.length-1;
                count=pos-endPos;
            }

            var subText=text.slice(endPos,endPos+count);
            var textWidth=this.Canvas.measureText(subText).width;
            if (textWidth>maxWidth)
            {
                for(var i=count; i>=0 ;--i)
                {
                    subText=text.slice(endPos, endPos+i);
                    textWidth=this.Canvas.measureText(subText).width;
                    if (textWidth<maxWidth)
                    {
                        aryText.push({Text:subText});
                        endPos+=i;
                        break;
                    }
                }
            }
            else if (textWidth<maxWidth)
            {
                var bFind=false;
                for(var i=count;(i+endPos)<=text.length;++i)
                {
                    subText=text.slice(endPos, endPos+i);
                    textWidth=this.Canvas.measureText(subText).width;
                    if (textWidth>maxWidth)
                    {
                        subText=text.slice(endPos, endPos+i-1);
                        aryText.push({Text:subText});
                        endPos+=i-1;
                        bFind=true;
                        break;
                    }
                }

                if (!bFind) 
                {
                    aryText.push({Text:subText});
                    endPos=text.length-1;
                }
            }
            else
            {
                aryText.push({Text:subText});
                endPos+=count;
            }
        }

        return { AryText:aryText };
    }

    this.CloneArrayText=function(aryText)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryText)) return [];

        var aryValue=[];
        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            if (!item) continue;

            aryValue.push({ Text:item.Text });
        }

        return aryValue;
    }

    //计算角度
    this.CalculateAngle=function(x1, y1, x2,y2)
    {
        var x = Math.abs(x1 - x2);
        var y = Math.abs(y1 - y2);
        var z = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        var cos = x / z;
        var radina = Math.acos(cos);   //用反三角函数求弧度
        var angle = 180 / (Math.PI / radina);//将弧度转换成角度 

        if (x2 == x1 && y2 < y1)    
            return 90;

        if (x2 == x1 && y2 > y1)    
            return 270;

        if (x2 > x1 && y2 == y1)    
            return 0;

        if (x2 < x1 && y2 == y1)
            return 180;

        if (x2 > x1 && y2 > y1)     //第四象限
            return 360 - angle;

        if (x2 < x1 && y2 > y1)     //第三象限
            return 180 + angle;
       
        if (x2 < x1 && y2 < y1)     //第二象限
            return 180 - angle;

        return angle;
    }

    //复制
    //this.CopyData=function() { }
    //this.PtInButtons=function(x, y) { }


    //计算标签页大小
    this.CalculateLabelSize=function(labelInfo)
    {
        var config=labelInfo.Config;
        this.Canvas.font=config.Font;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="top";
        var lineHeight=this.Canvas.measureText("擎").width+2;

        var maxWidth=0, lineCount=0, labelHeight=config.Mergin.Top+config.Mergin.Bottom;
        for(var i=0;i<labelInfo.AryText.length;++i)
        {
            if (i>0) labelHeight+=config.LineSpace;

            var item=labelInfo.AryText[i];
            item.NameWidth=0;
            item.TextWidth=0;
            if (item.Name) item.NameWidth=this.Canvas.measureText(item.Name).width+2;
            if (item.Text) item.TextWidth=this.Canvas.measureText(item.Text).width+2;

            var itemWidth=item.NameWidth+item.TextWidth;
            if (maxWidth<itemWidth) maxWidth=itemWidth;
            ++lineCount;

            labelHeight+=lineHeight;
        }

        var labelWidth=maxWidth+config.Mergin.Left+config.Mergin.Right;

        labelInfo.Width=labelWidth;
        labelInfo.Height=labelHeight;
        labelInfo.LineHeight=lineHeight;
    }

    this.DrawDefaultLabel=function(labelInfo, rtBG)
    {
        var config=labelInfo.Config;

        if (config.BGColor)
        {
            this.Canvas.fillStyle=config.BGColor
            this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top),ToFixedRect(rtBG.Width),ToFixedRect(rtBG.Height)); 
        }
    
        var xText=rtBG.Left+config.Mergin.Left;
        var yText=rtBG.Top+config.Mergin.Top;
        for(var i=0;i<labelInfo.AryText.length;++i)
        {
            var item=labelInfo.AryText[i];

            if (i>0) yText+=config.LineSpace;

            if (item.Name)
            {
                this.Canvas.fillStyle=item.NameColor;
                this.Canvas.fillText(item.Name,xText,yText);
            }
            
            if (item.Text)
            {
                var xOut=xText+item.NameWidth;
                if (config.TextAlign==1) //右对齐
                    xOut=rtBG.Right-config.Mergin.Right-item.TextWidth;
                
                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.fillText(item.Text,xOut ,yText);
            }

            yText+=labelInfo.LineHeight;
        }
    }
}

IChartDrawPicture.ColorToRGBA=function(color,opacity)
{
    var reg = /^(rgb|RGB)/;
    if (reg.test(color)) 
    {
        var strHex = "#";
        var colorArr = color.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");    // 把RGB的3个数值变成数组
        // 转成16进制
        for (var i = 0; i < colorArr.length; i++) 
        {
            var hex = Number(colorArr[i]).toString(16);
            if (hex === "0")  hex += hex;
            strHex += hex;
        }

        color=strHex;
    }
    
    return "rgba(" + parseInt("0x" + color.slice(1, 3)) + "," + parseInt("0x" + color.slice(3, 5)) + "," + parseInt("0x" + color.slice(5, 7)) + "," + opacity + ")";
}

IChartDrawPicture.RGBToHex=function(rgb) 
{
    // Choose correct separator
    let sep = rgb.indexOf(",") > -1 ? "," : " ";
    // Turn "rgb(r,g,b)" into [r,g,b]
    rgb = rgb.substr(4).split(")")[0].split(sep);
  
    let r = (+rgb[0]).toString(16),
        g = (+rgb[1]).toString(16),
        b = (+rgb[2]).toString(16);
  
    if (r.length == 1)
      r = "0" + r;
    if (g.length == 1)
      g = "0" + g;
    if (b.length == 1)
      b = "0" + b;
  
    return "#" + r + g + b;
}

//16进制颜色转rgb
IChartDrawPicture.HexToRGB=function(color)
{
    color = color.toLowerCase();
    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
    if (color && reg.test(color)) 
    {
        if (color.length === 4) 
        {
            var sColorNew = "#";
            for (var i=1; i<4; i+=1) 
            {
                sColorNew += color.slice(i, i+1).concat(color.slice(i, i+1));    
            }
            color = sColorNew;
        }

        //处理六位的颜色值
        var sColorChange = [];
        for (var i=1; i<7; i+=2) 
        {
            sColorChange.push(parseInt("0x"+color.slice(i, i+2)));    
        }

        return "rgb(" + sColorChange.join(",") + ")";
    }

    return null;
}

IChartDrawPicture.ArrayDrawPricture=
[
    { Name:"线段", ClassName:'ChartDrawPictureLine',  Create:function() { return new ChartDrawPictureLine(); } },
    { Name:"射线", ClassName:'ChartDrawPictureHaflLine',  Create:function() { return new ChartDrawPictureHaflLine(); } },
    { Name:"箭头", ClassName:"ChartDrawArrowLine", Create:function() { return new ChartDrawArrowLine(); } },
    { Name:"水平线", ClassName:'ChartDrawPictureHorizontalLine',  Create:function() { return new ChartDrawPictureHorizontalLine(); }},
    { Name:"水平射线", ClassName:"ChartDrawPictureHorizontalRay", Create:function() { return new ChartDrawPictureHorizontalRay(); }},
    { Name:"趋势线", ClassName:'ChartDrawPictureTrendLine',  Create:function() { return new ChartDrawPictureTrendLine(); }},
    { Name:"矩形", ClassName:'ChartDrawPictureRect', Create:function() { return new ChartDrawPictureRect(); }},
    { Name:"圆弧线", ClassName:'ChartDrawPictureArc',  Create:function() { return new ChartDrawPictureArc(); }},
    { Name:"M头W底", ClassName:'ChartDrawPictureWaveMW',  Create:function() { return new ChartDrawPictureWaveMW(); }},
    { Name:"头肩型", ClassName:"ChartDrawHeadShouldersBT", Create:function() { return new ChartDrawHeadShouldersBT(); }},
    { Name:"平行线", ClassName:'ChartDrawPictureParallelLines',  Create:function() { return new ChartDrawPictureParallelLines(); }},
    { Name:"平行通道", ClassName:'ChartDrawPictureParallelChannel',  Create:function() { return new ChartDrawPictureParallelChannel(); }},
    { Name:"价格通道线", ClassName:'ChartDrawPicturePriceChannel',  Create:function() { return new ChartDrawPicturePriceChannel(); }},
    { Name:"文本", ClassName:'ChartDrawPictureText', Create:function() { return new ChartDrawPictureText(); }},
    { Name:"江恩角度线", ClassName:'ChartDrawPictureGannFan',  Create:function() { return new ChartDrawPictureGannFan(); }},
    { Name:"江恩角度线2", ClassName:'ChartDrawPictureGannFan',  Create:function() { return new ChartDrawPictureGannFanV2(); }},
    { Name:"阻速线", ClassName:'ChartDrawPictureResistanceLine',  Create:function() { return new ChartDrawPictureResistanceLine(); }},
    { Name:"阻速线2", ClassName:'ChartDrawPictureResistanceLineV2',  Create:function() { return new ChartDrawPictureResistanceLineV2(); }},
    { Name:"黄金分割", ClassName:'ChartDrawPictureGoldenSection',  Create:function() { return new ChartDrawPictureGoldenSection(); }},
    { Name:"百分比线", ClassName:'ChartDrawPicturePercentage',  Create:function() { return new ChartDrawPicturePercentage(); }},
    { Name:"波段线", ClassName:'ChartDrawPictureWaveBand',  Create:function() { return new ChartDrawPictureWaveBand(); }},
    { Name:"三角形", ClassName:'ChartDrawPictureTriangle',  Create:function() { return new ChartDrawPictureTriangle(); }},
    { Name:"对称角度", ClassName:'ChartDrawPictureSymmetryAngle',  Create:function() { return new ChartDrawPictureSymmetryAngle(); }},
    { Name:"圆", ClassName:'ChartDrawPictureCircle',  Create:function() { return new ChartDrawPictureCircle(); }},
    { Name:"平行四边形", ClassName:'ChartDrawPictureQuadrangle',  Create:function() { return new ChartDrawPictureQuadrangle(); }},
    { Name:"斐波那契周期线", ClassName:'ChartDrawPictureFibonacci',  Create:function() { return new ChartDrawPictureFibonacci(); }},
    { Name:"线形回归线", ClassName:"ChartDrawLinearRegression", Create:function() { return new ChartDrawLinearRegression(); } },
    { Name:"线形回归带", ClassName:"ChartDrawLinearRegression", Create:function() { return new ChartDrawLinearRegression({ IsShowMaxMinLine:true }); } },
    { Name:"延长线形回归带", ClassName:"ChartDrawLinearRegression", Create:function() { return new ChartDrawLinearRegression({ IsShowMaxMinLine:true, IsShowExtendLine:true }); } },
    { Name:"尺子", ClassName:"ChartDrawRuler", Create:function() { return new ChartDrawRuler(); } },
    { Name:"标价线", ClassName:"ChartDrawPriceLine", Create:function() { return new ChartDrawPriceLine(); } },
    { Name:"标价线2", ClassName:"ChartDrawPriceLineV2", Create:function() { return new ChartDrawPriceLineV2(); } },
    { Name:"垂直线", ClassName:"ChartDrawVerticalLine", Create:function() { return new ChartDrawVerticalLine(); } },
    { Name:"十字线", ClassName:"ChartDrawCrosshair", Create:function() { return new ChartDrawCrosshair(); } },
    { Name:"波浪尺", ClassName:"ChartDrawWaveRuler", Create:function() { return new ChartDrawWaveRuler(); } },
    { Name:"AB波浪尺", ClassName:"ChartDrawWaveRuler2Point", Create:function() { return new ChartDrawWaveRuler2Point(); } },
    { Name:"箱型线", ClassName:"ChartDrawBox", Create:function() { return new ChartDrawBox(); } },
    { Name:"2点画图例子", ClassName:"ChartDrawTwoPointDemo", Create:function() { return new ChartDrawTwoPointDemo(); } },
    { Name:"3点画图例子", ClassName:"ChartDrawThreePointDemo", Create:function() { return new ChartDrawThreePointDemo(); } },
    { Name:"水平线段", ClassName:"ChartDrawHLineSegment", Create:function() { return new ChartDrawHLineSegment();} },
    { Name:"平行射线", ClassName:"ChartDrawParallelRaysLines", Create:function() { return new ChartDrawParallelRaysLines();}},
    { ClassName:'ChartDrawPictureIconFont',  Create:function() { return new ChartDrawPictureIconFont(); }},

    //涂鸦 不绑定K线坐标
    { Name:"涂鸦线段", ClassName:'ChartDrawGraffitiLine',  Create:function() { return new ChartDrawGraffitiLine(); } },

    { Name:"固定范围成交量分布图", ClassName:"ChartDrawVolProfile", Create:function() { return new ChartDrawVolProfile(); }},

    { Name:"DisjointChannel", ClassName:"ChartDrawDisjontChannel", Create:function() { return new ChartDrawDisjontChannel();}},
    { Name:"FlatTop", ClassName:"ChartDrawFlatTop", Create:function() { return new ChartDrawFlatTop();}},

    { Name:"水平线2", ClassName:"ChartDrawHLine", Create:function() { return new ChartDrawHLine(); }},

    { Name:"MonitorLine", ClassName:"ChartDrawMonitorLine", Create:function() { return new ChartDrawMonitorLine(); }},


    //trading view样式
    { Name:"Note", ClassName:"ChartDrawNote", Create:function() { return new ChartDrawNote(); } },
    { Name:"AnchoredText", ClassName:"ChartDrawAnchoredText", Create:function() { return new ChartDrawAnchoredText();} },
    { Name:"PriceLabel", ClassName:"ChartDrawPriceLabel", Create:function() { return new ChartDrawPriceLabel();} },
    { Name:"PriceNote", ClassName:"ChartDrawPriceNote", Create:function() { return new ChartDrawPriceNote();} },
    { Name:"FibWedge", ClassName:"ChartDrawFibWedge", Create:function(){ return new ChartDrawFibWedge(); }},
    { Name:"FibRetracement", ClassName:"ChartFibRetracement", Create:function() { return new ChartFibRetracement(); }},     //斐波那契回测
    { Name:"FibSpeedResistanceFan", ClassName:"ChartFibSpeedResistanceFan", Create:function() { return new ChartFibSpeedResistanceFan(); }}, //斐波那契扇形
    { Name:"PriceRange", ClassName:"ChartPriceRange", Create:function() { return new ChartPriceRange(); }},
    { Name:"DateRange", ClassName:"ChartDateRange", Create:function() { return new ChartDateRange(); }},
    { Name:"DatePriceRange", ClassName:"ChartDatePriceRange", Create:function() { return new ChartDatePriceRange(); }},
    { Name:"InfoLine", ClassName:"ChartInfoLine", Create:function() { return new ChartInfoLine(); }},
    { Name:"TrendAngle", ClassName:"ChartTrendAngle", Create:function() { return new ChartTrendAngle(); }},
    { Name:"ArrowMarker", ClassName:"ChartArrowMarker", Create:function() { return new ChartArrowMarker(); } },
    { Name:"BarsPattern", ClassName:"ChartBarsPattern", Create:function() { return new ChartBarsPattern(); } },
];

IChartDrawPicture.MapIonFont=new Map(
[
    ["icon-arrow_up", { Text:'\ue683', Color:'#318757', Family:"iconfont"}],
    ["icon-arrow_down", { Text:'\ue681', Color:'#db563e', Family:"iconfont"}],
    ["icon-arrow_right", {  Text:'\ue682', Color:'#318757', Family:"iconfont"}],
    ["icon-arrow_left", {  Text:'\ue680',Color:'#318757', Family:"iconfont"}]
]);

IChartDrawPicture.GetDrawPictureByName=function(value)
{
    for(var i in IChartDrawPicture.ArrayDrawPricture)
    {
        var item=IChartDrawPicture.ArrayDrawPricture[i];
        if (item.Name==value) return item;
    }

    return null;
}

IChartDrawPicture.GetDrawPictureByClassName=function(value)
{
    for(var i in IChartDrawPicture.ArrayDrawPricture)
    {
        var item=IChartDrawPicture.ArrayDrawPricture[i];
        if (item.ClassName==value) return item;
    }

    return null;
}

//注册一个新的画图工具 {Name:中文名字, ClassName:类名, Create:function()}
IChartDrawPicture.RegisterDrawPicture=function(obj)  
{
    if (!obj.Name || !obj.ClassName || !obj.Create) return false;

    var item={ Name:obj.Name, ClassName:obj.ClassName, Create:obj.Create };
    IChartDrawPicture.ArrayDrawPricture.push(item);

    JSConsole.Chart.Log('[IChartDrawPicture.RegisterDrawPicture] registered new draw picture class. item=',item);
    return true;
}

//注册一个新图标 {Name:, Text: , Color:, Family:}
IChartDrawPicture.RegisterIonFont=function(obj)
{
    if (!obj.Name || !obj.Text || !obj.Family) return false;

    var isOverwirte=IChartDrawPicture.MapIonFont.has(obj.Name);
    IChartDrawPicture.MapIonFont.set(obj.Name, obj);

    JSConsole.Chart.Log('[IChartDrawPicture.RegisterIonFont] registered new icon font, obj=, isOverwirte=',obj, isOverwirte);
    return true;
}

IChartDrawPicture.CreateChartDrawPicture=function(obj)    //创建画图工具
{
    var item=IChartDrawPicture.GetDrawPictureByClassName(obj.ClassName);
    if (!item) return null;

    var chartDraw=item.Create();    

    //TODO:后面都放到每一个SetOptin里面
    if (obj.Period>=0) chartDraw.Period=obj.Period;
    if (obj.Right>=0) chartDraw.Right=obj.Right;
    if (obj.Guid) chartDraw.Guid=obj.Guid;
    if (obj.Symbol) chartDraw.Symbol=obj.Symbol;
    if (obj.Value) chartDraw.Value=obj.Value;
    if (obj.Text) chartDraw.Text=obj.Text;
    if (obj.LineColor) chartDraw.LineColor=obj.LineColor;
    if (obj.AreaColor) chartDraw.AreaColor=obj.AreaColor;
    if (obj.FontOption) chartDraw.FontOption=obj.FontOption;
    if (obj.Label) chartDraw.Label=obj.Label;
    if (obj.LineWidth>0) chartDraw.LineWidth=obj.LineWidth;
    if (obj.EnableMove===false) chartDraw.EnableMove=obj.EnableMove;
    if (IFrameSplitOperator.IsBool(obj.EnableSave)) chartDraw.EnableSave=obj.EnableSave;
    if (IFrameSplitOperator.IsNumber(obj.ChannelWidth)) chartDraw.ChannelWidth=obj.ChannelWidth;
    if (IFrameSplitOperator.IsBool(obj.IsShowYCoordinate)) chartDraw.IsShowYCoordinate=obj.IsShowYCoordinate;

    if (chartDraw.SetOption) chartDraw.SetOption(obj);

    return chartDraw;
}



//画图工具-线段
function ChartDrawPictureLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureLine';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.IsShowYCoordinate=false;
    this.CopyData=this.CopyData_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:false} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        /*
        if (this.IsSelected)
        {
            this.Canvas.strokeStyle='rgba(255,0,0,0.5)';
            this.Canvas.lineWidth=20 * GetDevicePixelRatio();
            this.Canvas.stroke();
        }
        */

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.GetYCoordinatePoint=function()
    {
        if (this.IsFrameMinSize()) return null;
        if (!this.IsShow) return null;

        if (this.Status<2) return null;
        if(!this.Point.length || !this.Frame) return null;
        if (this.Status!=10)  return null;
          
        //完成
        var aryPoint=[];
        for(var i=0; i<this.Value.length; ++i)
        {
            var item=this.Value[i];
            var y=this.Frame.GetYFromData(item.YValue,false);

            aryPoint.push({ Y:y, YValue:item.YValue, Item:item, Color:this.PointColor });
        }

        return aryPoint;
    }
}

//趋势线角度
function ChartTrendAngle()
{
    this.newMethod=ChartDrawPictureLine;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartTrendAngle';
    this.AngleLineLength=100;
    this.AngleLineDash=[3,3];
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.Super_SetOption=this.SetOption;    //父类函数

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.AngleLineLength)) this.AngleLineLength=option.AngleLineLength;
            if (option.Font) this.Font=option.Font;
            if (option.AngleLineDash) this.AngleLineDash=option.AngleLineDash;
        }
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:false} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        this.DrawAngle(ptStart, ptEnd);

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.DrawAngle=function(ptStart, ptEnd)
    {
        var pixelRatio=GetDevicePixelRatio();
        var angle=this.CalculateAngle(ptStart.X, ptStart.Y, ptEnd.X, ptEnd.Y);  //角度
        var lineLength=this.AngleLineLength*pixelRatio; //角度线长度
        var ptRight={ X:ptStart.X+lineLength, Y:ptStart.Y };

        if (this.AngleLineDash) this.Canvas.setLineDash(this.AngleLineDash); //画虚线

        this.Canvas.lineWidth=1*GetDevicePixelRatio();
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(ptStart.X),ToFixedPoint(ptStart.Y));
        this.Canvas.lineTo(ToFixedPoint(ptRight.X),ToFixedPoint(ptRight.Y));
        this.Canvas.stroke();

        this.Canvas.beginPath();
        if (angle<=180)
        {
            this.Canvas.arc(ptStart.X,ToFixedPoint(ptStart.Y),lineLength,0,(Math.PI / 180)*(360-angle), true);
            var text=`${angle.toFixed(0)}°`;
        }
        else
        {
            this.Canvas.arc(ptStart.X,ToFixedPoint(ptStart.Y),lineLength,0,(Math.PI / 180)*(360-angle), false);
            var text=`${(angle-360).toFixed(0)}°`;
        }
        
        this.Canvas.stroke();

        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.font=this.Font;
        this.Canvas.fillStyle=this.LineColor;

        if (this.AngleLineDash) this.Canvas.setLineDash([]);

       
        this.Canvas.fillText(text,ptRight.X+5,ptRight.Y);
    }
}

//画图工具-涂鸦线段 Y轴关联数值， X轴不关联
function ChartDrawGraffitiLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawGraffitiLine';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=null;
    this.PointCount=2;                          //画点的个数
    this.EnableMoveCheck=false;                 //允许移动时不监测是否超出边界

    this.PointToValue=function()
    {
        if (!this.Frame) return false;

        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            for(var i=0;i<this.Point.length;++i)
            {
                var item=this.Point[i];
                var yValue=this.Frame.GetYData(item.X);
                var valueItem={ XValue:item.Y, YValue:yValue };
                this.Value[i]=valueItem;
            }
        }
        else
        {
            for(var i=0;i<this.Point.length;++i)
            {
                var item=this.Point[i];
                var yValue=this.Frame.GetYData(item.Y);
                var valueItem={ XValue:item.X, YValue:yValue };
                this.Value[i]=valueItem;
            }
        }

        return true;
    }

    //Value => Point
    this.ValueToPoint=function()
    {
        if (!this.Frame) return false;
       
        var isHScreen=this.Frame.IsHScreen;
        this.Point=[];
        for(var i in this.Value)
        {
            var item=this.Value[i];
            var pt=new Point();
            if (isHScreen)
            {
                pt.Y=item.XValue;
                pt.X=this.Frame.GetYFromData(item.YValue);
            }
            else
            {
                pt.X=item.XValue;
                pt.Y=this.Frame.GetYFromData(item.YValue,false);
            }
            this.Point[i]=pt;
        }
    }

    this.UpdateXValue=function()    //通过datetime更新x的索引
    {
       
    }

    this.CalculateDrawPoint=function(option)
    {
        if (this.Status<2) return null;
        if(!this.Point.length || !this.Frame) return null;

        var drawPoint=[];
        if (this.Status==10)
        {
            var isHScreen=this.Frame.IsHScreen;
            for(var i in this.Value)
            {
                var item=this.Value[i];
                var pt=new Point();
                if (isHScreen)  //横屏X,Y对调
                {
                    pt.Y=item.XValue;
                    pt.X=this.Frame.GetYFromData(item.YValue,false);
                }
                else
                {
                    pt.X=item.XValue;
                    pt.Y=this.Frame.GetYFromData(item.YValue,false);
                }
                drawPoint.push(pt);
            }
        }
        else
        {
            drawPoint=this.Point;
        }

        return drawPoint;
    }

     //坐标是否在点上 返回在第几个点上
     this.IsPointInXYValue=function(x,y,option)
     {
         if (!this.Frame) return -1;
         if (!this.Value) return -1;
 
         var radius=5;
         if (option && IFrameSplitOperator.IsNumber(option.Zoom)) radius+=option.Zoom;
         else if (this.Option && IFrameSplitOperator.IsNumber(this.Option.Zoom)) radius+=this.Option.Zoom;
         var isHScreen=this.Frame.IsHScreen;
         radius*=GetDevicePixelRatio();
         for(var i=0;i<this.Value.length; ++i)   //是否在点上
         {
             var item=this.Value[i];
             var pt=new Point();
             if (isHScreen)
             {
                 pt.Y=item.XValue;
                 pt.X==this.Frame.GetYFromData(item.YValue);
             }
             else
             {
                 pt.X=item.XValue;
                 pt.Y=this.Frame.GetYFromData(item.YValue);
             }
             this.Canvas.beginPath();
             this.Canvas.arc(pt.X,pt.Y,radius,0,360);
             if (this.Canvas.isPointInPath(x,y))  return i;
         }
 
         return -1;
     }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        /*
        if (this.IsSelected)
        {
            this.Canvas.strokeStyle='rgba(255,0,0,0.5)';
            this.Canvas.lineWidth=20 * GetDevicePixelRatio();
            this.Canvas.stroke();
        }
        */

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }
}

//画图工具-箭头线
function ChartDrawArrowLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawArrowLine';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.ArrawLineWidth=5;
    this.ArrawLength=15;        //三角斜边长度
    this.ArrawAngle=35;         //三角斜边一直线夹角
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        //计算箭头
        var theta=this.ArrawAngle;       //三角斜边一直线夹角
        var headlen=this.ArrawLength;    //三角斜边长度
        var angle = Math.atan2(ptStart.Y - ptEnd.Y, ptStart.X - ptEnd.X) * 180 / Math.PI,
        angle1 = (angle + theta) * Math.PI / 180,
        angle2 = (angle - theta) * Math.PI / 180,
        topX = headlen * Math.cos(angle1),
        topY = headlen * Math.sin(angle1),
        botX = headlen * Math.cos(angle2),
        botY = headlen * Math.sin(angle2);


        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();

        this.Canvas.beginPath();

        var arrowX = ptEnd.X + topX;
        var arrowY = ptEnd.Y + topY;
        this.Canvas.moveTo(arrowX,arrowY);

        this.Canvas.lineTo(ptEnd.X, ptEnd.Y);

        arrowX = ptEnd.X + botX;
        arrowY = ptEnd.Y + botY;
        this.Canvas.lineTo(arrowX,arrowY);

        this.Canvas.lineWidth=this.ArrawLineWidth*GetDevicePixelRatio();
        this.Canvas.stroke();

        this.RestoreLineWidth();

        /*
        if (this.IsSelected)
        {
            this.Canvas.strokeStyle='rgba(255,0,0,0.5)';
            this.Canvas.lineWidth=20 * GetDevicePixelRatio();
            this.Canvas.stroke();
        }
        */

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint([drawPoint[0]]);  //画点
        this.Canvas.restore();
    }
}

function ChartArrowMarker()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartArrowMarker';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
   
    this.InsideLineConfig={ Angle:25, MaxWidth:70, WidthRate:0.3 };
    this.InsideWidth=70;
   
    this.OutLineConfig={ Angle:35, MaxWidth:100, WidthRate:0.4 };
    this.OutWidth=100;

    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.Super_SetOption=this.SetOption;    //父类函数

    this.SetOption=function(option)
    {
        this.Super_SetOption(option);

        if (option.AreaColor) this.AreaColor=option.AreaColor;
        else this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor, 0.6);
    }

    this.CalculatePoint=function(angle, ptStart, ptEnd, lineWidth)
    {
        var theta=angle;            //三角斜边一直线夹角
        var headlen=lineWidth;      //三角斜边长度

        var angle = Math.atan2(ptStart.Y - ptEnd.Y, ptStart.X - ptEnd.X) * 180 / Math.PI,
        angle1 = (angle + theta) * Math.PI / 180,
        angle2 = (angle - theta) * Math.PI / 180,
        topX = headlen * Math.cos(angle1),
        topY = headlen * Math.sin(angle1),
        botX = headlen * Math.cos(angle2),
        botY = headlen * Math.sin(angle2);

        return { Top:{X:topX+ptEnd.X, Y:topY+ptEnd.Y}, Bottom:{X:botX+ptEnd.X, Y:botY+ptEnd.Y} };
    }

    this.CalculateLineWidth=function(ptStart, ptEnd)
    {
        var a=ptStart.X-ptEnd.X;
        var b=ptStart.Y-ptEnd.Y;
        var c=Math.sqrt(a*a+b*b);

        this.InsideWidth=c*this.InsideLineConfig.WidthRate;
        this.OutWidth=c*this.OutLineConfig.WidthRate;

        if (this.InsideWidth>this.InsideLineConfig.MaxWidth) this.InsideWidth=this.InsideLineConfig.MaxWidth;
        if (this.OutWidth>this.OutLineConfig.MaxWidth) this.OutWidth=this.OutLineConfig.MaxWidth;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.CalculateLineWidth(ptStart, ptEnd);

        //计算箭头 的两条边线坐标
        var outArrow=this.CalculatePoint(this.OutLineConfig.Angle, ptStart, ptEnd, this.OutWidth);
        var insideArrow=this.CalculatePoint(this.InsideLineConfig.Angle, ptStart, ptEnd, this.InsideWidth);

        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(insideArrow.Top.X,insideArrow.Top.Y);
        this.Canvas.lineTo(outArrow.Top.X,outArrow.Top.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.lineTo(outArrow.Bottom.X,outArrow.Bottom.Y);
        this.Canvas.lineTo(insideArrow.Bottom.X,insideArrow.Bottom.Y);
        this.Canvas.lineTo(ptStart.X,ptStart.Y);

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.stroke();

        this.Canvas.closePath();
        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.fill();

        /*
        if (this.IsSelected)
        {
            this.Canvas.strokeStyle='rgba(255,0,0,0.5)';
            this.Canvas.lineWidth=20 * GetDevicePixelRatio();
            this.Canvas.stroke();
        }
        */

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint([ptStart,ptEnd]);  //画点
        this.Canvas.restore();
    }
}

//画图工具-射线
function ChartDrawPictureHaflLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureHaflLine';
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    
    this.FullLine;


    this.IsPointIn=function(x, y, option)
    {
        var result=this.IsPointIn_XYValue_Line(x,y,option);
        if (result>=0) return result;

        if (!this.FullLine) return result;

        var ptStart=this.FullLine.Start;
        var ptEnd=this.FullLine.End;
        var pixel=GetDevicePixelRatio();
        var lineWidth=5*pixel;

        this.Canvas.beginPath();
        if (ptStart.X==ptEnd.X) //竖线
        {
            this.Canvas.moveTo(ptStart.X-lineWidth,ptStart.Y);
            this.Canvas.lineTo(ptStart.X+lineWidth,ptStart.Y);
            this.Canvas.lineTo(ptEnd.X+lineWidth,ptEnd.Y);
            this.Canvas.lineTo(ptEnd.X-lineWidth,ptEnd.Y);
        }
        else
        {
            this.Canvas.moveTo(ptStart.X,ptStart.Y+lineWidth);
            this.Canvas.lineTo(ptStart.X,ptStart.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y-lineWidth);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y+lineWidth);
        }
        this.Canvas.closePath();

        if (this.Canvas.isPointInPath(x,y))
            return 100;

        return result;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        this.FullLine=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:false, IsCheckY:false});
        if (!drawPoint || drawPoint.length!=2) return;

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];
        this.ClipFrame();

        this.Canvas.strokeStyle=this.LineColor;
        this.SetLineWidth();
        this.Canvas.beginPath();
        this.Canvas.moveTo(drawPoint[0].X,drawPoint[0].Y);
        this.Canvas.lineTo(drawPoint[1].X,drawPoint[1].Y);
        var endPoint=this.CalculateExtendLineEndPoint(drawPoint);
        this.Canvas.lineTo(endPoint.X,endPoint.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);

        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();

        this.FullLine={Start:drawPoint[0], End:endPoint};
    }
}

// 画图工具-水平线 支持横屏
function ChartDrawPictureHorizontalLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureHorizontalLine';
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsDrawFirst=true;
    this.LineWidth=1;
    this.Super_SetOption=this.SetOption;    //父类函数
    this.Super_ExportStorageData=this.ExportStorageData;

    this.LabelConfig=
    { 
        Left:{ IsShow:true, Margin:{ Left:5, Top:4, Bottom:2, Right:5 } },
        Right:{ IsShow:true, Margin:{ Left:5, Top:4, Bottom:2, Right:5 } },
        Font:`${12*GetDevicePixelRatio()}px 微软雅黑`, TextColor:"rgb(255,255,255)" 
    };

    this.InsideLabelConfig=
    {
        Position:0, //0=左, 1=右
        Font:`${14*GetDevicePixelRatio()}px 微软雅黑`,
        Margin:{ Left:5, Top:4, Bottom:2, Right:5 },
        TextColor:"rgb(255,255,255)",
        BGAlpha:0.8, //背景色透明度
    }

    this.LabelTitle;

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.LabelTitle) this.LabelTitle=option.LabelTitle;

            if (option.Label)
            {
                var item=option.Label;
                if (item.Left)
                {
                    var subItem=item.Left;
                    if (IFrameSplitOperator.IsBool(subItem.IsShow)) this.LabelConfig.Left.IsShow=subItem.IsShow;
                }
                

                if (item.Right)
                {
                    var subItem=item.Right;
                    if (IFrameSplitOperator.IsBool(subItem.IsShow)) this.LabelConfig.Right.IsShow=subItem.IsShow;
                }

                if (item.Font) this.LabelConfig.Font=item.Font;
                if (item.TextColor) this.LabelConfig.FoTextColornt=item.TextColor;
            }

            if (option.InsideLabel)
            {
                var item=option.InsideLabel;
                if (item.Font) this.InsideLabelConfig.Font=item.Font;
                if (item.TextColor) this.InsideLabelConfig.TextColor=item.TextColor;
                if (IFrameSplitOperator.IsNumber(item.Position)) this.InsideLabelConfig.Position=item.Position;
                if (IFrameSplitOperator.IsNumber(item.BGAlpha)) this.InsideLabelConfig.BGAlpha=item.BGAlpha;
            }
        }
    }

    this.ExportStorageData=function()
    {
        var storageData;
        if (this.Super_ExportStorageData) 
        {
            storageData=this.Super_ExportStorageData();
            if (this.LabelTitle) storageData.LabelTitle=this.LabelTitle;
        }

        return storageData;
    }

    /*
    this.GetXYCoordinate=function()
    {
        if (this.IsFrameMinSize()) return null;
        var drawPoint=this.CalculateDrawPoint();

        return this.PointRange(drawPoint);
    }
    */

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint || drawPoint.length!=1) return;
        if (!this.Frame) return;
        if (this.Value.length!=1) return;
        if (!this.IsYValueInFrame(this.Value[0].YValue)) return null;

        var isHScreen=this.Frame.IsHScreen;
        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        if (isHScreen)
        {
            left=this.Frame.ChartBorder.GetTop();
            right=this.Frame.ChartBorder.GetBottom();
        }
        this.ClipFrame();

        this.Canvas.strokeStyle=this.LineColor;
        this.SetLineWidth();
        this.Canvas.beginPath();
        if (isHScreen)
        {
            this.Canvas.moveTo(drawPoint[0].X,left);
            this.Canvas.lineTo(drawPoint[0].X,right);
        }
        else
        {
            var yFixed=ToFixedPoint2(this.LineWidth,drawPoint[0].Y);
            this.Canvas.moveTo(left,yFixed);
            this.Canvas.lineTo(right,yFixed);
        }
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:new Point(), End:new Point()};
        if (isHScreen)
        {
            line.Start.X=drawPoint[0].X;
            line.Start.Y=left;
            line.End.X=drawPoint[0].X;
            line.End.Y=right;
        }
        else
        {
            line.Start.X=left;
            line.Start.Y=drawPoint[0].Y;
            line.End.X=right;
            line.End.Y=drawPoint[0].Y;
        }
        this.LinePoint.push(line);

        //画点
        this.DrawPoint(drawPoint);

        //显示价格
        this.DrawInsideLabel(drawPoint[0])

        this.Canvas.restore();

        this.DrawValueLabel(drawPoint[0]);
    }
 
    this.DrawValueLabel=function(point)
    {
        if (!point) return;
        if (this.Frame.IsHScreen) return;   //不支持横屏

        var y=point.Y;
        var yValue=this.Frame.GetYData(y);
        var text=yValue.toFixed(2);

        var border=this.Frame.GetBorder();
        var config=this.LabelConfig;

        this.Canvas.font=config.Font;
        var textHeight=this.Canvas.measureText("擎").width;
        var textWidth=this.Canvas.measureText(text).width;

        if (config.Left.IsShow && this.Frame.ChartBorder.Left>5)
        {
            var margin=config.Left.Margin;
            var rtBG={ Right:border.Left-1, Height:textHeight+margin.Top+margin.Bottom, Width:textWidth+margin.Left+margin.Right };
            rtBG.Top=y-textHeight/2-margin.Top;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
            rtBG.Left=rtBG.Right-rtBG.Width;

            this.Canvas.fillStyle=this.LineColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

            this.Canvas.textAlign="left";
            this.Canvas.textBaseline = "top";
            var xText=rtBG.Left+margin.Left;
            var yText=rtBG.Top+margin.Top;
            this.Canvas.fillStyle=config.TextColor;
            this.Canvas.fillText(text,xText,yText);
        }

        if (config.Right.IsShow && this.Frame.ChartBorder.Right>5)
        {
            var margin=config.Right.Margin;
            var rtBG={ Left:border.Right+1, Height:textHeight+margin.Top+margin.Bottom, Width:textWidth+margin.Left+margin.Right };
            rtBG.Top=y-textHeight/2-margin.Top;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
            rtBG.Right=rtBG.Left+rtBG.Width;
            this.Canvas.fillStyle=this.LineColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

            this.Canvas.textAlign="left";
            this.Canvas.textBaseline = "top";
            var xText=rtBG.Left+margin.Left;
            var yText=rtBG.Top+margin.Top;
            this.Canvas.fillStyle=config.TextColor;
            this.Canvas.fillText(text,xText,yText);
        }
    }

    this.DrawInsideLabel=function(point)
    {
        if (!point) return;

        var isHScreen=this.Frame.IsHScreen;
        var config=this.InsideLabelConfig;
        if (config.Position!=0 && config.Position!=1) return;
        var margin=config.Margin;

        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.font=config.Font;
        var textHeight=this.Canvas.measureText("擎").width;
        var border=this.Frame.GetBorder();

        if (isHScreen)
        {
            var yValue=this.Frame.GetYData(point.X);
            var text=yValue.toFixed(2);
            if (this.LabelTitle) text=this.LabelTitle+text;
            var textWidth=this.Canvas.measureText(text).width;

            var rtBG=null;
            if (config.Position==0) //左
            {
                var rtBG={ Top:border.Top+1, Width:textHeight+margin.Top+margin.Bottom, Height:textWidth+margin.Left+margin.Right, Left:point.X };
                rtBG.Bottom=rtBG.Top+rtBG.Height;
                rtBG.Right=rtBG.Left+rtBG.Width;
            }
            else if (config.Position==1)    //右
            {
                var rtBG={ Bottom:border.Bottom-1, Width:textHeight+margin.Top+margin.Bottom, Height:textWidth+margin.Left+margin.Right, Left:point.X };
                rtBG.Top=rtBG.Bottom-rtBG.Height;
                rtBG.Right=rtBG.Left+rtBG.Width;
            }

            var bgColor=this.LineColor;
            if (config.BGAlpha<1) bgColor=IChartDrawPicture.ColorToRGBA(this.LineColor, config.BGAlpha);
            this.Canvas.fillStyle=bgColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
            
            var xText=rtBG.Right-margin.Top;
            var yText=rtBG.Top+margin.Left;
            this.Canvas.translate(xText, yText);
            this.Canvas.rotate(90 * Math.PI / 180); //数据和框子旋转180度

            this.Canvas.textAlign="left";
            this.Canvas.textBaseline="top";
            this.Canvas.fillStyle=config.TextColor;
            this.Canvas.fillText(text,0,0);
        }
        else
        {
            var yValue=this.Frame.GetYData(point.Y);
            var text=yValue.toFixed(2);
            if (this.LabelTitle) text=this.LabelTitle+text;
            var textWidth=this.Canvas.measureText(text).width;

            var rtBG=null;
            if (config.Position==0) //左
            {
                var rtBG={ Left:border.Left+1, Height:textHeight+margin.Top+margin.Bottom, Width:textWidth+margin.Left+margin.Right, Bottom:point.Y };
                rtBG.Top=rtBG.Bottom-rtBG.Height;
                rtBG.Right=rtBG.Left+rtBG.Width;
            }
            else if (config.Position==1)    //右
            {
                var rtBG={ Right:border.Right-1, Height:textHeight+margin.Top+margin.Bottom, Width:textWidth+margin.Left+margin.Right, Bottom:point.Y };
                rtBG.Top=rtBG.Bottom-rtBG.Height;
                rtBG.Left=rtBG.Right-rtBG.Width;
            }

            var bgColor=this.LineColor;
            if (config.BGAlpha<1) bgColor=IChartDrawPicture.ColorToRGBA(this.LineColor, config.BGAlpha);
            this.Canvas.fillStyle=bgColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

            var xText=rtBG.Left+margin.Left;
            var yText=rtBG.Top+margin.Top;
            this.Canvas.textAlign="left";
            this.Canvas.textBaseline = "top";
            this.Canvas.fillStyle=config.TextColor;
            this.Canvas.fillText(text,xText,yText);
        }
    }
}

// 画图工具-水平射线线 支持横屏
function ChartDrawPictureHorizontalRay()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureHorizontalRay';
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsDrawFirst=true;
    this.LineWidth=1;
    this.Super_SetOption=this.SetOption;    //父类函数
    this.Super_ExportStorageData=this.ExportStorageData;

    this.LabelConfig=
    { 
        Right:{ IsShow:true, Margin:{ Left:5, Top:4, Bottom:2, Right:5 } },
        Font:`${12*GetDevicePixelRatio()}px 微软雅黑`, TextColor:"rgb(255,255,255)" 
    };

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.LabelTitle) this.LabelTitle=option.LabelTitle;

            if (option.Label)
            {
                var item=option.Label;
                if (item.Right)
                {
                    var subItem=item.Right;
                    if (IFrameSplitOperator.IsBool(subItem.IsShow)) this.LabelConfig.Right.IsShow=subItem.IsShow;
                }

                if (item.Font) this.LabelConfig.Font=item.Font;
                if (item.TextColor) this.LabelConfig.FoTextColornt=item.TextColor;
            }
        }
    }

    this.ExportStorageData=function()
    {
        var storageData;
        if (this.Super_ExportStorageData) 
        {
            storageData=this.Super_ExportStorageData();
        }
        return storageData;
    }

    this.GetXYCoordinate=function()
    {
        if (this.IsFrameMinSize()) return null;
        var drawPoint=this.CalculateDrawPoint();

        var data=this.PointRange(drawPoint);
        if (data) data.IsShowYCoordinate=false;
        return data;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint || drawPoint.length!=1) return;
        if (!this.Frame) return;
        if (this.Value.length!=1) return;
        if (!this.IsYValueInFrame(this.Value[0].YValue)) return null;

        var isHScreen=this.Frame.IsHScreen;
        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        if (isHScreen)
        {
            left=this.Frame.ChartBorder.GetTop();
            right=this.Frame.ChartBorder.GetBottom();
        }
        this.ClipFrame();

        this.Canvas.strokeStyle=this.LineColor;
        this.SetLineWidth();
        this.Canvas.beginPath();
        if (isHScreen)
        {
            this.Canvas.moveTo(drawPoint[0].X,drawPoint[0].Y);
            this.Canvas.lineTo(drawPoint[0].X,right);
        }
        else
        {
            var yFixed=ToFixedPoint2(this.LineWidth,drawPoint[0].Y);
            this.Canvas.moveTo(drawPoint[0].X,yFixed);
            this.Canvas.lineTo(right,yFixed);
        }
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:new Point(), End:new Point()};
        if (isHScreen)
        {
            line.Start.X=drawPoint[0].X;
            line.Start.Y=drawPoint[0].Y;
            line.End.X=drawPoint[0].X;
            line.End.Y=right;
        }
        else
        {
            line.Start.X=drawPoint[0].X;
            line.Start.Y=drawPoint[0].Y;
            line.End.X=right;
            line.End.Y=drawPoint[0].Y;
        }
        this.LinePoint.push(line);

        //画点
        this.DrawPoint(drawPoint);

        this.Canvas.restore();

        this.DrawValueLabel(drawPoint[0]);
    }
 
    this.DrawValueLabel=function(point)
    {
        if (!point) return;
        if (this.Frame.IsHScreen) return;   //不支持横屏

        var y=point.Y;
        var yValue=this.Frame.GetYData(y);
        var text=yValue.toFixed(2);

        var border=this.Frame.GetBorder();
        var config=this.LabelConfig;

        this.Canvas.font=config.Font;
        var textHeight=this.Canvas.measureText("擎").width;
        var textWidth=this.Canvas.measureText(text).width;

        if (config.Right.IsShow && this.Frame.ChartBorder.Right>5)
        {
            var margin=config.Right.Margin;
            var rtBG={ Left:border.Right+1, Height:textHeight+margin.Top+margin.Bottom, Width:textWidth+margin.Left+margin.Right };
            rtBG.Top=y-textHeight/2-margin.Top;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
            rtBG.Right=rtBG.Left+rtBG.Width;
            this.Canvas.fillStyle=this.LineColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

            this.Canvas.textAlign="left";
            this.Canvas.textBaseline = "top";
            var xText=rtBG.Left+margin.Left;
            var yText=rtBG.Top+margin.Top;
            this.Canvas.fillStyle=config.TextColor;
            this.Canvas.fillText(text,xText,yText);
        }
    }
}


//水平线2
function ChartDrawHLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Super_SetOption=this.SetOption;    //父类函数
    this.Super_ExportStorageData=this.ExportStorageData;

    //this.Label;         //{Text:文本, Position: 0=左, 1=右 2=中间 }
    //this.Label={ Text:"xxxxxxx", Position:1};
    this.LineWidth=1;
    this.Precision=2;   //小数位数
    this.ValueTextColor='rgb(250,250,250)';
    this.IsShowCorssCursor=true;    //画的时候是否显示十字光标
    this.GetLabelCallback;          //绘制标题回调函数
    this.PointCount=1;
    this.ClassName='ChartDrawHLine';
    this.Font=14*GetDevicePixelRatio() +"px 微软雅黑";
    this.TextFont=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.RightSpaceWidth=50;

    this.ButtonPosition=0;              //按钮位置, 0=价格后面， 1=价格上面 2=价格上面 左对齐 3=垂直排列
    this.ButtonBGColor='rgb(190,190,190)';
    this.ButtonSpace=3;
    
    this.TextMargin={ Left:0, Right:0 };

    this.AlwaysShowLab=false;        //总是显示标签

    this.Button= 
    { 
        CloseIcon: {  Text:'\ue62b', Color:'rgb(255,255,255)', Family:"iconfont", Size:16, ID:JSCHART_BUTTON_ID.DRAW_PICTURE_DELETE, TooltipText:null, Margin:{ Left:2, Right:2 } },
        SettingIcon: { Text:'\ue623',Color:'rgb(255,255,255)', Family:"iconfont", Size:16, ID:JSCHART_BUTTON_ID.DRAW_PICTURE_SETTING, TooltipText:null, Margin:{ Left:2, Right:2 } }
        //修改ID, Text , TooltipText 可以外部定制按钮
    }

    this.CustomButton=[];   //自定义的按钮 { Text:'\ue62b', Color:'rgb(255,255,255)', Family:"iconfont", Size:16, ID:JSCHART_BUTTON_ID.DRAW_PICTURE_BUTTON_1, TooltipText:null, Data:null }

    this.AryShowButton=[];  //需要显示的按钮 { Data:, Width }
    this.AryButton=[];
    this.ExtendData;    //扩展数据
    this.ShowPriceTextConfig=
    { 
        IsShow:[false, false, true], //[0]=left内 [1]=right内 [2]=right外
        Font:
        [
            `${12*GetDevicePixelRatio()}px 微软雅黑`,
            `${12*GetDevicePixelRatio()}px 微软雅黑`,
        ],
    };  

    //内部变量
    this.ColseButtonSize=0;
    this.SettingButtonSize=0;
    this.ButtonBGWidth=0;
    this.VerticalButtonInfo={ Width:0, Height:0 };  //垂直按钮信息
   


    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.GetLabelCallback) 
            {
                this.GetLabelCallback=option.GetLabelCallback;
            }

            if (IFrameSplitOperator.IsNumber(option.Precision)) this.Precision=option.Precision;
            if (option.Font) this.Font=option.Font;
            if (option.ValueTextColor) this.ValueTextColor=option.ValueTextColor;
            if (option.ButtonBGColor) this.ButtonBGColor=option.ButtonBGColor;
            if (IFrameSplitOperator.IsNumber(option.ButtonPosition)) this.ButtonPosition=option.ButtonPosition;
            if (IFrameSplitOperator.IsNumber(option.RightSpaceWidth)) this.RightSpaceWidth=option.RightSpaceWidth;
            if (IFrameSplitOperator.IsBool(option.AlwaysShowLab)) this.AlwaysShowLab=option.AlwaysShowLab;

            
            if (option.Button)
            {
                var item=option.Button;
                if (item.CloseIcon) 
                {
                    this.Button.CloseIcon=CloneData(item.CloseIcon);
                    if (!this.Button.CloseIcon.ID) this.Button.CloseIcon.ID=JSCHART_BUTTON_ID.DRAW_PICTURE_DELETE;
                }
                else if (item.CloseIcon===null) 
                {
                    this.Button.CloseIcon=null;
                }

                if (item.SettingIcon) 
                {
                    this.Button.SettingIcon=CloneData(item.SettingIcon);
                    if (!this.Button.SettingIcon.ID) this.Button.SettingIcon.ID=JSCHART_BUTTON_ID.DRAW_PICTURE_SETTING;
                }
                else if (item.SettingIcon===null) 
                {
                    this.Button.SettingIcon=null;
                }
            }

            if (option.ExtendData) this.ExtendData=option.ExtendData;

            if (IFrameSplitOperator.IsNonEmptyArray(option.IsShowPriceText))
            {
                for(var i=0;i<option.IsShowPriceText.length && i<3;++i)
                {
                    var value=option.IsShowPriceText[i]
                    if (IFrameSplitOperator.IsBool(value)) this.ShowPriceTextConfig.IsShow[i]=value;
                }
            }

            if (option.TextMargin)
            {
                var item=option.TextMargin;
                if (IFrameSplitOperator.IsNumber(item.Left)) this.TextMargin.Left=item.Left;
                if (IFrameSplitOperator.IsNumber(item.Right)) this.TextMargin.Right=item.Right;
            }
        }
    }

    this.ExportStorageData=function()
    {
        var storageData;
        if (this.Super_ExportStorageData) 
        {
            storageData=this.Super_ExportStorageData();
            if (this.Label) storageData.Label=this.Label;
        }

        return storageData;
    }

   
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    

    /*
    this.GetXYCoordinate=function()
    {
        if (this.IsFrameMinSize()) return null;
        var drawPoint=this.CalculateDrawPoint();

        return this.PointRange(drawPoint);
    }
    */

    this.IsDrawMain=function()  //选中绘制在动态绘图上， 没有选中绘制在背景上
    {
        if (!this.GetActiveDrawPicture) return true;

        var active=this.GetActiveDrawPicture();
        if (active.Select.Guid==this.Guid) return false;

        return true;
    }

    this.MainDraw=function()
    {
        this.Draw();
    }

    //获取需要显示的按钮 系统按钮+自定义按钮
    this.GetShowButton=function()
    {
        var aryButton=[];

        var item=this.Button.SettingIcon;
        if (item && item.Text) aryButton.push({ Data:item, Width:null });

        item=this.Button.CloseIcon;
        if (item && item.Text) aryButton.push({ Data:item, Width:null });

        if (IFrameSplitOperator.IsNonEmptyArray(this.CustomButton))
        {
            for(var i=0;i<this.CustomButton.length;++i)
            {
                item=this.CustomButton[i];
                if (item && item.Text) aryButton.push({ Data:item, Width:null });
            }
        }

        return aryButton;
    }

    this.Draw=function(moveonPoint, mouseStatus)
    {
        this.AryShowButton=[];
        this.LinePoint=[];
        this.AryButton=[];
        this.ColseButtonSize=0;
        this.SettingButtonSize=0;
        this.ButtonBGWidth=0;

        this.VerticalButtonInfo.Width=0;
        this.VerticalButtonInfo.Height=0;

        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint || drawPoint.length!=1) return;
        if (!this.Frame) return;
        if (this.Value.length!=1) return;
        var bVisibleRange=this.IsYValueInFrame(this.Value[0].YValue);   //是否在可视范围
        if (!this.AlwaysShowLab && !bVisibleRange) return;

        var isHScreen=this.Frame.IsHScreen;
        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        if (isHScreen)
        {
            left=this.Frame.ChartBorder.GetTop();
            right=this.Frame.ChartBorder.GetBottom();
        }

        this.ClipFrame();

        //画线段
        if (bVisibleRange)
        {
            this.Canvas.strokeStyle=this.LineColor;
            this.SetLineWidth();
            this.Canvas.beginPath();
            if (isHScreen)
            {
                this.Canvas.moveTo(drawPoint[0].X,left);
                this.Canvas.lineTo(drawPoint[0].X,right);
            }
            else
            {
                this.Canvas.moveTo(left,ToFixedPoint(drawPoint[0].Y));
                this.Canvas.lineTo(right,ToFixedPoint(drawPoint[0].Y));
            }
            this.Canvas.stroke();
            this.RestoreLineWidth();
        }

        //画水平线段
        var line={Start:new Point(), End:new Point()};
        if (isHScreen)
        {
            line.Start.X=drawPoint[0].X;
            line.Start.Y=left;
            line.End.X=drawPoint[0].X;
            line.End.Y=right;
        }
        else
        {
            line.Start.X=left;
            line.Start.Y=drawPoint[0].Y;
            line.End.X=right;
            line.End.Y=drawPoint[0].Y;
        }
        this.LinePoint.push(line);

        if (bVisibleRange)
        {
            var yValue=this.Frame.GetYData(drawPoint[0].Y, false);
            var strPrice=yValue.toFixed(this.Precision);
            if (this.ShowPriceTextConfig.IsShow[0])
            {
                this.DrawPriceText(strPrice, line.Start, line.End, 0);
            }
    
            if (this.ShowPriceTextConfig.IsShow[1])
            {
                this.DrawPriceText(strPrice, line.Start, line.End, 1);
            }
        }
        
        var labInfo;
        if (this.GetLabelCallback) labInfo=this.GetLabelCallback(this);

        this.AryShowButton=this.GetShowButton();    //获取按钮

        //框架内的描述信息
        if (labInfo && bVisibleRange)
            this.DrawLab(labInfo, drawPoint[0].Y);

        //画中心点
        if (bVisibleRange)
        {
            var xCenter=left+(right-left)/2;
            var point={ X:xCenter, Y: drawPoint[0].Y };
            this.DrawPoint([point]);
        }

        this.Canvas.restore();
       
        //外部右侧显示价格
        if (this.ShowPriceTextConfig.IsShow[2])
        {
            var rtDraw={ };
            this.CalculateButtonSize();
            this.DrawValueText(drawPoint[0].Y, rtDraw, labInfo); 
            if (labInfo) this.DrawRightLab(labInfo, rtDraw);
            if (labInfo && bVisibleRange) this.DrawCustomHLine(labInfo, drawPoint[0].Y);
        }

        //鼠标是否在按钮上
        if (moveonPoint && mouseStatus)
        {
            for(var i=0;i<this.AryButton.length;++i)
            {
                var item=this.AryButton[i];
                var rtButton=item.Rect;
                if (moveonPoint.X>=rtButton.Left && moveonPoint.X<rtButton.Right && moveonPoint.Y>=rtButton.Top && moveonPoint.Y<=rtButton.Bottom)
                {
                    mouseStatus.MouseOnToolbar={ Rect:rtButton, Item:item, Frame:this.Frame, Point:{X:moveonPoint.X, Y:moveonPoint.Y} };
                    break;
                }
            }
        }
    }

    this.CalculateLabSize=function(labInfo)
    {
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="top";
        this.Canvas.font=this.TextFont;
        var lineHeight=this.Canvas.measureText("擎").width+2;
        var maxNameWidth=0, maxTextWidth=0;
        var lineCount=0;
        var lineSpace=0;
        if (IFrameSplitOperator.IsNumber(labInfo.LineSpace)) lineSpace=labInfo.LineSpace;

        var maxNameWidth=0, maxTextWidth=0;
        var lineCount=0;
        var maxWidth=0;
        for(var i=0;i<labInfo.AryText.length;++i)
        {
            var item=labInfo.AryText[i];
            item.NameWidth=0;
            item.TextWidth=0;
            if (item.Name) item.NameWidth=this.Canvas.measureText(item.Name).width+2;
            if (item.Text) item.TextWidth=this.Canvas.measureText(item.Text).width+2;

            if (maxNameWidth<item.NameWidth) maxNameWidth=item.NameWidth;
            if (maxTextWidth<item.TextWidth) maxTextWidth=item.TextWidth;

            var itemWidth=item.NameWidth+item.TextWidth;
            if (maxWidth<itemWidth) maxWidth=itemWidth;

            ++lineCount;
        }

        var size={ Width:maxWidth, Height: lineCount*(lineHeight+lineSpace)+lineSpace, NameWidth:maxNameWidth, TextWidth:maxTextWidth, LineHeight:lineHeight };

        return size;
    }

    this.DrawLab=function(labInfo, y)
    {
        if (!labInfo) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(labInfo.AryText)) return;
        if (labInfo.Position===2) return;

        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var labSize=this.CalculateLabSize(labInfo);
        var drawLeft=right-labSize.Width;
        var drawTop=y-labSize.Height-1;

        //背景色
        if (labInfo.BGColor)
        {
            this.Canvas.fillStyle=labInfo.BGColor;
            var rtTop=y-labSize.Height-4;
            this.Canvas.fillRect(ToFixedRect(drawLeft),ToFixedRect(rtTop),ToFixedRect(right+drawLeft),ToFixedRect(y-rtTop)); 
        }

        var yText=drawTop;
        for(var i=0;i<labInfo.AryText.length;++i)
        {
            var item=labInfo.AryText[i];
            if (item.Name)
            {
                this.Canvas.fillStyle=item.NameColor;
                this.Canvas.fillText(item.Name,drawLeft+1,yText+1);
            }
            
            if (item.Text)
            {
                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.fillText(item.Text,drawLeft+labSize.NameWidth+1,yText+1);
            }

            yText+=labSize.LineHeight;
        }
    }

    this.DrawRightLab=function(labInfo, rtLeftDraw)
    {
        if (!labInfo) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(labInfo.AryText)) return;
        if (labInfo.Position!=2) return;
        var labSize=this.CalculateLabSize(labInfo);

        var drawLeft=rtLeftDraw.Right-labSize.Width;
        if (drawLeft<rtLeftDraw.Left) drawLeft=rtLeftDraw.Left;
        var drawRight=drawLeft+labSize.Width;
        var drawTop=rtLeftDraw.Bottom;
        var lineSpace=0;
        if (IFrameSplitOperator.IsNumber(labInfo.LineSpace)) lineSpace=labInfo.LineSpace;

        //背景色
        var rtLab={ Left:drawLeft, Top:drawTop, Width:labSize.Width, Height:labSize.Height }
        rtLab.Right=rtLab.Left+rtLab.Width;
        rtLab.Bottom=rtLab.Top+rtLab.Height;
        if (labInfo.BGColor)
        {
            this.Canvas.fillStyle=labInfo.BGColor;
            this.Canvas.fillRect(ToFixedRect(rtLab.Left),ToFixedRect(rtLab.Top),ToFixedRect(rtLab.Width),ToFixedRect(rtLab.Height));  
        }

        var yText=drawTop+1+lineSpace;
        this.Canvas.textBaseline="top";
        for(var i=0;i<labInfo.AryText.length;++i)
        {
            var item=labInfo.AryText[i];
            if (item.Name)
            {
                this.Canvas.textAlign="left";
                this.Canvas.fillStyle=item.NameColor;
                this.Canvas.fillText(item.Name,drawLeft+1,yText+1);
            }
            
            if (item.Text)
            {
                this.Canvas.textAlign="right";
                this.Canvas.fillStyle=item.TextColor;
                this.Canvas.fillText(item.Text,drawRight-1,yText+1);
            }

            yText+=labSize.LineHeight+lineSpace;
        }

        this.DrawVerticalButton(rtLab);
    }

    this.DrawCustomHLine=function(labInfo, yLine)
    {
        if (!labInfo) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(labInfo.AryLine)) return;

        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var pixelRatio=GetDevicePixelRatio();

        var yMax=yLine, yMin=yLine;
        for(var i=0;i<labInfo.AryLine.length;++i)
        {
            var item=labInfo.AryLine[i];
            if (!IFrameSplitOperator.IsNumber(item.Value)) continue;
            if (item.Width<0) continue;

            var y=this.Frame.GetYFromData(item.Value);
            var yFixed=ToFixedPoint(y);
            var xRight=right;
            if (IFrameSplitOperator.IsPlusNumber(item.Width)) 
            {
                if (item.Width<1)  xRight=left+(item.Width*(right-left));   //0.3 百分比
                else xRight=left+item.Width*pixelRatio;     //>1 实际数值就是长度
            }

            if (item.Color) this.Canvas.strokeStyle=item.Color;
            else this.Canvas.strokeStyle=this.LineColor;
            
            this.Canvas.beginPath();
            this.Canvas.moveTo(left,yFixed);
            this.Canvas.lineTo(xRight,yFixed);
            this.Canvas.stroke();

            if (yMax<yFixed) yMax=yFixed;
            if (yMin>yFixed) yMin=yFixed;
        }

        if (yMax!=yMin && labInfo.VLine)
        {
            var item=labInfo.VLine;
            var x=left+20*pixelRatio;
            if (IFrameSplitOperator.IsNumber(item.XOffset)) x=left+item.XOffset*pixelRatio;
            x=ToFixedPoint(x);
            if (item.Color) this.Canvas.strokeStyle=item.Color;
            else this.Canvas.strokeStyle=this.LineColor;

            this.Canvas.beginPath();
            this.Canvas.moveTo(x,yMax);
            this.Canvas.lineTo(x,yMin);
            this.Canvas.stroke();
        }
    }

    this.DrawValueText=function(y, rtDraw, labInfo)
    {
        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var top=this.Frame.ChartBorder.GetTopEx();
        var bottom=this.Frame.ChartBorder.GetBottomEx();
        var pixelTatio = GetDevicePixelRatio();

        if (labInfo && IFrameSplitOperator.IsNumber(labInfo.TopOffset)) top-=labInfo.TopOffset;
        if (labInfo && IFrameSplitOperator.IsNumber(labInfo.BottomOffset)) bottom+=labInfo.BottomOffset;

        var yValue=this.Frame.GetYData(y,false);
        var strValue=yValue.toFixed(this.Precision);
        if (labInfo &&labInfo.PriceSuffixText) strValue+=labInfo.PriceSuffixText;

        var bVisibleRange=true;
        if (y<top) 
        {
            y=top;
            bVisibleRange=false;
        }
        else if (y>bottom) 
        {
            y=bottom;
            bVisibleRange=false;
        }

        if (this.RightSpaceWidth>0)
        {
            if (!bVisibleRange) this.Canvas.setLineDash([2*pixelTatio,3*pixelTatio]);   //虚线
            this.Canvas.strokeStyle=this.LineColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(right,ToFixedPoint(y));
            this.Canvas.lineTo(right+this.RightSpaceWidth,ToFixedPoint(y));
            this.Canvas.stroke();
            if (!bVisibleRange) this.Canvas.setLineDash([]);
        }

        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.font=this.Font;
        var textWidth=this.Canvas.measureText(strValue).width;
        var lineHeight=this.GetFontHeight();
        var rtBG={ Left:right+this.RightSpaceWidth, Top:y- lineHeight/2, Width:textWidth+4, Height:lineHeight };
        //rtBG.Right=rtBG.Left+rtBG.Width;
        rtBG.Bottom=rtBG.Top+rtBG.Height;
        rtBG.Width+=(this.TextMargin.Left+this.TextMargin.Right);
        rtBG.Right=rtBG.Left+rtBG.Width;
        var xText=rtBG.Left+this.TextMargin.Left+2;

        if (this.ButtonPosition==1)
        {
            this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top), ToFixedRect(rtBG.Width+this.ButtonBGWidth),ToFixedRect(rtBG.Height));
        }
        else
        {
            this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top), ToFixedRect(rtBG.Width),ToFixedRect(rtBG.Height));
        }

        this.Canvas.fillStyle=this.ValueTextColor
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.fillText(strValue,xText,y);

        rtDraw.Left=rtBG.Left;
        rtDraw.Top=rtBG.Top;
        rtDraw.Bottom=rtBG.Bottom;
        rtDraw.Right=rtBG.Right;

        this.DrawButton(rtBG.Top, rtBG.Right, lineHeight, rtDraw);
    }

    this.DrawPriceText=function(text, ptStart, ptEnd, position)
    {
        if (position!=1 && position!=0) return;

        var font=this.ShowPriceTextConfig.Font[position];
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.font=font;
        var textWidth=this.Canvas.measureText(text).width;
        var lineHeight=this.GetFontHeight();

        var rtBG=null;
        if (position==1)
        {
            var rtBG={ Left:ptStart.X, Top:ptStart.Y-lineHeight/2, Width:textWidth+4, Height:lineHeight };
            rtBG.Right=rtBG.Left+rtBG.Width;
            rtBG.Bottom=rtBG.Top+rtBG.Height;

        }
        else if (position==0)
        {
            var rtBG={ Right:ptEnd.X, Top:ptEnd.Y-lineHeight/2, Width:textWidth+4, Height:lineHeight };
            rtBG.Left=rtBG.Right-rtBG.Width;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
        }

        this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top), ToFixedRect(rtBG.Width+this.ButtonBGWidth),ToFixedRect(rtBG.Height));

        this.Canvas.fillStyle=this.ValueTextColor
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.fillText(text,rtBG.Left+2,ptStart.Y);
        
    }

    this.CalculateButtonSize=function()
    {
        var pixelRatio=GetDevicePixelRatio();

        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryShowButton)) return;

        var totalWidth=0;
        for(var i=0;i<this.AryShowButton.length;++i)
        {
            var item=this.AryShowButton[i];
            var icon=item.Data;
            var font=`${icon.Size*pixelRatio}px ${icon.Family}`;
            this.Canvas.font=font;
            item.Width=this.Canvas.measureText(icon.Text).width+2;
            item.Height=item.Width;

            if (icon.Margin)
            {
                var margin=icon.Margin;
                if (IFrameSplitOperator.IsNumber(margin.Left)) item.Width+=margin.Left;
                if (IFrameSplitOperator.IsNumber(margin.Right)) item.Width+=margin.Right;

                if (IFrameSplitOperator.IsNumber(margin.Top)) item.Height+=margin.Top;
                if (IFrameSplitOperator.IsNumber(margin.Bottom)) item.Height+=margin.Bottom;
            }

            if (this.VerticalButtonInfo.Width<item.Width) this.VerticalButtonInfo.Width=item.Width;
            this.VerticalButtonInfo.Height+=item.Height;

            totalWidth+=item.Width;
        }

        this.ButtonBGWidth=totalWidth;
    }

    //垂直排列按钮
    this.DrawVerticalButton=function(rtLab)
    {
        if (this.ButtonPosition!=3) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryShowButton)) return;
        if (this.VerticalButtonInfo.Height<=0) return;

        var rtBG={ Left:rtLab.Right, Top:rtLab.Top, Width:this.VerticalButtonInfo.Width, Height:this.VerticalButtonInfo.Height };
        rtBG.Right=rtBG.Left+rtBG.Width;
        rtBG.Bottom=rtBG.Top+rtBG.Height;
        this.Canvas.fillStyle=this.ButtonBGColor;
        this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top), ToFixedRect(rtBG.Width),ToFixedRect(rtBG.Height));

        var pixelRatio=GetDevicePixelRatio();
        var yTop=rtLab.Top;
        for(var i=0;i<this.AryShowButton.length;++i)
        {
            var item=this.AryShowButton[i];
            var icon=item.Data;

            var rtButton={Left:rtBG.Left, Top:yTop, Width:this.VerticalButtonInfo.Width, Height:item.Height };
            rtButton.Right=rtButton.Left+rtButton.Width;
            rtButton.Bottom=rtButton.Top+rtButton.Height;
            var yCenter=rtButton.Top+rtButton.Height/2;
            var xCenter=rtButton.Left+rtButton.Width/2;

            var font=`${icon.Size*pixelRatio}px ${icon.Family}`;
            this.Canvas.font=font;
            this.Canvas.textAlign="center";
            this.Canvas.textBaseline="middle";
            this.Canvas.fillStyle=icon.Color;
            this.Canvas.fillText(icon.Text,xCenter,yCenter);

            this.AryButton.push({Rect:rtButton,ID:icon.ID, TooltipText:icon.TooltipText, Data:icon.Data });

            yTop=rtButton.Bottom;
        }
    }

    this.DrawButton=function(drawTop, drawLeft, drawHeight, rtDraw)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryShowButton)) return;
        if (this.ButtonPosition==3) return; //垂直按钮在DrawVerticalButton()调用
 
        if (this.ButtonPosition==1) 
        {
            drawTop-=drawHeight;
            var chartWidth=this.Frame.ChartBorder.GetChartWidth();
            var chartLeft=this.Frame.ChartBorder.GetRight()+this.RightSpaceWidth;
            if (drawLeft+this.ButtonBGWidth>chartWidth) //右边不够了 往左移动
            {
                drawLeft=chartWidth-this.ButtonBGWidth;
            }

            if (rtDraw.Left>drawLeft) drawLeft=rtDraw.Left;

        }
        else if (this.ButtonPosition==2)
        {
            drawTop-=drawHeight;
            drawLeft=rtDraw.Left;
        }

        this.Canvas.fillStyle=this.LineColor;
        var left=drawLeft;
        var rtBG={ Left:drawLeft, Top:drawTop, Width:this.ButtonBGWidth, Height:drawHeight };
        rtBG.Right=rtBG.Left+rtBG.Width;
        rtBG.Bottom=rtBG.Top+rtBG.Height;
        this.Canvas.fillStyle=this.ButtonBGColor;
        this.Canvas.fillRect(ToFixedRect(rtBG.Left),ToFixedRect(rtBG.Top), ToFixedRect(rtBG.Width),ToFixedRect(rtBG.Height));

        var pixelRatio=GetDevicePixelRatio();
        for(var i=0;i<this.AryShowButton.length;++i)
        {
            var item=this.AryShowButton[i];
            var icon=item.Data;

            var rtButton={Left:left, Top:drawTop, Width:item.Width, Height:drawHeight };
            rtButton.Right=rtButton.Left+rtButton.Width;
            rtButton.Bottom=rtButton.Top+rtButton.Height;
            var yCenter=rtButton.Top+rtButton.Height/2;
            var xCenter=rtButton.Left+rtButton.Width/2;

            var font=`${icon.Size*pixelRatio}px ${icon.Family}`;
            this.Canvas.font=font;
            this.Canvas.textAlign="center";
            this.Canvas.textBaseline="middle";
            this.Canvas.fillStyle=icon.Color;
            this.Canvas.fillText(icon.Text,xCenter,yCenter);

            this.AryButton.push({Rect:rtButton,ID:icon.ID, TooltipText:icon.TooltipText, Data:icon.Data });

            left=rtButton.Right;
        }
    }

    this.PtInButtons=function(x,y)
    {
        for(var i=0;i<this.AryButton.length;++i)
        {
            var item=this.AryButton[i];
            if (!item.Rect) continue;

            var rect=item.Rect;
            this.Canvas.beginPath();
            this.Canvas.rect(rect.Left,rect.Top,rect.Width,rect.Height);
            if (this.Canvas.isPointInPath(x,y))
            {
                return { ID:item.ID, Rect:rect, Data:item.Data };
            }
        }

        return null;
    }
}

//趋势线
function ChartDrawPictureTrendLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureTrendLine';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:false, IsCheckY:false});
        if (!drawPoint || drawPoint.length!=2) return;

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];
        var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);

        this.ClipFrame();

        this.Canvas.strokeStyle=this.LineColor;
        this.SetLineWidth();
        this.Canvas.beginPath();
        this.Canvas.moveTo(extendLine.Start.X,extendLine.Start.Y);
        this.Canvas.lineTo(extendLine.End.X,extendLine.End.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);

        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }
}


//画图工具-矩形
function ChartDrawPictureRect()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureRect';
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.Draw=function()
    {
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint || drawPoint.length!=2) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();

        this.Canvas.strokeStyle=this.LineColor;
        this.SetLineWidth();
        this.Canvas.beginPath();
        this.Canvas.rect(drawPoint[0].X,drawPoint[0].Y,drawPoint[1].X-drawPoint[0].X,drawPoint[1].Y-drawPoint[0].Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();
        
        //透明背景
        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.fillRect(drawPoint[0].X,drawPoint[0].Y,drawPoint[1].X-drawPoint[0].X,drawPoint[1].Y-drawPoint[0].Y);
        this.Canvas.restore();

        //画点
        this.DrawPoint(drawPoint);
    }

    //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
    this.IsPointIn=function(x,y,option)
    {
        if (this.IsFrameMinSize()) return -1;
        if (!this.Frame || this.Status!=10) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;

        var nIndex=this.IsPointInXYValue(x,y,option);
        if (nIndex>=0) return nIndex;

        var aryPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!aryPoint || aryPoint.length!=2) return -1;

        //是否在矩形边框上
        var linePoint=[ {X:aryPoint[0].X,Y:aryPoint[0].Y},{X:aryPoint[1].X,Y:aryPoint[0].Y}];
        if (this.IsPointInLine(linePoint,x,y,option))
            return 100;

        linePoint=[ {X:aryPoint[1].X,Y:aryPoint[0].Y},{X:aryPoint[1].X,Y:aryPoint[1].Y}];
        if (this.IsPointInLine2(linePoint,x,y,option))
            return 100;

        linePoint=[ {X:aryPoint[1].X,Y:aryPoint[1].Y},{X:aryPoint[0].X,Y:aryPoint[1].Y}];
        if (this.IsPointInLine(linePoint,x,y,option))
            return 100;

        linePoint=[ {X:aryPoint[0].X,Y:aryPoint[1].Y},{X:aryPoint[0].X,Y:aryPoint[0].Y}];
        if (this.IsPointInLine2(linePoint,x,y,option))
            return 100;

        return -1;
    }

    //点是否在线段上 水平线段
    this.IsPointInLine=function(aryPoint,x,y,option)
    {
        var radius=5;
        if (option && IFrameSplitOperator.IsNumber(option.Zoom)) radius+=option.Zoom;
        else if (this.Option && IFrameSplitOperator.IsNumber(this.Option.Zoom)) radius+=this.Option.Zoom;
        var pixel=GetDevicePixelRatio();
        radius*=pixel;

        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X,aryPoint[0].Y+radius);
        this.Canvas.lineTo(aryPoint[0].X,aryPoint[0].Y-radius);
        this.Canvas.lineTo(aryPoint[1].X,aryPoint[1].Y-radius);
        this.Canvas.lineTo(aryPoint[1].X,aryPoint[1].Y+radius);
        this.Canvas.closePath();
        if (this.Canvas.isPointInPath(x,y))
            return true;
    }

    //垂直线段
    this.IsPointInLine2=function(aryPoint,x,y,option)
    {
        var radius=5;
        if (option && IFrameSplitOperator.IsNumber(option.Zoom)) radius+=option.Zoom;
        else if (this.Option && IFrameSplitOperator.IsNumber(this.Option.Zoom)) radius+=this.Option.Zoom;
        var pixel=GetDevicePixelRatio();
        radius*=pixel;

        this.Canvas.beginPath();
        this.Canvas.moveTo(aryPoint[0].X-radius,aryPoint[0].Y);
        this.Canvas.lineTo(aryPoint[0].X+radius,aryPoint[0].Y);
        this.Canvas.lineTo(aryPoint[1].X+radius,aryPoint[1].Y);
        this.Canvas.lineTo(aryPoint[1].X-radius,aryPoint[1].Y);
        this.Canvas.closePath();
        if (this.Canvas.isPointInPath(x,y))
            return true;
    }
}


//画图工具-弧形
function ChartDrawPictureArc()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureArc';

    this.Draw=function()
    {
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint || drawPoint.length!=2) return;

        this.ClipFrame();

        //this.Canvas.beginPath();
        //this.Canvas.rect(drawPoint[0].X,drawPoint[0].Y,drawPoint[1].X-drawPoint[0].X,drawPoint[1].Y-drawPoint[0].Y);
        this.SetLineWidth();
        if (drawPoint[0].X < drawPoint[1].X && drawPoint[0].Y > drawPoint[1].Y) // 第一象限
        {
            var a = drawPoint[1].X - drawPoint[0].X;
            var b = drawPoint[0].Y - drawPoint[1].Y;
            var step = (a > b) ? 1/a : 1 / b;
            var xcenter = drawPoint[0].X;
            var ycenter = drawPoint[1].Y;
            this.Canvas.beginPath();
            this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
            for (var i = 1.5*Math.PI; i < 2*Math.PI; i+=step)
            {
                this.Canvas.lineTo(xcenter+a*Math.cos(i), ycenter+b*Math.sin(i)*-1);
            }
            for (var j = 0; j <= 0.5*Math.PI; j += step)
            {
                this.Canvas.lineTo(xcenter+a*Math.cos(j), ycenter+b*Math.sin(j)*-1);
            }
        }
        else if (drawPoint[0].X > drawPoint[1].X && drawPoint[0].Y > drawPoint[1].Y) // 第二象限
        {
            var a = drawPoint[0].X - drawPoint[1].X;
            var b = drawPoint[0].Y - drawPoint[1].Y;
            var step = (a > b) ? 1/a:1/b;
            var xcenter = drawPoint[1].X;
            var ycenter = drawPoint[0].Y;
            this.Canvas.beginPath();
            this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
            for (var i = 0; i <= Math.PI; i += step)
            {
                this.Canvas.lineTo(xcenter + a*Math.cos(i), ycenter + b*Math.sin(i)*-1);
            }
        }
        else if (drawPoint[0].X > drawPoint[1].X && drawPoint[0].Y < drawPoint[1].Y) // 第三象限
        {
            var a = drawPoint[0].X - drawPoint[1].X;
            var b = drawPoint[1].Y - drawPoint[0].Y;
            var step = (a > b) ? 1/a:1/b;
            var xcenter = drawPoint[0].X;
            var ycenter = drawPoint[1].Y;
            this.Canvas.beginPath();
            this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
            for (var i = 0.5*Math.PI; i <= 1.5*Math.PI; i += step)
            {
                this.Canvas.lineTo(xcenter + a*Math.cos(i), ycenter + b*Math.sin(i)*-1);
            }
        }
        else if (drawPoint[0].X < drawPoint[1].X && drawPoint[0].Y < drawPoint[1].Y) // 第四象限
        {
            var a = drawPoint[1].X - drawPoint[0].X;
            var b = drawPoint[1].Y - drawPoint[0].Y;
            var step = (a > b) ? 1/a : 1/b;
            var xcenter = drawPoint[1].X;
            var ycenter = drawPoint[0].Y;
            this.Canvas.beginPath();
            this.Canvas.moveTo(drawPoint[0].X, drawPoint[0].Y);
            for (var i = Math.PI; i <= 2*Math.PI; i += step)
            {
                this.Canvas.lineTo(xcenter+a*Math.cos(i), ycenter + b*Math.sin(i)*-1);
            }
        }


        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.stroke();
        this.RestoreLineWidth();
        //this.Canvas.closePath();
        this.Canvas.restore();

        //画点
        this.DrawPoint(drawPoint);
    }

    //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
    this.IsPointIn=function(x,y,option)
    {
        if (this.IsFrameMinSize()) return -1;
        if (!this.Frame || this.Status!=10) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;

        //是否在点上
        var nIndex=this.IsPointInXYValue(x,y,option);
        if (nIndex>=0) return nIndex;

        var aryPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!aryPoint || aryPoint.length!=2) return -1;

        //是否在弧线上
        var ArcPoint=[ {X:aryPoint[0].X,Y:aryPoint[0].Y},{X:aryPoint[1].X,Y:aryPoint[1].Y}];
        if (this.IsPointInArc(ArcPoint, x, y))
            return 100;

        return -1;
    }
    this.IsPointInArc=function(aryPoint,x,y)
    {
        if (aryPoint.length != 2)
         return false;
        if (aryPoint[0].X < aryPoint[1].X && aryPoint[0].Y > aryPoint[1].Y) // 第一象限
        {
             var a = aryPoint[1].X - aryPoint[0].X;
             var b = aryPoint[0].Y - aryPoint[1].Y;
             var step = (a > b) ? 1/a : 1 / b;
             var ainer = a * 0.8;
             var biner = b * 0.8;
             var stepiner = (ainer > biner) ? 1/ainer : 1/biner;
             var xcenter = aryPoint[0].X;
             var ycenter = aryPoint[1].Y;
             this.Canvas.beginPath();
             this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
             for (var i = 1.5*Math.PI; i < 2*Math.PI; i+=step)
             {
                 this.Canvas.lineTo(xcenter+a*Math.cos(i), ycenter+b*Math.sin(i)*-1);
             }
             for (var j = 0; j <= 0.5*Math.PI; j += step)
             {
                 this.Canvas.lineTo(xcenter+a*Math.cos(j), ycenter+b*Math.sin(j)*-1);
             }
             for (var k = 0.5*Math.PI; k >= 0; k -= stepiner)
             {
                 this.Canvas.lineTo(xcenter+ainer*Math.cos(k), ycenter + biner*Math.sin(j)*-1);
             }
             for (var l = 2*Math.PI; l >= 1.5*Math.PI; l -= stepiner)
             {
                 this.Canvas.lineTo(xcenter + ainer*Math.cos(l), ycenter + biner*Math.sin(l)*-1);
             }
             this.Canvas.closePath();
        }
         else if (aryPoint[0].X > aryPoint[1].X && aryPoint[0].Y > aryPoint[1].Y) // 第二象限
         {
             var a = aryPoint[0].X - aryPoint[1].X;
             var b = aryPoint[0].Y - aryPoint[1].Y;
             var step = (a > b) ? 1/a:1/b;
             var ainer = a * 0.8;
             var biner = b * 0.8;
             var stepiner = (ainer > biner) ? 1 / ainer : 1 / biner;
             var xcenter = aryPoint[1].X;
             var ycenter = aryPoint[0].Y;
             this.Canvas.beginPath();
             this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
             for (var i = 0; i <= Math.PI; i += step)
             {
                 this.Canvas.lineTo(xcenter + a*Math.cos(i), ycenter + b*Math.sin(i)*-1);
             }
             for (var j = Math.PI; j >= 0; j -= stepiner)
             {
                 this.Canvas.lineTo(xcenter + ainer * Math.cos(j), ycenter + biner*Math.sin(j)*-1);
             }
             this.Canvas.closePath();
         }
         else if (aryPoint[0].X > aryPoint[1].X && aryPoint[0].Y < aryPoint[1].Y) // 第三象限
         {
             var a = aryPoint[0].X - aryPoint[1].X;
             var b = aryPoint[1].Y - aryPoint[0].Y;
             var step = (a > b) ? 1/a:1/b;
             var ainer = a * 0.8;
             var biner = b * 0.8;
             var stepiner = (ainer > biner) ? 1/ainer : 1/biner;
             var xcenter = aryPoint[0].X;
             var ycenter = aryPoint[1].Y;
             this.Canvas.beginPath();
             this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
             for (var i = 0.5*Math.PI; i <= 1.5*Math.PI; i += step)
             {
                 this.Canvas.lineTo(xcenter + a*Math.cos(i), ycenter + b*Math.sin(i)*-1);
             }
             for (var j = 1.5*Math.PI; j >= 0.5*Math.PI; j -= stepiner)
             {
                 this.Canvas.lineTo(xcenter + ainer * Math.cos(j), ycenter + biner*Math.sin(j)*-1);
             }
             this.Canvas.closePath();
         }
         else if (aryPoint[0].X < aryPoint[1].X && aryPoint[0].Y < aryPoint[1].Y) // 第四象限
         {
             var a = aryPoint[1].X - aryPoint[0].X;
             var b = aryPoint[1].Y - aryPoint[0].Y;
             var step = (a > b) ? 1/a : 1/b;
             var ainer = a * 0.8;
             var biner = b * 0.8;
             var stepiner = (ainer > biner) ? 1/ainer : 1/biner;
             var xcenter = aryPoint[1].X;
             var ycenter = aryPoint[0].Y;
             this.Canvas.beginPath();
             this.Canvas.moveTo(aryPoint[0].X, aryPoint[0].Y);
             for (var i = Math.PI; i <= 2*Math.PI; i += step)
             {
                 this.Canvas.lineTo(xcenter+a*Math.cos(i), ycenter + b*Math.sin(i)*-1);
             }
             for (var j = 2*Math.PI; j >= Math.PI; j -= stepiner)
             {
                 this.Canvas.lineTo(xcenter + ainer*Math.cos(j), ycenter + biner*Math.sin(j)*-1);
             }
             this.Canvas.closePath();
         }
         if (this.Canvas.isPointInPath(x,y))
            return true;
         else
            return false;

    }

}

//M头W底 支持横屏
function ChartDrawPictureWaveMW()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureWaveMW';
    this.PointCount=5;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.IsHScreen=false;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (!this.Frame) return;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        this.IsHScreen=this.Frame.IsHScreen;
        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;
        
        //var points=drawPoint.slice(0);
        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();
        
        this.CalculateLines(drawPoint);
        this.SetLineWidth();
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }
        this.RestoreLineWidth();
       
        this.DrawPoint(drawPoint); //画点
        this.Canvas.restore();
    }

    this.CalculateLines=function(points)
    {
        if (!this.Frame) return;
        if (points.length<2) return;

        if (this.Status==2)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);
    
            var xMove=points[1].X-points[0].X;
            var yMove=points[1].Y-points[0].Y;
            line={Start:new Point(), End:new Point()};
            if (this.IsHScreen)
            {   
                line.Start.Y=points[1].Y;
                line.Start.X=points[1].X;
                line.End.Y=points[1].Y+yMove;
                line.End.X=points[0].X;
            }
            else
            {
                line.Start.Y=points[1].Y;
                line.Start.X=points[1].X;
                line.End.Y=points[0].Y;
                line.End.X=points[1].X+xMove;
            }
            this.LinePoint.push(line);

            var ptStart=line.End;
            var newPt=new Point();
            newPt.X=ptStart.X;
            newPt.Y=ptStart.Y;
            this.Point[2]=newPt;
            line={Start:new Point(), End:new Point()};
            if (this.IsHScreen)
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=ptStart.Y+yMove;
                line.End.X=points[1].X;
            }
            else
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=points[1].Y;
                line.End.X=ptStart.X+xMove;
            }
            this.LinePoint.push(line);

            var ptStart=line.End;
            var newPt=new Point();
            newPt.X=ptStart.X;
            newPt.Y=ptStart.Y;
            this.Point[3]=newPt;
            line={Start:new Point(), End:new Point()};
            if (this.IsHScreen)
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=ptStart.Y+yMove;
                line.End.X=points[0].X;
            }
            else
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=points[0].Y;
                line.End.X=ptStart.X+xMove;
            }
            this.LinePoint.push(line);

            var ptStart=line.End;
            var newPt=new Point();
            newPt.X=ptStart.X;
            newPt.Y=ptStart.Y;
            this.Point[4]=newPt;

            this.PointCount=this.Point.length;
        }
        else if (points.length==5)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);
    
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[1].Y;
            line.Start.X=points[1].X;
            line.End.Y=points[2].Y;
            line.End.X=points[2].X;
            this.LinePoint.push(line);

            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[2].Y;
            line.Start.X=points[2].X;
            line.End.Y=points[3].Y;
            line.End.X=points[3].X;
            this.LinePoint.push(line);

            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[3].Y;
            line.Start.X=points[3].X;
            line.End.Y=points[4].Y;
            line.End.X=points[4].X;
            this.LinePoint.push(line);
        }
    }
}

//头肩 头肩顶(Head and shoulders top)以及头肩底(Head and shoulders bottom)两种形态
//支持横屏
function ChartDrawHeadShouldersBT()
{
    this.newMethod=ChartDrawPictureWaveMW;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawHeadShouldersBT';

    this.CalculateLines_Backup=this.CalculateLines;
    this.CalculateLines=function(points)
    {
        if (!this.Frame) return;
        if (points.length<2) return;

        if (this.Status==2)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);
    
            var xMove=points[1].X-points[0].X;
            var yMove=points[1].Y-points[0].Y;
            line={Start:new Point(), End:new Point()};
            if (this.IsHScreen)
            {
                line.Start.Y=points[1].Y;
                line.Start.X=points[1].X;

                line.End.Y=points[1].Y+yMove;
                line.End.X=points[0].X-xMove;
            }
            else
            {
                line.Start.Y=points[1].Y;
                line.Start.X=points[1].X;
                line.End.Y=points[0].Y-yMove;
                line.End.X=points[1].X+xMove;
            }
            this.LinePoint.push(line);

            var ptStart=line.End;
            var newPt=new Point();
            newPt.X=ptStart.X;
            newPt.Y=ptStart.Y;
            this.Point[2]=newPt;
            line={Start:new Point(), End:new Point()};
            if (this.IsHScreen)
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=ptStart.Y+yMove;
                line.End.X=points[1].X; 
            }
            else
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=points[1].Y;
                line.End.X=ptStart.X+xMove;
            }
            this.LinePoint.push(line);

            var ptStart=line.End;
            var newPt=new Point();
            newPt.X=ptStart.X;
            newPt.Y=ptStart.Y;
            this.Point[3]=newPt;
            line={Start:new Point(), End:new Point()};
            if (this.IsHScreen)
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=ptStart.Y+yMove;
                line.End.X=points[0].X;
            }
            else
            {
                line.Start.Y=ptStart.Y;
                line.Start.X=ptStart.X;
                line.End.Y=points[0].Y;
                line.End.X=ptStart.X+xMove;
            }
            this.LinePoint.push(line);

            var ptStart=line.End;
            var newPt=new Point();
            newPt.X=ptStart.X;
            newPt.Y=ptStart.Y;
            this.Point[4]=newPt;

            this.PointCount=this.Point.length;
        }
        else
        {
            return this.CalculateLines_Backup(points);
        }

    }
}

//平行线
function ChartDrawPictureParallelLines()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureParallelLines';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointCount=3;
    this.LastPoint;

    //中心线
    this.CenterLine={ LineDash:[2*GetDevicePixelRatio(),3*GetDevicePixelRatio()], Line:null, IsShow:false };

    this.Super_SetOption=this.SetOption;    //父类函数
    this.Super_ExportStorageData=this.ExportStorageData;

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.CenterLine)
            {
                var item=option.CenterLine;
                if (IFrameSplitOperator.IsNonEmptyArray(item.LineDash)) this.CenterLine.LineDash=item.LineDash.slice(0);
                if (IFrameSplitOperator.IsBool(item.IsShow)) this.CenterLine.IsShow=item.IsShow;
            }
        }
    }

    this.ExportStorageData=function()
    {
        var storageData;
        if (this.Super_ExportStorageData) 
        {
            storageData=this.Super_ExportStorageData();
            if (this.CenterLine) 
            {
                storageData.CenterLine={ IsShow:this.CenterLine.IsShow, LineDash:this.CenterLine.LineDash.slice(0) };
            }
        }

        return storageData;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        this.CenterLine.Line=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:false, IsCheckY:false}); //不检测x,y
        if (!drawPoint) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        var points=drawPoint.slice(0);
        this.CalculateLines(points);

        this.ClipFrame();

        this.DrawArea();

        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        if (this.CenterLine.IsShow && this.CenterLine.Line)
        {
            var item=this.CenterLine.Line;
            this.Canvas.setLineDash(this.CenterLine.LineDash);
            this.DrawLine(item.Start,item.End);
            this.Canvas.setLineDash([]);
        }

        this.DrawPoint(points);  //画点
        this.Canvas.restore(); 
    }

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    this.DrawArea=function()
    {
        if (this.LinePoint.length!=2) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(this.LinePoint[0].Start.X,this.LinePoint[0].Start.Y);
        this.Canvas.lineTo(this.LinePoint[0].End.X,this.LinePoint[0].End.Y);
        this.Canvas.lineTo(this.LinePoint[1].End.X,this.LinePoint[1].End.Y);
        this.Canvas.lineTo(this.LinePoint[1].Start.X,this.LinePoint[1].Start.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length==2)
        {
            var linePoint=this.CalculateExtendLinePoint(points[0],points[1]);
            this.LinePoint.push(linePoint);
        }
        else if (points.length==3)
        {
            var linePoint=this.CalculateExtendLinePoint(points[0],points[1]);
            this.LinePoint.push(linePoint);

            //计算平行线
            var xMove=points[2].X-points[1].X;
            var yMove=points[2].Y-points[1].Y;

            var ptStart=new Point();
            var ptEnd=new Point();
            ptStart.X=points[0].X+xMove;
            ptStart.Y=points[0].Y+yMove;
            ptEnd.X=points[1].X+xMove;
            ptEnd.Y=points[1].Y+yMove;

            linePoint=this.CalculateExtendLinePoint(ptStart,ptEnd);
            this.LinePoint.push(linePoint);

            //中心线
            var ptStart=new Point();
            var ptEnd=new Point();
            ptStart.X=points[0].X+xMove/2;
            ptStart.Y=points[0].Y+yMove/2;
            ptEnd.X=points[1].X+xMove/2;
            ptEnd.Y=points[1].Y+yMove/2;
            linePoint=this.CalculateExtendLinePoint(ptStart,ptEnd);
            this.CenterLine.Line=linePoint;
        }
    }
}


//FlatTop/Bottom 平滑顶/底
function ChartDrawFlatTop()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawFlatTop';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.PointCount=3;
    this.LastPoint;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        var points=drawPoint.slice(0);
        this.CalculateLines(points);

        this.ClipFrame();

        for(var i=0;i<this.LinePoint.length; ++i)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        this.DrawArea();
        this.DrawPoint(points);  //画点
        this.Canvas.restore(); 
    }

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    this.DrawArea=function()
    {
        if (this.LinePoint.length!=2) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(this.LinePoint[0].Start.X,this.LinePoint[0].Start.Y);
        this.Canvas.lineTo(this.LinePoint[0].End.X,this.LinePoint[0].End.Y);
        this.Canvas.lineTo(this.LinePoint[1].End.X,this.LinePoint[1].End.Y);
        this.Canvas.lineTo(this.LinePoint[1].Start.X,this.LinePoint[1].Start.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
        
    }

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var ptSecond=points[1];
            var pt=new Point();
            pt.X=ptSecond.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length==2)
        {
            this.LinePoint.push({ Start:points[0], End:points[1]});
        }
        else if (points.length==3)
        {
            this.LinePoint.push({ Start:points[0], End:points[1]});

            //计算水平线
            var ptThrid=points[2];
            ptThrid.X=points[1].X;
            var ptStart={ X:points[0].X, Y:ptThrid.Y };
            var ptEnd={ X:points[1].X, Y:ptThrid.Y };
            this.LinePoint.push({ Start:ptStart, End:ptEnd});
        }
    }
}

//Disjont Channel 不相交通道 (未完成)
function ChartDrawDisjontChannel()
{
    this.newMethod=ChartDrawFlatTop;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawDisjontChannel';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.PointCount=3;
    this.LastPoint;
}

//平行射线
function ChartDrawParallelRaysLines()
{
    this.newMethod=ChartDrawPictureParallelLines;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawParallelRaysLines';

    this.DrawArea=function()
    {
    }

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length==2)
        {
            var endPoint=this.CalculateExtendLineEndPoint([points[0],points[1]]);
            this.LinePoint.push({ Start:points[0], End:endPoint });
        }
        else if (points.length==3)
        {
            var endPoint=this.CalculateExtendLineEndPoint([points[0],points[1]]);
            this.LinePoint.push({ Start:points[0], End:endPoint });

            //计算平行线
            var xMove=points[2].X-points[1].X;
            var yMove=points[2].Y-points[1].Y;

            var ptStart=new Point();
            var ptEnd=new Point();
            ptStart.X=points[0].X+xMove;
            ptStart.Y=points[0].Y+yMove;
            ptEnd.X=points[1].X+xMove;
            ptEnd.Y=points[1].Y+yMove;
            endPoint=this.CalculateExtendLineEndPoint([ptStart,ptEnd]);
            this.LinePoint.push({ Start:points[2], End:endPoint });
        }
    }
}

//价格通道线
function ChartDrawPicturePriceChannel()
{
    this.newMethod=ChartDrawPictureParallelLines;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPicturePriceChannel';

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length==2)
        {
            var linePoint=this.CalculateExtendLinePoint(points[0],points[1]);
            this.LinePoint.push(linePoint);
        }
        else if (points.length==3)
        {
            var linePoint=this.CalculateExtendLinePoint(points[0],points[1]);
            this.LinePoint.push(linePoint);

            //计算平行线
            var xMove=points[2].X-points[1].X;
            var yMove=points[2].Y-points[1].Y;

            var ptStart=new Point();
            var ptEnd=new Point();
            ptStart.X=points[0].X+xMove;
            ptStart.Y=points[0].Y+yMove;
            ptEnd.X=points[1].X+xMove;
            ptEnd.Y=points[1].Y+yMove;
            linePoint=this.CalculateExtendLinePoint(ptStart,ptEnd);
            this.LinePoint.push(linePoint);

            var ptStart=new Point();
            var ptEnd=new Point();
            ptStart.X=points[0].X-xMove;
            ptStart.Y=points[0].Y-yMove;
            ptEnd.X=points[1].X-xMove;
            ptEnd.Y=points[1].Y-yMove;
            linePoint=this.CalculateExtendLinePoint(ptStart,ptEnd);
            this.LinePoint.push(linePoint);
        }
    }

    this.DrawArea=function()
    {
        if (this.LinePoint.length!=3) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(this.LinePoint[1].Start.X,this.LinePoint[1].Start.Y);
        this.Canvas.lineTo(this.LinePoint[1].End.X,this.LinePoint[1].End.Y);
        this.Canvas.lineTo(this.LinePoint[2].End.X,this.LinePoint[2].End.Y);
        this.Canvas.lineTo(this.LinePoint[2].Start.X,this.LinePoint[2].Start.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }
}

//平行通道
function ChartDrawPictureParallelChannel()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureParallelChannel';
    this.ChannelWidth=50;
    this.AreaColor='rgba(25,25,25,0.4)';
    this.LinePoint=[];

    //中心线
    this.CenterLine={ LineDash:[2*GetDevicePixelRatio(),3*GetDevicePixelRatio()], Line:null, IsShow:false };

    this.Super_SetOption=this.SetOption;    //父类函数

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();
        
        storageData.ChannelWidth=this.ChannelWidth;
        storageData.Value=[];
        
        //只保存2个点就可以了
        for(var i=0; i<this.Value.length && i<2; ++i)
        {
            var item=this.Value[i];
            storageData.Value.push({ XValue:item.XValue, YValue:item.YValue, DateTime:item.DateTime });
        }

        if (this.CenterLine) 
        {
            storageData.CenterLine={ IsShow:this.CenterLine.IsShow, LineDash:this.CenterLine.LineDash.slice(0) };
        }

        return storageData;
    }

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.ChannelWidth)) this.ChannelWidth=option.ChannelWidth;
            if (option.CenterLine)
            {
                var item=option.CenterLine;
                if (IFrameSplitOperator.IsNonEmptyArray(item.LineDash)) this.CenterLine.LineDash=item.LineDash.slice(0);
                if (IFrameSplitOperator.IsBool(item.IsShow)) this.CenterLine.IsShow=item.IsShow;
            }
        }
    }


    //计算需要画的点的坐标
    this.CalculateDrawPoint=function()
    {
        if (this.Status<2) return null;
        if(!this.Point.length || !this.Frame) return null;
        var data=this.Frame.Data;
        if (!data) return null;

        var drawPoint=[];
        if (this.Status==10)    //完成
        {
            for(var i=0; i<2; ++i)
            {
                var item=this.Value[i];
                var pt=new Point();
                pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset, false);
                pt.Y=this.Frame.GetYFromData(item.YValue, false);
                drawPoint.push(pt);
            }
        }
        else
        {
            for(var i=0; i<this.Point.length; ++i)
            {
                var item=this.Point[i];
                var pt=new Point();
                pt.X=item.X;
                pt.Y=item.Y;
                drawPoint.push(pt);
            }
        }

        if (drawPoint.length>=2)
        {
            var linePoint={Start:new Point(), End:new Point() };
            linePoint.Start.X=drawPoint[0].X;
            linePoint.Start.Y=drawPoint[0].Y;
            linePoint.End.X=drawPoint[1].X;
            linePoint.End.Y=drawPoint[1].Y;
            this.LinePoint.push(linePoint);

            if (drawPoint.length==3 || this.Status==10)
            {
                var x=linePoint.End.X-linePoint.Start.X;
                var y=linePoint.End.Y-linePoint.Start.Y;
                var angle=Math.atan(Math.abs(x/y));
                var yMove=this.ChannelWidth/Math.sin(angle);

                //JSConsole.Chart.Log('[ChartDrawPictureParallelChannel::CalculateDrawPoint]',xMove);
                
                linePoint={Start:new Point(), End:new Point() };
                linePoint.Start.X=drawPoint[0].X;
                linePoint.Start.Y=drawPoint[0].Y-yMove;
                linePoint.End.X=drawPoint[1].X;
                linePoint.End.Y=drawPoint[1].Y-yMove;
                this.LinePoint.push(linePoint);

                var ptCenter=new Point();
                ptCenter.X=linePoint.Start.X+(linePoint.End.X-linePoint.Start.X)/2;
                ptCenter.Y=linePoint.Start.Y+(linePoint.End.Y-linePoint.Start.Y)/2;
                drawPoint[2]=ptCenter;

                this.Point[2]=ptCenter;
                var xValue=parseInt(this.Frame.GetXData(ptCenter.X))+data.DataOffset;
                var yValue=this.Frame.GetYData(ptCenter.Y);
                this.Value[2]={XValue:xValue,YValue:yValue};
                this.PointCount=this.Point.length;  //完成以后是3个点

                linePoint={Start:new Point(), End:new Point() };
                linePoint.Start.X=drawPoint[0].X;
                linePoint.Start.Y=drawPoint[0].Y-yMove/2;
                linePoint.End.X=drawPoint[1].X;
                linePoint.End.Y=drawPoint[1].Y-yMove/2;
                this.CenterLine.Line=linePoint;
            }
        }
    
        return drawPoint;
    }

    this.DrawArea=function(pt,pt2,pt3,pt4)
    {
        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(pt.X,pt.Y);
        this.Canvas.lineTo(pt2.X,pt2.Y);
        this.Canvas.lineTo(pt3.X,pt3.Y);
        this.Canvas.lineTo(pt4.X,pt4.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();

        if (this.LinePoint.length==2)
        {
            this.DrawArea(this.LinePoint[0].Start,this.LinePoint[0].End,this.LinePoint[1].End,this.LinePoint[1].Start);
        }

        for(var i=0;i<this.LinePoint.length; ++i)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        if (this.CenterLine.IsShow && this.CenterLine.Line)
        {
            var item=this.CenterLine.Line;
            this.Canvas.setLineDash(this.CenterLine.LineDash);
            this.DrawLine(item.Start,item.End);
            this.Canvas.setLineDash([]);
        }

        this.Canvas.restore();
       
        this.DrawPoint(drawPoint); //画点
    }

    //xStep,yStep 移动的偏移量
    this.Move=function(xStep,yStep)
    {
        if (this.Status!=20) return false;
        if (!this.Frame) return false;
        var data=this.Frame.Data;
        if (!data) return false;

        if (this.MovePointIndex==100)    //整体移动
        {
            for(var i=0; i<this.Point.length; ++i)
            {
                this.Point[i].X+=xStep;
                this.Point[i].Y+=yStep;
            }
        }
        else if (this.MovePointIndex==0 || this.MovePointIndex==1)
        {
            if (this.MovePointIndex<this.Point.length)
            {
                this.Point[this.MovePointIndex].X+=xStep;
                this.Point[this.MovePointIndex].Y+=yStep;
            }
        }
        else if (this.MovePointIndex==2)    //宽度的点要计算
        {
            this.Point[this.MovePointIndex].X+=xStep;
            this.Point[this.MovePointIndex].Y+=yStep;

            var x=this.Point[1].X-this.Point[0].X;
            var y=this.Point[1].Y-this.Point[0].Y;
            var angle=Math.atan(Math.abs(x/y));
            var yMove=this.ChannelWidth/Math.sin(angle)-yStep;
            this.ChannelWidth=Math.sin(angle)*yMove;
        }
    }

    //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;

        //是否在点上
        for(var i=0;i<this.Value.length; ++i)
        {
            var item=this.Value[i];
            var pt=new Point();
            if (i<2)
            {
                pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset);
                pt.Y=this.Frame.GetYFromData(item.YValue);
            }
            else    //第3个点使用实际坐标
            {
                if (i>=this.Point.length) continue;
                pt.X=this.Point[i].X;
                pt.Y=this.Point[i].Y;
            }

            this.Canvas.beginPath();
            this.Canvas.arc(pt.X,pt.Y,5,0,360);
            if (this.Canvas.isPointInPath(x,y))  return i;
        }

        //是否在线段上
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            var ptStart=item.Start;
            var ptEnd=item.End;
            this.Canvas.beginPath();
            this.Canvas.moveTo(ptStart.X,ptStart.Y+5);
            this.Canvas.lineTo(ptStart.X,ptStart.Y-5);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y-5);
            this.Canvas.lineTo(ptEnd.X,ptEnd.Y+5);
            this.Canvas.closePath();
            if (this.Canvas.isPointInPath(x,y))
                return 100;
        }

        return -1;
    }
}

//文本
function ChartDrawPictureText()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureText';
    this.Text='文本';
    this.PointCount=1;
    this.FontOption={ Family:'微软雅黑', Size:20, Weight:null, Style:null };    //Weight(bold 粗体), Style(italic)
    //矢量图片
    //this.Text="\ue606";
    //this.FontOption={ Family:'iconfont', Size:20, Weight:null, Style:null };    //Weight(bold 粗体), Style(italic)
    this.TextRect=null;   //文字区域
    this.IsInitialized=false;   //是否初始化了
    this.SettingMenu;
    this.HQChart;

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.LineColor) this.LineColor=option.LineColor;
        if (option.Text) this.Text=option.Text;
        if (option.FontOption) this.FontOption=option.FontOption;
    }

    this.Draw=function(textFont)
    {
        this.TextRect=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint || drawPoint.length!=1) return;

        this.ClipFrame();

        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="center";
        this.Canvas.textBaseline="bottom";
        this.Canvas.font=this.GetTextFont();
        this.Canvas.fillText(this.Text,drawPoint[0].X,drawPoint[0].Y);
        var textWidth=this.Canvas.measureText(this.Text).width;

        var textHeight=this.FontOption.Size*GetDevicePixelRatio();
        this.TextRect={};
        this.TextRect.Left=drawPoint[0].X-textWidth/2;
        this.TextRect.Top=drawPoint[0].Y-textHeight;
        this.TextRect.Width=textWidth;
        this.TextRect.Height=textHeight
        //this.Canvas.strokeRect(this.TextRect.Left,this.TextRect.Top,this.TextRect.Width,this.TextRect.Height);
        this.Canvas.restore();

        if (this.IsInitialized===false) 
        {
            this.SetTextOption();
            this.IsInitialized=true;
        }
    }

    //根据设置动态生成字体
    this.GetTextFont=function()
    {
        const defaultFont=16*GetDevicePixelRatio() +"px 微软雅黑";
        if (!this.FontOption || !this.FontOption.Family || this.FontOption.Size<=0) return defaultFont;

        var font='';
        if (this.FontOption.Color) font+=this.FontOption.Color+' ';
        if (this.FontOption.Style) font+=this.FontOption.Style+' ';
        if (this.FontOption.Weight) font+=this.FontOption.Weight+' ';
        if (this.FontOption.Size>=0) font+=this.FontOption.Size*GetDevicePixelRatio()+'px ';
        font+=this.FontOption.Family;

        return font;
    }

    this.SetTextOption=function()
    {
        JSConsole.Chart.Log('[ChartDrawPictureText::SetTextOption]');
        //创建div设置窗口
        if (!this.SettingMenu) this.SettingMenu=new ChartPictureTextSettingMenu(this.Frame.ChartBorder.UIElement.parentNode);

        this.SettingMenu.ChartPicture=this;
        this.SettingMenu.HQChart=this.HQChart;
        this.SettingMenu.Position={Left:this.TextRect.Left+this.TextRect.Width,Top:this.TextRect.Top};
        this.SettingMenu.DoModal();
    }

    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;
        if (!this.TextRect) return -1;

        this.Canvas.beginPath();
        this.Canvas.rect(this.TextRect.Left,this.TextRect.Top,this.TextRect.Width,this.TextRect.Height);
        if (this.Canvas.isPointInPath(x,y)) return 100;

        return -1;
    }
}

//iconfont 图片
function ChartDrawPictureIconFont()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureIconFont';
    this.PointCount=1;
    //矢量图片
    this.Text="\ue606";
    this.FontOption={ Family:'iconfont', Size:24};    //Weight(bold 粗体), Style(italic)
    this.TextRect=null;         //文字区域
    this.SettingMenu;
    this.Angle=0;   //旋转角度


    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.LineColor) this.LineColor=option.LineColor;
        if (option.FontOption && option.FontOption.Size>0) this.FontOption.Size=option.FontOption.Size;
        if (IFrameSplitOperator.IsNumber(option.Angle)) this.Angle=option.Angle;
    }

    this.Draw=function()
    {
        this.TextRect=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint || drawPoint.length!=1) return;
        var font=this.GetTextFont();
        if (!font) return;

        this.ClipFrame();

        var isHScreen=this.Frame.IsHScreen;
        var pixel=GetDevicePixelRatio();

        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="center";
        this.Canvas.textBaseline="middle";
        this.Canvas.font=font;

        if (isHScreen)
        {
            this.Canvas.translate(drawPoint[0].X, drawPoint[0].Y);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(this.Text,0,0);
        }
        else
        {
            if (this.Angle!=0)
            {
                this.Canvas.translate(drawPoint[0].X, drawPoint[0].Y);
                this.Canvas.rotate(this.Angle*(Math.PI / 180));
                this.Canvas.fillText(this.Text,0,0);
            }
            else
            {
                this.Canvas.fillText(this.Text,drawPoint[0].X,drawPoint[0].Y);
            }
        }
        
        var textWidth=this.Canvas.measureText(this.Text).width;
        this.TextRect={};
        this.TextRect.Left=drawPoint[0].X-textWidth/2;
        this.TextRect.Top=drawPoint[0].Y-this.FontOption.Size*pixel;
        this.TextRect.Width=textWidth;
        this.TextRect.Height=this.FontOption.Size*pixel;

        //this.Canvas.strokeRect(this.TextRect.Left,this.TextRect.Top,this.TextRect.Width,this.TextRect.Height);
        this.Canvas.restore();
    }

    //根据设置动态生成字体
    this.GetTextFont=function()
    {
        if (!this.FontOption || !this.FontOption.Family || this.FontOption.Size<=0) return null;

        var font='';
        if (this.FontOption.Size>=0) font+=this.FontOption.Size*GetDevicePixelRatio()+'px ';
        font+=this.FontOption.Family;

        return font;
    }

    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;
        if (!this.TextRect) return -1;

        var offset=0;
        if (this.Option && this.Option.Zoom>=1)
        {
            offset=this.Option.Zoom*GetDevicePixelRatio();
        }

        this.Canvas.beginPath();
        this.Canvas.rect(this.TextRect.Left-offset,this.TextRect.Top-offset,this.TextRect.Width+offset*2,this.TextRect.Height+offset*2);
        if (this.Canvas.isPointInPath(x,y)) return 100;

        return -1;
    }
}

//江恩角度线（Gann Fan），亦又称作甘氏线的
function ChartDrawPictureGannFan()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureGannFan';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.LinePoint=[];
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.LineDash=[5,10];
    this.EnableDottedLine=false;    //辅助线是否使用虚线
    this.EnableArea=true;           //是否绘制面积图
    this.IsShowTitle=true;

    this.Super_SetOption=this.SetOption;    //父类函数

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.Font) this.Font=option.Font;
            if (Array.isArray(option.LineDash)) this.LineDash=option.LineDash;
            if (IFrameSplitOperator.IsBool(option.EnableDottedLine)) this.EnableDottedLine=option.EnableDottedLine;
            if (IFrameSplitOperator.IsBool(option.EnableArea)) this.EnableArea=option.EnableArea;
            if (IFrameSplitOperator.IsBool(option.IsShowTitle)) this.IsShowTitle=option.IsShowTitle;
        }
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();
        var quadrant=this.GetQuadrant(drawPoint[0],drawPoint[1]);

        this.SetLineWidth();
        if (quadrant===1 || quadrant===2 || quadrant===3 || quadrant===4)
        {
            this.CalculateLines(drawPoint[0],drawPoint[1],quadrant);
            if (this.EnableArea) this.DrawArea();

            for(var i=0; i<this.LinePoint.length; ++i)
            {
                var item=this.LinePoint[i];
                this.DrawLine(item.Start,item.End,item.IsDottedLine);
            }

            if (this.IsShowTitle)
            {
                for(var i=0; i<this.LinePoint.length; ++i)
                {
                    var item =this.LinePoint[i];
                    if (item.Text && item.PtEnd) this.DrawTitle(item.PtEnd,item.Text);
                }
            }
        }
        else
        {
            this.DrawLine(drawPoint[0],drawPoint[1],false);
        }
        this.RestoreLineWidth();

        this.Canvas.restore();
        this.DrawPoint(drawPoint); //画点
    }

    //获取在第几象限
    this.GetQuadrant=function(ptStart,ptEnd)
    {
        if (ptStart.X<ptEnd.X && ptStart.Y>ptEnd.Y) return 1;
        else if (ptStart.X>ptEnd.X && ptStart.Y>ptEnd.Y) return 2;
        else if (ptStart.X < ptEnd.X && ptStart.Y< ptEnd.Y) return 4;
        else return 3;
    }


    //isDotline 是否是虚线
    this.DrawLine=function(ptStart,ptEnd,isDottedline)
    {
        if (isDottedline) this.Canvas.setLineDash(this.LineDash);

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();

        if (isDottedline) this.Canvas.setLineDash([]);
    }

    this.DrawTitle=function(pt,text)
    {
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        this.Canvas.font=this.Font;
        this.Canvas.fillText(text,pt.X,pt.Y);
    }

    this.DrawArea=function()
    {
        var lineStart=null,lineEnd=null;
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            if (item.Text=='1:8') lineStart=this.LinePoint[i];
            else if (item.Text=='8:1') lineEnd=this.LinePoint[i];
        }

        if (!lineStart || !lineEnd) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(lineStart.End.X,lineStart.End.Y);
        this.Canvas.lineTo(lineStart.Start.X,lineStart.Start.Y);
        this.Canvas.lineTo(lineEnd.End.X,lineEnd.End.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    //计算线段
    this.CalculateLines=function(ptStart,ptEnd,quadrant)
    {
        if (!this.Frame) return false;
        var top=this.Frame.ChartBorder.GetTopEx();
        var right=this.Frame.ChartBorder.GetRight();
        var bottom=this.Frame.ChartBorder.GetBottom();

        const SPLIT_LINE_VALUE=[0.5, 1.0/3, 0.25, 0.125, 2.0/3]; 
        const SPLIT_LINE_X_TITLE=["1:2","1:3","1:4","1:8","2:3"];
	    const SPLIT_LINE_Y_TITLE=["2:1","3:1","4:1","8:1","3:2"];
        var ptLineStart=new Point();
        var ptLineEnd=new Point();
        ptLineStart.X=ptStart.X;
        ptLineStart.Y=ptStart.Y;
        ptLineEnd.X=ptEnd.X;
        ptLineEnd.Y=ptEnd.Y;
        var lineWidth=Math.abs(ptStart.X-ptEnd.X);
        var lineHeight=Math.abs(ptStart.Y-ptEnd.Y);
        if (quadrant===1)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.Start, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineWidth>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(),Text:SPLIT_LINE_X_TITLE[i]};
                    line.PtEnd.Y=ptEnd.Y;
                    line.PtEnd.X=ptStart.X+lineWidth*SPLIT_LINE_VALUE[i];
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.Start;
                    this.LinePoint.push(line);
                }
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y-lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.Start;
                    this.LinePoint.push(line);
                }
            }
            
        }
        else if (quadrant==2)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.Start, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                
                if (lineWidth>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(),Text:SPLIT_LINE_X_TITLE[i]};
                    line.PtEnd.Y=ptEnd.Y;
                    line.PtEnd.X=ptStart.X-lineWidth*SPLIT_LINE_VALUE[i];
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.Start;
                    this.LinePoint.push(line);
                }

                
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y-lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.Start;
                    this.LinePoint.push(line);
                }
                    
            }
        }
        else if (quadrant==3)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.End, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineWidth>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(),Text:SPLIT_LINE_X_TITLE[i]};
                    line.PtEnd.Y=ptEnd.Y;
                    line.PtEnd.X=ptStart.X-lineWidth*SPLIT_LINE_VALUE[i];
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.End;
                    this.LinePoint.push(line);
                }
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y+lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.End;
                    this.LinePoint.push(line);
                }
            }
        }
        else if (quadrant==4)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.End, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineWidth>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(),Text:SPLIT_LINE_X_TITLE[i]};
                    line.PtEnd.Y=ptEnd.Y;
                    line.PtEnd.X=ptStart.X+lineWidth*SPLIT_LINE_VALUE[i];
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.End;
                    this.LinePoint.push(line);
                }
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y+lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.End;
                    this.LinePoint.push(line);
                }
            }
        }
        else 
        {
            return false;
        }

        return true;
    }
}


//江恩角度线（Gann Fan） 通达信版本
function ChartDrawPictureGannFanV2()
{
    this.newMethod=ChartDrawPictureGannFan;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureGannFanV2';
    this.EnableDottedLine=true;    //辅助线是否使用虚线
    this.LineDash=[4,8];
    this.EnableArea=false;

    this.Super_CalculateLines=this.CalculateLines;

    this.CalculateLines=function(ptStart,ptEnd,quadrant)
    {
        if (!this.Super_CalculateLines(ptStart,ptEnd,quadrant)) return false;

        var border=this.Frame.ChartBorder.GetBorder();
        if (quadrant==1)
        {
            var line={ Start:ptStart, End:{ X:border.Right, Y:ptStart.Y}, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);

            var line={ Start:ptStart, End:{ X:ptStart.X, Y:border.TopEx }, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);
        }
        else if (quadrant==2)
        {
            var line={ Start:ptStart, End:{ X:ptStart.X, Y:border.TopEx }, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);

            var line={ Start:ptStart, End:{ X:border.Left, Y:ptStart.Y}, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);
        }
        else if (quadrant==3)
        {
            var line={ Start:ptStart, End:{ X:border.Left, Y:ptStart.Y}, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);

            var line={ Start:ptStart, End:{ X:ptStart.X, Y:border.BottomEx }, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);
        }
        else if (quadrant==4)
        {
            var line={ Start:ptStart, End:{ X:ptStart.X, Y:border.BottomEx }, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);

            var line={ Start:ptStart, End:{ X:border.Right, Y:ptStart.Y}, IsDottedLine:false, PtEnd:null, Text:null };
            this.LinePoint.push(line);
        }
    }
}

//阻速线  （高 3等份）
function ChartDrawPictureResistanceLine()
{
    this.newMethod=ChartDrawPictureGannFan;   //派生
    this.newMethod();
    delete this.newMethod;
    
    this.ClassName='ChartDrawPictureResistanceLine';

    //计算线段
    this.CalculateLines=function(ptStart,ptEnd,quadrant)
    {
        if (!this.Frame) return false;
        var top=this.Frame.ChartBorder.GetTopEx();
        var right=this.Frame.ChartBorder.GetRight();
        var bottom=this.Frame.ChartBorder.GetBottom();

        const SPLIT_LINE_VALUE=[1.0/3, 2.0/3]; 
	    const SPLIT_LINE_Y_TITLE=["3:1","3:2"];
        var ptLineStart=new Point();
        var ptLineEnd=new Point();
        ptLineStart.X=ptStart.X;
        ptLineStart.Y=ptStart.Y;
        ptLineEnd.X=ptEnd.X;
        ptLineEnd.Y=ptEnd.Y;
        var lineWidth=Math.abs(ptStart.X-ptEnd.X);
        var lineHeight=Math.abs(ptStart.Y-ptEnd.Y);
        if (quadrant===1)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.Start, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y-lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.Start;
                    this.LinePoint.push(line);
                }
            }
        }
        else if (quadrant==2)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.Start, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y-lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.Start;
                    this.LinePoint.push(line);
                }
                    
            }
        }
        else if (quadrant==3)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.End, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y+lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.End;
                    this.LinePoint.push(line);
                }
            }
        }
        else if (quadrant==4)
        {
            var extendLine=this.CalculateExtendLinePoint(ptStart,ptEnd);
            var line={Start:ptLineStart, End:extendLine.End, IsDottedLine:false,PtEnd:ptLineEnd, Text:'1:1'};
            this.LinePoint.push(line);

            for(var i=0;i<SPLIT_LINE_VALUE.length; ++i)
            {
                if (lineHeight>5)
                {
                    line={Start:ptLineStart, End:null, IsDottedLine:this.EnableDottedLine,PtEnd:new Point(), Text:SPLIT_LINE_Y_TITLE[i]};
                    line.PtEnd.Y=ptStart.Y+lineHeight*SPLIT_LINE_VALUE[i];
                    line.PtEnd.X=ptEnd.X;
                    var extendLine=this.CalculateExtendLinePoint(line.Start,line.PtEnd);
                    line.End=extendLine.End;
                    this.LinePoint.push(line);
                }
            }
        }
        else 
        {
            return false;
        }

        return true;
    }

    this.DrawArea=function()
    {
        var lineStart=null,lineEnd=null;
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            if (item.Text=='1:1') lineStart=this.LinePoint[i];
            else if (item.Text=='3:1') lineEnd=this.LinePoint[i];
        }

        if (!lineStart || !lineEnd) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(lineStart.End.X,lineStart.End.Y);
        this.Canvas.lineTo(lineStart.Start.X,lineStart.Start.Y);
        this.Canvas.lineTo(lineEnd.End.X,lineEnd.End.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }
}

//阻速线2  （高 3等份）通达信版本
function ChartDrawPictureResistanceLineV2()
{
    this.newMethod=ChartDrawPictureResistanceLine;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureResistanceLineV2';
    this.EnableDottedLine=true;    //辅助线是否使用虚线
    this.LineDash=[4,8];
    this.EnableArea=false;
    this.IsShowTitle=false;
}




//黄金分割线
function ChartDrawPictureGoldenSection()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureGoldenSection';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.Font=14*GetDevicePixelRatio() +"px 微软雅黑";
    
    this.GetSectionData=function()
    {
        const GOLDEN_SECTION_DATA= [0,0.236,0.382,0.5,0.618,0.80,1,1.236,1.382,1.5,1.618,1.8,2];
        return GOLDEN_SECTION_DATA;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        
        this.CalculateLines(drawPoint[0],drawPoint[1]);
        this.ClipFrame();
        
        this.SetLineWidth();
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End,item.IsDottedLine);
        }
        this.RestoreLineWidth();

        for(var i in this.LinePoint)
        {
            var item =this.LinePoint[i];
            if (item.Text) this.DrawTitle(item.Start,item.Text);
        }

        this.DrawPoint(drawPoint); //画点
        this.Canvas.restore();
        
    }

    this.CalculateHSCreenLines=function(ptStart,ptEnd)
    {
        var sectionData=this.GetSectionData();
        var left=this.Frame.ChartBorder.GetTop();
        var right=this.Frame.ChartBorder.GetBottom();
        var lineHeight=ptStart.X-ptEnd.X;

        for(var i=0;i<sectionData.length;++i)
        {
            var yMove=lineHeight*sectionData[i];

            var line={Start:new Point(), End:new Point()};
            line.Start.X=ptStart.X-yMove;
            line.Start.Y=left;
            line.End.X=ptStart.X-yMove;
            line.End.Y=right;
            
            var text='';
            if (i==0) text='Base '
            else text=(sectionData[i]*100).toFixed(2)+'% ';

            var yValue=this.Frame.GetYData(line.Start.X);
            text+=yValue.toFixed(2);

            line.Text=text;
           
            this.LinePoint.push(line);
        }
    }

    this.CalculateLines=function(ptStart,ptEnd)
    {
        if (this.Frame.IsHScreen)
        {
            this.CalculateHSCreenLines(ptStart,ptEnd);
            return;
        }

        var sectionData=this.GetSectionData();
        var left=this.Frame.ChartBorder.GetLeft();
        var right=this.Frame.ChartBorder.GetRight();
        var lineHeight=ptStart.Y-ptEnd.Y;
        for(var i=0;i<sectionData.length;++i)
        {
            var yMove=lineHeight*sectionData[i];

            var line={Start:new Point(), End:new Point()};
            line.Start.Y=ptStart.Y-yMove;
            line.Start.X=left;
            line.End.Y=ptStart.Y-yMove;
            line.End.X=right;
            
            var text='';
            if (i==0) text='Base '
            else text=(sectionData[i]*100).toFixed(2)+'% ';

            var yValue=this.Frame.GetYData(line.Start.Y);
            text+=yValue.toFixed(2);

            line.Text=text;
           
            this.LinePoint.push(line);
        }
    }

    this.DrawLine=function(ptStart,ptEnd)
    {
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
    }

    this.DrawTitle=function(pt,text)
    {
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        this.Canvas.font=this.Font;

        if (this.Frame.IsHScreen)
        {
            this.Canvas.save();
            this.Canvas.translate(pt.X,pt.Y);
            this.Canvas.rotate(90 * Math.PI / 180);

            this.Canvas.fillText(text,0,0);
            this.Canvas.restore();
        }
        else
        {
            this.Canvas.fillText(text,pt.X,pt.Y);
        }    
    }
}

//百分比线
function ChartDrawPicturePercentage()
{
    this.newMethod=ChartDrawPictureGoldenSection;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPicturePercentage';

    this.GetSectionData=function()
    {
        const GOLDEN_SECTION_DATA= [0, 0.25, 0.333, 0.50, 1];
        return GOLDEN_SECTION_DATA;
    }

}

//波段线
function ChartDrawPictureWaveBand()
{
    this.newMethod=ChartDrawPictureGoldenSection;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureWaveBand';

    this.GetSectionData=function()
    {
        const GOLDEN_SECTION_DATA= [0,0.125, 0.25, 0.375, 0.50, 0.625, 0.75, 0.875,1];
        return GOLDEN_SECTION_DATA;
    }
}

//三角形
function ChartDrawPictureTriangle()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureTriangle';
    this.PointCount=3;
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.LastPoint;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;
        
        var points=drawPoint.slice(0);
        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();
        
        this.CalculateLines(points);
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        this.DrawArea(points);
        this.DrawPoint(points); //画点
        this.DrawTitle(points);

        this.Canvas.restore();
        
    }

    this.DrawArea=function(points)
    {
        if (points.length!=3) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(points[0].X,points[0].Y);
        this.Canvas.lineTo(points[1].X,points[1].Y);
        this.Canvas.lineTo(points[2].X,points[2].Y);
        this.Canvas.lineTo(points[0].X,points[0].Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    //显示角度数据
    this.DrawTitle=function(points)
    {
        if (this.Status!=10) return;   //拖拽完成以后才显示角度数据

        //输出3个点的角度
        /*
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        this.Canvas.font=this.Font;
        this.Canvas.fillText('∠60',points[0].X,points[0].Y);
        */
    }

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length===2)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);
        }
        else if (points.length===3)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);

            line={Start:new Point(), End:new Point()};
            line.Start.Y=points[1].Y;
            line.Start.X=points[1].X;
            line.End.Y=points[2].Y;
            line.End.X=points[2].X;
            this.LinePoint.push(line);

            line={Start:new Point(), End:new Point()};
            line.Start.Y=points[2].Y;
            line.Start.X=points[2].X;
            line.End.Y=points[0].Y;
            line.End.X=points[0].X;
            this.LinePoint.push(line);
        }
    }
}

//对称角度
function ChartDrawPictureSymmetryAngle()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureSymmetryAngle';
    this.PointCount=2;
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;
        
        //var points=drawPoint.slice(0);
        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();
        
        this.CalculateLines(drawPoint);
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }
        this.DrawArea();
        this.DrawPoint(drawPoint); //画点
        this.DrawTitle(drawPoint);
        this.Canvas.restore();
    }

    this.CalculateLines=function(points)
    {
        if (points.length!=2) return;
        if (!this.Frame) return;

        var line={Start:new Point(), End:new Point()};
        line.Start.Y=points[0].Y;
        line.Start.X=points[0].X;
        line.End.Y=points[1].Y;
        line.End.X=points[1].X;
        this.LinePoint.push(line);

        line={Start:new Point(), End:new Point()};
        line.Start.Y=points[0].Y;
        line.Start.X=points[0].X;
        line.End.Y=points[1].Y;
        line.End.X=points[0].X;
        this.LinePoint.push(line);

        var xMove=points[0].X-points[1].X;
        line={Start:new Point(), End:new Point()};
        line.Start.Y=points[0].Y;
        line.Start.X=points[0].X;
        line.End.Y=points[1].Y;
        line.End.X=points[0].X+xMove;
        this.LinePoint.push(line);
    }

    this.DrawArea=function()
    {
        if (this.LinePoint.length!=3) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(this.LinePoint[0].Start.X,this.LinePoint[0].Start.Y);
        this.Canvas.lineTo(this.LinePoint[0].End.X,this.LinePoint[0].End.Y);
        this.Canvas.lineTo(this.LinePoint[2].End.X,this.LinePoint[2].End.Y);
        this.Canvas.moveTo(this.LinePoint[0].Start.X,this.LinePoint[0].Start.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    //显示角度数据
    this.DrawTitle=function(points)
    {
        if (this.Status!=10) return;   //拖拽完成以后才显示角度数据

        //输出点的角度
        /*
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        this.Canvas.font=this.Font;
        this.Canvas.fillText('∠60',points[0].X,points[0].Y);
        */
    }
}

//圆
function ChartDrawPictureCircle()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureCircle';
    this.PointCount=2;
    this.CircleData;
    this.GetXYCoordinate=this.GetXYCoordinate_default;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint || drawPoint.length!=2) return;
        
        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        this.ClipFrame();

        var x=drawPoint[0].X-drawPoint[1].X;
        var y=drawPoint[0].Y-drawPoint[1].Y;
        var r=Math.sqrt(x*x+y*y);
        
        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.strokeStyle=this.LineColor;
        this.DrawLine(drawPoint[0],drawPoint[1]);
        this.Canvas.beginPath();
        this.Canvas.arc(drawPoint[0].X,drawPoint[0].Y,r,0,2*Math.PI);
        this.Canvas.stroke();
        this.Canvas.fill();
        this.CircleData={X:drawPoint[0].X, Y:drawPoint[0].Y, R:r};

        this.DrawPoint(drawPoint); //画点
        this.Canvas.restore();
    }

    //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
    this.IsPointIn=function(x,y,option)
    {
        if (this.IsFrameMinSize()) return -1;
        if (this.Status!=10) return -1;

        var value=this.IsPointInXYValue(x,y,option);
        if (value>=0) 
            return value;

        if (this.CircleData && this.CircleData.R>8)
        {
            var triangleX=this.CircleData.X-x;
            var triangleY=this.CircleData.Y-y;
            var r=Math.sqrt(triangleX*triangleX+triangleY*triangleY);   //计算直径
            if (r<this.CircleData.R && r>this.CircleData.R-8) return 100;
        }

        return -1;
    }
}

//四边形
function ChartDrawPictureQuadrangle()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureQuadrangle';
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointCount=3;
    this.LastPoint;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;

        this.AreaColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.3);
        var points=drawPoint.slice(0);
        this.CalculateLines(points);

        this.ClipFrame();

        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        this.DrawArea();
        this.DrawPoint(points);  //画点
        this.Canvas.restore(); 
    }

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    this.DrawArea=function()
    {
        if (this.LinePoint.length!=4) return;

        this.Canvas.fillStyle=this.AreaColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(this.LinePoint[0].Start.X,this.LinePoint[0].Start.Y);
        this.Canvas.lineTo(this.LinePoint[0].End.X,this.LinePoint[0].End.Y);
        this.Canvas.lineTo(this.LinePoint[1].End.X,this.LinePoint[1].End.Y);
        this.Canvas.lineTo(this.LinePoint[2].End.X,this.LinePoint[2].End.Y);
        this.Canvas.closePath();
        this.Canvas.fill();
    }

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length==2)
        {
            var linePoint=this.CreateLineData(points[0],points[1]);
            this.LinePoint.push(linePoint);
        }
        else if (points.length==3)
        {
            var linePoint=this.CreateLineData(points[0],points[1]);
            this.LinePoint.push(linePoint);

            var linePoint=this.CreateLineData(points[1],points[2]);
            this.LinePoint.push(linePoint);

            //计算平行线
            var xMove=points[2].X-points[1].X;
            var yMove=points[2].Y-points[1].Y;

            var pt4=new Point();    //第4个点的坐标
            pt4.X=points[0].X+xMove;
            pt4.Y=points[0].Y+yMove;
            
            var linePoint=this.CreateLineData(points[2],pt4);
            this.LinePoint.push(linePoint);

            var linePoint=this.CreateLineData(pt4,points[0]);
            this.LinePoint.push(linePoint);
        }
    }
}

//斐波那契周期线
function ChartDrawPictureFibonacci()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPictureFibonacci';
    this.PointCount=1;
    this.Font=14*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint) return;

        this.CalculateLines();
        if (this.LinePoint.length<=0) return;

        this.ClipFrame();

        this.SetLineWidth();
        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
            this.DrawTitle(item.Start,item.Title);
        }
        this.RestoreLineWidth();
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore(); 
    }

    this.DrawTitle=function(pt,text)
    {
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="top";
        this.Canvas.font=this.Font;
        if (this.Frame.IsHScreen)
        {
            this.Canvas.save();
            this.Canvas.translate(pt.X,pt.Y);
            this.Canvas.rotate(90 * Math.PI / 180);

            this.Canvas.fillText(text,2,10);
            this.Canvas.restore();
        }
        else
        {
            this.Canvas.fillText(text,pt.X+2,pt.Y+10);
        }
    }

    this.CalculateHSCreenLines=function()
    {
        var data=this.Frame.Data;
        if (!data) return;

        var xStart=null;
        if (this.Status==10)
        {
            if (this.Value.length!=1) return;
            xStart=this.Value[0].XValue;
        }
        else
        {
            if (this.Point.length!=1) return;
            xStart=parseInt(this.Frame.GetXData(this.Point[0].Y))+data.DataOffset;
        }
        
        var top=this.Frame.ChartBorder.GetRightEx();
        var bottom=this.Frame.ChartBorder.GetLeftEx();
        var showCount=this.Frame.XPointCount;
        const LINE_DATA=[1,2,3,5,8,13,21,34,55,89,144,233];
        for(var i=0;i<LINE_DATA.length;++i)
        {
            var xValue=xStart+LINE_DATA[i];
            var dataIndex=xValue-data.DataOffset;
            if (dataIndex<0 || dataIndex>=showCount) continue;

            var x=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            var line={Start:new Point(), End:new Point(), Title:LINE_DATA[i]};
            line.Start.X=top;
            line.Start.Y=x;
            line.End.X=bottom;
            line.End.Y=x;
            this.LinePoint.push(line);
        }
    }

    this.CalculateLines=function()
    {
        if (this.Status<2) return;
        if (!this.Frame) return;
        var data=this.Frame.Data;
        if (!data) return;

        if (this.Frame.IsHScreen)
        {
            this.CalculateHSCreenLines();
            return;
        }

        var xStart=null;
        if (this.Status==10)
        {
            if (this.Value.length!=1) return;
            xStart=this.Value[0].XValue;
        }
        else
        {
            if (this.Point.length!=1) return;
            xStart=parseInt(this.Frame.GetXData(this.Point[0].X))+data.DataOffset;
        }
        
        var top=this.Frame.ChartBorder.GetTopEx();
        var bottom=this.Frame.ChartBorder.GetBottom();
        var showCount=this.Frame.XPointCount;
        const LINE_DATA=[1,2,3,5,8,13,21,34,55,89,144,233];
        for(var i=0;i<LINE_DATA.length;++i)
        {
            var xValue=xStart+LINE_DATA[i];
            var dataIndex=xValue-data.DataOffset;
            if (dataIndex<0 || dataIndex>=showCount) continue;

            var x=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            var line={Start:new Point(), End:new Point(), Title:LINE_DATA[i]};
            line.Start.Y=top;
            line.Start.X=x;
            line.End.Y=bottom;
            line.End.X=x;
            this.LinePoint.push(line);
        }

    }
}

//线性回归
function ChartDrawLinearRegression(option)
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawLinearRegression';
    this.PointCount=2;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.ChartBorder;
    this.Lines=[];  //回归线 { XValue:, YValue: }
    this.IsShowMaxMinLine=false;     //是否显示最高 最低价通道
    this.IsShowExtendLine=false;     //是否显示延长线
    this.ExtendLineDash=[5,5];       //延长线虚线
    this.MaxPoint;
    this.MinPoint;

    if (option) 
    {
        if (option.IsShowMaxMinLine==true) this.IsShowMaxMinLine=true;
        if (option.IsShowExtendLine==true) this.IsShowExtendLine=true;
    }

    //导入
    this.ImportStorageData=function(storageData)
    {
        if (storageData.IsShowMaxMinLine==true) this.IsShowMaxMinLine=true;
        if (storageData.IsShowExtendLine==true) this.IsShowExtendLine=true;
        if (storageData.Lines) this.Lines=storageData.Lines;
        if (storageData.MaxPoint && storageData.MinPoint) 
        {
            this.MaxPoint=storageData.MaxPoint;
            this.MinPoint=storageData.MinPoint;
        }
    }

    //导出
    this.Super_ExportStorageData=this.ExportStorageData;
    this.ExportStorageData=function()
    {
        var storageData;
        if (this.Super_ExportStorageData) 
        {
            storageData=this.Super_ExportStorageData();
            storageData.IsShowMaxMinLine=this.IsShowMaxMinLine;
            storageData.IsShowExtendLine=this.IsShowExtendLine;
            storageData.Lines=this.Lines;
            if (this.IsShowMaxMinLine)
            {
                storageData.MaxPoint=this.MaxPoint;
                storageData.MinPoint=this.MinPoint;
            }
        }

        return storageData;
    }


    this.PointToValue_Backup=this.PointToValue;

    this.PointToValue=function()
    {
        //拖拽完成 把点移动到线段头尾
        this.Point[0]={X:this.Lines[0].X, Y:this.Lines[0].Y};
        this.Point[1]={X:this.Lines[this.Lines.length-1].X, Y:this.Lines[this.Lines.length-1].Y};
        this.PointToValue_Backup();
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( { IsCheckX:true, IsCheckY:true} );
        if (!drawPoint || drawPoint.length!=2) 
        {
            if (this.Status==10)
            {
                this.ClipFrame();
                this.ChartBorder=this.Frame.ChartBorder;
                this.SetLineWidth();
                this.Canvas.strokeStyle=this.LineColor;
                this.DrawLinearLines();
                this.RestoreLineWidth();
                this.Canvas.restore();
            }
            return;
        }

        this.ClipFrame();
        this.ChartBorder=this.Frame.ChartBorder;
        
        //0=开始画 1=完成第1个点  2=完成第2个点 3=完成第3个点  10=完成 20=移动)
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        if (this.Status==10)
        {
            this.DrawLinearLines();
        }  
        else
        {
            var top=this.ChartBorder.GetTopEx();
            var bottom=this.ChartBorder.GetBottomEx();

            var kPoint=this.PointToKLine([ptStart,ptEnd]);
            //JSConsole.Chart.Log('[ChartDrawLinearRegression::Draw] kPoint', kPoint);
            var linear=this.Calculate(kPoint);
            //JSConsole.Chart.Log('[ChartDrawLinearRegression::Draw] linear', linear);
    
            this.Lines=linear.Points;
            this.MaxPoint=linear.Max;
            this.MinPoint=linear.Min;

            this.DrawLinearLines();

            this.Canvas.beginPath();
            this.Canvas.moveTo(ptStart.X,top);
            this.Canvas.lineTo(ptStart.X,bottom);

            this.Canvas.moveTo(ptEnd.X,top);
            this.Canvas.lineTo(ptEnd.X,bottom);
            this.Canvas.stroke();

        }                            
        
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.Calculate=function(kPoint)
    {
        var startPoint=kPoint[0];
        var endPoint=kPoint[1];
        if (startPoint.XValue>endPoint.XValue)
        {
            startPoint=kPoint[1];
            endPoint=kPoint[0];
        }
        
        var num=(endPoint.XValue-startPoint.XValue)+1;
        var data=this.Frame.Data.Data;
        var i=endPoint.XValue;
        var Ex = 0, Ey = 0, Sxy = 0, Sxx = 0, Const, Slope;
        var i, j,x, k;
        for(j = 0, x=num; j < num && j <= i; ++j, --x)
        {
            Ex += x;
            Ey += data[i - j].Close;
        }
        Ex /= num;
        Ey /= num;
        for(j = 0, x=num; j < num && j <= i; ++j,--x)
        {
            Sxy += (x-Ex)*(data[i-j].Close-Ey);
            Sxx += (x-Ex)*(x-Ex);
        }
        Slope = Sxy / Sxx;  //斜率
        Const = Ey - Ex*Slope;
        //value=Slope * num + Const; //Y轴值 线性回归公式

        var points=[];
        var max=null, min=null;
        for(j = 0, k=num; j < num && j <= i; ++j,--k)
        {
            var xIndex=endPoint.XIndex-j;
            var xValue=endPoint.XValue-j;
            var x=this.Frame.GetXFromIndex(xIndex);

            var yValue=Slope * k + Const;
            var y=this.Frame.GetYFromData(yValue,false);

            var item={ X:x, Y:y, XValue:xValue, YValue:yValue };
            points.push(item);

            if (max==null || max.High<data[xValue].High)
            {
                max={X:x,Y:y,XValue:xValue, YValue:yValue, High:data[xValue].High };
            }

            if (min==null || min.Low>data[xValue].Low)
            {
                min={X:x,Y:y,XValue:xValue, YValue:yValue, Low:data[xValue].Low };
            }
        }

        return { Points:points, Slope:Slope, Const:Const , Max:max, Min:min };
    }

    this.DrawLinearLines=function()
    {
        if (!this.Frame) return null;
        var data=this.Frame.Data;
        if (!data) return null;

        var showCount=this.Frame.XPointCount;
        var dataOffset=data.DataOffset;
        var isHScreen=this.Frame.IsHScreen;
        var drawLines=[];
        for(var i in this.Lines)
        {
            var item=this.Lines[i];
            var dataIndex=item.XValue-dataOffset;
            if (dataIndex<0 || dataIndex>=showCount) continue;
            var pt={};
            if (isHScreen)  //横屏X,Y对调
            {

            }
            else
            {
                pt.X=this.Frame.GetXFromIndex(dataIndex,false);
                pt.Y=this.Frame.GetYFromData(item.YValue,false);
                pt.YValue=item.YValue;
            }

            drawLines.push(pt);
        }

        if (drawLines.length>1)
        {
            for(var i in drawLines)
            {
                var item=drawLines[i];

                if (i==0)
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(item.X,item.Y);
                }
                else
                {
                    this.Canvas.lineTo(item.X,item.Y);
                    if (i==drawLines.length-1) this.Canvas.stroke();
                }
            }

            this.DrawExtendLine(drawLines);
        }

        //最大 最小通道
        if (this.IsShowMaxMinLine && drawLines.length>1 && this.MaxPoint && this.MinPoint)
        {
            var highOffset=this.MaxPoint.High-this.MaxPoint.YValue;
            for(var i in drawLines)
            {
                var item=drawLines[i];
                item.Y=this.Frame.GetYFromData((item.YValue+highOffset),false);

                if (i==0)
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(item.X,item.Y);
                }
                else
                {
                    this.Canvas.lineTo(item.X,item.Y);
                    if (i==drawLines.length-1) this.Canvas.stroke();
                }
            }
            this.DrawExtendLine(drawLines);

            var lowOffset=this.MinPoint.Low-this.MinPoint.YValue;
            for(var i in drawLines)
            {
                var item=drawLines[i];
                item.Y=this.Frame.GetYFromData((item.YValue+lowOffset),false);

                if (i==0)
                {
                    this.Canvas.beginPath();
                    this.Canvas.moveTo(item.X,item.Y);
                }
                else
                {
                    this.Canvas.lineTo(item.X,item.Y);
                    if (i==drawLines.length-1) this.Canvas.stroke();
                }
            }
            this.DrawExtendLine(drawLines);
        }
    }

    //画延长线
    this.DrawExtendLine=function(lines)
    {
        if (!this.IsShowExtendLine) return;
        
        var ptStart=lines[0];
        var ptEnd=lines[lines.length-1];
        var aryPoint;
        if (ptEnd.X>ptStart.X) aryPoint=[ptStart, ptEnd];
        else aryPoint=[ptEnd, ptStart];

        var ptExtend=this.CalculateExtendLineEndPoint(aryPoint);
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptEnd.X,ptEnd.Y);
        this.Canvas.lineTo(ptExtend.X,ptExtend.Y);
        this.Canvas.setLineDash(this.ExtendLineDash);
        this.Canvas.stroke();
        this.Canvas.setLineDash([]);
    }

}

//尺子
function ChartDrawRuler()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawRuler';
    this.PointCount=2;
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.TitleColor=g_JSChartResource.ChartDrawRuler.TitleColor;
    this.IsHScreen=false;

    this.Draw=function()
    {
        this.LinePoint=[];
        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;
        this.IsHScreen=this.Frame.IsHScreen;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        var kPoint=this.PointToKLine([ptStart,ptEnd]);
        //JSConsole.Chart.Log('[ChartDrawLinearRegression::ChartDrawRuler] kPoint', kPoint);
        var kDataInfo=this.Calculate(kPoint);
        //JSConsole.Chart.Log('[ChartDrawLinearRegression::ChartDrawRuler] kDataInfo', kDataInfo);

        var increase=IFrameSplitOperator.IsNumber(kDataInfo.Increase)? kDataInfo.Increase.toFixed(2)+'%': "--";
        var risefall=IFrameSplitOperator.IsNumber(kDataInfo.Risefall)? kDataInfo.Risefall.toFixed(2): "--";
        var title=`间距:${kDataInfo.Count} 涨跌:${risefall} 涨幅:${increase}`;
        //JSConsole.Chart.Log('[ChartDrawLinearRegression::ChartDrawRuler] title', title);
        
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点

        //绘制信息
        this.Canvas.textBaseline='bottom';
        this.Canvas.textAlign='left';
        this.Canvas.font=this.Font;
        if (this.TitleColor)
        {
            this.Canvas.fillStyle=this.TitleColor;
        }
        else if (IFrameSplitOperator.IsNumber(kDataInfo.Increase))
        {
            if (kDataInfo.Increase>0) this.Canvas.fillStyle=g_JSChartResource.UpTextColor;
            else if (kDataInfo.Increase<0) this.Canvas.fillStyle=g_JSChartResource.DownTextColor;
            else this.Canvas.fillStyle=g_JSChartResource.UnchagneTextColor;
        }
        else
        {
            this.Canvas.fillStyle=g_JSChartResource.UnchagneTextColor;
        }

        var offset=3*GetDevicePixelRatio();
        var xText=ptStart.X
        var yText=ptStart.Y
        if (this.IsHScreen)
        {
            this.Canvas.translate(xText+offset,yText+offset);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(title,0,0);
        }
        else
        {
            this.Canvas.fillText(title,xText+offset,yText-offset);
        }
        
        
        this.Canvas.restore();
    }

    this.Calculate=function(kPoint)
    {
        var startPoint=kPoint[0];
        var endPoint=kPoint[1];
        if (startPoint.XValue>endPoint.XValue)
        {
            startPoint=kPoint[1];
            endPoint=kPoint[0];
        }

        var data=this.Frame.Data.Data;
        var open, high, low, yClose, close;
        var count=0;
        for(var i=startPoint.XValue;i<=endPoint.XValue;++i, ++count)
        {
            var item=data[i];
            if (count==0)
            {
                yClose=item.YClose;
                open=item.Open;
                close=item.Close;
                low=item.Low;
                high=item.High;
            }
            else
            {
                close=item.Close;
                if (low>item.Low) low=item.Low;
                if (high<item.High)  high=item.High;
            }
        }

        if (!IFrameSplitOperator.IsPlusNumber(yClose))  //前收盘无效， 取上一个交易日的收盘价
        {
            var index=startPoint.XValue-1;
            if (index>=0 && index<data.length) yClose=data[index].Close;
        }

        var result={ YClose:yClose, Open:open, High:high, Low:low, Close:close, Count:count };
        if (IFrameSplitOperator.IsPlusNumber(yClose)) 
        {
            result.Increase=(close-yClose)/yClose*100;
            result.Risefall=(close-yClose);
        }
        
        return result;
    }

}

//画图工具-标价线 支持横屏
function ChartDrawPriceLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPriceLine';
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( { IsCheckX:false, IsCheckY:true } );
        if (!drawPoint) return;
        if (drawPoint.length!=1) return;

        this.IsHScreen=this.Frame.IsHScreen;
        var ptStart=drawPoint[0];
        var chartBorder=this.Frame.ChartBorder;
        if (this.IsHScreen)
        {
            var left=chartBorder.GetLeftEx();
            var right=chartBorder.GetRightEx();
            if (ptStart.X<left || ptStart.X>right) return;

            var bottom=chartBorder.GetBottom();
            var ptEnd={X:ptStart.X, Y:bottom};
            var price=this.Frame.GetYData(ptStart.X, false);
        }
        else
        {
            var bottom=chartBorder.GetBottomEx();
            var top=chartBorder.GetTopEx();
            if (ptStart.Y<top || ptStart.Y>bottom) return;

            var right=chartBorder.GetRight();
            var ptEnd={X:right, Y:ptStart.Y};
            var price=this.Frame.GetYData(ptStart.Y, false);
        }
        
        

        this.ClipFrame();
       
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        
        this.Canvas.textBaseline='bottom';
        this.Canvas.textAlign='left';
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.font=this.Font;
        var offset=2*GetDevicePixelRatio();
        var xText=ptStart.X;
        var yText=ptStart.Y;
        if (this.IsHScreen)
        {
            this.Canvas.translate(xText+offset,yText+offset);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(price.toFixed(2),0,0);
        }
        else
        {
            this.Canvas.fillText(price.toFixed(2),xText+offset,yText-offset);
        }
        
        this.Canvas.restore();
    }
}

//画图工具-标价线2 支持横屏 支持价格文字在坐标内部显示
function ChartDrawPriceLineV2()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPriceLineV2';
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;
    this.LineWidth=1;
    this.IsDrawFirst=true;
    this.TextColor="rgb(255,255,255)";
    this.Title; //标题
    this.TextPosition=[null, 0];   //[0]=左侧(没有做)     [1]=右侧  0=自动 1=内部 2=外部

    this.Super_SetOption=this.SetOption;    //父类函数
    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.TextColor) this.TextColor=option.TextColor;
            if (option.Title) this.Title=option.Title;
            if (IFrameSplitOperator.IsNonEmptyArray(option.TextPosition)) this.TextPosition=option.TextPosition.slice();
        }
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( { IsCheckX:false, IsCheckY:true } );
        if (!drawPoint) return;
        if (drawPoint.length!=1) return;
        if (!this.IsYValueInFrame(this.Value[0].YValue)) return;

        this.IsHScreen=this.Frame.IsHScreen;
        var chartBorder=this.Frame.ChartBorder;
        var border=this.Frame.GetBorder();
        if (this.IsHScreen)
        {
            var left=border.LeftEx;
            var right=border.RightEx;
            var bottom=border.Bottom;
            var top=border.Top;

            var ptStart={ X:drawPoint[0].X, Y:top };
            if (ptStart.X<left || ptStart.X>right) return;
            
            var ptEnd={X:drawPoint[0].X, Y:bottom };
            var price=this.Frame.GetYData(ptStart.X, false);
        }
        else
        {
            var bottom=border.BottomEx;
            var top=border.TopTitle;
            var left=border.Left;
            var right=border.Right;

            var ptStart={ X:left, Y:drawPoint[0].Y };
            if (ptStart.Y<top || ptStart.Y>bottom) return;

            var ptEnd={ X:right, Y:drawPoint[0].Y };
            var price=this.Frame.GetYData(ptStart.Y, false);
        }
        
        //this.ClipFrame();
       
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(ptStart.X),ToFixedPoint(ptStart.Y));
        this.Canvas.lineTo(ToFixedPoint(ptEnd.X),ToFixedPoint(ptEnd.Y));
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        var pixelTatio = GetDevicePixelRatio();
        this.Canvas.font=this.Font;
        var offset=2*pixelTatio;
        var xText=ptEnd.X;
        var yText=ptEnd.Y;

        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        var textHeight=this.GetFontHeight();
        var text=price.toFixed(2);
        var textWidth=this.Canvas.measureText(text).width+2*offset;

        var centerPoint=null;
        if (this.IsHScreen)
        {
            var position=this.TextPosition[1];
            var bDrawInside=false;  //在内部绘制
            if (position==0) bDrawInside=chartBorder.Bottom<=10;
            else if (position==1) bDrawInside=true;
            else if (position==2) bDrawInside=false;

            if (bDrawInside)
            {
                yText=yText-textWidth;
                var rtBG={ Left:(xText-textHeight/2), Top:yText , Width:textHeight, Height: textWidth};
            }
            else    //框架内部显示
            {
                var rtBG={ Left:(xText-textHeight/2), Top:yText , Width: textHeight, Height:textWidth };
            }
            
            this.Canvas.fillStyle=this.LineColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

            this.Canvas.save();
            this.Canvas.translate(xText,yText+1*pixelTatio);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillStyle=this.TextColor;
            this.Canvas.fillText(text,0,0);
            this.Canvas.restore();

            if (this.Title)
            {
                var textWidth=this.Canvas.measureText(this.Title).width+2*pixelTatio;
                if (bDrawInside)
                {
                    var rtTitle={Left:rtBG.Left, Top:rtBG.Top-textWidth-1*pixelTatio, Width:textHeight, Height:textWidth};
                }
                else
                {
                    var rtTitle={ Left:rtBG.Left, Top:bottom-textWidth-1*pixelTatio, Width:textHeight, Height:textWidth };
                }

                this.Canvas.fillStyle=this.LineColor;
                this.Canvas.fillRect(rtTitle.Left, rtTitle.Top, rtTitle.Width, rtTitle.Height);

                this.Canvas.save();
                this.Canvas.translate(xText,rtTitle.Top+1*pixelTatio);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillStyle=this.TextColor;
                this.Canvas.fillText(this.Title,0,0);
                this.Canvas.restore();
            }

            centerPoint={ X:ptStart.X, Y:ptStart.Y+(ptEnd.Y-ptStart.Y)/2 };   //中心点
        }
        else
        {
            var position=this.TextPosition[1];
            var bDrawInside=false;  //在内部绘制
            if (position==0) bDrawInside=chartBorder.Right<=10;
            else if (position==1) bDrawInside=true;
            else if (position==2) bDrawInside=false;

            if (bDrawInside)
            {
                var rtBG={ Left:xText-textWidth, Top:(yText-textHeight/2-1*pixelTatio) , Width:textWidth, Height: textHeight};
            }
            else    //框架内部显示
            {
                var rtBG={ Left:xText, Top:(yText-textHeight/2-1*pixelTatio) , Width:textWidth, Height: textHeight};
                if (rtBG.Left+rtBG.Width>border.ChartWidth) rtBG.Left=border.ChartWidth-rtBG.Width-2*pixelTatio;
            }
            
            this.Canvas.fillStyle=this.LineColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

            this.Canvas.fillStyle=this.TextColor;
            this.Canvas.fillText(text, rtBG.Left+offset, yText);

            if (this.Title)
            {
                var textWidth=this.Canvas.measureText(this.Title).width+2*pixelTatio;
                if (bDrawInside)
                {
                    var rtTitle={Left:rtBG.Left-textWidth, Top:rtBG.Top, Width:textWidth, Height:textHeight}
                }
                else
                {
                    var rtTitle={ Left:right-textWidth-1*pixelTatio, Top:rtBG.Top, Width:textWidth, Height:textHeight };
                    if (rtBG.Left!=right) rtTitle.Left=rtBG.Left-textWidth-1*pixelTatio;
                }

                this.Canvas.fillStyle=this.LineColor;
                this.Canvas.fillRect(rtTitle.Left, rtTitle.Top, rtTitle.Width, rtTitle.Height);

                this.Canvas.fillStyle=this.TextColor;
                this.Canvas.fillText(this.Title, rtTitle.Left+1*pixelTatio, yText);
            }

            centerPoint={ X:ptStart.X+(ptEnd.X-ptStart.X)/2, Y:ptStart.Y };   //中心点
        }
        
        if (centerPoint) this.DrawPoint([centerPoint]);
    }

    this.DrawPrice=function()
    {

    }
}

//画图工具-竖线 支持横屏
function ChartDrawVerticalLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawVerticalLine';
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;
    this.GetXYCoordinate=this.GetXYCoordinate_default;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        if (!this.Frame || !this.Frame.Data) return;
        var data=this.Frame.Data;
        var drawPoint=this.CalculateDrawPoint( { IsCheckX:true, IsCheckY:true } );
        if (!drawPoint) return;
        if (drawPoint.length!=1) return;

        this.IsHScreen=this.Frame.IsHScreen;
        var pt=drawPoint[0];

        var chartBorder=this.Frame.ChartBorder;
        if (this.IsHScreen)
        {
            var xValue=Math.round(this.Frame.GetXData(pt.Y,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var yLine=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);
            yLine=ToFixedPoint2(this.LineWidth,yLine);
            var left=chartBorder.GetLeftEx();
            var right=chartBorder.GetRightEx();
            var ptStart={ X:left, Y:yLine };
            var ptEnd={ X:right, Y:yLine };
        }
        else
        {
            var xValue=Math.round(this.Frame.GetXData(pt.X,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var xLine=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);
            xLine=ToFixedPoint2(this.LineWidth,xLine);
            var top=chartBorder.GetTopEx();
            var bottom=chartBorder.GetBottomEx();
            var ptStart={ X:xLine, Y:top };
            var ptEnd={ X:xLine, Y:bottom };
        }
        
        this.ClipFrame();
       
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        if (this.Status==10) this.DrawPoint(drawPoint);  //画点 
        this.Canvas.restore();
    }
}

//画图工具-十字线 支持横屏
function ChartDrawCrosshair()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawCrosshair';
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;
    this.GetXYCoordinate=this.GetXYCoordinate_default;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        if (!this.Frame || !this.Frame.Data) return;
        var data=this.Frame.Data;
        var drawPoint=this.CalculateDrawPoint( { IsCheckX:false, IsCheckY:false } );
        if (!drawPoint) return;
        if (drawPoint.length!=1) return;

        this.IsHScreen=this.Frame.IsHScreen;
        var pt=drawPoint[0];

        var chartBorder=this.Frame.ChartBorder;
        var border=this.Frame.GetBorder();
        if (this.IsHScreen)
        {
            var xValue=Math.round(this.Frame.GetXData(pt.Y,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var yLine=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);
            yLine=ToFixedPoint2(this.LineWidth,yLine);
            var xLine=ToFixedPoint2(this.LineWidth,pt.X);
            var left=border.LeftEx
            var right=border.RightEx
            var top=border.Top;
            var bottom=border.Bottom;
            var ptStart={ X:left, Y:yLine };
            var ptEnd={ X:right, Y:yLine };

            var ptStart2={ X:xLine, Y:top };
            var ptEnd2={ X:xLine, Y:bottom };
        }
        else
        {
            var xValue=Math.round(this.Frame.GetXData(pt.X,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var xLine=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);
            xLine=ToFixedPoint2(this.LineWidth,xLine);
            var yLine=ToFixedPoint2(this.LineWidth, pt.Y);
            var top=border.TopEx;
            var bottom=border.BottomEx;
            var left=border.Left;
            var right=border.Right;
            var ptStart={ X:xLine, Y:top };
            var ptEnd={ X:xLine, Y:bottom };

            var ptStart2={ X:left, Y:yLine };
            var ptEnd2={ X:right, Y:yLine };
        }
        
        this.ClipFrame();
       
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);

        this.Canvas.moveTo(ptStart2.X, ptStart2.Y);
        this.Canvas.lineTo(ptEnd2.X,ptEnd2.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        var line2={Start:ptStart2, End:ptEnd2};
        this.LinePoint.push(line);
        this.LinePoint.push(line2);
        
        if (this.Status==10) this.DrawPoint(drawPoint);  //画点 
        this.Canvas.restore();
    }
}

//画图工具-监测线
function ChartDrawMonitorLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawMonitorLine';
    this.PointCount=1;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.FormatLabelTextCallback=null;

    this.LineColor='rgb(255,215,0)'
    this.LabelConfig=
    { 
        Font:`${12*GetDevicePixelRatio()}px 微软雅黑`, 
        BGColor:"rgb(30,144,255)",
        LineColor:"rgba(255,215,0,0.8)",
        LineDash:[3,5],

        Mergin:{ Left:5, Right:5, Top:5, Bottom:4 },
        LineSpace:5,    //行间距
        TextAlign:1,    //对齐方式 0=left 1=right
    }

    this.PointToValue_Backup=this.PointToValue;

    this.PointToValue=function()
    {
        if (!this.PointToValue_Backup()) return false;

        if (this.Frame.IsKLineFrame(false))
        {
            if (this.Frame.Identify===0)
            {
                var dataIndex=this.Value[0].XValue;
                var data=this.Frame.Data;
                var kItem=data.Data[dataIndex];
                this.Value[0].YValue=kItem.Close;   //使用收盘价
            }
        }

        return true;
    }

    this.SetOption=function(option)
    {
        if (option.LineColor) this.LineColor=option.LineColor;
        if (option.Label)
        {
            var item=option.Label;
            var dest=this.LabelConfig
            if (item.Font) dest.Font=item.Font;
            if (item.BGColor) dest.BGColor=item.BGColor;
            if (item.LineColor) dest.LineColor=item.LineColor;
            if (item.LineDash) dest.LineDash=item.LineDash;
            if (IFrameSplitOperator.IsNumber(item.LineSpace)) dest.LineSpace=item.LineSpace;
            if (IFrameSplitOperator.IsNumber(item.TextAlign)) dest.TextAlign=item.TextAlign;
            if (item.Mergin) CopyMarginConfig(dest.Mergin, item.Mergin);
        }

        if (option.FormatLabelTextCallback) this.FormatLabelTextCallback=option.FormatLabelTextCallback;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        if (!this.Frame || !this.Frame.Data) return;
        var data=this.Frame.Data;
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Data)) return;

        if (this.Point.length!=1) return;
        if (this.Value.length!=1) return;
        this.IsHScreen=this.Frame.IsHScreen;
        if (this.IsHScreen) return;

        if (this.Status==20) this.DrawMoveLine();
        else if (this.Status==10) this.DrawMonitorLine(data);
    }

    this.DrawMoveLine=function()
    {
        var border=this.Frame.ChartBorder.GetBorder();
        var pt=this.Point[0];
        var x=ToFixedPoint(pt.X);
        this.ClipFrame();

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(x,border.TopEx);
        this.Canvas.lineTo(x,border.BottomEx);
        this.Canvas.stroke();

        this.Canvas.restore();
    }

    this.DrawMonitorLine=function(data)
    {
        var isMinute=this.Frame.IsMinuteFrame();
        var dataWidth=this.Frame.DataWidth;
        var distanceWidth=this.Frame.DistanceWidth;
        var xPointCount=this.Frame.XPointCount;

        if (this.IsHScreen)
        {
            //var border=this.Frame.ChartBorder.GetHScreenBorder();
            //var chartright=border.BottomEx;
            //var xOffset=border.TopEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
        }
        else
        {
            var border=this.Frame.ChartBorder.GetBorder();
            var xOffset=border.LeftEx+distanceWidth/2.0+g_JSChartResource.FrameLeftMargin;
            var chartright=border.RightEx;
        }

        var ptData=this.Value[0];
        this.ClipFrame();
        
        var labelInfo=null;
        for(var i=data.DataOffset,j=0;i<data.Data.length && j<xPointCount;++i,++j,xOffset+=(dataWidth+distanceWidth))
        {
            var item=data.Data[i];

            if (isMinute)
            {
                var x=this.Frame.GetXFromIndex(j);
            }
            else
            {
                var left=xOffset;
                var right=xOffset+dataWidth;
                if (right>chartright) break;
                var x=left+(right-left)/2;
            }

            if (i==ptData.XValue)   //起始
            {
                this.Canvas.strokeStyle=this.LineColor;
                this.Canvas.beginPath();
                this.Canvas.moveTo(x,border.TopEx);
                this.Canvas.lineTo(x,border.BottomEx);
                this.Canvas.stroke();

                var line={Start:{X:x, Y:border.TopEx}, End:{X:x, Y:border.BottomEx}};
                this.LinePoint.push(line);
            }
            else if (i==data.Data.length-1)  //结束
            {
                if (this.LabelConfig.LineDash)  this.Canvas.setLineDash(this.LabelConfig.LineDash);
                this.Canvas.strokeStyle=this.LabelConfig.LineColor;
                this.Canvas.beginPath();
                this.Canvas.moveTo(x,border.TopEx);
                this.Canvas.lineTo(x,border.BottomEx);
                this.Canvas.stroke();
                if (this.LabelConfig.LineDash) this.Canvas.setLineDash([]);

                labelInfo={ Left:right, Data:data, StartIndex:ptData.XValue, AryText:[] };
            }
        }

        this.Canvas.restore();

        if (labelInfo) this.DrawLabel(labelInfo);
    }

    this.DrawLabel=function(labelInfo)
    {
        if (!this.FormatLabelTextCallback) return;
        labelInfo.Config=this.LabelConfig;
        this.FormatLabelTextCallback(labelInfo);
        if (!IFrameSplitOperator.IsNonEmptyArray(labelInfo.AryText)) return;
        if (!IFrameSplitOperator.IsNumber(labelInfo.YValue)) return;

        /*
        labelInfo.YValue=7.15;
        labelInfo.AryText=
        [
            { Name:"标题1:", Text:"6666", NameColor:"rgb(255,255,255)", TextColor:"rgb(30,10,30)" },
            { Name:"标题2:", Text:"08.00", NameColor:"rgb(255,255,255)", TextColor:"rgb(30,10,30)" },
            { Name:"标题3:", Text:"999.1", NameColor:"rgb(255,255,255)", TextColor:"rgb(30,10,30)" },
            { Name:"标题4:", Text:"320" , NameColor:"rgb(255,255,255)", TextColor:"rgb(30,10,30)"},
            { Name:"标题5:", Text:"77775.77", NameColor:"rgb(255,255,255)", TextColor:"rgb(30,10,30)" }
        ]
        */

        this.CalculateLabelSize(labelInfo);

        var y=this.Frame.GetYFromData(labelInfo.YValue,false);
        var rtBG={ Left:labelInfo.Left+1, Top:y, Width:labelInfo.Width, Height:labelInfo.Height };
        rtBG.Right=rtBG.Left+rtBG.Width;
        rtBG.Bottom=rtBG.Top+rtBG.Height;
        
        this.DrawDefaultLabel(labelInfo, rtBG);
    }
}

//画图工具-波浪尺
function ChartDrawWaveRuler()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawWaveRuler';
    this.PointCount=3;
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.LastPoint;
    this.LinePoint;
    this.ScaleRuler=g_JSChartResource.ChartDrawWaveRuler.ScaleRuler;
    this.RulerWidth=g_JSChartResource.ChartDrawWaveRuler.RulerWidth;;       //刻度尺长度
    this.RulerLineWidth=g_JSChartResource.ChartDrawWaveRuler.RulerLineWidth;
    this.MaxScaleRuler=g_JSChartResource.ChartDrawWaveRuler.MaxScaleRuler;   //尺子最大的高度比
    this.Font=g_JSChartResource.ChartDrawWaveRuler.MaxScaleRuler;
    this.IsHScreen=false;

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;

        this.IsHScreen=this.Frame.IsHScreen;
        this.CalculateLines(drawPoint);

        this.ClipFrame();
        this.SetLineWidth();

        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        //绘制波浪信息
        if (drawPoint.length==3) this.DrawWaveRuler(drawPoint);
        
        this.RestoreLineWidth();
       
        this.DrawPoint(drawPoint); //画点
        this.Canvas.restore();
    }

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    this.CalculateLines=function(points)
    {
        if (this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            points[2]=pt;
        }

        if (points.length==2)
        {
            var linePoint=
            { 
                Start:{X:points[0].X,Y:points[0].Y}, 
                End:{X:points[1].X,Y:points[1].Y}
            };
            this.LinePoint.push(linePoint);
        }
        else if (points.length==3)
        {
            var linePoint=
            { 
                Start:{X:points[0].X,Y:points[0].Y}, 
                End:{X:points[1].X,Y:points[1].Y}
            };
            this.LinePoint.push(linePoint);

            linePoint=
            { 
                Start:{X:points[1].X,Y:points[1].Y}, 
                End:{X:points[2].X,Y:points[2].Y}
            };
           
            this.LinePoint.push(linePoint);
        }
    }

    this.DrawWaveRuler=function(points)
    {
        var ptBottom=points[1];
        var ptStart=points[0];
        var ptEnd=points[2];

        var lineWidth=this.RulerLineWidth*GetDevicePixelRatio();
        this.Canvas.lineWidth=lineWidth;
        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.font=this.Font;
        var rulerWidth=this.RulerWidth*GetDevicePixelRatio();//刻度线长度

        if (this.IsHScreen)
        {
            var rulerHeight=ptStart.X-ptBottom.X;
            var ptExtendBottom={ X:ptEnd.X-this.MaxScaleRuler*rulerHeight, Y:ptEnd.Y};
            this.DrawLine(ptEnd,ptExtendBottom);
            this.LinePoint.push({Start:ptEnd, End:ptExtendBottom});
            var y=ptEnd.Y-rulerWidth/2, y2=ptEnd.Y+rulerWidth/2;
        }
        else
        {
            var rulerHeight=ptStart.Y-ptBottom.Y;
            var ptExtendBottom={ X:ToFixedPoint2(lineWidth,ptEnd.X), Y:ptEnd.Y-this.MaxScaleRuler*rulerHeight };
            this.DrawLine({X:ToFixedPoint2(lineWidth,ptEnd.X), Y:ptEnd.Y},ptExtendBottom);
            this.LinePoint.push({Start:ptEnd, End:ptExtendBottom});
            var x=ptEnd.X-rulerWidth/2, x2=ptEnd.X+rulerWidth/2;
        }

        var textOffset=4*GetDevicePixelRatio();
        for(var i in this.ScaleRuler)
        {
            var item=this.ScaleRuler[i];
            if (this.IsHScreen)
            {
                var x=ptEnd.X - item.Value*rulerHeight;
                var price=this.Frame.GetYData(x, false);
                this.DrawLine({X:x, Y:y}, {X:x, Y:y2});
                var text=`${price.toFixed(2)}  ${item.Text? item.Text: item.Value.toFixed(3)}`;
                this.Canvas.save();
                this.Canvas.translate(x,ptEnd.Y);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(text,textOffset,0);
                this.Canvas.restore();
            }
            else
            {
                var y=ptEnd.Y - item.Value*rulerHeight;
                var price=this.Frame.GetYData(y, false);
                this.DrawLine({X:x, Y:ToFixedPoint2(lineWidth,y)}, {X:x2, Y:ToFixedPoint2(lineWidth,y)});
                var text=`${price.toFixed(2)}  ${item.Text? item.Text: item.Value.toFixed(3)}`;
                this.Canvas.fillText(text,x2+textOffset,y);
            }
        }
    }
}

//画图工具-波浪尺 2个点的
function ChartDrawWaveRuler2Point()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawWaveRuler2Point';
    this.PointCount=2;
    this.Font=14*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.PointRate=[ 510, 517, 511.4];
    this.LinePoint;
    this.CPoint;
    this.ScaleRuler=g_JSChartResource.ChartDrawWaveRuler2Point.ScaleRuler;
    this.RulerWidth=g_JSChartResource.ChartDrawWaveRuler2Point.RulerWidth;;       //刻度尺长度
    this.RulerLineWidth=g_JSChartResource.ChartDrawWaveRuler2Point.RulerLineWidth;
    this.MaxScaleRuler=g_JSChartResource.ChartDrawWaveRuler2Point.MaxScaleRuler;   //尺子最大的高度比
    this.Font=g_JSChartResource.ChartDrawWaveRuler2Point.MaxScaleRuler;
    this.IsHScreen=false;
    this.Super_SetOption=this.SetOption;    //父类函数

    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.PointRate) this.PointRate=option.PointRate;
        }
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;

        this.IsHScreen=this.Frame.IsHScreen;
        this.CalculateLines(drawPoint);

        this.ClipFrame();
        this.SetLineWidth();

        for(var i in this.LinePoint)
        {
            var item=this.LinePoint[i];
            this.DrawLine(item.Start,item.End);
        }

        var points=[drawPoint[0],drawPoint[1],this.CPoint];
        this.DrawWaveRuler(points);
        
        this.RestoreLineWidth();
       
        this.DrawPoint(drawPoint); //画点
        this.Canvas.restore();
    }

    this.CalculateLines=function(points)
    {
        var firstLine=
        { 
            Start:{ X:points[0].X,Y:points[0].Y }, 
            End:{ X:points[1].X,Y:points[1].Y }
        };
        this.LinePoint.push(firstLine);

        var a=points[0].Y;
        var b=points[1].Y;

        var width=this.PointRate[1]-this.PointRate[0];
        var offset=this.PointRate[2]-this.PointRate[0];

        var c=a-((a-b)*offset)/width;

        this.CPoint={ X:points[1].X, Y:c };
    }

    this.DrawWaveRuler=function(points)
    {
        var ptBottom=points[1];
        var ptStart=points[0];
        var ptEnd=points[2];

        var lineWidth=this.RulerLineWidth*GetDevicePixelRatio();
        this.Canvas.lineWidth=lineWidth;
        this.Canvas.textBaseline='middle';
        this.Canvas.textAlign='left';
        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.font=this.Font;
        var rulerWidth=this.RulerWidth*GetDevicePixelRatio();//刻度线长度

        if (this.IsHScreen)
        {
            var rulerHeight=ptStart.X-ptBottom.X;
            var ptExtendBottom={ X:ptEnd.X-this.MaxScaleRuler*rulerHeight, Y:ptEnd.Y};
            this.DrawLine(ptEnd,ptExtendBottom);
            this.LinePoint.push({Start:ptEnd, End:ptExtendBottom});
            var y=ptEnd.Y-rulerWidth/2, y2=ptEnd.Y+rulerWidth/2;
        }
        else
        {
            var rulerHeight=ptStart.Y-ptBottom.Y;
            var ptExtendBottom={ X:ToFixedPoint2(lineWidth,ptEnd.X), Y:ptEnd.Y-this.MaxScaleRuler*rulerHeight };
            this.DrawLine({X:ToFixedPoint2(lineWidth,ptEnd.X), Y:ptEnd.Y},ptExtendBottom);
            this.LinePoint.push({Start:ptEnd, End:ptExtendBottom});
            var x=ptEnd.X, x2=ptEnd.X+rulerWidth;
        }

        var textOffset=4*GetDevicePixelRatio();
        for(var i in this.ScaleRuler)
        {
            var item=this.ScaleRuler[i];
            if (this.IsHScreen)
            {
                var x=ptEnd.X - item.Value*rulerHeight;
                var price=this.Frame.GetYData(x, false);
                this.DrawLine({X:x, Y:y}, {X:x, Y:y2});
                var text=`${price.toFixed(2)}  ${item.Text? item.Text: item.Value.toFixed(3)}`;
                this.Canvas.save();
                this.Canvas.translate(x,ptEnd.Y);
                this.Canvas.rotate(90 * Math.PI / 180);
                this.Canvas.fillText(text,textOffset,0);
                this.Canvas.restore();
            }
            else
            {
                var y=ptEnd.Y - item.Value*rulerHeight;
                var price=this.Frame.GetYData(y, false);
                this.DrawLine({X:x, Y:ToFixedPoint2(lineWidth,y)}, {X:x2, Y:ToFixedPoint2(lineWidth,y)});
                var text=`${price.toFixed(2)}  ${item.Text? item.Text: item.Value.toFixed(3)}`;
                this.Canvas.fillText(text,x2+textOffset,y);
            }
        }
    }
}

//画图工具-箱型线 支持横屏
function ChartDrawBox()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawBox';
    this.PointCount=2;
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;
    this.AvPriceLineDash=[5*GetDevicePixelRatio(),5*GetDevicePixelRatio()];
    this.KLineBorder;

    this.PointToValue_Backup=this.PointToValue;
    this.PointToValue=function()
    {
        //拖拽完成 把点移动到线段头尾
        this.Point[0]={X:this.KLineBorder.Left, Y:this.KLineBorder.Top};
        this.Point[1]={X:this.KLineBorder.Right, Y:this.KLineBorder.Bottom};
        this.PointToValue_Backup();
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;
        this.IsHScreen=this.Frame.IsHScreen;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        var kPoint=this.PointToKLine([ptStart,ptEnd]);
        JSConsole.Chart.Log('[ChartDrawBox::Draw] kPoint', kPoint);
        var kDataInfo=this.Calculate(kPoint);
        JSConsole.Chart.Log('[ChartDrawBox::Draw] kDataInfo', kDataInfo);
        var klineBorder=this.GetKLineBorder(drawPoint, kDataInfo);
        this.KLineBorder=klineBorder;
        
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.strokeRect(ToFixedRect(klineBorder.Left), ToFixedRect(klineBorder.Top), ToFixedRect(klineBorder.Right-klineBorder.Left), ToFixedRect(klineBorder.Bottom-klineBorder.Top));

        //均价
        var avPriceText;
        if (kDataInfo.Amount>0 && kDataInfo.Vol>0)
        {
            var price=kDataInfo.Amount/kDataInfo.Vol;
            avPriceText=`均价${price.toFixed(2)}`;
            
            this.Canvas.beginPath();
            if (this.IsHScreen)
            {
                var x=this.Frame.GetYFromData(price,false);
                this.Canvas.moveTo(ToFixedPoint2(this.Canvas.lineWidth,x),klineBorder.Top);
                this.Canvas.lineTo(ToFixedPoint2(this.Canvas.lineWidth,x),klineBorder.Bottom);
            }
            else
            {
                var y=this.Frame.GetYFromData(price,false);
                this.Canvas.moveTo(klineBorder.Left,ToFixedPoint2(this.Canvas.lineWidth,y));
                this.Canvas.lineTo(klineBorder.Right,ToFixedPoint2(this.Canvas.lineWidth,y));
            }
            
            this.Canvas.setLineDash(this.AvPriceLineDash);
            this.Canvas.stroke();
            this.Canvas.setLineDash([]);
        }
        this.RestoreLineWidth();

        this.DrawPoint(drawPoint);  //画点

        //绘制信息
        this.Canvas.textBaseline='top';
        this.Canvas.textAlign='left';
        this.Canvas.font=this.Font;
        this.Canvas.fillStyle=this.LineColor;
        var textOffset=2*GetDevicePixelRatio();
        var text=`K线数${kDataInfo.Count}`;
        if (this.IsHScreen) this.DrawText(text,klineBorder.Right,klineBorder.Top, textOffset, textOffset);
        else this.DrawText(text,klineBorder.Left,klineBorder.Top, textOffset, textOffset);

        if (avPriceText) 
        {
            if (this.IsHScreen) this.DrawText(avPriceText,x,klineBorder.Top, textOffset, textOffset);   //均价
            else this.DrawText(avPriceText,klineBorder.Left,y, textOffset, textOffset);   //均价
        }

        var yClose=IFrameSplitOperator.IsNumber(kDataInfo.YClose)? kDataInfo.YClose:kDataInfo.Open;
        var value=(kDataInfo.Close-yClose)/yClose*100;
        text=`${value.toFixed(2)}%`;
        if (this.IsHScreen) this.DrawText(text,klineBorder.Right,klineBorder.Bottom, textOffset, textOffset);
        else this.DrawText(text,klineBorder.Right,klineBorder.Top, textOffset, textOffset);

        value=kDataInfo.Close-yClose;
        text=`${value.toFixed(2)}`;
        this.Canvas.textBaseline='bottom';
        if (this.IsHScreen) this.DrawText(text,klineBorder.Left,klineBorder.Bottom, textOffset, 0);
        else this.DrawText(text,klineBorder.Right,klineBorder.Bottom, textOffset, 0);

        this.Canvas.restore();
    }

    this.Calculate=function(kPoint)
    {
        var startPoint=kPoint[0];
        var endPoint=kPoint[1];
        if (startPoint.XValue>endPoint.XValue)
        {
            startPoint=kPoint[1];
            endPoint=kPoint[0];
        }

        var data=this.Frame.Data.Data;
        var open, high, low, yClose, close, vol=0, amount=0;
        var count=0;
        for(var i=startPoint.XValue;i<=endPoint.XValue;++i, ++count)
        {
            var item=data[i];
            if (count==0)
            {
                yClose=item.YClose;
                open=item.Open;
                close=item.Close;
                low=item.Low;
                high=item.High;
            }
            else
            {
                close=item.Close;
                if (low>item.Low) low=item.Low;
                if (high<item.High)  high=item.High;
            }

            vol+=item.Vol;
            amount+=item.Amount;
        }

        var result={ YClose:yClose, Open:open, High:high, Low:low, Close:close, Count:count,Vol:vol, Amount:amount  };

        return result;
    }

    this.GetKLineBorder=function(drawPoint, kInfo)
    {
        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];
        var data=this.Frame.Data;
        if (this.IsHScreen)
        {
            var xValue=Math.round(this.Frame.GetXData(ptStart.Y,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var yStart=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            xValue=Math.round(this.Frame.GetXData(ptEnd.Y,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var yEnd=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            var xHigh=this.Frame.GetYFromData(kInfo.High,false);
            var xLow=this.Frame.GetYFromData(kInfo.Low,false);

            var result= { Left:xLow, Top:yStart, Right:xHigh, Bottom:yEnd };

            this.LinePoint.push({Start:{X:xLow, Y:yStart}, End:{X:yEnd, Y:yStart}});
            this.LinePoint.push({Start:{X:xLow, Y:yEnd}, End:{X:yEnd, Y:yEnd}});
            this.LinePoint.push({Start:{X:xLow, Y:yStart}, End:{X:xLow, Y:yEnd}});
            this.LinePoint.push({Start:{X:xHigh, Y:yStart}, End:{X:xHigh, Y:yEnd}});

            return result;
        }
        else
        {
            var xValue=Math.round(this.Frame.GetXData(ptStart.X,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var xStart=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            xValue=Math.round(this.Frame.GetXData(ptEnd.X,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var xEnd=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            var yHigh=this.Frame.GetYFromData(kInfo.High,false);
            var yLow=this.Frame.GetYFromData(kInfo.Low,false);
            var result= { Left:xStart, Top:yHigh, Right:xEnd, Bottom:yLow };

            this.LinePoint.push({Start:{X:xStart, Y:yHigh}, End:{X:xEnd, Y:yHigh}});
            this.LinePoint.push({Start:{X:xStart, Y:yLow}, End:{X:xEnd, Y:yLow}});
            this.LinePoint.push({Start:{X:xStart, Y:yHigh}, End:{X:xStart, Y:yLow}});
            this.LinePoint.push({Start:{X:xEnd, Y:yHigh}, End:{X:xEnd, Y:yLow}});

            return result;
        }
    }

    this.DrawText=function(text, x, y, xOffset, yOffset)
    {
        if (this.IsHScreen)
        {
            this.Canvas.save();
            this.Canvas.translate(x,y);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(text,xOffset,yOffset);
            this.Canvas.restore();
        }
        else
        {
            this.Canvas.fillText(text,x+xOffset,y+yOffset);
        }   
    }

}

function ChartDrawTwoPointDemo()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawTwoPointDemo';
    this.PointCount=2;
    this.Font=16*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.IsHScreen=false;
    this.PointInfo=[];  //保存点及点对应K线的信息

    this.PointToValue_Backup=this.PointToValue;
    this.PointToValue=function()
    {
        this.OnFinish();
        this.PointToValue_Backup();
    }

    //移动或创建完成
    this.OnFinish=function()
    {
        for(var i in this.PointInfo)
        {
            var item=this.PointInfo[i];
            if (!item || !item.Point || !IFrameSplitOperator.IsNumber(item.Point.Y2)) continue;
            this.Point[i].Y=this.PointInfo[i].Point.Y2; //点Y轴坐标调整
        }
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        this.PointInfo=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint) return;

        this.IsHScreen=this.Frame.IsHScreen;
        //this.CalculateLines(drawPoint);

        this.ClipFrame();
        this.SetLineWidth();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1]
        this.CalculatePointInfo(drawPoint); 
        if (this.Status==10)    //绘制完成
        {
            this.DrawEx();
        }
        else    //绘制中只画连线
        {
            for(var i=1;i<drawPoint.length;++i)
            {
                this.DrawLine(drawPoint[i-1],drawPoint[i]);
            }
        }

        this.RestoreLineWidth();
        this.DrawPoint(drawPoint); //画点
        this.Canvas.restore();
    }

    //计算点信息及K线信息
    this.CalculatePointInfo=function(drawPoint)
    {
        if (!this.Frame || !this.Frame.Data) return;
        var kPoint=this.PointToKLine(drawPoint);

        //3个点
        if (this.PointCount==3 && this.PointStatus==2 && this.LastPoint)
        {
            var pt=new Point();
            pt.X=this.LastPoint.X;
            pt.Y=this.LastPoint.Y;
            drawPoint[2]=pt;
        }

        var data=this.Frame.Data;
        for(var i in kPoint)
        {
            var item=kPoint[i];
            var pt=drawPoint[i];
            var kItem=data.Data[item.XValue];
            var obj={ KItem: kItem, Data:item, Point:{ X:pt.X, Y:pt.Y } };
            this.PointInfo.push(obj);
        }

        this.CalculateYPoint();

        JSConsole.Chart.Log('[ChartDrawTwoPointDemo::CalculateLines] kPoint', this.PointInfo);
    }

    //计算需要调整的Y轴坐标
    this.CalculateYPoint=function()
    {
        var ptStart=this.PointInfo[0];
        var yStart=this.Frame.GetYFromData(ptStart.KItem.Low,false);
        ptStart.Point.Y2=yStart;

        var ptEnd=this.PointInfo[1];
        var yEnd=this.Frame.GetYFromData(ptEnd.KItem.High,false);
        ptEnd.Point.Y2=yEnd;
    }

    this.DrawEx=function()
    {
        //起始点 结束点信息
        var startInfo=this.PointInfo[0];
        var endInfo=this.PointInfo[1];

        //K线边框信息
        var chartBorder=this.Frame.ChartBorder;
        var frameRight=chartBorder.GetRight();  //最右边

        var ptStart={X:startInfo.Point.X, Y:startInfo.Point.Y2 };
        var ptEnd={X:endInfo.Point.X, Y:endInfo.Point.Y2 };

        this.DrawLine(ptStart,ptEnd);
        this.LinePoint.push({Start:ptStart, End:ptEnd});

        this.Canvas.setLineDash([5,5]);
        //this.Canvas.lineWidth=2;
        var topPrice=endInfo.KItem.YClose*0.09+endInfo.KItem.High;    //结束点最高价+涨幅6% 画竖线
        var y=this.Frame.GetYFromData(topPrice,false);
        this.DrawLine({X:this.ToFixedPoint(ptEnd.X), Y:ptEnd.Y}, {X:this.ToFixedPoint(ptEnd.X), Y:y});

        this.Canvas.textAlign="right";
        this.Canvas.textBaseline = 'center';
        this.Canvas.fillStyle='rgb(33,45,100)';

        for(var i=3;i>0;--i)
        {
            var price=endInfo.KItem.YClose*(0.03*i)+endInfo.KItem.High;     //%2涨幅一档画线
            var y=this.Frame.GetYFromData(price,false);
            y=this.ToFixedPoint(y);

            //线段
            this.DrawLine({X:ptEnd.X, Y:y}, {X:ptEnd.X+100, Y:y});

            //文字
            this.Canvas.fillText(price.toFixed(2), ptEnd.X-5, y);
        }
        this.Canvas.setLineDash([]);
    }

    //防止竖线或横线模糊调整坐标
    this.ToFixedPoint=function(value,width)
    {
        if (!IFrameSplitOperator.IsNumber(width)) width=this.LineWidth;
        return ToFixedPoint2(width, value)
    }
}

function ChartDrawThreePointDemo()
{
    this.newMethod=ChartDrawTwoPointDemo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawThreePointDemo';
    this.PointCount=3;

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    //计算需要调整的Y轴坐标
    this.CalculateYPoint=function()
    {
        var y;
        for(var i in this.PointInfo)
        {
            var item=this.PointInfo[i];
            if (i==0 || i==2) y=this.Frame.GetYFromData(item.KItem.Low,false);
            else y=this.Frame.GetYFromData(item.KItem.High,false);
            item.Point.Y2=y;
        }
    }

    this.DrawEx=function()
    {
        //起始点 结束点信息
        var startInfo=this.PointInfo[0];
        var secondInfo=this.PointInfo[1];
        var endInfo=this.PointInfo[2];

        //K线边框信息
        var chartBorder=this.Frame.ChartBorder;
        var frameRight=chartBorder.GetRight();  //右边
        var frameLeft=chartBorder.GetLeft();    //左边

        var ptStart={ X:startInfo.Point.X, Y:startInfo.Point.Y2 };
        var ptSecond={ X:secondInfo.Point.X, Y:secondInfo.Point.Y2};
        var ptEnd={ X:endInfo.Point.X, Y:endInfo.Point.Y2 };

        this.DrawLine(ptStart,ptSecond);
        this.DrawLine(ptSecond,ptEnd);
        this.LinePoint.push({Start:ptStart, End:ptSecond});
        this.LinePoint.push({Start:ptSecond, End:ptEnd});

        this.Canvas.setLineDash([5,5]);
        //this.Canvas.lineWidth=2;
        var topPrice=endInfo.KItem.YClose*0.09+endInfo.KItem.High;    //结束点最高价+涨幅6% 画竖线
        var y=this.Frame.GetYFromData(topPrice,false);
        this.DrawLine({X:this.ToFixedPoint(ptEnd.X), Y:ptEnd.Y}, {X:this.ToFixedPoint(ptEnd.X), Y:y});

        this.Canvas.textAlign="right";
        this.Canvas.textBaseline = 'center';
        this.Canvas.fillStyle='rgb(33,45,100)';

        for(var i=3;i>0;--i)
        {
            var price=endInfo.KItem.YClose*(0.03*i)+endInfo.KItem.High;     //%2涨幅一档画线
            var y=this.Frame.GetYFromData(price,false);
            y=this.ToFixedPoint(y);

            //线段
            this.DrawLine({X:ptEnd.X, Y:y}, {X:ptEnd.X+100, Y:y});

            //文字
            this.Canvas.fillText(price.toFixed(2), ptEnd.X-5, y);
        }
        this.Canvas.setLineDash([]);
    }
}

//画图工具-水平线段
function ChartDrawHLineSegment()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawHLineSegment';
    this.PointCount=2;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.ChartBorder;

    this.PointToValue_Backup=this.PointToValue;
    this.PointToValue=function()
    {
        //拖拽完成 把点移动到线段头尾
        if (this.Frame.IsHScreen)
        {
            this.Point[1].X=this.Point[0].X;
        }
        else
        {
            this.Point[1].Y=this.Point[0].Y;
        }
        
        this.PointToValue_Backup();
    }

    this.GetXYCoordinate=function()
    {
        if (this.IsFrameMinSize()) return null;
        var drawPoint=this.CalculateDrawPoint({ IsCheckX:false, IsCheckY:true });

        return this.PointRange(drawPoint);
    }

    this.Draw=function()
    {
        if (!this.Frame) return;
        this.IsHScreen=this.Frame.IsHScreen;
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( { IsCheckX:false, IsCheckY:true} );
        if (!drawPoint || drawPoint.length!=2) return;

        this.ClipFrame();
        this.ChartBorder=this.Frame.ChartBorder;
        
        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        if (this.Status==10)    //0=开始画 1=完成第1个点  2=完成第2个点 3=完成第3个点  10=完成 20=移动)
        {
            this.DrawLine(ptStart,ptEnd,false);
        }  
        else
        {
            //var kPoint=this.PointToKLine([ptStart,ptEnd]);
            this.DrawVerticalLine(ptStart,ptEnd);
        }                            
        
        this.RestoreLineWidth();

        var line={ Start:ptStart, End:ptEnd };
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.DrawVerticalLine=function(ptStart, ptEnd)
    {
        var data=this.Frame.Data;
        if (this.IsHScreen)
        {
            var left=this.ChartBorder.GetLeft();
            var right=this.ChartBorder.GetRight();
            var xValue=Math.round(this.Frame.GetXData(ptStart.Y,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var yStart=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            xValue=Math.round(this.Frame.GetXData(ptEnd.Y,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var yEnd=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);

            this.Canvas.beginPath();
            this.Canvas.moveTo(left,yStart);
            this.Canvas.lineTo(right,yStart);
    
            this.Canvas.moveTo(left,yEnd);
            this.Canvas.lineTo(right,yEnd);
            this.Canvas.stroke();

            this.Canvas.beginPath();
            this.Canvas.moveTo(ptStart.X,yStart);
            this.Canvas.lineTo(ptStart.X,yEnd);
            this.Canvas.stroke();
        }
        else
        {
            var top=this.ChartBorder.GetTopEx();
            var bottom=this.ChartBorder.GetBottomEx();
            
            var xValue=Math.round(this.Frame.GetXData(ptStart.X,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var xStart=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);
    
            xValue=Math.round(this.Frame.GetXData(ptEnd.X,false))+data.DataOffset;
            if (xValue<0) xValue=0;
            else if (xValue>=data.Data.length) xValue=data.Data.length-1;
            var xEnd=this.Frame.GetXFromIndex(xValue-data.DataOffset,false);
    
            this.Canvas.beginPath();
            this.Canvas.moveTo(xStart,top);
            this.Canvas.lineTo(xStart,bottom);
    
            this.Canvas.moveTo(xEnd,top);
            this.Canvas.lineTo(xEnd,bottom);
            this.Canvas.stroke();
    
            this.Canvas.beginPath();
            this.Canvas.moveTo(xStart,ptStart.Y);
            this.Canvas.lineTo(xEnd,ptStart.Y);
            this.Canvas.stroke();
        }
    }
}

//画图工具-volume profile fixed range
function ChartDrawVolProfile()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawVolProfile';
    this.PointCount=2;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.ChartBorder;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
   
    this.IsShowText=true;   //是否显示成交量数据
    this.VolType=0;         //0=up|down bar  1=total bar
    this.BarPosition=0;     //柱子方向 0=左边  1=右边
    this.VolFont;
    this.VAVol=60;          //Value area volume
    this.BarWidthRate=0.3;
    
    this.Data;
    this.MaxVol;
    this.MaxVolPrice;

    this.DataStatus=0;  //0=请求总  1=完成

    this.BGColor=g_JSChartResource.ChartDrawVolProfile.BGColor;
    this.BorderColor=g_JSChartResource.ChartDrawVolProfile.BorderColor;
    this.VolLineColor=g_JSChartResource.ChartDrawVolProfile.VolLineColor;
    
    this.TextConfig=
    {
        Color:g_JSChartResource.ChartDrawVolProfile.Text.Color,
        Family:g_JSChartResource.ChartDrawVolProfile.Text.Family,
        FontMaxSize:g_JSChartResource.ChartDrawVolProfile.Text.FontMaxSize,
        FontMinSize:g_JSChartResource.ChartDrawVolProfile.Text.FontMinSize,
        Color:g_JSChartResource.ChartDrawVolProfile.Text.Color,
    }

    this.BarColor=
    [
        g_JSChartResource.ChartDrawVolProfile.UpVolColor,
        g_JSChartResource.ChartDrawVolProfile.DownVolColor,
        g_JSChartResource.ChartDrawVolProfile.AreaUpColor,
        g_JSChartResource.ChartDrawVolProfile.AreaDonwColor
    ]

    this.Super_SetOption=this.SetOption;    //父类函数
    this.SetOption=function(option)
    {
        if (this.Super_SetOption) this.Super_SetOption(option);
        if (option)
        {
            if (option.BGColor) this.BGColor=option.BGColor;
            if (option.BorderColor) this.BGColor=option.BorderColor;
            if (option.VolLineColor) this.BGColor=option.VolLineColor;

            if (option.UpVolColor) this.BarColor[0]=option.UpVolColor;
            if (option.DownVolColor) this.BarColor[1]=option.DownVolColor;
            if (option.AreaUpColor) this.BarColor[2]=option.AreaUpColor;
            if (option.AreaDonwColor) this.BarColor[3]=option.AreaDonwColor;
            if (IFrameSplitOperator.IsNumber(option.BarWidthRate)) this.BarWidthRate=option.BarWidthRate;

            if (IFrameSplitOperator.IsBool(option.IsShowText)) this.IsShowText=option.IsShowText;
            if (IFrameSplitOperator.IsNumber(option.VolType)) this.VolType=option.VolType;
            if (IFrameSplitOperator.IsNumber(option.BarPosition)) this.BarPosition=option.BarPosition;
            if (IFrameSplitOperator.IsNumber(option.VAVol)) this.VAVol=option.VAVol;
        }
    }
    
    this.OnFinish=function()
    {
        this.RequestVolumeProfileData();
    }

    this.OnMoveFinish=function()
    {
        this.RequestVolumeProfileData();
    }

    this.IsDrawMain=function()  //选中绘制在动态绘图上， 没有选中绘制在背景上
    {
        if (!this.GetActiveDrawPicture) return true;

        var active=this.GetActiveDrawPicture();
        if (active.Select.Guid==this.Guid) return false;

        return true;
    }

    this.RequestVolumeProfileData=function()
    {
        //请求数据
        var start=this.Value[0], end=this.Value[1];
        if (start.XValue>end.XValue)
        {
            start=this.Value[1];
            end=this.Value[0];
        }

        var option={ Start:{ Date:start.DateTime.Date, DataIndex:start.XValue }, End:{ Date:end.DateTime.Date, DataIndex:end.XValue }, Chart:this };
        if (IFrameSplitOperator.IsNumber(start.DateTime.Time)) option.Start.Time=start.DateTime.Time;
        if (IFrameSplitOperator.IsNumber(end.DateTime.Time)) option.End.Time=end.DateTime.Time;
        option.ValueAreaVol=this.VAVol;

        this.DataStatus=0
        if (this.HQChart && this.HQChart.RequestVolumeProfileData)
        {
            this.HQChart.RequestVolumeProfileData(option);
        }
    }

    this.OnRecvVolumeProfileData=function(data)
    {
        if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) return;

        var maxVol=0,vol=0;
        var maxVolPrice=null;
        for(var i=0, j=0;i<data.Data.length;++i)
        {
            var item=data.Data[i];
            vol=0;
            for(j=0; j<item.Vol.length;++j)
            {
                var volItem=item.Vol[j];
                if (IFrameSplitOperator.IsNumber(volItem.Value)) vol+=volItem.Value;
            }

            if (maxVol<vol) 
            {
                maxVol=vol;
                maxVolPrice=item.Price;
            }
        }

        this.MaxVolPrice=maxVolPrice;
        this.MaxVol=maxVol;

        if (this.MaxVolPrice<=0 || this.MaxVol<=0) return;

        if (!IFrameSplitOperator.IsNumber(data.MaxPrice) || !IFrameSplitOperator.IsNumber(data.MinPrice)) return;

        var yHigh=this.Frame.GetYFromData(data.MaxPrice,false);
        var yLow=this.Frame.GetYFromData(data.MinPrice,false);

        this.Point[0].Y=yHigh;
        this.Point[1].Y=yLow;
        this.PointToValue();

        this.Data=data;
        this.DataStatus=1;
    }

    this.Draw=function()
    {
        this.VolFont=null;

        if (!this.IsDrawMain()) this.MainDraw();

        if (this.IsFrameMinSize()) return;
        if (this.Frame) this.ChartBorder=this.Frame.ChartBorder;

        var drawPoint=this.CalculateDrawPoint( { IsCheckX:true, IsCheckY:true} );
        if (!drawPoint || drawPoint.length!=2) return;
        
        this.ClipFrame();
        this.SetLineWidth();
        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

         //0=开始画 1=完成第1个点  2=完成第2个点 3=完成第3个点  10=完成 20=移动)
        if (this.Status==10)
        {
            if (this.DataStatus==0) this.DrawLineBorder(ptStart,ptEnd);
        }  
        else
        {
            this.DrawLineBorder(ptStart,ptEnd);
        }                            
        
        this.RestoreLineWidth();

        this.DrawPoint(drawPoint);  //画点
        
        this.Canvas.restore();
    }

    this.MainDraw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (this.DataStatus!=1) return;
        if (this.Status!=10) return;

        this.ClipFrame();

        var drawPoint=this.CalculateDrawPoint( { IsCheckX:true, IsCheckY:true} );

        this.DrawVolBar();

        this.Canvas.restore();
    }

    this.DrawLineBorder=function(ptStart, ptEnd)
    {
        this.Canvas.strokeStyle=this.LineColor;

        var top=this.ChartBorder.GetTopEx();
        var bottom=this.ChartBorder.GetBottomEx();

        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X, ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);

        this.Canvas.moveTo(ptStart.X,top);
        this.Canvas.lineTo(ptStart.X,bottom);

        this.Canvas.moveTo(ptEnd.X,top);
        this.Canvas.lineTo(ptEnd.X,bottom);
        this.Canvas.stroke();
    }

    this.DrawVolBar=function()
    {
        var start=this.Value[0], end=this.Value[1];
        if (start.XValue>end.XValue)
        {
            start=this.Value[1];
            end=this.Value[0];
        }
        
        var dataOffset=this.GetKDataOffset();
        var cellHeight=this.GetPriceYOffset(this.Data.PriceOffset);
        var left=this.Frame.GetXFromIndex(start.XValue-dataOffset,false);
        var right=this.Frame.GetXFromIndex(end.XValue-dataOffset,false);
        var top=this.Frame.GetYFromData(this.Data.MaxPrice)-cellHeight/2;
        var bottom=this.Frame.GetYFromData(this.Data.MinPrice)+cellHeight/2;
        var width=right-left;
        var height=bottom-top;
        var maxBarWidth=width*this.BarWidthRate;

        this.Canvas.fillStyle=this.BGColor;  
        //JSConsole.Chart.Log('[ChartDrawVolProfile::DrawVolBar] BGColor ', this.BGColor);
        this.Canvas.fillRect(left,top,width,height);   //背景

        if (this.MaxVolPrice>=this.Frame.HorizontalMin&& this.MaxVolPrice<=this.Frame.HorizontalMax)
        {
            var lineWidth=2;
            var yLine=ToFixedPoint2(lineWidth,this.Frame.GetYFromData(this.MaxVolPrice,false));
            this.Canvas.lineWidth=lineWidth;
            this.Canvas.strokeStyle=this.VolLineColor;
            this.Canvas.beginPath();
            this.Canvas.moveTo(left,yLine);
            this.Canvas.lineTo(right,yLine);
            this.Canvas.stroke();

            var linePoint= { Start:{X:left,Y:yLine}, End:{X:right,Y:yLine} };
            this.LinePoint.push(linePoint);
        }

        if (this.IsShowText)
        {
            this.VolFont=this.GetDynamicVolTextFont(cellHeight, maxBarWidth);
            if (this.VolFont) this.Canvas.font=this.VolFont;
        }
        
        //this.Canvas.lineWidth=1;
        for(var i=0;i<this.Data.Data.length;++i)
        {
            var item=this.Data.Data[i];
            if (item.Price<this.Frame.HorizontalMin || item.Price>this.Frame.HorizontalMax) continue;

            this.DrawVolBarItem(item, left, right, maxBarWidth, cellHeight);
        }
    }

    this.DrawVolBarItem=function(item, left, right, maxBarWidth, cellHeight)
    {
        var barLeft=left;
        var barRight=right;
        var barTop=this.Frame.GetYFromData(item.Price)-cellHeight/2;
        var barHeight=cellHeight-1;
        if (barHeight<1) barHeight=1;

        if (this.VolType==1)
        {
            if (!item.TotalVol) return;
            if (!IFrameSplitOperator.IsNumber(item.TotalVol.Value)) return;
            var barWidth=item.TotalVol.Value*maxBarWidth/this.MaxVol;

            var color;
            if (IFrameSplitOperator.IsNumber(item.TotalVol.ColorID)) color=this.BarColor[item.TotalVol.ColorID];
            else if (item.TotalVol.Color) color=item.TotalVol.Color;

            this.Canvas.fillStyle=color;
            if (this.BarPosition==1)
            {
                this.Canvas.fillRect(barRight,ToFixedRect(barTop),-barWidth,ToFixedRect(barHeight));
            }
            else
            {
                this.Canvas.fillRect(barLeft,ToFixedRect(barTop),barWidth,ToFixedRect(barHeight));
            }
            
            if (this.IsShowText && this.VolFont)
            {
                var text=IFrameSplitOperator.FormatVolString(item.TotalVol.Value, this.HQChart.LanguageID);
                this.Canvas.textBaseline = 'middle';
                this.Canvas.fillStyle=this.TextConfig.Color;
                if (this.BarPosition==1)
                {
                    this.Canvas.textAlign = 'right';
                    this.Canvas.fillText(text,right-5,barTop+cellHeight/2);
                }
                else
                {
                    this.Canvas.textAlign = 'left';
                    this.Canvas.fillText(text,left+5,barTop+cellHeight/2);
                }
                
            }
        }
        else
        {
            var text="";
            for(var i=0;i<item.Vol.length;++i)
            {
                var volItem=item.Vol[i];
    
                if (!IFrameSplitOperator.IsNumber(volItem.Value)) continue;
                
                var color;
                if (IFrameSplitOperator.IsNumber(volItem.ColorID)) color=this.BarColor[volItem.ColorID];
                else if (volItem.Color) color=volItem.Color;
    
                if (!color) continue;
                
                var barWidth=volItem.Value*maxBarWidth/this.MaxVol;
                this.Canvas.fillStyle=color;

                if (this.BarPosition==1)
                {
                    this.Canvas.fillRect(barRight,ToFixedRect(barTop),-barWidth,ToFixedRect(barHeight));
                    barRight-=barWidth;
                }
                else
                {
                    this.Canvas.fillRect(barLeft,ToFixedRect(barTop),barWidth,ToFixedRect(barHeight));
                    barLeft+=barWidth;
                }
                
                var volText=IFrameSplitOperator.FormatVolString(volItem.Value, this.HQChart.LanguageID);
                if (text.length>0) text+="x";
                text+=volText;
            }

            if (this.IsShowText && this.VolFont)
            {
                
                this.Canvas.textBaseline = 'middle';
                this.Canvas.fillStyle=this.TextConfig.Color;
                if (this.BarPosition==1)
                {
                    this.Canvas.textAlign = 'right';
                    this.Canvas.fillText(text,right-5,barTop+cellHeight/2);
                }
                else
                {
                    this.Canvas.textAlign = 'left';
                    this.Canvas.fillText(text,left+5,barTop+cellHeight/2);
                }
                
            }
        }
    }

    this.GetKDataOffset=function()
    {
        var kData=this.HQChart.ChartPaint[0].Data;
        return kData.DataOffset;
    }

    this.GetPriceYOffset=function(value)
    {
        var frame=this.Frame
        var y=frame.ChartBorder.GetHeightEx()*(value)/(frame.HorizontalMax-frame.HorizontalMin);
        return y;
    }


    this.GetDynamicVolTextFont=function(cellHeight, width, fontOption)
    {
        var fontSize=parseInt(cellHeight)-2;
        if (cellHeight<5) fontSize=parseInt(cellHeight);    //高度太小了就不要上下间距了
        if (fontSize>this.TextConfig.FontMaxSize) fontSize=this.TextConfig.FontMaxSize;
        else if (fontSize<=0) fontSize=1;

        if (fontSize<this.TextConfig.FontMinSize) return null;

        var font=this.FormatFontString(fontSize, this.TextConfig.Family, fontOption);

        return font;
    }

    this.FormatFontString=function(fontSize, family, option)
    {
        var font;
        if (!option) 
        {
            font=`${fontSize}px ${family}`;
        }
        else
        {
            if (option.Weight) font=`${option.Weight} ${fontSize}px ${family}`;
        }

        return font;
    }
    
}

//画图工具 tradingview

function ChartDrawNote()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawNote';
    this.PointCount=1;

    //矢量图片
    this.Text=g_JSChartResource.ChartDrawNote.Text;
    this.FontOption={ Family:g_JSChartResource.ChartDrawNote.FontOption.Family, Size:g_JSChartResource.ChartDrawNote.FontOption.Size };    //Weight(bold 粗体), Style(italic)
    
    this.AryNoteText=[ {Text:"输入内容 ......"}];
    /*
    this.AryNoteText=
    [ 
        {Text:"  北京时间6月5日，U20世界杯1/4决赛全部结束，韩国创造历史，将在半决赛对阵意大利，另一场半决赛则是以色列对阵乌拉圭", } , 
        {Text:"", }, 
        {Text:"  韩国是上届U20世界杯亚军，今年他们经过加时赛1-0力克淘汰阿根廷的尼日利亚，历史上第三次进入四强，亚洲球队最多，也是第一支连续两届晋级四强的球队。", }
    ];
    */

    this.NoteFontOption=
    {
        Family:g_JSChartResource.ChartDrawNote.NoteFontOption.Family,
        Size:g_JSChartResource.ChartDrawNote.NoteFontOption.Size,
        Weight:g_JSChartResource.ChartDrawNote.NoteFontOption.Weight,
        Style:g_JSChartResource.ChartDrawNote.NoteFontOption.Style
    }

    this.NoteWidth=g_JSChartResource.ChartDrawNote.NoteWidth;
    this.NoteMargin=
    { 
        Left:g_JSChartResource.ChartDrawNote.NoteMargin.Left, 
        Top:g_JSChartResource.ChartDrawNote.NoteMargin.Top, 
        Bottom:g_JSChartResource.ChartDrawNote.NoteMargin.Bottom, 
        Right:g_JSChartResource.ChartDrawNote.NoteMargin.Right
    };
    this.NoteBGColor=g_JSChartResource.ChartDrawNote.NoteBGColor;
    this.NoteTextColor=g_JSChartResource.ChartDrawNote.NoteTextColor;
    this.NoteBorderColor=g_JSChartResource.ChartDrawNote.NoteBorderColor;
    this.LineSpace=g_JSChartResource.ChartDrawNote.LineSpace; //行间距
    this.ArrowSize=g_JSChartResource.ChartDrawNote.ArrowSize;

    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=false;

    //内部变量
    this.PtButtom;
    this.PtTop;
    this.TextRect=null;         //文字区域
    this.PtCenter;
    

    this.SetOption_Backup=this.SetOption;
    this.SetOption=function(option)
    {
        this.SetOption_Backup(option);

        if (!option) return;

        if (option.Text) this.Text=option.Text;
        if (option.FontOption) this.SetFont(this.FontOption, option.FontOption);
        if (option.NoteFontOption) this.SetFont(this.NoteFontOption, option.NoteFontOption);

        if (IFrameSplitOperator.IsNumber(option.NoteWidth)) this.NoteWidth=option.NoteWidth;
        if (option.NoteMargin)
        {
            var item=option.NoteMargin;
            if (IFrameSplitOperator.IsNumber(item.Left)) this.NoteMargin.Left=item.Left;
            if (IFrameSplitOperator.IsNumber(item.Top)) this.NoteMargin.Top=item.Top;
            if (IFrameSplitOperator.IsNumber(item.Bottom)) this.NoteMargin.Bottom=item.Bottom;
            if (IFrameSplitOperator.IsNumber(item.Right)) this.NoteMargin.Right=item.Right;
        }

        if (option.NoteBGColor) this.NoteBGColor=option.NoteBGColor;
        if (option.NoteTextColor) this.NoteTextColor=option.NoteTextColor;
        if (option.NoteBorderColor) this.NoteBorderColor=option.NoteBorderColor;
        if (IFrameSplitOperator.IsNumber(option.LineSpace)) this.LineSpace=option.LineSpace;
        if (IFrameSplitOperator.IsNumber(option.ArrowSize)) this.ArrowSize=option.ArrowSize;

        if (IFrameSplitOperator.IsNonEmptyArray(option.AryNoteText)) this.AryNoteText=this.CloneArrayText(option.AryNoteText);
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();
        storageData.Value=[];

        if (this.Value && this.Value[0])
        {
            var item=this.Value[0];
            storageData.Value.push({ XValue:item.XValue, YValue:item.YValue, DateTime:item.DateTime });
        }

        storageData.NoteFont=this.NoteFont;
        storageData.NoteWidth=this.NoteWidth;
        storageData.NoteBGColor=this.NoteBGColor;
        storageData.NoteTextColor=this.NoteTextColor;
        storageData.NoteBorderColor=this.NoteBorderColor;
        storageData.LineSpace=this.LineSpace;
        storageData.ArrowSize=this.ArrowSize;
        storageData.NoteMargin={ Left:this.NoteMargin.Left, Top:this.NoteMargin.Right, Bottom:this.NoteMargin.Bottom, Right:this.NoteMargin.Right };

        storageData.AryNoteText=this.CloneArrayText(this.AryNoteText);

        return storageData;
    }

    this.ImportStorageData=function(storageData)
    {
        if (storageData.NoteFont) this.NoteFont=storageData.NoteFont;
        if (IFrameSplitOperator.IsNumber(storageData.NoteWidth)) this.NoteWidth=storageData.NoteWidth;
        if (storageData.NoteMargin)
        {
            var item=storageData.NoteMargin;
            if (IFrameSplitOperator.IsNumber(item.Left)) this.NoteMargin.Left=item.Left;
            if (IFrameSplitOperator.IsNumber(item.Top)) this.NoteMargin.Top=item.Top;
            if (IFrameSplitOperator.IsNumber(item.Bottom)) this.NoteMargin.Bottom=item.Bottom;
            if (IFrameSplitOperator.IsNumber(item.Right)) this.NoteMargin.Right=item.Right;
        }

        if (storageData.NoteBGColor) this.NoteBGColor=storageData.NoteBGColor;
        if (storageData.NoteTextColor) this.NoteTextColor=storageData.NoteTextColor;
        this.NoteBorderColor=storageData.NoteBorderColor;
        if (IFrameSplitOperator.IsNumber(storageData.LineSpace)) this.LineSpace=storageData.LineSpace;
        if (IFrameSplitOperator.IsNumber(storageData.ArrowSize)) this.ArrowSize=storageData.ArrowSize;
        
        this.AryNoteText=this.CloneArrayText(storageData.AryNoteText);
    }

    this.Draw=function()
    {
        this.PtButtom=null;
        this.PtTop=null;
        this.TextRect=null;
        this.PtCenter=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint || drawPoint.length!=1) return;
        var font=this.GetTextFont();
        if (!font) return;

        this.ClipFrame();

        var isHScreen=this.Frame.IsHScreen;
        var pixel=GetDevicePixelRatio();

        this.Canvas.fillStyle=this.LineColor;
        this.Canvas.textAlign="center";
        this.Canvas.textBaseline="middle";
        this.Canvas.font=font;

        if (isHScreen)
        {
            this.Canvas.translate(drawPoint[0].X, drawPoint[0].Y);
            this.Canvas.rotate(90 * Math.PI / 180);
            this.Canvas.fillText(this.Text,0,0);

            this.PtButtom={ X:drawPoint[0].X, Y:drawPoint[0].Y+this.FontOption.Size*pixel/2+2 };
            this.PtTop={ X:drawPoint[0].X, Y:drawPoint[0].Y-this.FontOption.Size*pixel/2-2};
            this.PtCenter=drawPoint[0];

            var ptSelected={X:drawPoint[0].X-this.FontOption.Size*pixel/2-2, Y:drawPoint[0].Y};
        }
        else
        {
            this.Canvas.fillText(this.Text,drawPoint[0].X,drawPoint[0].Y);

            this.PtButtom={ X:drawPoint[0].X, Y:drawPoint[0].Y+this.FontOption.Size*pixel/2+2 };
            this.PtTop={ X:drawPoint[0].X, Y:drawPoint[0].Y-this.FontOption.Size*pixel/2-2 };

            var ptSelected={X:this.PtButtom.X, Y:this.PtButtom.Y};
        }
        
        var textWidth=this.Canvas.measureText(this.Text).width;
        this.TextRect={};
        this.TextRect.Left=drawPoint[0].X-textWidth/2;
        this.TextRect.Top=drawPoint[0].Y-(this.FontOption.Size*pixel)/2;
        this.TextRect.Width=textWidth;
        this.TextRect.Height=this.FontOption.Size*pixel;

        if (this.IsShowNoteText())
            this.DrawText();

        //this.Canvas.strokeRect(this.TextRect.Left,this.TextRect.Top,this.TextRect.Width,this.TextRect.Height);

        this.Canvas.restore();

        this.DrawPoint([ptSelected]);  //画点
    }

    this.DrawText=function()
    {
        this.Canvas.font=this.GetFontString(this.NoteFontOption);
        
        var height=0;
        var lineHeight=this.Canvas.measureText("擎").width;
        var border=this.Frame.GetBorder();
        var pixel=GetDevicePixelRatio();
        var isHScreen=this.Frame.IsHScreen;
        var width=this.NoteWidth;

        var aryText=[];
        if (IFrameSplitOperator.IsNonEmptyArray(this.AryNoteText))
        {
            for(var i=0; i<this.AryNoteText.length; ++i)
            {
                var item=this.AryNoteText[i];
                if (!item) continue;
    
                if (height>0) height+=this.LineSpace;
                if (item.Text)
                {
                    var value=this.GetMultiLineText(item.Text, width);
                    if (value && IFrameSplitOperator.IsNonEmptyArray(value.AryText))
                    {
                        for(var j=0; j<value.AryText.length; ++j)
                        {
                            if (j>0) height+=this.LineSpace;
                            var textItem=value.AryText[j];
                            aryText.push(textItem);
                            height+=lineHeight;
                        }
                    }
                }
                else
                {
                    aryText.push({Text:""});
                    height+=lineHeight;
                }
            }
        }
        else
        {
            height=lineHeight;
        }

        var rtBG={ Width:width+this.NoteMargin.Left+this.NoteMargin.Right, Height:height+this.NoteMargin.Top+this.NoteMargin.Bottom, ArrowType:0 };

        if (isHScreen)
        {
            rtBG.Left=this.PtTop.X-rtBG.Width/2-this.PtCenter.X;
            rtBG.Top=this.PtTop.Y-rtBG.Height-this.ArrowSize-this.PtCenter.Y;
            rtBG.Right=rtBG.Left+rtBG.Width;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
            rtBG.Arrow={ X:this.PtTop.X-this.PtCenter.X, Y:this.PtTop.Y-this.PtCenter.Y};  //Type 0=向下箭头 1=向上箭头

            if (this.PtCenter.X+height+this.FontOption.Size*pixel/2+2+this.ArrowSize>border.RightEx)
            {
                rtBG.Top=this.PtButtom.Y+this.ArrowSize+this.PointRadius*pixel-this.PtCenter.Y;
                rtBG.Bottom=rtBG.Top+rtBG.Height;
                rtBG.Arrow.X=this.PtButtom.X-this.PtCenter.X;
                rtBG.Arrow.Y=this.PtButtom.Y-this.PtCenter.Y;
                rtBG.ArrowType=1;
            }
        }
        else
        {
            rtBG.Left=this.PtTop.X-rtBG.Width/2;
            rtBG.Top=this.PtTop.Y-rtBG.Height-this.ArrowSize;
            rtBG.Right=rtBG.Left+rtBG.Width;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
            rtBG.Arrow={ X:this.PtTop.X, Y:this.PtTop.Y};  //Type 0=向下箭头 1=向上箭头
            
            if (rtBG.Left<border.Left)
            {
                rtBG.Left=border.Left;
                rtBG.Right=rtBG.Left+rtBG.Width;
            }
            else if (rtBG.Right>border.Right)
            {
                rtBG.Right=border.Right;
                rtBG.Left=rtBG.Right-rtBG.Width;
            }
    
            if (rtBG.Top<border.TopEx)
            {
                rtBG.Top=this.PtButtom.Y+this.ArrowSize+this.PointRadius*pixel;
                rtBG.Bottom=rtBG.Top+rtBG.Height;
                rtBG.Arrow.X=this.PtButtom.X;
                rtBG.Arrow.Y=this.PtButtom.Y;
                rtBG.ArrowType=1;
            }
        }

        this.DrawNoteBG(rtBG);

        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="top";
        this.Canvas.fillStyle=this.NoteTextColor;

        var xText=rtBG.Left+this.NoteMargin.Left;
        var yText=rtBG.Top+this.NoteMargin.Top;

        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            if (!item) continue;

            if (item.Text)
            {
                this.Canvas.fillText(item.Text,xText,yText);
                yText+=lineHeight;
            }
            else
            {
                yText+=lineHeight;
            }

            yText+=this.LineSpace;
        }
    }

    this.DrawNoteBG=function(rtBG)
    {
        this.Canvas.fillStyle=this.NoteBGColor;
       
        if (rtBG.ArrowType==0 || rtBG.ArrowType==1)
        {
            var path=new Path2D();
            if (rtBG.ArrowType==0)
            {
                path.moveTo(rtBG.Left, rtBG.Bottom);
                path.lineTo(rtBG.Left, rtBG.Top);
                path.lineTo(rtBG.Right, rtBG.Top);
                path.lineTo(rtBG.Right,rtBG.Bottom);

                var x=rtBG.Arrow.X+this.ArrowSize*0.6;
                path.lineTo(x,rtBG.Bottom);

                path.lineTo(rtBG.Arrow.X, rtBG.Arrow.Y);

                var x=rtBG.Arrow.X-this.ArrowSize*0.6;
                path.lineTo(x,rtBG.Bottom);
            }
            else
            {
                path.moveTo(rtBG.Left, rtBG.Top);
                path.lineTo(rtBG.Left, rtBG.Bottom);
                path.lineTo(rtBG.Right, rtBG.Bottom);
                path.lineTo(rtBG.Right, rtBG.Top);

                var x=rtBG.Arrow.X+this.ArrowSize*0.6;
                path.lineTo(x,rtBG.Top);

                path.lineTo(rtBG.Arrow.X, rtBG.Arrow.Y);

                var x=rtBG.Arrow.X-this.ArrowSize*0.6;
                path.lineTo(x,rtBG.Top);
            }

            path.closePath();
            this.Canvas.fill(path);

            if (this.NoteBorderColor) 
            {
                this.Canvas.strokeStyle=this.NoteBorderColor;
                this.Canvas.stroke(path);
            }
        }
        else
        {
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
        }
    }

    this.IsShowNoteText=function()
    {
        if (this.GetActiveDrawPicture)
        {
            var active=this.GetActiveDrawPicture();
            if (active.Move.Guid!=this.Guid && active.Select.Guid!=this.Guid && active.MoveOn.Guid!=this.Guid) 
                return false;
            
            //if (active.Select.Guid!=this.Guid && active.MoveOn.Guid==this.Guid)
            //    return true;

            return true;
        }

        return false;
    }

    //根据设置动态生成字体
    this.GetTextFont=function()
    {
        if (!this.FontOption || !this.FontOption.Family || this.FontOption.Size<=0) return null;

        var font='';
        if (this.FontOption.Size>=0) font+=this.FontOption.Size*GetDevicePixelRatio()+'px ';
        font+=this.FontOption.Family;

        return font;
    }

    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;
        if (!this.TextRect) return -1;

        var offset=0;
        if (this.Option && this.Option.Zoom>=1)
        {
            offset=this.Option.Zoom*GetDevicePixelRatio();
        }

        var rect={ Left:this.TextRect.Left-offset, Top:this.TextRect.Top-offset, Width:this.TextRect.Width+offset*2, Height:this.TextRect.Height+offset*2 };
        rect.Right=rect.Left+rect.Width;
        rect.Bottom=rect.Top+rect.Height;

        if (x>rect.Left && x<rect.Right && y>rect.Top && y<rect.Bottom) 
            return 100;

        return -1;
    }

    this.GetCursorType=function(ptIndex)
    {
        if (ptIndex==100) return "pointer";
        return null;
    }

}


function ChartDrawAnchoredText()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawAnchoredText';
    this.PointCount=1;

    this.AryText=[ {Text:"输入内容"} ];
    this.TextColor=g_JSChartResource.ChartDrawAnchoredText.TextColor;
    this.FontOption=
    { 
        Family:g_JSChartResource.ChartDrawAnchoredText.FontOption.Family,
        Size:g_JSChartResource.ChartDrawAnchoredText.FontOption.Size,
        Weight:g_JSChartResource.ChartDrawAnchoredText.FontOption.Weight,
        Style:g_JSChartResource.ChartDrawAnchoredText.FontOption.Style
    };    
    this.TextMaxWidth=g_JSChartResource.ChartDrawAnchoredText.TextMaxWidth;   //文本最大宽度
    this.LineSpace=g_JSChartResource.ChartDrawAnchoredText.LineSpace;
    this.BGColor=g_JSChartResource.ChartDrawAnchoredText.BGColor;
    this.BorderColor=g_JSChartResource.ChartDrawAnchoredText.BorderColor;

    this.TextMargin=
    { 
        Left:g_JSChartResource.ChartDrawAnchoredText.TextMargin.Left, 
        Top:g_JSChartResource.ChartDrawAnchoredText.TextMargin.Top, 
        Bottom:g_JSChartResource.ChartDrawAnchoredText.TextMargin.Bottom, 
        Right:g_JSChartResource.ChartDrawAnchoredText.TextMargin.Right
    };

    //内部变量
    this.TextRect;

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.TextColor) this.TextColor=option.TextColor;
        if (option.Text) this.Text=option.Text;
        if (option.FontOption) this.SetFont(this.FontOption, option.FontOption);
        if (IFrameSplitOperator.IsNumber(option.TextMaxWidth)) this.TextMaxWidth=option.TextMaxWidth;
        if (IFrameSplitOperator.IsNonEmptyArray(option.AryText)) this.AryText=this.CloneArrayText(option.AryText);
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();

        var item=this.Value[0];
        storageData.Value=[ { XValue:item.XValue, YValue:item.YValue } ];

        storageData.FontOption={};
        this.SetFont(storageData.FontOption, this.FontOption);
        storageData.BGColor=this.BGColor;
        storageData.TextColor=this.TextColor;
        storageData.BorderColor=this.BorderColor;
        storageData.LineSpace=this.LineSpace;
        storageData.TextMaxWidth=this.TextMaxWidth;
        storageData.TextMargin={ Left:this.TextMargin.Left, Top:this.TextMargin.Right, Bottom:this.TextMargin.Bottom, Right:this.TextMargin.Right };
        storageData.AryText= this.CloneArrayText(this.AryText);

        return storageData;
    }

    this.ImportStorageData=function(storageData)
    {
        if (storageData.TextMargin)
        {
            var item=storageData.TextMargin;
            if (IFrameSplitOperator.IsNumber(item.Left)) this.TextMargin.Left=item.Left;
            if (IFrameSplitOperator.IsNumber(item.Top)) this.TextMargin.Top=item.Top;
            if (IFrameSplitOperator.IsNumber(item.Bottom)) this.TextMargin.Bottom=item.Bottom;
            if (IFrameSplitOperator.IsNumber(item.Right)) this.TextMargin.Right=item.Right;
        }

        if (storageData.TextColor) this.TextColor=storageData.TextColor;
        this.BGColor=storageData.BGColor;
        this.BorderColor=storageData.BorderColor;
        this.TextMaxWidth=storageData.TextMaxWidth;
        if (IFrameSplitOperator.IsNumber(storageData.LineSpace)) this.LineSpace=storageData.LineSpace;
        this.AryText = this.CloneArrayText(storageData.AryText);
    }

    this.Draw=function()
    {
        this.TextRect=null;
        if (this.Status<2) return;
        if(this.Point.length!=1 || !this.Frame) return;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint();
        if (!drawPoint || drawPoint.length!=1) return;

        this.ClipFrame();

        this.DrawMultiLineText(drawPoint[0]);

        this.Canvas.restore();
    }

    this.ValueToPoint=function()
    {
        if (!this.Frame) return false;

        var item=this.Value[0];
        var pt=this.XYValueToPoint(item.XValue, item.YValue);
        this.Point=[pt];
    }

    this.PointToValue=function()
    {
        if (!this.Frame) return false;

        var border=this.Frame.GetBorder();

        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            var left=border.LeftEx;
            var top=border.Top;
            var width=border.RightEx-left;
            var height=border.Bottom-top;

            var pt=this.Point[0];
            var yValue=(pt.X-left)/width;
            var xValue=(pt.Y-top)/height;

            this.Value[0]={ XValue:xValue, YValue:yValue };
        }
        else
        {
            var left=border.Left;
            var top=border.TopEx;
            var width=border.Right-left;
            var height=border.BottomEx-top;

            var pt=this.Point[0];
            var xValue=(pt.X-left)/width;
            var yValue=(pt.Y-top)/height;

            this.Value[0]={ XValue:xValue, YValue:yValue };
        }
    }


    this.XYValueToPoint=function(xValue, yValue)
    {
        if (!this.Frame) return null;

        var isHScreen=this.Frame.IsHScreen;
        var border=this.Frame.GetBorder();

        if (isHScreen)
        {
            var left=border.LeftEx;
            var top=border.Top;
            var width=border.RightEx-left;
            var height=border.Bottom-top;

            var x=(yValue*width)+left;
            var y=(xValue*height)+top;

            return {X:x, Y:y};
        }
        else
        {
            var left=border.Left;
            var top=border.TopEx;
            var width=border.Right-left;
            var height=border.BottomEx-top;

            var x=(xValue*width)+left;
            var y=(yValue*height)+top;

            return {X:x, Y:y};
        }
    }

    this.CalculateDrawPoint=function(option)
    {
        if (this.Status<2) return null;
        if(this.Point.length!=1 || !this.Frame) return null;

        var drawPoint=[];
        if (this.Status==10)
        {
            var item=this.Value[0];
            var pt=this.XYValueToPoint(item.XValue, item.YValue);
            drawPoint.push(pt);
        }
        else
        {
            drawPoint=this.Point;
        }

        return drawPoint;
    }


    this.DrawMultiLineText=function(pt)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.AryText)) return;
        
        var height=0;
        this.Canvas.font=this.GetFontString(this.FontOption);
        
        var lineHeight=this.Canvas.measureText("擎").width;
        var border=this.Frame.GetBorder();
        var pixel=GetDevicePixelRatio();
        var isHScreen=this.Frame.IsHScreen;
        var ptBottom={X:pt.X, Y:pt.Y};

        if (isHScreen)
        {
            this.Canvas.translate(ptBottom.X, ptBottom.Y);
            this.Canvas.rotate(90 * Math.PI / 180);

            ptBottom.X=0;
            ptBottom.Y=0;
        }

        var aryText=[];
        var maxTextWidth=0;
        for(var i=0; i<this.AryText.length; ++i)    //计算输出高度和宽度
        {
            var item=this.AryText[i];
            if (!item) continue;

            if (height>0) height+=this.LineSpace;

            if (this.TextMaxWidth>50 && item.Text)  //限制宽度
            {
                var value=this.GetMultiLineText(item.Text, this.TextMaxWidth);
                if (value && IFrameSplitOperator.IsNonEmptyArray(value.AryText))
                {
                    for(var j=0; j<value.AryText.length; ++j)
                    {
                        if (j>0) height+=this.LineSpace;
                        var textItem=value.AryText[j];
                        aryText.push(textItem);
                        height+=lineHeight;
                    }
                }
            }
            else
            {
                if (item.Text)
                {
                    var textWidth=this.Canvas.measureText(item.Text).width+2;
                    if (maxTextWidth<textWidth) maxTextWidth=textWidth;
                }
                aryText.push({ Text:item.Text });
                height+=lineHeight;
            }
        }

        if (this.TextMaxWidth>50) maxTextWidth=this.TextMaxWidth;

        var rtBG=
        { 
            Left:ptBottom.X, Bottom:ptBottom.Y, 
            Height:height+this.TextMargin.Top+this.TextMargin.Bottom, 
            Width:maxTextWidth+this.TextMargin.Left+this.TextMargin.Right 
        };
        rtBG.Top=rtBG.Bottom-rtBG.Height;
        rtBG.Right=rtBG.Left+rtBG.Width;

        this.DrawBG(rtBG);

        this.Canvas.fillStyle=this.TextColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="top";

        var xText=rtBG.Left+this.TextMargin.Left;
        var yText=rtBG.Top+this.TextMargin.Top;
        for(var i=0;i<aryText.length;++i)
        {
            var item=aryText[i];
            if (!item) continue;

            if (item.Text)
            {
                this.Canvas.fillText(item.Text,xText,yText);
                yText+=lineHeight;
            }
            else
            {
                yText+=lineHeight;
            }

            yText+=this.LineSpace;
        }


        if (isHScreen)
        {
            rtBG.Left=pt.X;
            rtBG.Top=pt.Y;
            rtBG.Width=height+this.TextMargin.Top+this.TextMargin.Bottom;
            rtBG.Height=maxTextWidth+this.TextMargin.Left+this.TextMargin.Right;
            rtBG.Right=rtBG.Left+rtBG.Width;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
        }

        this.TextRect=rtBG;
        var ptSelected={ X:rtBG.Left+rtBG.Width/2, Y:rtBG.Bottom };

        this.DrawPoint([ptSelected]);  //画点
    }

    this.DrawBG=function(rtBG)
    {
        if (!this.BGColor && !this.BorderColor) return;

        var path=new Path2D();
        path.rect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);

        if (this.BGColor)
        {
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fill(path);
        }

        if (this.BorderColor)
        {
            this.Canvas.strokeStyle=this.BorderColor;
            this.Canvas.stroke(path);
        }
        
    }

    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;
        if (!this.TextRect) return -1;

        var rect=this.TextRect;

        if (x>rect.Left && x<rect.Right && y>rect.Top && y<rect.Bottom) 
            return 100;

        return -1;
    }

    this.GetCursorType=function(ptIndex)
    {
        if (ptIndex==100) return "pointer";
        return null;
    }
}

function ChartDrawPriceLabel()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPriceLabel';
    this.PointCount=1;

    this.OnlyMoveXIndex=true;

    this.TextColor=g_JSChartResource.ChartDrawPriceLabel.TextColor;
    this.FontOption=
    { 
        Family:g_JSChartResource.ChartDrawPriceLabel.FontOption.Family,
        Size:g_JSChartResource.ChartDrawPriceLabel.FontOption.Size,
        Weight:g_JSChartResource.ChartDrawPriceLabel.FontOption.Weight,
        Style:g_JSChartResource.ChartDrawPriceLabel.FontOption.Style
    };    
   
    this.BGColor=g_JSChartResource.ChartDrawPriceLabel.BGColor;
    this.BorderColor=g_JSChartResource.ChartDrawPriceLabel.BorderColor;
    this.LabelOffset={ X:10, Y:20 };

    this.TextMargin=
    { 
        Left:g_JSChartResource.ChartDrawPriceLabel.TextMargin.Left, 
        Top:g_JSChartResource.ChartDrawPriceLabel.TextMargin.Top, 
        Bottom:g_JSChartResource.ChartDrawPriceLabel.TextMargin.Bottom, 
        Right:g_JSChartResource.ChartDrawPriceLabel.TextMargin.Right
    };

    //内部变量
    this.TextRect;

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.TextColor) this.TextColor=option.TextColor;
        if (option.BGColor) this.BGColor=option.BGColor;
        if (option.BorderColor) this.BorderColor=option.BorderColor;
        if (option.FontOption) this.SetFont(this.FontOption, option.FontOption);
        if (option.LabelOffset)
        {
            var item=option.LabelOffset;
            if (IFrameSplitOperator.IsNumber(item.X)) this.LabelOffset.X=item.X;
            if (IFrameSplitOperator.IsNumber(item.Y)) this.LabelOffset.Y=item.Y;
        }
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();

        var item=this.Value[0];
        storageData.Value=[ { XValue:item.XValue, YValue:item.YValue } ];

        storageData.BGColor=this.BGColor;
        storageData.TextColor=this.TextColor;
        storageData.BorderColor=this.BorderColor;
        storageData.TextMargin={ Left:this.TextMargin.Left, Top:this.TextMargin.Right, Bottom:this.TextMargin.Bottom, Right:this.TextMargin.Right };

        return storageData;
    }

    this.ImportStorageData=function(storageData)
    {
        if (storageData.TextMargin)
        {
            var item=storageData.TextMargin;
            if (IFrameSplitOperator.IsNumber(item.Left)) this.TextMargin.Left=item.Left;
            if (IFrameSplitOperator.IsNumber(item.Top)) this.TextMargin.Top=item.Top;
            if (IFrameSplitOperator.IsNumber(item.Bottom)) this.TextMargin.Bottom=item.Bottom;
            if (IFrameSplitOperator.IsNumber(item.Right)) this.TextMargin.Right=item.Right;
        }

        if (storageData.TextColor) this.TextColor=storageData.TextColor;
        this.BGColor=storageData.BGColor;
        this.BorderColor=storageData.BorderColor;
    }

    this.Draw=function()
    {
        this.TextRect=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:true, IsCheckY:true});
        if (!drawPoint || drawPoint.length!=1) return;
        
       

        var pt=drawPoint[0];
        this.ClipFrame();

        this.DrawPriceLabel(pt);

        this.Canvas.restore(); 

        this.DrawPoint([pt]);  //画点
    }

    this.DrawPriceLabel=function(pt)
    {
        var font=this.GetFontString(this.FontOption);
        if (!font) return;

        var isHScreen=this.Frame.IsHScreen;
        var pixelRatio=GetDevicePixelRatio();

        var ptBottom, price;
        var yOffset=0;
        if (isHScreen)
        {
            this.Canvas.translate(pt.X, pt.Y);
            this.Canvas.rotate(90 * Math.PI / 180);

            ptBottom={ X:0, Y:0 };
            price=this.Frame.GetYData(pt.X, false);
            yOffset=1;
        }
        else
        {
            ptBottom={ X:pt.X, Y:pt.Y };
            price=this.Frame.GetYData(pt.Y, false);
        }

        var floatPrecision=2;  
        if (this.Symbol && this.Frame.Identify==0) 
            floatPrecision=GetfloatPrecision(this.Symbol);

        var text=price.toFixed(floatPrecision);

        this.Canvas.font=font;
        var left=ptBottom.X+this.LabelOffset.X;
        var bottom=ptBottom.Y-this.LabelOffset.Y;
        var textHeight=this.Canvas.measureText("擎").width;
        var textWidth=this.Canvas.measureText(text).width;

        var rtBG={ Left:left, Bottom:bottom, Width:textWidth+this.TextMargin.Left+this.TextMargin.Right, Height:textHeight+this.TextMargin.Top+this.TextMargin.Bottom };
        rtBG.Top=rtBG.Bottom-rtBG.Height;
        rtBG.Right=rtBG.Left+rtBG.Width;

        this.DrawBG(rtBG, ptBottom);

        var xText=rtBG.Left+rtBG.Width/2;
        var yText=rtBG.Top+rtBG.Height/2;

        this.Canvas.textAlign="center";
        this.Canvas.textBaseline="middle";
        this.Canvas.fillStyle=this.TextColor;
        this.Canvas.fillText(text,xText,yText+yOffset);

        if (isHScreen)
        {
            this.TextRect=
            { 
                Left:pt.X+this.LabelOffset.Y, Top:pt.Y+this.LabelOffset.X, 
                Width:textHeight+this.TextMargin.Top+this.TextMargin.Bottom, 
                Height:textWidth+this.TextMargin.Left+this.TextMargin.Right 
            }

            this.TextRect.Right=this.TextRect.Left+this.TextRect.Width;
            this.TextRect.Bottom=this.TextRect.Top+this.TextRect.Height;
        }
        else
        {
            this.TextRect=rtBG;
        }
    }

    this.DrawBG=function(rtBG, pt)
    {
        var pixelRatio=GetDevicePixelRatio();

        var path=new Path2D();
        
        path.moveTo(rtBG.Left, rtBG.Bottom);
        path.lineTo(rtBG.Left, rtBG.Top);
        path.lineTo(rtBG.Right, rtBG.Top);
        path.lineTo(rtBG.Right,rtBG.Bottom);

        var x=rtBG.Left+15*pixelRatio;
        path.lineTo(x,rtBG.Bottom);

        path.lineTo(pt.X, pt.Y);

        x=rtBG.Left+5*pixelRatio;
        path.lineTo(x,rtBG.Bottom);

        path.closePath();

        if (this.BGColor)
        {
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fill(path);
        }

        if (this.BorderColor)
        {
            this.Canvas.strokeStyle=this.BorderColor;
            this.Canvas.stroke(path);
        }

         //绘制一个点
         if (this.BGColor)
         {
            this.Canvas.beginPath();
            this.Canvas.arc(pt.X,pt.Y,2*pixelRatio,0,360,false);
            this.Canvas.fillStyle=this.BGColor;     
            this.Canvas.fill();  
         }
             
    }

    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;
        if (!this.TextRect) return -1;

        var rect=this.TextRect;

        if (x>rect.Left && x<rect.Right && y>rect.Top && y<rect.Bottom) 
            return 100;

        return -1;
    }

    this.GetCursorType=function(ptIndex)
    {
        if (ptIndex==100) return "pointer";
        return null;
    }
}

function ChartDrawPriceNote()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawPriceNote';
    this.PointCount=2;

    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.FontOption=
    { 
        Family:g_JSChartResource.ChartDrawPriceNote.FontOption.Family,
        Size:g_JSChartResource.ChartDrawPriceNote.FontOption.Size,
        Weight:g_JSChartResource.ChartDrawPriceNote.FontOption.Weight,
        Style:g_JSChartResource.ChartDrawPriceNote.FontOption.Style
    };  
    
    this.TextMargin=
    { 
        Left:g_JSChartResource.ChartDrawPriceNote.TextMargin.Left, 
        Top:g_JSChartResource.ChartDrawPriceNote.TextMargin.Top, 
        Bottom:g_JSChartResource.ChartDrawPriceNote.TextMargin.Bottom, 
        Right:g_JSChartResource.ChartDrawPriceNote.TextMargin.Right
    };

    this.BGColor=g_JSChartResource.ChartDrawPriceNote.BGColor;
    this.BorderColor=g_JSChartResource.ChartDrawPriceNote.BorderColor;
    this.TextColor=g_JSChartResource.ChartDrawPriceNote.TextColor;
    this.BorderRoundRadius=3;

    
    //内部变量
    this.TextRect;

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.TextColor) this.TextColor=option.TextColor;
        if (option.BGColor) this.BGColor=option.BGColor;
        if (option.BorderColor) this.BorderColor=option.BorderColor;
        if (option.FontOption) this.SetFont(this.FontOption, option.FontOption);
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();

        storageData.Value=[];
        for(var i=0;i<this.Value.length;++i)
        {
            var item=this.Value[i];
            storageData.Value.push( { XValue:item.XValue, YValue:item.YValue } );
        }
    
        storageData.BGColor=this.BGColor;
        storageData.TextColor=this.TextColor;
        storageData.BorderColor=this.BorderColor;
        storageData.TextMargin={ Left:this.TextMargin.Left, Top:this.TextMargin.Right, Bottom:this.TextMargin.Bottom, Right:this.TextMargin.Right };

        return storageData;
    }

    this.ImportStorageData=function(storageData)
    {
        if (storageData.TextMargin)
        {
            var item=storageData.TextMargin;
            if (IFrameSplitOperator.IsNumber(item.Left)) this.TextMargin.Left=item.Left;
            if (IFrameSplitOperator.IsNumber(item.Top)) this.TextMargin.Top=item.Top;
            if (IFrameSplitOperator.IsNumber(item.Bottom)) this.TextMargin.Bottom=item.Bottom;
            if (IFrameSplitOperator.IsNumber(item.Right)) this.TextMargin.Right=item.Right;
        }

        if (storageData.TextColor) this.TextColor=storageData.TextColor;
        this.BGColor=storageData.BGColor;
        this.BorderColor=storageData.BorderColor;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        this.TextRect=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:true} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];
        this.LineWidth=1;

        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        this.DrawPriceLabel(ptStart, ptEnd);

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.DrawPriceLabel=function(ptStart, ptEnd)
    {
        var font=this.GetFontString(this.FontOption);
        if (!font) return;

        var floatPrecision=2;  
        if (this.Symbol && this.Frame.Identify==0) floatPrecision=GetfloatPrecision(this.Symbol);
        var pixelRatio=GetDevicePixelRatio();

        var ptPrice={ X:ptEnd.X, Y:ptEnd.Y };

        var price=this.Frame.GetYData(ptStart.Y, false);
        var text=price.toFixed(floatPrecision);
        var textHeight=this.Canvas.measureText("擎").width;
        var textWidth=this.Canvas.measureText(text).width;
        var angle=this.CalculateAngle(ptStart.X, ptStart.Y, ptEnd.X, ptEnd.Y);
        if ((angle>=0 && angle<=45) || (angle>=315 && angle<=360))
        {
            var left=ptPrice.X;
            var bottom=ptPrice.Y;

            var rtBG={ Left:left, Bottom:bottom, Width:textWidth+this.TextMargin.Left+this.TextMargin.Right, Height:textHeight+this.TextMargin.Top+this.TextMargin.Bottom };
            rtBG.Bottom=bottom+(rtBG.Height/2);
            rtBG.Top=rtBG.Bottom-rtBG.Height;
            rtBG.Right=rtBG.Left+rtBG.Width;
        }
        else if (angle>45 && angle<=135)
        {
            var left=ptPrice.X;
            var bottom=ptPrice.Y;
    
            var rtBG={ Left:left, Bottom:bottom, Width:textWidth+this.TextMargin.Left+this.TextMargin.Right, Height:textHeight+this.TextMargin.Top+this.TextMargin.Bottom };
            rtBG.Left=left-(rtBG.Width/2);
            rtBG.Top=rtBG.Bottom-rtBG.Height;
            rtBG.Right=rtBG.Left+rtBG.Width;
        }
        else if (angle>=135 && angle<=225)
        {
            var left=ptPrice.X;
            var bottom=ptPrice.Y;

            var rtBG={ Width:textWidth+this.TextMargin.Left+this.TextMargin.Right, Height:textHeight+this.TextMargin.Top+this.TextMargin.Bottom };
            rtBG.Bottom=bottom+(rtBG.Height/2);
            rtBG.Top=rtBG.Bottom-rtBG.Height;
            rtBG.Right=left;
            rtBG.Left=rtBG.Right-rtBG.Width;
        }
        else if (angle>=225 && angle<=315)
        {
            var left=ptPrice.X;
            var top=ptPrice.Y;

            var rtBG={ Width:textWidth+this.TextMargin.Left+this.TextMargin.Right, Height:textHeight+this.TextMargin.Top+this.TextMargin.Bottom };
            rtBG.Top=top;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
            rtBG.Left=left-(rtBG.Width/2);
            rtBG.Right=rtBG.Left-rtBG.Width;
        }
        else 
            return;

        this.DrawBG(rtBG);

        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="middle";
        this.Canvas.fillStyle=this.TextColor;
        var xText=rtBG.Left+this.TextMargin.Left;
        var yText=rtBG.Top+rtBG.Height/2;
        var yOffset=0;
        this.Canvas.fillText(text,xText,yText+yOffset);

        //绘制一个点
        if (this.BGColor)
        {
           this.Canvas.beginPath();
           this.Canvas.arc(ptStart.X,ptStart.Y,2*pixelRatio,0,360,false);
           this.Canvas.fillStyle=this.BGColor;     
           this.Canvas.fill();  
        }

        this.TextRect=rtBG;
    }

    this.DrawBG=function(rtBG)
    {
        if (!rtBG) return;

        var pixelRatio=GetDevicePixelRatio();
        var roundRadius=this.BorderRoundRadius*pixelRatio;

        var path=new Path2D();
        path.roundRect(ToFixedPoint(rtBG.Left), ToFixedPoint(rtBG.Top), ToFixedRect(rtBG.Width), ToFixedRect(rtBG.Height), [roundRadius]);
        
        if (this.BGColor)
        {
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fill(path);
        }

        if (this.BorderColor)
        {
            this.Canvas.strokeStyle=this.BorderColor;
            this.Canvas.stroke(path);
        }
    }


    this.IsPointIn=function(x,y)
    {
        if (!this.Frame || this.Status!=10) return -1;
        if (!this.TextRect) return -1;

        var rect=this.TextRect;

        if (x>rect.Left && x<rect.Right && y>rect.Top && y<rect.Bottom) 
            return 1;

        return this.IsPointIn_XYValue_Line(x,y);
    }
}

/////////////////////////////////////////////////////////////////////////////
// 0=中心点  1=起始点(决定半径长度)  2=结束点(任意位置)
//
function ChartDrawFibWedge()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDrawFibWedge';
    this.PointCount=3;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointToValue_Default=this.PointToValue;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    this.LastPoint;

    this.AreaConfig=
    { 
        AryData:
        [
            { Value: 0.236, Color:"rgb(242,52,69)", Enable:true },
            { Value: 0.382, Color:"rgb(255,152,0)",Enable:true },
            { Value: 0.5, Color:"rgb(76,175,80)", Enable:true },
            { Value: 0.618, Color:"rgb(8,153,129)", Enable:true },
            { Value: 0.786, Color:"rgb(0,188,212)" ,Enable:true },
            { Value: 1, Color:"rgb(120,123,134)", Enable:true },
            { Value: 1.618, Color:"rgb(41,98,255)",Enable:false },
            { Value: 2.618, Color:"rgb(242,54,69)",Enable:false },
        ],

        Opacity:0.3
    }

    //内部变量
    this.TextAngle;     
    this.Radius;        //半径

    //计算斜边
    this.CalculateHypotenuse=function(pt1, pt2)
    {
        var a=pt1.X-pt2.X;
        var b=pt1.Y-pt2.Y;
        var c=Math.sqrt(a*a+b*b);
        return c;
    }

    //吸附X轴和Y轴K线价格
    this.MagnetXY=function(aryPoint)
    {
        var option= { IsFixedX:this.OnlyMoveXIndex };

        //磁吸功能
        if (this.Option && this.Option.Magnet && this.Option.Magnet.Enable && this.IsSupportMagnet  && this.Frame.Identify==0)
        {
            var pointIndex=-1;
            if (this.Status==2) pointIndex=1;   //创建第2个点
            if (IFrameSplitOperator.IsNumber(this.MovePointIndex)) pointIndex=this.MovePointIndex;
                
            if (pointIndex>=0)
            {
                option.Magnet=
                {
                    Enable:true,
                    PointIndex:pointIndex,
                    Distance:this.Option.Magnet.Distance,
                    Type:this.Option.Magnet.Type
                }
            }
        }
         
        this.AdjustPoint(aryPoint,option)
    }

    this.CalculateAllPoint=function(ptStart, pt2, ptEnd)
    {
        var drawPoint=[];
        drawPoint.push({ X:ptStart.X, Y:ptStart.Y });
        drawPoint.push({ X:pt2.X, Y:pt2.Y });
        this.MagnetXY(drawPoint);

        drawPoint.push({ X:ptEnd.X, Y:ptEnd.Y });

        var radius=this.CalculateHypotenuse(drawPoint[0], drawPoint[1]);    //求半径
        var a=drawPoint[0].X-drawPoint[2].X;
        var b=drawPoint[0].Y-drawPoint[2].Y;
        var c=Math.sqrt(a*a+b*b);

        var a2=a*radius/c;
        var b2=b*radius/c;

        drawPoint[2].X=drawPoint[0].X-a2;
        drawPoint[2].Y=drawPoint[0].Y-b2;

        return drawPoint;
    }

    //数值转成坐标
    this.ValueToPoint_V2=function(aryValue)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryValue)) return null;

        if (!this.Frame) return null;
        var data=this.Frame.Data;
        if (!data) return null;
        
        var isHScreen=this.Frame.IsHScreen;
        var aryPoint=[];
        for(var i=0; i<aryValue.length; ++i)
        {
            var item=aryValue[i];
            var pt=new Point();
            if (isHScreen)
            {
                pt.Y=this.Frame.GetXFromIndex(item.XValue-data.DataOffset,false);
                pt.X=this.Frame.GetYFromData(item.YValue,false);
            }
            else
            {
                pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset, false);
                pt.Y=this.Frame.GetYFromData(item.YValue,false);
            }
            aryPoint[i]=pt;
        }

        return aryPoint;
    }

    this.CalculateDrawPoint=function(option)
    {
        if (this.Status<2) return null;
        if(!this.Point.length || !this.Frame) return null;

        var drawPoint=[];
        if (this.Status==2) //完成第2个点
        {
            if (this.PointStatus==2 && this.LastPoint)  //第3个点
            {
                drawPoint=this.CalculateAllPoint(this.Point[0], this.Point[1], this.LastPoint);
            }
            else
            {
                for(var i=0;i<this.Point.length && i<2;++i)
                {
                    var item=this.Point[i];
                    drawPoint.push({ X:item.X, Y:item.Y });
                }

                this.MagnetXY(drawPoint);
            }
        }
        else if (this.Status==10)
        {
            var data=this.Frame.Data;
            if (!data) return null;

            var showCount=this.Frame.XPointCount;
            var invaildX=0; //超出范围的x点个数
            var isHScreen=this.Frame.IsHScreen;
            for(var i=0; i<this.Value.length; ++i)
            {
                var item=this.Value[i];
                var dataIndex=item.XValue-data.DataOffset;
                if (dataIndex<0 || dataIndex>=showCount) ++invaildX;
            
                var pt=new Point();
                if (isHScreen)  //横屏X,Y对调
                {
                    pt.Y=this.Frame.GetXFromIndex(item.XValue-data.DataOffset,false);
                    pt.X=this.Frame.GetYFromData(item.YValue,false);
                }
                else
                {
                    pt.X=this.Frame.GetXFromIndex(item.XValue-data.DataOffset,false);
                    pt.Y=this.Frame.GetYFromData(item.YValue,false);
                }
                drawPoint.push(pt);
            }
        }
        else if (this.Status==20)
        {
            drawPoint=this.CalculateAllPoint(this.Point[0], this.Point[1], this.Point[2]);
        }

        return drawPoint;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        this.TextAngle=null;
        this.Radius=null;
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint({IsCheckX:false, IsCheckY:false});
        if (!IFrameSplitOperator.IsNonEmptyArray(drawPoint)) return;
        
        var points=drawPoint.slice(0);
        this.CalculateLines(points);

        this.ClipFrame();
        
        this.DrawArea(points);
        this.DrawLines(this.LinePoint);
        this.DrawPoint(points); //画点
        this.DrawTitle(points);

        this.Canvas.restore();
    }

    this.DrawArea=function(aryPoint)
    {
        if (aryPoint.length!=3) return;
        if (!this.AreaConfig || !IFrameSplitOperator.IsNonEmptyArray(this.AreaConfig.AryData)) return;

        var ptCenter=aryPoint[0];
        var radius=this.CalculateHypotenuse(ptCenter, aryPoint[1]);    //求半径
        var startAngle=this.CalculateAngle(ptCenter.X,ptCenter.Y,aryPoint[1].X,aryPoint[1].Y);
        var endAngle=this.CalculateAngle(ptCenter.X,ptCenter.Y,aryPoint[2].X,aryPoint[2].Y);

        var sectorAngle=startAngle-endAngle;
        if (sectorAngle<0) sectorAngle+=360;
        if (sectorAngle>180)
        {
            var temp=startAngle;
            startAngle=endAngle;
            endAngle=temp;
        }

        var centerAngle=startAngle-(startAngle-endAngle)/2;
        if (startAngle-endAngle<0) centerAngle-=180;

        var preValue=null;
        for(var i=0;i<this.AreaConfig.AryData.length;++i)
        {
            var item=this.AreaConfig.AryData[i];
            if (!item.Enable) continue;

            var value=radius*item.Value;    //半径
            var lineColor=item.Color;
            var areaColor=IChartDrawPicture.ColorToRGBA(lineColor, this.AreaConfig.Opacity);

            var path=new Path2D();
            if (IFrameSplitOperator.IsNumber(preValue))
            {
                path.arc(ptCenter.X,ptCenter.Y,preValue,(Math.PI / 180)*(360-startAngle),(Math.PI / 180)*(360-endAngle));
                path.arc(ptCenter.X,ptCenter.Y,value,(Math.PI / 180)*(360-endAngle), (Math.PI / 180)*(360-startAngle),true);
            }
            else
            {
                path.moveTo(ptCenter.X,ptCenter.Y);
                path.arc(ptCenter.X,ptCenter.Y,value,(Math.PI / 180)*(360-startAngle),(Math.PI / 180)*(360-endAngle));
            }
            
            this.Canvas.fillStyle=areaColor;
            this.Canvas.fill(path);

            preValue=value;
        }

        for(var i=0;i<this.AreaConfig.AryData.length;++i)
        {
            var item=this.AreaConfig.AryData[i];
            if (!item.Enable) continue;

            var value=radius*item.Value;    //半径
            var lineColor=item.Color;

            var path=new Path2D();
            path.arc(ptCenter.X,ptCenter.Y,value,(Math.PI / 180)*(360-startAngle),(Math.PI / 180)*(360-endAngle));
            this.Canvas.strokeStyle = lineColor;
            this.Canvas.stroke(path);
        }

        this.Radius=radius;
        this.TextAngle=centerAngle;
    }

    //显示角度数据
    this.DrawTitle=function(aryPoint)
    {
        if (aryPoint.length!=3) return;
        if (!this.AreaConfig || !IFrameSplitOperator.IsNonEmptyArray(this.AreaConfig.AryData)) return;

        var ptCenter=aryPoint[0];
        var radian =(Math.PI/180)*(360-this.TextAngle);
        this.Canvas.font=this.Font;
        for(var i=0;i<this.AreaConfig.AryData.length;++i)
        {
            var item=this.AreaConfig.AryData[i];
            if (!item.Enable) continue;

            var value=this.Radius*item.Value;    //半径
            var lineColor=item.Color;
            var text=`${item.Value}`;
            var y=Math.sin(radian)*value+ptCenter.Y
            var x=Math.cos(radian)*value+ptCenter.X;

            this.Canvas.fillStyle=lineColor;
            this.Canvas.textAlign="left";
            this.Canvas.textBaseline="top";
            this.Canvas.fillText(text,x+2,y+2);
        }
    }

    this.SetLastPoint=function(obj)
    {
        this.LastPoint={X:obj.X,Y:obj.Y};
    }

    this.DrawLines=function(aryLine)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryLine)) return;

        for(var i=0; i<aryLine.length; ++i)
        {
            var item=aryLine[i];
            this.DrawLine(item.Start,item.End);
        }
    }

    this.CalculateLines=function(points)
    {
        if (points.length===2)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);
        }
        else if (points.length===3)
        {
            var line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[1].Y;
            line.End.X=points[1].X;
            this.LinePoint.push(line);

            line={Start:new Point(), End:new Point()};
            line.Start.Y=points[0].Y;
            line.Start.X=points[0].X;
            line.End.Y=points[2].Y;
            line.End.X=points[2].X;
            this.LinePoint.push(line);
        }
    }

    //0-10 鼠标对应的点索引   100=鼠标在正个图形上  -1 鼠标不在图形上
    this.IsPointIn=function(x,y,option)
    {
        if (this.Status!=10) return -1;

        var value=this.IsPointInXYValue(x,y,this.AryPoint,option);
        if (value>=0) return value;

        value=this.IsPointInLine(x,y,option);
        if (value>=0) return 100;

        return -1;
    }

    this.IsPointInDots=function(x, y, aryPoint, option)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryPoint)) return -1;

        if (!this.Frame) return -1;

        var data=this.Frame.Data;
        if (!data) return -1;
        if (!this.Value) return -1;
       

        var radius=5;
        if (option && IFrameSplitOperator.IsNumber(option.Zoom)) radius+=option.Zoom;
        else if (this.Option && IFrameSplitOperator.IsNumber(this.Option.Zoom)) radius+=this.Option.Zoom;

        var isHScreen=this.Frame.IsHScreen;
        radius*=GetDevicePixelRatio();
        for(var i=0;i<aryPoint.length; ++i)   //是否在点上
        {
            var pt=aryPoint[i];
            var path=new Path2D();
            path.arc(pt.X,pt.Y,radius,0,360);
            if (this.Canvas.isPointInPath(path,x,y))  return i;
        }

        return -1;
    }

    this.GetCursorType=function(ptIndex)
    {
        if (ptIndex==2) return "ns-resize";
        return null;
    }

    
    this.PointToValue=function()
    {
        if (!this.Frame) return false;

        var item=this.Point[2];
        var ptLast={X:item.X, Y:item.Y};

        if (!this.PointToValue_Default()) return false;

        //计算第3个点的位置
        var aryValue=[this.Value[0], this.Value[1]];
        var aryPoint=this.ValueToPoint_V2(aryValue);

        var radius=this.CalculateHypotenuse(aryPoint[0], aryPoint[1]);    //求半径
        var a=aryPoint[0].X-ptLast.X;
        var b=aryPoint[0].Y-ptLast.Y;
        var c=Math.sqrt(a*a+b*b);

        var a2=a*radius/c;
        var b2=b*radius/c;

        this.Point[2].X=aryPoint[0].X-a2;
        this.Point[2].Y=aryPoint[0].Y-b2;

        var aryValue=this.PointToValue_V2([this.Point[2]], {Type:1});
        if (!aryValue) return false;

        this.Value[2]=aryValue[0];

        return true;
    }

    this.PointToValue_V2=function(aryPoint,option)
    {
        if (!this.Frame) return null;

        if (this.Frame.ClassName=="MinuteFrame" || this.Frame.Class=="MinuteHScreenFrame")
        {
            return this.PointToValue_Minute_V2(aryPoint, option);
        }
        else
        {
            return this.PointToValue_KLine_V2(aryPoint, option);
        }
    }

    this.PointToValue_KLine_V2=function(aryPoint, option)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryPoint)) return null;
        if (!this.Frame) return null;
        var data=this.Frame.Data;
        if (!data) return null;

        var aryValue=[]
        var isHScreen=this.Frame.IsHScreen;
        if (isHScreen)
        {
            for(var i=0;i<aryPoint.length;++i)
            {
                var item=aryPoint[i];
                var xValue=this.Frame.GetXData(item.Y,false)+data.DataOffset;
                var yValue=this.Frame.GetYData(item.X,false);

                var valueItem={ XValue:xValue, YValue:yValue, Type:1 };
                aryValue[i]=valueItem;
            }
        }
        else
        {
            for(var i=0; i<aryPoint.length; ++i)
            {
                var item=aryPoint[i];
                var xValue=this.Frame.GetXData(item.X,false)+data.DataOffset;
                var yValue=this.Frame.GetYData(item.Y,false);

                var valueItem={ XValue:xValue, YValue:yValue, Type:1 };
                aryValue[i]=valueItem;
            }
        }

        return aryValue;
    }

}

//////////////////////////////////////////////////////////////////////////////
// 斐波那契回测
//
function ChartFibRetracement()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartFibRetracement';
    this.PointCount=2;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointToValue_Default=this.PointToValue;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    this.LineDash=[6,3];
    this.LineWidth=1;
    this.EnableBGColor=true;
    this.ExtendLine={ Left:false, Right: false }; //延长线

    this.AreaConfig=
    { 
        AryData:
        [
            { Value: 0, Color:"rgb(128,128,128)", Enable:true },
            { Value: 0.236, Color:"rgb(242,52,69)", Enable:true },
            { Value: 0.382, Color:"rgb(255,152,0)",Enable:true },
            { Value: 0.5, Color:"rgb(76,175,80)", Enable:true },
            { Value: 0.618, Color:"rgb(8,153,129)", Enable:true },
            { Value: 0.786, Color:"rgb(0,188,212)" ,Enable:true },
            { Value: 1, Color:"rgb(120,123,134)", Enable:true },
            { Value: 1.618, Color:"rgb(41,98,255)",Enable:true },
            { Value: 2.618, Color:"rgb(242,54,69)",Enable:false },
        ],

        Opacity:0.3
    }

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.Font) this.Font=option.Font;
        if (option.LineWidth) this.LineWidth=option.LineWidth;
        if (option.LineDash) this.LineDash=option.LineDash;
        if (IFrameSplitOperator.IsBool(option.EnableBGColor)) this.EnableBGColor=option.EnableBGColor;
        if (option.ExtendLine) 
        {
            var item=option.ExtendLine;
            if (IFrameSplitOperator.IsBool(item.Left)) this.ExtendLine.Left=item.Left;
            if (IFrameSplitOperator.IsBool(item.Right)) this.ExtendLine.Left=item.Right;
        }

        if (option.AreaConfig) this.AreaConfig=option.AreaConfig;
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();

        storageData.Value=[];
        for(var i=0;i<this.Value.length && i<this.PointCount;++i)
        {
            var item=this.Value[i];
            storageData.Value.push( { XValue:item.XValue, YValue:item.YValue } );
        }
    
        storageData.Font=this.Font;
        storageData.EnableBGColor=this.EnableBGColor;
        storageData.LineDash=this.LineDash;
        storageData.ExtendLine={ Left:this.ExtendLine.Left, Right:this.ExtendLine.Right };
        storageData.AreaConfig=CloneData(this.AreaConfig);

        return storageData;
    }

    this.ImportStorageData=function(storageData)
    {
        if (storageData.Font) this.Font=storageData.Font;
        if (storageData.LineDash) this.LineDash=storageData.LineDash;
        if (IFrameSplitOperator.IsBool(storageData.EnableBGColor))  this.EnableBGColor=storageData.EnableBGColor;
        if (storageData.ExtendLine) this.ExtendLine=storageData.ExtendLine;
        if (storageData.AreaConfig) this.AreaConfig=storageData.AreaConfig;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var bCheckXY=true;
        if (this.ExtendLine.Left || this.ExtendLine.Right) bCheckXY=false;
        var drawPoint=this.CalculateDrawPoint( {IsCheckX:bCheckXY, IsCheckY:bCheckXY} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.setLineDash(this.LineDash);
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.Canvas.setLineDash([]);

        this.DrawBlock(ptStart, ptEnd);

        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.GetArrayAreaConfig=function()
    {
        var aryArea=[];
        for(var i=0;i<this.AreaConfig.AryData.length;++i)
        {
            var item=this.AreaConfig.AryData[i];
            if (item.Enable) aryArea.push(item);
        }

        aryArea.sort((left,right)=>{ return right.Value-left.Value; })

        return aryArea;
    }

    this.DrawBlock=function(ptStart, ptEnd)
    {
        var yTop=Math.min(ptStart.Y, ptEnd.Y);
        var yBottom=Math.max(ptStart.Y, ptEnd.Y);
        var xLeft=Math.min(ptStart.X, ptEnd.X);
        var xRight=Math.max(ptStart.X, ptEnd.X);
        var height=yBottom-yTop;
        //var baseValue=Math.min(this.Value[0].YValue, this.Value[1].YValue);
        //var diffValue=Math.abs(this.Value[0].YValue-this.Value[1].YValue);  //差值

        if (this.ExtendLine.Right) xRight=this.Frame.ChartBorder.GetRight();
        if (this.ExtendLine.Left) xLeft=this.Frame.ChartBorder.GetLeft();

        var aryArea=this.GetArrayAreaConfig();
        var yPre=null;      //上一个点
        var clrArea=null;
        this.Canvas.font=this.Font;
        if (this.ExtendLine.Left) this.Canvas.textAlign="left";
        else this.Canvas.textAlign="right";
        this.Canvas.textBaseline="bottom";

        for(var i=0;i<aryArea.length;++i)
        {
            var item=aryArea[i];
            var y=yBottom-height*item.Value;
            //var yValue=baseValue+diffValue*item.Value;
            yValue=this.Frame.GetYData(y,false);
            y=ToFixedPoint(y);
            if (this.EnableBGColor && IFrameSplitOperator.IsNumber(yPre))
            {
                var rtBG={ Left:xLeft, Right:xRight, Top:yPre, Bottom:y };
                rtBG.Width=rtBG.Right-rtBG.Left;
                rtBG.Height=rtBG.Bottom-rtBG.Top;
                this.Canvas.fillStyle=clrArea;
                this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
            }

            this.Canvas.strokeStyle=item.Color;
            this.Canvas.beginPath();
            this.Canvas.moveTo(xLeft,y);
            this.Canvas.lineTo(xRight,y);
            this.Canvas.stroke();

            var line={ Start:{X:xLeft, Y:y}, End:{X:xRight, Y:y} };
            this.LinePoint.push(line);

            //文字
            var text=`${item.Value} (${yValue.toFixed(2)})`;
            this.Canvas.fillStyle=item.Color;
            if (this.ExtendLine.Left)
                this.Canvas.fillText(text,xLeft+2,y-2);
            else 
                this.Canvas.fillText(text,xLeft-2,y-2);

            yPre=y;
            clrArea=IChartDrawPicture.ColorToRGBA(item.Color, this.AreaConfig.Opacity);
        }
    }

}


function ChartFibSpeedResistanceFan()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartFibSpeedResistanceFan';
    this.PointCount=2;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointToValue_Default=this.PointToValue;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    this.LineWidth=1;
    this.EnableBGColor=true;

    this.AreaConfig=
    { 
        AryYData:
        [
            { Value: 0, Color:"rgb(128,128,128)", Enable:true },
            { Value: 0.25, Color:"rgb(242,52,69)", Enable:true },
            { Value: 0.382, Color:"rgb(255,152,0)",Enable:true },
            { Value: 0.5, Color:"rgb(76,175,80)", Enable:true },
            { Value: 0.618, Color:"rgb(8,153,129)", Enable:true },
            { Value: 0.75, Color:"rgb(0,188,212)" ,Enable:true },
            { Value: 1, Color:"rgb(120,123,134)", Enable:true },
           
        ],

        AryXData:
        [
            { Value: 0, Color:"rgb(128,128,128)", Enable:true },
            { Value: 0.25, Color:"rgb(242,52,69)", Enable:true },
            { Value: 0.382, Color:"rgb(255,152,0)",Enable:true },
            { Value: 0.5, Color:"rgb(76,175,80)", Enable:true },
            { Value: 0.618, Color:"rgb(8,153,129)", Enable:true },
            { Value: 0.75, Color:"rgb(0,188,212)" ,Enable:true },
            { Value: 1, Color:"rgb(120,123,134)", Enable:true },
        ],

        Opacity:0.3
    }

    this.SetOption=function(option)
    {
        if (!option) return;

        if (option.Font) this.Font=option.Font;
        if (option.LineWidth) this.LineWidth=option.LineWidth;
        if (IFrameSplitOperator.IsBool(option.EnableBGColor)) this.EnableBGColor=option.EnableBGColor;
        if (option.AreaConfig) this.AreaConfig=option.AreaConfig;
    }

    //导出成存储格式
    this.ExportStorageData=function()
    {
        var storageData=this.ExportBaseData();

        storageData.Value=[];
        for(var i=0;i<this.Value.length && i<this.PointCount;++i)
        {
            var item=this.Value[i];
            storageData.Value.push( { XValue:item.XValue, YValue:item.YValue } );
        }
    
        storageData.Font=this.Font;
        storageData.EnableBGColor=this.EnableBGColor;
        storageData.AreaConfig=CloneData(this.AreaConfig);

        return storageData;
    }

    this.ImportStorageData=function(storageData)
    {
        if (storageData.Font) this.Font=storageData.Font;
        if (IFrameSplitOperator.IsBool(storageData.EnableBGColor))  this.EnableBGColor=storageData.EnableBGColor;
        if (storageData.AreaConfig) this.AreaConfig=storageData.AreaConfig;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var bCheckXY=false;
        var drawPoint=this.CalculateDrawPoint( {IsCheckX:bCheckXY, IsCheckY:bCheckXY} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.DrawBlock(ptEnd, ptStart);
        this.RestoreLineWidth();

        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    //获取在第几象限
    this.GetQuadrant=function(ptStart,ptEnd)
    {
        if (ptStart.X<ptEnd.X && ptStart.Y>ptEnd.Y) return 1;
        else if (ptStart.X>ptEnd.X && ptStart.Y>ptEnd.Y) return 2;
        else if (ptStart.X<ptEnd.X && ptStart.Y< ptEnd.Y) return 4;
        else return 3;
    }

    this.DrawBlock=function(ptStart, ptEnd)
    {
        var center=ptEnd;
        var xDiff=ptEnd.X-ptStart.X;
        var yDiff=ptEnd.Y-ptStart.Y;
        var quadrant=this.GetQuadrant(center,ptStart);   //象限

        var aryYData=this.GetArrayAreaConfig(this.AreaConfig.AryYData);
        var ptPre=null; //上一个点
        var clrArea=null;
        this.Canvas.font=this.Font;
       
        var border=this.Frame.GetBorder();
        var ptLeftTop={ X:border.Left, Y:border.TopEx };
        var ptRightTop={X:border.Right, Y:border.TopEx };
        var ptLeftBottom={ X:border.Left, Y:border.BottomEx };
        var ptRightBottom={ X:border.Right, Y:border.BottomEx };

        var textOffset=4;
        if (quadrant==1 || quadrant==4) 
        {
            this.Canvas.textAlign="right";
            textOffset=-4;
        }
        else 
        {
            this.Canvas.textAlign="left";
            textOffset=4;
        }


        this.Canvas.textBaseline="middle";
        for(var i=0;i<aryYData.length;++i)
        {
            var item=aryYData[i];
            var y=item.Value*yDiff+ptStart.Y;

            var pt=this.CalculateExtendLineEndPoint([center, {X:ptStart.X, Y:y}]);

            if (ptPre)
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(center.X,center.Y);
                this.Canvas.lineTo(ptPre.X,ptPre.Y);

                if (quadrant==1)
                {   
                    if (ptPre.X>=ptRightTop.X && pt.X<ptRightTop.X)
                    {
                        this.Canvas.lineTo(ptRightTop.X,ptRightTop.Y);
                    }
                }
                else if (quadrant==2)
                {
                    if (ptPre.X<=ptLeftTop.X && pt.X>ptLeftTop.X)
                    {
                        this.Canvas.lineTo(ptLeftTop.X,ptLeftTop.Y);
                    }
                }
                else if (quadrant==3)
                {
                    if (ptPre.X<=ptLeftBottom.X && pt.X>ptLeftBottom.X)
                    {
                        this.Canvas.lineTo(ptLeftBottom.X,ptLeftBottom.Y);
                    }
                }
                else if (quadrant==4)
                {
                    if (ptPre.X>=ptRightBottom.X && pt.X<ptRightBottom.X)
                    {
                        this.Canvas.lineTo(ptRightBottom.X,ptRightBottom.Y);
                    }
                }

                this.Canvas.lineTo(pt.X,pt.Y);
                this.Canvas.closePath();
                this.Canvas.fillStyle=clrArea;
                this.Canvas.fill();
            }

            this.Canvas.strokeStyle=item.Color;
            this.Canvas.beginPath();
            this.Canvas.moveTo(center.X,center.Y);
            this.Canvas.lineTo(pt.X,pt.Y);
            this.Canvas.stroke();

            this.LinePoint.push({Start:center, End:pt});

            if (item.Value!=1)
            {
                this.Canvas.strokeStyle=this.LineColor;
                this.Canvas.beginPath();
                this.Canvas.moveTo(center.X,y);
                this.Canvas.lineTo(ptStart.X,y);
                this.Canvas.stroke();
            }

            ptPre=pt;
            clrArea=IChartDrawPicture.ColorToRGBA(item.Color, this.AreaConfig.Opacity);
            
            //文字
            var text=`${item.Value}`;
            this.Canvas.fillStyle=item.Color;
            this.Canvas.fillText(text,center.X+textOffset,y);
        }

        var aryXData=this.GetArrayAreaConfig(this.AreaConfig.AryXData);
        var ptPre=null;
        this.Canvas.textAlign="center";
        if (quadrant==3 || quadrant==4) 
        {
            this.Canvas.textBaseline="bottom";
            textOffset=-5;
        }
        else
        {
            this.Canvas.textBaseline="top";
            textOffset=5;
        }
            
        for(var i=0;i<aryXData.length;++i)
        {
            var item=aryXData[i];
            var x=item.Value*xDiff+ptStart.X;

            var pt=this.CalculateExtendLineEndPoint([center, {X:x, Y:ptStart.Y}]);

            if (ptPre)  //面积
            {
                this.Canvas.beginPath();
                this.Canvas.moveTo(center.X,center.Y);
                this.Canvas.lineTo(ptPre.X,ptPre.Y);

                if (quadrant==1)
                {
                    if (ptPre.X<ptRightTop.X && pt.X>=ptRightTop.X)
                    {
                        this.Canvas.lineTo(ptRightTop.X,ptRightTop.Y);
                    }
                }
                else if (quadrant==2)
                {
                    if (ptPre.X>ptLeftTop.X && pt.X<=ptLeftTop.X)
                    {
                        this.Canvas.lineTo(ptLeftTop.X,ptLeftTop.Y);
                    }
                }
                else if (quadrant==3)
                {
                    if (ptPre.X>ptLeftBottom.X && pt.X<=ptLeftBottom.X)
                    {
                        this.Canvas.lineTo(ptLeftBottom.X,ptLeftBottom.Y);
                    }
                }
                else if (quadrant==4)
                {
                    if (ptPre.X<ptRightBottom.X && pt.X>=ptRightBottom.X)
                    {
                        this.Canvas.lineTo(ptRightBottom.X,ptRightBottom.Y);
                    }
                }

                this.Canvas.lineTo(pt.X,pt.Y);
                this.Canvas.closePath();
                this.Canvas.fillStyle=clrArea;
                this.Canvas.fill();
            }

            this.Canvas.strokeStyle=item.Color;
            this.Canvas.beginPath();
            this.Canvas.moveTo(center.X,center.Y);
            this.Canvas.lineTo(pt.X,pt.Y);
            this.Canvas.stroke();

            this.LinePoint.push({Start:center, End:pt});

            if (item.Value!=1)
            {
                this.Canvas.strokeStyle=this.LineColor;
                this.Canvas.beginPath();
                this.Canvas.moveTo(x,center.Y);
                this.Canvas.lineTo(x,ptStart.Y);
                this.Canvas.stroke();
            }

            ptPre=pt;
            clrArea=IChartDrawPicture.ColorToRGBA(item.Color, this.AreaConfig.Opacity);

            //文字
            var text=`${item.Value}`;
            this.Canvas.fillStyle=item.Color;
            this.Canvas.fillText(text,x,center.Y+textOffset);
        }
    }

    this.GetArrayAreaConfig=function(aryData)
    {
        var aryArea=[];
        for(var i=0;i<aryData.length;++i)
        {
            var item=aryData[i];
            if (item.Enable) aryArea.push(item);
        }

        aryArea.sort((left,right)=>{ return right.Value-left.Value; })

        return aryArea;
    }

}


function ChartPriceRange()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartPriceRange';
    this.PointCount=2;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.TextColor=this.LineColor;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointToValue_Default=this.PointToValue;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    this.LineWidth=1;
    this.EnableBGColor=true;
    this.BGColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.15);
    this.ExtendLine={ Left:false, Right: false }; //延长线

    this.Label={ TextColor:"rgb(0,0,0)", BGColor:"rgb(211,211,211)", EnableBGColor:true, LeftMargin:5, RightMargin:5 };

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var bCheckXY=true;
        if (this.ExtendLine.Left || this.ExtendLine.Right) bCheckXY=false;
        var drawPoint=this.CalculateDrawPoint( {IsCheckX:bCheckXY, IsCheckY:bCheckXY} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.DrawRange(ptStart,ptEnd);
        this.RestoreLineWidth();

        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.DrawRange=function(ptStart, ptEnd)
    {
        var yTop=Math.min(ptStart.Y, ptEnd.Y);
        var yBottom=Math.max(ptStart.Y, ptEnd.Y);
        var xLeft=Math.min(ptStart.X, ptEnd.X);
        var xRight=Math.max(ptStart.X, ptEnd.X);
        var height=yBottom-yTop;
        var xCenter=ptStart.X+(ptEnd.X-ptStart.X)/2;

        if (this.ExtendLine.Right) xRight=this.Frame.ChartBorder.GetRight();
        if (this.ExtendLine.Left) xLeft=this.Frame.ChartBorder.GetLeft();

        if (this.EnableBGColor)
        {
            var rtBG={ Left:xLeft, Top:yTop, Right:xRight, Bottom:yBottom };
            rtBG.Width=rtBG.Right-rtBG.Left;
            rtBG.Height=rtBG.Bottom-rtBG.Top;
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
        }
        

        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(xLeft,ToFixedPoint(yTop));
        this.Canvas.lineTo(xRight,ToFixedPoint(yTop));

        this.Canvas.moveTo(xLeft,ToFixedPoint(yBottom));
        this.Canvas.lineTo(xRight,ToFixedPoint(yBottom));

        this.Canvas.moveTo(ToFixedPoint(xCenter),ToFixedPoint(yTop));
        this.Canvas.lineTo(ToFixedPoint(xCenter),ToFixedPoint(yBottom));
        this.Canvas.stroke();

        this.LinePoint.push({ Start:{X:xLeft, Y:yTop}, End:{X:xRight, Y:yTop} });
        this.LinePoint.push({ Start:{X:xLeft, Y:yBottom}, End:{X:xRight, Y:yBottom} });
        this.LinePoint.push({ Start:{X:xCenter, Y:yTop}, End:{X:xCenter, Y:yBottom} });

        this.DrawArrow({X:ToFixedPoint(xCenter), Y:ptStart.Y}, {X:ToFixedPoint(xCenter), Y:ptEnd.Y});

        var bottom=this.Frame.ChartBorder.GetBottomEx();
        var top=this.Frame.ChartBorder.GetTopEx();

        //文字输出
        var startValue=this.Frame.GetYData(ptStart.Y,false);
        var endValue=this.Frame.GetYData(ptEnd.Y,false);
        var diffValue=endValue-startValue;
        var rate=(diffValue/startValue)*100;
        var text=`${diffValue.toFixed(2)} (${rate.toFixed(2)}%)`;

        this.Canvas.font=this.Font;
        var textHeight=this.GetFontHeight();
        var textWidth=this.Canvas.measureText(text).width+4+(this.Label.LeftMargin+this.Label.RightMargin);
        var rtTextBG={ Left:xCenter-textWidth/2, Width:textWidth, Height:textHeight+2 };
        if (diffValue>0) rtTextBG.Top=ptEnd.Y-rtTextBG.Height-4;
        else rtTextBG.Top=ptEnd.Y+4;
        rtTextBG.Bottom=rtTextBG.Top+rtTextBG.Height;

        if (diffValue>0)
        {
            if (rtTextBG.Top<=top)
            {
                rtTextBG.Top=top;
                rtTextBG.Bottom=rtTextBG.Top+rtTextBG.Height;
            }
        }
        else
        {
            if (rtTextBG.Bottom>=bottom)
            {
                rtTextBG.Bottom=bottom;
                rtTextBG.Top=rtTextBG.Bottom-rtTextBG.Height;
            }
        }

        if (this.Label.EnableBGColor)
        {
            var path=new Path2D();
            path.roundRect(ToFixedPoint(rtTextBG.Left), ToFixedPoint(rtTextBG.Top), ToFixedRect(rtTextBG.Width), ToFixedRect(rtTextBG.Height), [3]);
            this.Canvas.fillStyle=this.Label.BGColor;
            this.Canvas.fill(path);
        }

        this.Canvas.fillStyle=this.Label.TextColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        this.Canvas.fillText(text,rtTextBG.Left+2+this.Label.LeftMargin,rtTextBG.Bottom-2);
    }

}


function ChartDateRange()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDateRange';
    this.PointCount=2;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.TextColor=this.LineColor;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointToValue_Default=this.PointToValue;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    this.LineWidth=1;
    this.EnableBGColor=true;
    this.BGColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.15);
    this.ExtendLine={ Top:false, Bottom: false }; //延长线

    this.Label={ TextColor:"rgb(0,0,0)", BGColor:"rgb(211,211,211)", EnableBGColor:true, LeftMargin:5, RightMargin:5 };

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var bCheckXY=true;
        var drawPoint=this.CalculateDrawPoint( {IsCheckX:bCheckXY, IsCheckY:bCheckXY} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.DrawRange(ptStart,ptEnd);
        this.RestoreLineWidth();

        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.DrawRange=function(ptStart, ptEnd)
    {
        var yTop=Math.min(ptStart.Y, ptEnd.Y);
        var yBottom=Math.max(ptStart.Y, ptEnd.Y);
        var xLeft=Math.min(ptStart.X, ptEnd.X);
        var xRight=Math.max(ptStart.X, ptEnd.X);
        var height=yBottom-yTop;
        var width=xRight-xLeft;
        var yCenter=ptStart.Y+(ptEnd.Y-ptStart.Y)/2;
        var xCenter=ptStart.X+(ptEnd.X-ptStart.X)/2;

        if (this.ExtendLine.Top) yTop=this.Frame.ChartBorder.GetTopEx();
        if (this.ExtendLine.Bottom) yBottom=this.Frame.ChartBorder.GetBottomEx();

        if (this.EnableBGColor)
        {
            var rtBG={ Left:xLeft, Top:yTop, Right:xRight, Bottom:yBottom };
            rtBG.Width=rtBG.Right-rtBG.Left;
            rtBG.Height=rtBG.Bottom-rtBG.Top;
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
        }
        
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(xLeft),yTop);
        this.Canvas.lineTo(ToFixedPoint(xLeft),yBottom);

        this.Canvas.moveTo(ToFixedPoint(xRight),yTop);
        this.Canvas.lineTo(ToFixedPoint(xRight),yBottom);

        this.Canvas.moveTo(ToFixedPoint(xLeft),ToFixedPoint(yCenter));
        this.Canvas.lineTo(ToFixedPoint(xRight),ToFixedPoint(yCenter));
        this.Canvas.stroke();

        this.LinePoint.push({ Start:{X:xLeft, Y:yTop}, End:{X:xLeft, Y:yBottom} });
        this.LinePoint.push({ Start:{X:xRight, Y:yTop}, End:{X:xRight, Y:yBottom} });
        this.LinePoint.push({ Start:{X:xLeft, Y:yCenter}, End:{X:xRight, Y:yCenter} });

        this.DrawArrow({X:ptStart.X, Y:ToFixedPoint(yCenter)}, {X:ptEnd.X, Y:ToFixedPoint(yCenter)});

        
        //文字输出
        var bottom=this.Frame.ChartBorder.GetBottomEx();
        var top=this.Frame.ChartBorder.GetTopEx();
        var startIndex=this.Frame.GetXData(ptStart.X,false);
        var endIndex=this.Frame.GetXData(ptEnd.X,false);
        var startValue=this.Frame.GetYData(ptStart.Y,false);
        var endValue=this.Frame.GetYData(ptEnd.Y,false);
        var diffValue=endValue-startValue;
        var barCount=endIndex-startIndex+1;
        var text=`${barCount} bars`;

        this.Canvas.font=this.Font;
        var textHeight=this.GetFontHeight();
        var textWidth=this.Canvas.measureText(text).width+4+(this.Label.LeftMargin+this.Label.RightMargin);
        var rtTextBG={ Left:xCenter-textWidth/2, Top:ptEnd.Y+4, Width:textWidth, Height:textHeight+2 };
        if (diffValue>0) rtTextBG.Top=ptEnd.Y-rtTextBG.Height-4;
        else rtTextBG.Top=ptEnd.Y+4;
        rtTextBG.Bottom=rtTextBG.Top+rtTextBG.Height;

        if (diffValue>0)
        {
            if (rtTextBG.Top<=top)
            {
                rtTextBG.Top=top;
                rtTextBG.Bottom=rtTextBG.Top+rtTextBG.Height;
            }
        }
        else
        {
            if (rtTextBG.Bottom>=bottom)
            {
                rtTextBG.Bottom=bottom;
                rtTextBG.Top=rtTextBG.Bottom-rtTextBG.Height;
            }
        }
        

        if (this.Label.EnableBGColor)
        {
            var path=new Path2D();
            path.roundRect(ToFixedPoint(rtTextBG.Left), ToFixedPoint(rtTextBG.Top), ToFixedRect(rtTextBG.Width), ToFixedRect(rtTextBG.Height), [3]);
            this.Canvas.fillStyle=this.Label.BGColor;
            this.Canvas.fill(path);
        }

        this.Canvas.fillStyle=this.Label.TextColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        this.Canvas.fillText(text,rtTextBG.Left+2+this.Label.LeftMargin,rtTextBG.Bottom-2);
        
    }
}

function ChartDatePriceRange()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartDatePriceRange';
    this.PointCount=2;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";
    this.TextColor=this.LineColor;
    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.PointToValue_Default=this.PointToValue;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;
    this.LineWidth=1;
    this.EnableBGColor=true;
    this.BGColor=IChartDrawPicture.ColorToRGBA(this.LineColor,0.15);
    this.ExtendLine={ Top:false, Bottom: false }; //延长线

    this.Label={ TextColor:"rgb(0,0,0)", BGColor:"rgb(211,211,211)", EnableBGColor:true, LeftMargin:5, RightMargin:5 };

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var bCheckXY=true;
        var drawPoint=this.CalculateDrawPoint( {IsCheckX:bCheckXY, IsCheckY:bCheckXY} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.DrawRange(ptStart,ptEnd);
        this.RestoreLineWidth();

        this.DrawPoint(drawPoint);  //画点
        this.Canvas.restore();
    }

    this.DrawRange=function(ptStart, ptEnd)
    {
        var yTop=Math.min(ptStart.Y, ptEnd.Y);
        var yBottom=Math.max(ptStart.Y, ptEnd.Y);
        var xLeft=Math.min(ptStart.X, ptEnd.X);
        var xRight=Math.max(ptStart.X, ptEnd.X);
        var height=yBottom-yTop;
        var width=xRight-xLeft;
        var yCenter=ptStart.Y+(ptEnd.Y-ptStart.Y)/2;
        var xCenter=ptStart.X+(ptEnd.X-ptStart.X)/2;

        if (this.ExtendLine.Top) yTop=this.Frame.ChartBorder.GetTopEx();
        if (this.ExtendLine.Bottom) yBottom=this.Frame.ChartBorder.GetBottomEx();

        if (this.EnableBGColor)
        {
            var rtBG={ Left:xLeft, Top:yTop, Right:xRight, Bottom:yBottom };
            rtBG.Width=rtBG.Right-rtBG.Left;
            rtBG.Height=rtBG.Bottom-rtBG.Top;
            this.Canvas.fillStyle=this.BGColor;
            this.Canvas.fillRect(rtBG.Left, rtBG.Top, rtBG.Width, rtBG.Height);
        }
        
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ToFixedPoint(xLeft),yTop);
        this.Canvas.lineTo(ToFixedPoint(xLeft),yBottom);

        this.Canvas.moveTo(ToFixedPoint(xRight),yTop);
        this.Canvas.lineTo(ToFixedPoint(xRight),yBottom);

        this.Canvas.moveTo(ToFixedPoint(xLeft),ToFixedPoint(yCenter));
        this.Canvas.lineTo(ToFixedPoint(xRight),ToFixedPoint(yCenter));

        this.Canvas.moveTo(ToFixedPoint(xCenter),ToFixedPoint(yTop));
        this.Canvas.lineTo(ToFixedPoint(xCenter),ToFixedPoint(yBottom));

        this.Canvas.stroke();

        this.LinePoint.push({ Start:{X:xLeft, Y:yTop}, End:{X:xLeft, Y:yBottom} });
        this.LinePoint.push({ Start:{X:xRight, Y:yTop}, End:{X:xRight, Y:yBottom} });
        this.LinePoint.push({ Start:{X:xLeft, Y:yCenter}, End:{X:xRight, Y:yCenter} });

        this.DrawArrow({X:ptStart.X, Y:ToFixedPoint(yCenter)}, {X:ptEnd.X, Y:ToFixedPoint(yCenter)});
        this.DrawArrow({X:ToFixedPoint(xCenter), Y:ptStart.Y}, {X:ToFixedPoint(xCenter), Y:ptEnd.Y});
        
        //文字输出
        var bottom=this.Frame.ChartBorder.GetBottomEx();
        var top=this.Frame.ChartBorder.GetTopEx();
        var startIndex=this.Frame.GetXData(ptStart.X,false);
        var endIndex=this.Frame.GetXData(ptEnd.X,false);
        var barCount=endIndex-startIndex+1;
        var startValue=this.Frame.GetYData(ptStart.Y,false);
        var endValue=this.Frame.GetYData(ptEnd.Y,false);
        var diffValue=endValue-startValue;

        var rate=(diffValue/startValue)*100;
        var aryText=
        [
            `${diffValue.toFixed(2)} (${rate.toFixed(2)}%)`,
            `${barCount} bars`
        ];

        this.Canvas.font=this.Font;
        var textHeight=this.GetFontHeight();
        var textWidth=0;
        for(var i=0;i<aryText.length;++i)
        {
            var text=aryText[i];
            var value=this.Canvas.measureText(text).width;
            if (textWidth<value) textWidth=value;
        }
        textWidth+=(this.Label.LeftMargin+this.Label.RightMargin);

        var rtTextBG={ Left:xCenter-textWidth/2, Top:ptEnd.Y+4, Width:textWidth, Height:aryText.length*textHeight+2 };
        if (diffValue>0) rtTextBG.Top=ptEnd.Y-rtTextBG.Height-4;
        else rtTextBG.Top=ptEnd.Y+4;
        rtTextBG.Bottom=rtTextBG.Top+rtTextBG.Height;

        if (diffValue>0)
        {
            if (rtTextBG.Top<=top)
            {
                rtTextBG.Top=top;
                rtTextBG.Bottom=rtTextBG.Top+rtTextBG.Height;
            }
        }
        else
        {
            if (rtTextBG.Bottom>=bottom)
            {
                rtTextBG.Bottom=bottom;
                rtTextBG.Top=rtTextBG.Bottom-rtTextBG.Height;
            }
        }

        if (this.Label.EnableBGColor)
        {
            var path=new Path2D();
            path.roundRect(ToFixedPoint(rtTextBG.Left), ToFixedPoint(rtTextBG.Top), ToFixedRect(rtTextBG.Width), ToFixedRect(rtTextBG.Height), [3]);
            this.Canvas.fillStyle=this.Label.BGColor;
            this.Canvas.fill(path);
        }

        this.Canvas.fillStyle=this.Label.TextColor;
        this.Canvas.textAlign="left";
        this.Canvas.textBaseline="bottom";
        var yText=rtTextBG.Bottom-2;
        for(var i=0;i<aryText.length;++i)
        {
            var text=aryText[i];
            this.Canvas.fillText(text,rtTextBG.Left+2+this.Label.LeftMargin,yText);
            yText-=textHeight;
        }
    }
}

//线段信息统计
function ChartInfoLine()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartInfoLine';
    this.PointCount=2;
    this.Font=12*GetDevicePixelRatio() +"px 微软雅黑";

    this.IsPointIn=this.IsPointIn_XYValue_Line;
    this.GetXYCoordinate=this.GetXYCoordinate_default;
    this.IsShowYCoordinate=false;
    this.CopyData=this.CopyData_default;
    this.OnlyMoveXIndex=true;
    this.IsSupportMagnet=true;

    this.LabelConfig=
    { 
        Font:`${12*GetDevicePixelRatio()}px 微软雅黑`, 
        BGColor:"rgba(135, 206 ,250,0.95)", 
        Mergin:{ Left:10, Right:10, Top:10, Bottom:8 },
        LineSpace:5,    //行间距
        TextAlign:1,    //对齐方式 0=left 1=right
    }

    this.FormatLabelTextCallback=null;

    this.SetOption=function(option)
    {
        if (option.LineColor) this.LineColor=option.LineColor;
        if (option.PointColor) this.PointColor=option.PointColor
        if (option.Label)
        {
            var item=option.Label;
            var dest=this.LabelConfig
            if (item.Font) dest.Font=item.Font;
            if (item.BGColor) dest.BGColor=item.BGColor;
            if (IFrameSplitOperator.IsNumber(item.LineSpace)) dest.LineSpace=item.LineSpace;
            if (IFrameSplitOperator.IsNumber(item.TextAlign)) dest.TextAlign=item.TextAlign;
            if (item.Mergin) CopyMarginConfig(dest.Mergin, item.Mergin);
        }

        if (option.FormatLabelTextCallback) this.FormatLabelTextCallback=option.FormatLabelTextCallback;
    }

    this.Draw=function()
    {
        this.LinePoint=[];
        if (this.IsFrameMinSize()) return;
        if (!this.IsShow) return;

        var drawPoint=this.CalculateDrawPoint( {IsCheckX:true, IsCheckY:false} );
        if (!drawPoint) return;
        if (drawPoint.length!=2) return;

        this.ClipFrame();

        var ptStart=drawPoint[0];
        var ptEnd=drawPoint[1];

        this.SetLineWidth();
        this.Canvas.strokeStyle=this.LineColor;
        this.Canvas.beginPath();
        this.Canvas.moveTo(ptStart.X,ptStart.Y);
        this.Canvas.lineTo(ptEnd.X,ptEnd.Y);
        this.Canvas.stroke();
        this.RestoreLineWidth();

        var line={Start:ptStart, End:ptEnd};
        this.LinePoint.push(line);
        
        this.DrawPoint(drawPoint);  //画点

        var labelInfo={ };
        labelInfo.Config=this.LabelConfig;
        labelInfo.PtStart=ptStart;
        labelInfo.PtEnd=ptEnd;

        this.Canvas.restore();

        this.DrawLabel(labelInfo);
    }

    this.DrawLabel=function(labelInfo)
    {
        if (!this.FormatLabelTextCallback) return;

        labelInfo.AryPoint=this.Point;
        if (this.Status!=10)
        {
            labelInfo.AryValue=this.PointToKLine(this.Point);
        }
        else
        {
            labelInfo.AryValue=this.Value;
        }

        labelInfo.Data=this.Frame.Data; //数据

        this.FormatLabelTextCallback(labelInfo);
        if (!IFrameSplitOperator.IsNonEmptyArray(labelInfo.AryText)) return;

        this.CalculateLabelSize(labelInfo);

        var ptStart=labelInfo.PtStart;
        var ptEnd=labelInfo.PtEnd;
        if (ptStart.X>ptEnd.X) 
        {
            ptStart=labelInfo.PtEnd;
            ptEnd=labelInfo.PtStart;
        }

        var config=labelInfo.Config;
        var xCenter=labelInfo.PtStart.X+(labelInfo.PtEnd.X-labelInfo.PtStart.X)/2;
        var yCenter=labelInfo.PtStart.Y+(labelInfo.PtEnd.Y-labelInfo.PtStart.Y)/2;
        if (ptStart.Y<ptEnd.Y)
        {
            var rtBG={ Left:xCenter, Bottom:yCenter, Width:labelInfo.Width, Height:labelInfo.Height };
            rtBG.Right=rtBG.Left+rtBG.Width;
            rtBG.Top=rtBG.Bottom-rtBG.Height;
        }
        else
        {
            var rtBG={ Left:xCenter, Top:yCenter, Width:labelInfo.Width, Height:labelInfo.Height };
            rtBG.Right=rtBG.Left+rtBG.Width;
            rtBG.Bottom=rtBG.Top+rtBG.Height;
        }

        this.DrawDefaultLabel(labelInfo, rtBG);
    }
}

function ChartBarsPattern()
{
    this.newMethod=IChartDrawPicture;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ChartBarsPattern';
    this.PointCount=2;
    this.KData=null; //K线数据 []

    this.Draw=function()
    {

    }
}


function ChartDrawStorage()
{
    this.DrawData=new Map();    //画图工具数据 key=symbol-Period, value=Map() Key:Guid, Value:{Guid, Symbol, Period, ClassName, Value}
    this.StorageKey;
    this.GetEventCallback;      //事件回调

    this.Load=function(key)     //从本地读取画图工具
    {
        if (!key) return;
        this.StorageKey=key;
        var cacheValue = localStorage[this.StorageKey];
        JSConsole.Chart.Log(`[ChartDrawStorage::Load] Load to localStorage, key=${this.StorageKey}, cache=${cacheValue}`);

        if (!cacheValue) return;
        if (typeof(cacheValue) != "string") return;

        var saveData=JSON.parse(cacheValue);
        for(var i in saveData)
        {
            var item=saveData[i];
            var drawMap=new Map();

            for(var j in item.Value)
            {
                var drawItem=item.Value[j];
                drawMap.set(drawItem.Key, drawItem.Value);    
            }

            this.DrawData.set(item.Key,drawMap);
        }
    }

    this.Save=function()        //把数据保存到本地
    {
        if (!this.StorageKey) return;
        
        var saveData=[];
        for(var stock of this.DrawData)
        {
            var key=stock[0];
            var value=stock[1];
            var itemData={ Key:key, Value:[]};

            for(var drawItem of value)
            {
                if (drawItem[1] && drawItem[1].EnableSave===false) continue;

                itemData.Value.push({Key:drawItem[0], Value:drawItem[1]});
            }

            if (IFrameSplitOperator.IsNonEmptyArray(itemData.Value))
                saveData.push(itemData);
        }

        JSConsole.Chart.Log(`[ChartDrawStorage::Save] save to localStorage, key=${this.StorageKey}`);
        var strData=JSON.stringify(saveData);
        localStorage[this.StorageKey]=strData;
    }

    this.GetItemKey=function(obj)   //生成每个画图工具的key
    {
        var strKey=`${obj.Symbol}-${obj.Period}`;
        return strKey;
    }

    this.SaveDrawData=function(drawPicture)   //保存一个画图工具
    {
        var strKey=this.GetItemKey(drawPicture);
        var data=drawPicture.ExportStorageData();
        if (!data) return;

        if (this.DrawData.has(strKey))  //更新
        {
            JSConsole.Chart.Log('[ChartDrawStorage::SaveDrawData] Upate: key, drawPicture, data', strKey, drawPicture,data);
            this.DrawData.get(strKey).set(data.Guid, data);
        }
        else    //新增
        {
            JSConsole.Chart.Log('[ChartDrawStorage::SaveDrawData] Insert: key, drawPicture, data', strKey, drawPicture,data);
            var newData=new Map();
            newData.set(data.Guid, data);
            this.DrawData.set(strKey,newData);
        }

        JSConsole.Chart.Log('[ChartDrawStorage::SaveDrawData] All draw data： ', this.DrawData);

        this.Save();
    }

    this.DeleteDrawData=function(drawPicture)   //删除一个画图工具
    {
        var strKey=this.GetItemKey(drawPicture);
        if (!this.DrawData.has(strKey))  return;

        var mapDraw=this.DrawData.get(strKey);
        if (!mapDraw.has(drawPicture.Guid)) return;

        mapDraw.delete(drawPicture.Guid);
        this.Save();
    }

    this.Clear=function()
    {
        this.DrawData=new Map();
        this.Save();
    }

    this.GetDrawData=function(obj) //获取已有的画图工具数据{Symbol: , Period:, }
    {
        var data=[];
        var strKey=this.GetItemKey(obj);
        if (!this.DrawData.has(strKey)) return data;

        var stockData=this.DrawData.get(strKey);
        for(var item of stockData)
        {
            data.push(item[1]);
        }

        return data;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  数据分割
//  [0]=Start起始 [1]=End结束 [2]=FixInterval修正的间隔 [3]=Increase
//
function SplitData()
{
    this.Data=[
        [0.000001,	0.000002,	0.000001,	0.0000001],
        [0.000002,	0.000004,	0.000002,	0.0000002],
        [0.000004,	0.000005,	0.000004,	0.0000001],
        [0.000005,	0.00001,	0.000005,	0.0000005],

        [0.00001,	0.00002,	0.00001,	0.000001],
        [0.00002,	0.00004,	0.00002,	0.000002],
        [0.00004,	0.00005,	0.00004,	0.000001],
        [0.00005,	0.0001,		0.00005,	0.000005],

        [0.0001,		0.0002,		0.0001,	0.00001],
        [0.0002,		0.0004,		0.0002,	0.00002],
        [0.0004,		0.0005,		0.0004,	0.00001],
        [0.0005,		0.001,		0.0005,	0.00005],

        [0.001,		0.002,		0.001,	0.0001],
        [0.002,		0.004,		0.002,	0.0002],
        [0.004,		0.005,		0.004,	0.0001],
        [0.005,		0.01,		0.005,	0.0005],

        [0.01,		0.02,		0.01,	0.001],
        [0.02,		0.04,		0.02,	0.002],
        [0.04,		0.05,		0.04,	0.001],
        [0.05,		0.1,		0.05,	0.005],

        [0.1,		0.2,		0.1,	0.01],
        [0.2,		0.4,		0.2,	0.02],
        [0.4,		0.5,		0.4,	0.01],
        [0.5,		1,			0.5,	0.05],

        [1,		2,		0.5,	0.05],
        [2,		4,		0.5,	0.05],
        [4,		5,		0.5,	0.05],
        [5,		10,		0.5,	0.05],

        [10,		20,		10,	2],
        [20,		40,		20,	5],
        [40,		50,		40,	2],
        [50,		100,	50,	10],

        [100,		200,		100,	10],
        [200,		400,		200,	20],
        [400,		500,		400,	10],
        [500,		1000,		500,	50],

        [1000,		2000,		1000,	50],
        [2000,		4000,		2000,	50],
        [4000,		5000,		4000,	50],
        [5000,		10000,		5000,	100],

        [10000,		20000,		10000,	1000],
        [20000,		40000,		10000,	1000],
        [40000,		50000,		10000,	1000],
        [50000,		100000,		10000,	1000],

        [100000,		200000,		100000,	10000],
        [200000,		400000,		100000,	10000],
        [400000,		500000,		100000,	10000],
        [500000,		1000000,	100000,	10000],

        [1000000,		2000000,		1000000,	100000],
        [2000000,		4000000,		1000000,	100000],
        [4000000,		5000000,		1000000,	100000],
        [5000000,		10000000,		1000000,	100000],

        [10000000,		20000000,		10000000,	1000000],
        [20000000,		40000000,		10000000,	1000000],
        [40000000,		50000000,		10000000,	1000000],
        [50000000,		100000000,		10000000,	1000000],

        [100000000,		200000000,		100000000,	10000000],
        [200000000,		400000000,		100000000,	10000000],
        [400000000,		500000000,		100000000,	10000000],
        [500000000,		1000000000,		100000000,	10000000],

        [1000000000,		2000000000,		1000000000,	100000000],
        [2000000000,		4000000000,		1000000000,	100000000],
        [4000000000,		5000000000,		1000000000,	100000000],
        [5000000000,		10000000000,	1000000000,	100000000]
    ];

    this.Find=function(interval)
    {
        for(var i in this.Data)
        {
            var item =this.Data[i];
            if (interval>item[0] && interval<=item[1])
            {
                var result={};
                result.FixInterval=item[2];
                result.Increase=item[3];
                return result;
            }
        }

        return null;
    }
}

function PriceSplitData()
{
    this.newMethod=SplitData;   //派生
    this.newMethod();
    delete this.newMethod;

    this.Data=[
        [0.000001,	0.000002,	0.000001,	0.0000001],
        [0.000002,	0.000004,	0.000002,	0.0000002],
        [0.000004,	0.000005,	0.000004,	0.0000001],
        [0.000005,	0.00001,	0.000005,	0.0000005],

        [0.00001,	0.00002,	0.00001,	0.000001],
        [0.00002,	0.00004,	0.00002,	0.000002],
        [0.00004,	0.00005,	0.00004,	0.000001],
        [0.00005,	0.0001,		0.00005,	0.000005],

        [0.0001,		0.0002,		0.0001,	0.00001],
        [0.0002,		0.0004,		0.0002,	0.00002],
        [0.0004,		0.0005,		0.0004,	0.00001],
        [0.0005,		0.001,		0.0005,	0.00005],

        [0.001,		0.002,		0.001,	0.0001],
        [0.002,		0.004,		0.002,	0.0001],
        [0.004,		0.005,		0.004,	0.0001],
        [0.005,		0.01,		0.005,	0.0005],

        [0.01,		0.02,		0.01,	0.001],
        [0.02,		0.04,		0.02,	0.001],
        [0.04,		0.05,		0.04,	0.001],
        [0.05,		0.1,		0.05,	0.001],

        [0.1,		0.2,		0.1,	0.01],
        [0.2,		0.4,		0.2,	0.01],
        [0.4,		0.5,		0.2,	0.01],
        [0.5,		0.8,		0.2,	0.01],
        [0.8,		1,			0.5,	0.01],

        [1,		2,		0.5,	0.05],
        [2,		4,		0.5,	0.05],
        [4,		5,		0.5,	0.05],
        [5,		10,		0.5,	0.05],

        [10,		12,		10,	2],
        [20,		40,		20,	5],
        [40,		50,		40,	2],
        [50,		100,	50,	10],

        [100,		200,		100,	10],
        [200,		400,		200,	20],
        [400,		500,		400,	10],
        [500,		1000,		500,	50],

        [1000,		2000,		1000,	50],
        [2000,		4000,		2000,	50],
        [4000,		5000,		4000,	50],
        [5000,		10000,		5000,	100],

        [10000,		20000,		10000,	1000],
        [20000,		40000,		20000,	2000],
        [40000,		50000,		40000,	1000],
        [50000,		100000,		50000,	5000],

        [100000,		200000,		100000,	10000],
        [200000,		400000,		200000,	20000],
        [400000,		500000,		400000,	10000],
        [500000,		1000000,	500000,	50000],

        [1000000,		2000000,		1000000,	100000],
        [2000000,		4000000,		2000000,	200000],
        [4000000,		5000000,		4000000,	100000],
        [5000000,		10000000,		5000000,	500000],

        [10000000,		20000000,		10000000,	1000000],
        [20000000,		40000000,		20000000,	2000000],
        [40000000,		50000000,		40000000,	1000000],
        [50000000,		100000000,		50000000,	5000000],

        [100000000,		200000000,		100000000,	10000000],
        [200000000,		400000000,		200000000,	20000000],
        [400000000,		500000000,		400000000,	10000000],
        [500000000,		1000000000,		500000000,	50000000],

        [1000000000,		2000000000,		1000000000,	100000000],
        [2000000000,		4000000000,		2000000000,	200000000],
        [4000000000,		5000000000,		4000000000,	100000000],
        [5000000000,		10000000000,	5000000000,	500000000]
    ];
}

/////////////////////////////////////////////////////////////////////////////
//   全局配置颜色
//
//
function JSChartResource()
{
    this.IsDOMFrameTitle=false;  //外部DOM指标标题栏
    this.IsDOMFrameToolbar=false;

    //全局K线窗口按钮配置
    this.KLineToolbar=
    {
        ModifyIndex:true,   //修改参数
        ChangeIndex:true,   //切换指标
        CloseIndex:true,    //关闭窗口
        OverlayIndex:false, //叠加指标
        MaxMinWindow:true,  //最大最小化窗口
        TitleWindow:true,   //标题模式
        ExportData:false,   //数据导出

        IsShowOverlayToolbar:true,      //是否显示叠加坐标工具栏按钮
        IsShowOverlayFrame:true,        //是否显示右侧叠加坐标
    }

    //全局分时图窗口按钮配置
    this.MinuteToolbar=
    {
        ModifyIndex:true,   //修改参数
        ChangeIndex:true,   //切换指标
        CloseIndex:true,    //关闭窗口
        OverlayIndex:true, //叠加指标
        MaxMinWindow:true,  //最大最小化窗口
        TitleWindow:true,   //标题模式
        ExportData:false,   //数据导出
    }

    this.TooltipBGColor="rgb(255, 255, 255)"; //背景色
    this.TooltipAlpha=0.92;                  //透明度

    this.PopMinuteChart=
    {
        BGColor:"rgba(250,250,250,0.95)",
        BorderColor:"rgb(0,0,0)",
    }

    this.SelectRectBGColor="rgba(1,130,212,0.06)"; //背景色
 //   this.SelectRectAlpha=0.06;                  //透明度

    this.UpBarColor="rgb(238,21,21)";   //上涨柱子颜色
    this.DownBarColor="rgb(25,158,0)";  //下跌柱子颜色
    this.UnchagneBarColor="rgb(0,0,0)"; //平盘柱子颜色
    this.EmptyBarBGColor="rgb(255,255,255)";  //空心柱子背景色
    this.HighLowBarColor='rgb(41,98,255)';  //high low bar 颜色
    this.HighLowText={ FontName:"arial", MaxSize:30, MinSize:4, Color:"rgb(41,98,255)", MaxText:"9999.9" };

    this.SplashScreen=
    {
        BGColor:"rgba(112,128,144,0.5)",
        Title:"下载数据中......",
        TextColor:"rgb(43,54,69)",
        Font:14*GetDevicePixelRatio() +'px 微软雅黑'
    }

    this.HLCArea=
    {
        HighLineColor:'rgb(242,54,69)',
        LowLineColor:"rgb(8,153,129)",
        CloseLineColor:"rgb(224,227,227)",
        LineWidth:2*GetDevicePixelRatio(),

        UpAreaColor:"rgba(253,214,218, 0.5)",
        DownAreaColor:"rgba(205,235,230, 0.5)",
    };

    this.Minute={};
    this.Minute.VolBarColor=null;                       //分时图成交量柱子颜色 默认不用, 设置了柱子就不是红绿了
    this.Minute.VolTitleColor="rgb(105,105,105)";
    this.Minute.PriceColor="rgb(50,171,205)";           //分时图价格线颜色
    this.Minute.PriceLineWidth=1*GetDevicePixelRatio(); //价格线宽度
    this.Minute.AreaPriceColor='rgba(50,171,205,0.1)';  //价格的面积图
    this.Minute.AvPriceColor="rgb(238,127,9)";          //分时图均价线颜色
    this.Minute.PositionColor='rgb(218,165,32)';        //持仓量线段颜色
    this.Minute.FrameSplitTextColor=null;   //刻度文字颜色 (缺省使用 this.FrameSplitTextColor)
    
    this.Minute.Before=
    {
        BGColor:'rgba(240,240,240,0.7)',    //分钟 集合竞价背景
        LineColor:"rgb(50,171,205)",        //集合竞价线段颜色
        VolColor:["rgb(192,192,0)"],        //成交量其他的颜色 colorID=3 开始
        AvPriceColor:'rgb(190,190,190)',    //均线
        Point:{ Color:"rgb(65,105,225)", Radius:2*GetDevicePixelRatio() },

        CloseIcon:
        { 
            Family:'iconfont', 
            Text:"\ue60c", 
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Size:12*GetDevicePixelRatio()
        }                        //关闭按钮
    };

    this.Minute.After=
    {
        BGColor:'rgba(240,240,240,0.7)',    //分钟 集合竞价背景
        LineColor:"rgb(50,171,205)",        //集合竞价线段颜色
        VolColor:["rgb(192,192,0)"],        //成交量其他的颜色 colorID=3 开始
        AvPriceColor:'rgb(190,190,190)',    //均线
        Point:{ Color:"rgb(65,105,225)", Radius:2*GetDevicePixelRatio() },
    };

    this.Minute.NightDay=
    { 
        NightBGColor:"rgba(0,0,0,0.2)",
        Font:`${12*GetDevicePixelRatio()}px 微软雅黑`,
        Day: { Color:"rgb(0,0,0)", BGColor:"rgb(179,179,179)", BorderColor:"rgb(179,179,179)", Margin:{ Left:5, Top:2, Bottom:2, Right:5 } },
        Night: { Color:"rgb(0,0,0)", BGColor:"rgb(179,179,179)", BorderColor:"rgb(179,179,179)", Margin:{ Left:5, Top:2, Bottom:2, Right:5 } },
    }

    this.DefaultTextColor="rgb(43,54,69)";                          //图形中默认的字体颜色
    this.DefaultTextFont=14*GetDevicePixelRatio() +'px 微软雅黑';    //图形中默认的字体
    this.TitleFont=13*GetDevicePixelRatio() +'px 微软雅黑';          //指标显示,tooltip显示字体
    this.IndexTitleBGColor='rgb(250,250,250)';                      //指标名字背景色
    this.IndexTitleBorderColor='rgb(180,180,180)';                  //指标名字边框颜色
    this.IndexTitleBorderMoveOnColor='rgb(0,0,0)';                   //指标名字边框颜色(鼠标在上面)
    this.IndexTitleBorderStyle=1,                                   //0=直角边框 1=圆角边框
    this.IndexTitleColor="rgb(43,54,69)";                           //指标名字颜色
    this.IndexTitleSelectedColor="rgb(65,105,225)";
    this.OverlayIndexTitleBGColor='rgba(255,255,255,0.7)';
    this.IndexTitleMerginLeft=1;        //指标输出左边间距

    this.IndexTitle=
    {
        UpDownArrow:    //数值涨跌箭头
        {
            UpColor:"rgb(238,21,21)",   //上涨
            DownColor:"rgb(25,158,0)",  //下跌
            UnchangeColor:"rgb(0,0,0)"  //不变
        },

        ArrowType:0,
        EnableIndexArrow:true,  //指标数值是否带上涨下跌箭头

        NameArrow:{ Color:"rgb(43,54,69)", Space:2, Symbol:'▼' },
    }

    this.Title={
        TradeIndexColor:'rgb(105,105,105)', //交易指标颜色
        ColorIndexColor:'rgb(112,128,144)',  //五彩K线颜色

        VolColor:"rgb(43,54,69)",       //标题成交量
        AmountColor:"rgb(43,54,69)",    //成交金额 
        DateTimeColor:"rgb(43,54,69)",  //时间,日期  
        SettingColor:"rgb(43,54,69)",   //周期,复权
        NameColor:"rgb(43,54,69)" ,     //股票名称
        TurnoverRateColor:'rgb(43,54,69)',       //换手率
        PositionColor:"rgb(43,54,69)"       //持仓
    };

    this.UpTextColor="rgb(238,21,21)";      //上涨文字颜色
    this.DownTextColor="rgb(25,158,0)";     //下跌文字颜色
    this.UnchagneTextColor="rgb(0,0,0)";    //平盘文字颜色 
    this.CloseLineColor='rgb(0,191,255)';   //收盘价线颜色
    this.CloseLineAreaColor=['rgba(0,191,255,0.8)','rgba(0,191,255,0.2)'];  //收盘价面积图颜色
    this.CloseLineWidth=2;  //收盘价面积|收盘价|叠加的收盘价线段宽度

    this.FrameBorderPen="rgb(225,236,242)";         //边框颜色
    this.MultiDayBorderPen='rgb(225,236,242)';      //多日分时图集合竞价分割线
    this.FrameSplitPen="rgb(225,236,242)";          //刻度分割线
    this.FrameDotSplitPen='rgb(105,105,105)';       //分割虚线
    this.FrameYLineDash= null; //[5*GetDevicePixelRatio(), 5*GetDevicePixelRatio()];                     //Y轴线段虚线点间距,填null 就是实线
    this.FrameXLineDash= null; //[5*GetDevicePixelRatio(), 5*GetDevicePixelRatio()];                   //X轴线段虚线点间距,填null 就是实线
    this.FrameSplitTextColor="rgb(117,125,129)";    //刻度文字颜色
    this.FrameSplitTextFont=14*GetDevicePixelRatio() +"px 微软雅黑";            //坐标刻度文字字体
    this.FrameTitleBGColor="rgb(246,251,253)";  //标题栏背景色
    this.SelFrameBorderColor='rgb(130, 130, 130)';
    this.Frame={ 
        XBottomOffset:2*GetDevicePixelRatio(),  //X轴文字向下偏移
        YTopOffset:2*GetDevicePixelRatio(),      //Y轴顶部文字向下偏移
        YTextPadding:[2,2],
        EnableRemoveZero:true,                  //移除小数点后面的0
        StringFormat:0
    };
    this.ToolbarButtonStyle=0;

    this.FrameLogo=
    {
        TextColor:'rgb(178,34,34)',
        Font:"bold "+ 16*GetDevicePixelRatio() +"px 微软雅黑",
        Text:"*仅学习使用*",     //不要修改声明, 任何修改声明产生的任何法律责任由修改者自行独立承担，与HQChart插件作者无关。
        BGColor:"rgba(230,230,230, 0.5)",
    };

    //百分比坐标文字颜色
    this.Frame.PercentageText= { 
        PriceColor:'rgb(117,125,129)', 
        PercentageColor:"rgb(117,125,129)", 
        SplitColor:"rgb(117,125,129)",
        Font:14*GetDevicePixelRatio() +"px 微软雅黑"
    };

    //对数坐标
    this.FrameLogarithmic= {
        OpenPriceFont: "bold "+14*GetDevicePixelRatio() +"px 微软雅黑",     //开盘价刻度文字字体
        MinInterval: 45*GetDevicePixelRatio()       //刻度最小间距
    };  

    //等比坐标
    this.FrameSplitIncrease= { 
        Increase:0.1    //涨幅
    };

    //等分坐标
    this.FrameSplitAverage= { 
        Count:4     //分割个数
    };

    //黄金分割坐标
    this.FrameGoldenSection=
    {
        Golden:[0, 0.191, 0.382, 0.5, 0.618, 0.809, 1]
    };

    //Y轴最新价格刻度颜色
    this.FrameLatestPrice = 
    {
        TextColor:'rgb(255,255,255)',   //最新价格文字颜色
        UpBarColor:"rgb(238,21,21)",    //上涨
        DownBarColor:"rgb(25,158,0)",   //下跌
        UnchagneBarColor:"rgb(0,0,0)",   //平盘
        BGAlpha:0.6,
        EmptyBGColor:"rgb(255,255,255)",    //空心背景色

        OverlayTextColor:"rgb(255,255,255)",       //叠加股票的文字颜色
    };

    this.FrameMargin=4;     //左右一共的边距
    this.FrameLeftMargin=2;
    this.FrameRightMargin=2;

    this.DragSubFrameBorder= {
        TopBorderHeight:6*GetDevicePixelRatio(), //拖拽边框高度
        MinFrameHeight:50*GetDevicePixelRatio() //指标窗口最小高度
    },

    //叠加指标框架
    this.OverlayFrame={
        BolderPen:'rgb(190,190,190)',                    //指标边框线
        TitleColor:'rgb(105,105,105)',                   //指标名字颜色
        TitleFont:11*GetDevicePixelRatio() +'px arial',  //指标名字字体
    };

    this.CorssCursorBGColor="rgb(43,54,69)";            //十字光标背景
    this.CorssCursorTextColor="rgb(255,255,255)";       //十字光文字颜色
    this.CorssCursorTextFont=14*GetDevicePixelRatio() +"px 微软雅黑";
    this.CorssCursorHPenColor="rgb(130,130,130)";          //十字光标线段颜色(水平)
    this.CorssCursorVPenColor="rgb(130,130,130)";          //十字光标线段颜色(垂直)
    this.CorssCursorXRangeBGColor="rgba(100,149,237,0.3)";  //十字光标X轴访问背景色

    this.CorssCursor=
    { 
        RightButton : 
        { 
            BGColor:'rgb(43,54,69)', 
            PenColor:'rgb(255,255,255)',
            Icon: { Text:'\ue6a3', Color:'rgb(255,255,255)', Family:"iconfont", Size:18 }
        },

        RightMargin: { Left:2, Right:2, Top:5, Bottom:3 }
    };

    this.LockBGColor = "rgb(220, 220, 220)";        //指标锁区域颜色
    this.LockTextColor = "rgb(210, 34, 34)";        //指标锁提示信息文字颜色

    this.Domain="http://127.0.0.1:8080";                 //API域名
    this.CacheDomain="http://127.0.0.1:8087";            //缓存域名
    this.PyIndexDomain='http://127.0.0.1:8088';          //py指标计算域名

    //K线配置
    this.KLine=
    {
        MaxMin: {Font:12*GetDevicePixelRatio() +'px 微软雅黑',Color:'rgb(43,54,69)', RightArrow:"→", LeftArrow:"←", HighYOffset:0, LowYOffset:0},   //K线最大最小值显示
        Info:  //信息地雷
        {
            Investor:
            {
                ApiUrl:'/API/NewsInteract', //互动易
                IconFont: { Family:'iconfont', Text:'\ue631' , HScreenText:'\ue684', Color:'#1c65db'} //SVG 文本
            },
            Announcement:                                           //公告
            {
                ApiUrl:'/API/ReportList',
                IconFont: { Family:'iconfont', Text:'\ue633', HScreenText:'\ue685', Color:'#f5a521' },  //SVG 文本
                IconFont2: { Family:'iconfont', Text:'\ue634', HScreenText:'\ue686', Color:'#ed7520' }, //SVG 文本 //季报
            },
            Pforecast:  //业绩预告
            {
                ApiUrl:'/API/StockHistoryDay',
                IconFont: { Family:'iconfont', Text:'\ue62e', HScreenText:'\ue687', Color:'#986cad' } //SVG 文本
            },
            Research:   //调研
            {
                ApiUrl:'/API/InvestorRelationsList',
                IconFont: { Family:'iconfont', Text:'\ue632', HScreenText:'\ue688', Color:'#19b1b7' } //SVG 文本
            },
            BlockTrading:   //大宗交易
            {
                ApiUrl:'/API/StockHistoryDay',
                IconFont: { Family:'iconfont', Text:'\ue630', HScreenText:'\ue689', Color:'#f39f7c' } //SVG 文本
            },
            TradeDetail:    //龙虎榜
            {
                ApiUrl:'/API/StockHistoryDay',
                IconFont: { Family:'iconfont', Text:'\ue62f', HScreenText:'\ue68a' ,Color:'#b22626' } //SVG 文本
            },

            //扩展图标库
            IconLibrary:
            {
                Family:'iconfont',
                Icon:
                [
                    { Text:'\ue630', HScreenText:'\ue689', Color:'#f39f7c' }, 
                    { Text:'\ue632', HScreenText:'\ue688', Color:'#19b1b7' },
                    { Text:'\ue62f', HScreenText:'\ue68a' ,Color:'#b22626' },
                    { Text:'\ue634', HScreenText:'\ue686', Color:'#ed7520' }
                ]
            },

        },
        NumIcon:
        {
            Color:'rgb(251,80,80)',Family:'iconfont',
            Text:[  '\ue649',
                    '\ue63b','\ue640','\ue63d','\ue63f','\ue645','\ue641','\ue647','\ue648','\ue646','\ue636',
                    '\ue635','\ue637','\ue638','\ue639','\ue63a','\ue63c','\ue63e','\ue642','\ue644','\ue643'
                ]
        },
        TradeIcon:  //交易指标 图标
        {
            Family:'iconfont', 
            Buy: { Color:'rgb(255,15,4)', Text:'\ue683', HScreenText:'\ue682'}, 
            Sell: { Color:'rgb(64,122,22)', Text:'\ue681',HScreenText:'\ue680'},
        }
    };

    this.VirtualKLine=
    {
        Color:'rgb(100,100,100)', 
        LineDash:[2,2]
    };

    this.PriceGapStyple=
    { 
        Line:{ Color:"rgb(186,186,186)" }, 
        Text:{ Color:"rgb(105,105,105)", Font:`${12*GetDevicePixelRatio()}px 微软雅黑`} 
    };

    //订单流配置
    this.OrderFlow=
    { 
        UpColor:{BG:'rgb(223,191,180)', Border:"rgb(196,84,86)" },          //阳线
        DownColor:{ BG:"rgb(176,212,184)", Border:'rgb(66,94,74)' },        //阴线
        UnchagneColor: {BG:"rgb(216,221,177)", Border:"rgb(209,172,129)"},  //平盘
        Text:{ Color: "rgb(92,96,89)" , Family:'Arial', FontMaxSize:18, MaxValue:"8888" },  //文字(风格 2，3共用)
        Line:{ UpDownColor: "rgb(0,0,0)", MiddleColor:"rgb(211,211,211)" },  //最大, 最低,中间 竖线
        AlwaysShowOrderText:true,   //总是显示订单流文字

        POCGBColor:"rgba(178,34,34,0.8)",
        AskBarColor:'rgb(14,209,69)',
        BidBarColor:'rgb(236,28,36)'
    };

    this.OrderFlow_Style2=
    {
        BarWidth:10,
        UpColor:'rgb(241,55,63)',
        DownColor:"rgb(75,105,150)",
        UnchagneColor:"rgb(79,79,79)"
    };

    this.OrderFlow_Style3=
    {
        BarWidth:20,
        UpColor:'rgb(241,55,63)',
        DownColor:"rgb(75,105,150)",
        UnchagneColor:"rgb(79,79,79)"
    };

    this.OrderFlow_Style4=
    {
        KBarWidth:5,
        UpColor:'rgb(241,55,63)',
        DownColor:"rgb(75,105,150)",
        UnchagneColor:"rgb(79,79,79)",
        VolBarSpace:1,
        LeftMargin:1,
        RightMargin:1
    };

    
    this.OrderFlow_Style5=
    {
        AskBarColor:"rgb(176,22,22)",  //左
        BidBarColor:"rgb(98,126,176)",    //右
        LeftMargin:3,
        RightMargin:2,
    };
   

    this.Index={};
    //指标线段颜色
    this.Index.LineColor=
    [
        "rgb(255,174,0)",
        "rgb(25,199,255)",
        "rgb(175,95,162)",
        "rgb(236,105,65)",
        "rgb(68,114,196)",
        "rgb(229,0,79)",
        "rgb(0,128,255)",
        "rgb(252,96,154)",
        "rgb(42,230,215)",
        "rgb(24,71,178)",

    ];

    this.OverlaySymbol={ Random:0 };    //Random 颜色的随机数
    this.OverlaySymbol.Color=   //叠加股票颜色
    [
        "rgb(38,198,218)",
        "rgb(103,58,183)",
        "rgb(0,191,165)",
        "rgb(130,177,255)",
    ];

    //历史数据api
    this.Index.StockHistoryDayApiUrl="http://127.0.0.1:8080/API/StockHistoryDay";
    //市场多空
    this.Index.MarketLongShortApiUrl="http://127.0.0.1:8080/API/FactorTiming";
    //市场关注度
    this.Index.MarketAttentionApiUrl="http://127.0.0.1:8080/API/MarketAttention";
    //行业,指数热度
    this.Index.MarketHeatApiUrl="http://127.0.0.1:8080/API/MarketHeat";
    //自定义指数热度
    this.Index.CustomIndexHeatApiUrl="http://127.0.0.1:8080/API/QuadrantCalculate";

    //指标不支持信息
    this.Index.NotSupport={Font:`${14*GetDevicePixelRatio()}px 微软雅黑`, TextColor:"rgb(52,52,52)"};

    //按钮
    this.Buttons=
    {
        CloseOverlayIndex:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue60c",
            Size:12*GetDevicePixelRatio(),
            MerginLeft:3
        },

        CloseWindow:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue60c",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        ChangeIndex:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue656",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        OverlayIndex:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue655",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        ModifyIndexParam:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue604",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        //最大化, 最小化
        MaxMinWindow:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue6a5",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        //指标标题窗口模式
        TitleWindow:
        {
            Color:"rgb(0,0,0)",
            MoveOnColor:'rgb(30,144,255)',
            Family:"iconfont",
            Text:"\ue6a6",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

         //指标标题窗口模式
         ExportData:
         {
             Color:"rgb(0,0,0)",
             MoveOnColor:'rgb(30,144,255)',
             Family:"iconfont",
             Text:"\ue6a9",
             Size:13*GetDevicePixelRatio(),
             MerginLeft:4
         },

        Tooltip:
        {
            Font:13*GetDevicePixelRatio() +"px 微软雅黑",
            Color:'rgb(71,71,71)',
            ColorBG:'rgb(255,255,255)',
            ColorBorder:'rgb(0,0,0)',
            BorderRadius:2,
            Mergin:{ Left:4, Right:4, Top:2, Bottom:3 },
        }
    }
   
    //画图工具
    this.DrawPicture=
    {
        LineColor:
        [ 
            "rgb(41,98,255)" 
        ],
        PointColor:
        [
            "rgb(41,98,255)",          //选中颜色
            "rgb(89,135,255)",    //moveon颜色
            "rgb(255,255,255)"          //空心点背景色
        ],

        XYCoordinate:
        {
            BGColor:'rgba(203,216,255,0.5)',    //区间段背景色
            TextBGColor:"rgb(52,101,255)",      //文字背景色
            TextColor:"rgb(255,255,255)",       //文字颜色
            Font:14*GetDevicePixelRatio() +"px 微软雅黑"   //文字字体
        },

        PointType:2,    // 0=圆点  1=方框 2=空心圆
        IsShowPoint:false //是否始终显示点
    };

    this.ChartOX=
    {
        Family:'iconfont', 
        Up:{Color:'rgb(178,34,34)', Text:"\ue697" },
        Down:{Color:"rgb(0,206,209)", Text:"\ue68c" },
        SquareLineColor:'rgb(119,136,153)'
    };

    this.KLineTrain = {
        Font:'bold 14px arial',
        LastDataIcon: {Color:'rgb(0,0,205)',Text:'⬇'},
        BuyIcon: {Color:'rgb(0,205,102 )',Text:'B'},
        SellIcon: {Color:'rgb(255,127,36 )',Text:'S'},

        IconFont:
        {
            Family:'iconfont', 
            Buy:{ Text:'\ue64a', HScreenText:'\ue68a' ,Color:'rgb(255,140,0)' },
            Sell:{ Text:'\ue64b', HScreenText:'\ue68a' ,Color:'rgb(6,79,18)' },
            Last:{ Text:'\ue681', HScreenText:'\ue68a' ,Color:'rgb(55,0,255)' },
        }
    };

    this.ChartKLineTable=
    {
        TextFont:{ Family:'Arial' , FontMaxSize:25 },
        ItemMergin:{ Left:5, Right:5, Top:4, Bottom:2 },
    };

    //手机端tooltip
    this.TooltipPaint = {
        BGColor:'rgba(250,250,250,0.8)',    //背景色
        BorderColor:'rgb(120,120,120)',     //边框颜色
        TitleColor:'rgb(79, 79, 79)',       //标题颜色
        TitleFont:13*GetDevicePixelRatio() +'px 微软雅黑',   //字体
        DateTimeColor:'rgb(105 105 105)',
        VolColor:"rgb(255, 185, 15)",       //标题成交量
        AmountColor:"rgb(79, 79, 79)",    //成交金额
    };

    this.PCTooltipPaint = 
    {
        BGColor:'rgba(250,250,250)',        //背景色
        BorderColor:'rgb(120,120,120)',     //边框颜色
        TitleColor:'rgb(60,60,60)',       //标题颜色
        TitleFont:12*GetDevicePixelRatio() +'px 微软雅黑',   //字体
        DateTimeColor:'rgb(60,60,60)',
        VolColor:"rgb(60,60,60)",       //标题成交量
        AmountColor:"rgb(60,60,60)",    //成交金额
    };

    this.PCTooltip= {
        LineHeight:25   //单行高度
    };

    //弹幕
    this.Barrage= {
        Font:16*GetDevicePixelRatio() +'px 微软雅黑',   //字体
        Height:20,
        Color:'RGB(109,109,109)'
    }

    //走势图 信息地雷
    this.MinuteInfo={
        TextColor: 'rgb(84,143,255)',
        Font: 14*GetDevicePixelRatio() +'px 微软雅黑',
        PointColor:'rgb(38,113,254)',
        LineColor:'rgb(120,167,255)',
        TextBGColor:'rgba(255,255,255,0.8)',
        PointRadius:4*GetDevicePixelRatio(),   //圆点半径
    }

    //画图工具-尺子
    this.ChartDrawRuler=
    {
        TitleColor:null,    //K线信息标题颜色, (可选,不填使用涨跌颜色)
    }

    //画图工具-波浪尺
    this.ChartDrawWaveRuler=
    {
        RulerWidth:10,          //刻度尺长度
        RulerLineWidth:1,       //刻度线粗细
        MaxScaleRuler:2,       //尺子最大的高度比
        Font:14*GetDevicePixelRatio() +"px 微软雅黑",
        ScaleRuler:
        [
            {Value:0, Text:"0.0%"}, { Value:0.382, Text:"38.2%" }, { Value:0.618, Text:"61.8%" } ,{ Value:1, Text:"100%"},
            { Value:1.618, Text:"161.8%" }, { Value:2.0, Text:"200%" }
        ]
    }

    this.ChartDrawWaveRuler2Point=
    {
        RulerWidth:20,          //刻度尺长度
        RulerLineWidth:1,       //刻度线粗细
        MaxScaleRuler:2,        //尺子最大的高度比
        Font:14*GetDevicePixelRatio() +"px 微软雅黑",
        ScaleRuler:
        [
            {Value:0, Text:"base"},  { Value:0.618, Text:"61.8%" } ,{ Value:1, Text:"100%"},
            { Value:1.618, Text:"161.8%" }
        ]
    }

    this.ChartDrawVolProfile=
    {
        BGColor:"rgba(244,250,254,0.8)",
        BorderColor:"rgba(255,255,255)",
        VolLineColor:"rgb(232,5,9)",

        UpVolColor:"rgba(103,179,238, 0.24)",
        DownVolColor:"rgba(237,208,105,0.24)",
        AreaUpColor:"rgb(103,179,238,0.7)",
        AreaDonwColor:"rgba(237,208,105,0.7)",

        Text:{ Color: "rgb(0,0,0)" , Family:'Arial', FontMaxSize:18, FontMinSize:6 },  //文字
    }

    this.ChartVolProfileVisibleRange=
    {
        VolLineColor:"rgb(232,5,9)",
        VolLineFont:14*GetDevicePixelRatio() +"px 微软雅黑",
        VolLineTextColor:'rgb(255,255,255)',

        UpVolColor:"rgba(103,179,238, 0.24)",
        DownVolColor:"rgba(237,208,105,0.24)",
        AreaUpColor:"rgb(103,179,238,0.7)",
        AreaDonwColor:"rgba(237,208,105,0.7)",

        Text:{ Color: "rgb(0,0,0)" , Family:'Arial', FontMaxSize:18, FontMinSize:6 },  //文字

        VAHLineColor:'rgb(0,0,255)',
        VAHTextColor:"rgb(255,255,255)",
        VALLineColor:"rgb(0,0,255)",
        VALTextColor:"rgb(255,255,255)",
        VAFont:14*GetDevicePixelRatio() +"px 微软雅黑",
    }

    this.ChartDrawNote=
    {
        Text:"\ue6aa",
        FontOption:{ Family:'iconfont', Size:32 },
        NoteFontOption:{ Family:'微软雅黑', Size:12, Weight:null, Style:null },    //Weight(bold 粗体), Style(italic)

        NoteWidth:200,
        NoteMargin:{ Left:5, Top:5, Bottom:5, Right:5 },
        NoteBGColor:'rgba(104,114,255,0.7)',
        NoteTextColor:"rgb(240,240,240)",
        NoteBorderColor:"rgb(220,220,220)",
        LineSpace:3, //行间距
        ArrowSize:10
    }

    this.ChartDrawAnchoredText=
    {
        TextMargin:{ Left:5, Top:5, Bottom:5, Right:5 },
        BGColor:'rgba(104,114,255,0.7)',
        BorderColor:"rgb(220,220,220)",
        TextColor:'rgb(0,0,0)',
        FontOption:{ Family:'微软雅黑', Size:12, Weight:null, Style:null },    //Weight(bold 粗体), Style(italic)
        LineSpace:2,    //行间距
        TextMaxWidth:-1
    }

    this.ChartDrawPriceLabel=
    {
        TextMargin:{ Left:10, Top:5, Bottom:5, Right:10 },
        BGColor:'rgba(104,114,255,0.7)',
        BorderColor:"rgb(220,220,220)",
        TextColor:'rgb(0,0,0)',
        FontOption:{ Family:'微软雅黑', Size:14, Weight:null, Style:null },    //Weight(bold 粗体), Style(italic)
    }

    this.ChartDrawPriceNote=
    {
        TextMargin:{ Left:10, Top:5, Bottom:5, Right:10 },
        BGColor:'rgba(104,114,255,0.7)',
        BorderColor:"rgb(220,220,220)",
        TextColor:'rgb(0,0,0)',
        FontOption:{ Family:'微软雅黑', Size:14, Weight:null, Style:null },    //Weight(bold 粗体), Style(italic)
    }

    //多图标指标ChartMultiSVGIcon -> MULTI_SVGICON
    //单图标指标ChartSingleText -> DRAWICON
    this.DRAWICON=
    {
        Icon:
        {
            MaxSize:24,  //图标最大
            MinSize:12,  //图标最小
            YOffset:0,
    
            Zoom:
            {
                Type:1,    //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
                Value:1
            }
        },
       
        Text:
        {
            MaxSize:50,  //字体最大
            MinSize:12,  //字体最小
            YOffset:0,
    
            Zoom:
            {
                Type:1,    //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
                Value:1
            },

            FontName:'Arial'    //字体
        }
    }

    this.DRAWTEXT=
    {
        MaxSize:30,  //字体最大
        MinSize:20,  //字体最小
        YOffset:0,

        Zoom:
        {
            Type:1,    //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
            Value:1
        },

        FontName:'微软雅黑'    //字体
    }

    this.DRAWNUMBER=
    {
        MaxSize:30,  //字体最大
        MinSize:20,  //字体最小
        YOffset:0,

        Zoom:
        {
            Type:1,    //0=放大(K线宽度*Value) 1=放大(K线+间距)*Value 2=(K线+间距)+2*Value;
            Value:1
        },

        FontName:'微软雅黑'    //字体
    }

    this.DRAWABOVE=
    {
        YOffset:0   //y坐标向上偏移
    }

    this.DRAWTEXT_FIX={ Font:14*GetDevicePixelRatio() +'px 微软雅黑' }
    this.DRAWNUMBER_FIX={ Font:14*GetDevicePixelRatio() +'px 微软雅黑' }

    //虚线配置
    this.DOTLINE=
    {
        LineDash:[3,5]  //虚线配置
    }

    this.DRAWSL=
    {
        PixelWidth:15   //1个像素点宽度
    }

    this.CIRCLEDOT=
    {
        Radius:1.3*GetDevicePixelRatio()
    }

    this.TIPICON=
    {
        Family:'iconfont', 
        TextFont:`${GetDevicePixelRatio()}px 微软雅黑`,
        Size:10*GetDevicePixelRatio(),
        Color:"rgb(255,165,0)"
    }

    this.POINTDOT=
    {
        Radius:2*GetDevicePixelRatio()
    }

    this.DepthMapPaint=
    {
        LineColor:"rgba(255,185,15)",
        AreaColor:["rgba(255,185,15,0.8)","rgba(255,185,15,0.4)"],
        TextColor:"rgba(255,255,255)",
        TextBGColor:'rgb(43,54,69)'
    }

    this.KLineYAxisBGPaint=
    {
        Font:12*GetDevicePixelRatio() +'px 微软雅黑',
        LineColor:"rgb(117,125,129)",
        DiffValutTextColor:"rgb(117,125,129)",
        DiffValueBGColor:"rgb(251,140,1)"
    }

    //筹码分布图
    this.StockChip=
    {
        InfoColor:'rgb(0,0,0)', //文字颜色
        DayInfoColor:'rgb(255,255,255)', //周期颜色内文字颜色

        DefaultButton:
        {
            Color:"rgb(128,128,128)",
            MoveOnColor:'rgb(30,144,255)',
            SelectedColor:"rgb(255,0,0)",
            Family:"iconfont",
            Text:"\ue621",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        LongButton:
        {
            Color:"rgb(128,128,128)",
            MoveOnColor:'rgb(30,144,255)',
            SelectedColor:"rgb(255,128,0)",
            Family:"iconfont",
            Text:"\ue617",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },

        RecentButton:
        {
            Color:"rgb(128,128,128)",
            MoveOnColor:'rgb(30,144,255)',
            SelectedColor:"rgb(0,0,204)",
            Family:"iconfont",
            Text:"\ue617",
            Size:13*GetDevicePixelRatio(),
            MerginLeft:4
        },
    }

    //深度图
    this.DepthChart=
    {
        BidColor: { Line:"rgb(82,176,123)", Area:"rgba(82,176,123,0.8)"},  //卖
        AskColor: { Line:"rgb(207,76,89)", Area:"rgba(207,76,89, 0.8)"},   //买
        LineWidth:4
    }

    this.DepthCorss=
    {
        BidColor: { Line:"rgb(82,176,123)" },  //卖
        AskColor: { Line:"rgb(207,76,89)" },   //买
        LineWidth:2,    //线段宽度
        LineDash:[3,3],
        Tooltip:
        { 
            BGColor:'rgba(236,240,245, 0.8)', TextColor:"rgb(130,140,151)",
            Border:{ Top:5, Left:20, Right:20, Bottom:5, ItemSpace:5 },
            Font:14*GetDevicePixelRatio() +"px 微软雅黑",
        }
    }

    //区间选择
    this.RectSelect=
    {
        LineColor:"rgb(64,64,64)",          //竖线  
        LineWidth:1*GetDevicePixelRatio(),
        LineDotted:[3,3], 
        AreaColor:"rgba(234,234,234,0.5)",     //面积
        SubAreaColor:"rgba(105,105,105,0.5)",

        RangeTextColor:"rgb(248,248,255)",
        RangeTextFont:14*GetDevicePixelRatio() +"px 微软雅黑",
        RangeTextBGColor:'rgb(43,54,69)',

        RangeTextSubColor:"rgb(255,255,255)",
        RangeTextSubFont:12*GetDevicePixelRatio() +"px 微软雅黑",
        RangeTextSubBGColor:'rgb(54,54,54)',
    }

    //选中图形
    this.SelectedChart=
    {
        LineWidth:1,
        LineColor:'rgb(55,100,100)',
        Radius:4,
        MinSpace:200, //点和点间最小间距
        BGColor:"rgb(255,255,255)"
    }

    //鼠标区间选中
    this.RectDrag=
    {
        LineColor:"rgb(0,0,0)",          //竖线  
        LineWidth:1*GetDevicePixelRatio(),
        BGColor:"rgba(128,128,128,0.2)",     //面积
    }

    this.DragMovePaint=
    {
        TextColor:"rgb(0,0,0)",
        Font:14*GetDevicePixelRatio() +"px 微软雅黑"
    }

    this.SessionBreaksPaint=
    {
        BGColor:[null, "rgb(245,246,246)"],
        SplitLine:{ Color:'rgb(73,133,231)', Width:1*GetDevicePixelRatio(), Dash:[5*GetDevicePixelRatio(),5*GetDevicePixelRatio()] }
    }


    //成交明细
    this.DealList=
    {
        BorderColor:'rgb(192,192,192)',    //边框线
        Header:
        {
            Color:"RGB(60,60,60)",
            Mergin:{ Left:5, Right:5, Top:4, Bottom:2 },
            Font:{ Size:12, Name:"微软雅黑" }
        },

        Row:
        {
            Mergin:{ Top:2, Bottom:2 },
            Font:{ Size:15, Name:"微软雅黑"},
            BarMergin:{ Top:2, Left:3, Right:3, Bottom:2 }
        },

        FieldColor:
        {
            Vol:"rgb(90,90,90)",    //成交量
            Time:"rgb(60,60,60)",   //时间
            Deal:"rgb(90,90,90)",   //成交笔数
            Index:"rgb(60,60,60)",  //序号
            BarTitle:'rgb(60,60,60)',   //柱子文字

            Text:"rgb(60,60,60)",   //默认文本

            Bar:
            [
                "rgb(255,0,0)", "rgb(34,139,34)", "rgb(119,136,153)","rgb(75,0,130)",
                "rgb(65,105,225)","rgb(255,215,0)", 'rgb(255,0,255)', "rgb(128,128,0)"
            ]  //柱子颜色
        },

        UpTextColor:"rgb(238,21,21)",      //上涨文字颜色
        DownTextColor:"rgb(25,158,0)",     //下跌文字颜色
        UnchagneTextColor:"rgb(0,0,0)"     //平盘文字颜色 
    },

    //报价列表
    this.Report=
    {
        BorderColor:'rgb(192,192,192)',    //边框线
        SelectedColor:"rgb(180,240,240)",  //选中行
        Header:
        {
            Color:"rgb(60,60,60)",      //表头文字颜色
            SortColor:"rgb(255,0,0)",   //排序箭头颜色
            Mergin:{ Left:5, Right:5, Top:4, Bottom:4 },    //表头四周间距
            Font:{ Size:12, Name:"微软雅黑" },   //表头字体
        },

        //排序图标
        SortIcon:
        {
            Size:12, Family:"iconfont",
            Arrow:[null, "\ue6b2", "\ue6b1"],
            Color:[null, "rgb(255,0,0)", "rgb(255,0,0)"],
            Margin:{ Left:0, Bottom:6 }
        },

        Item:
        {
            Mergin:{ Top:2, Bottom:4,Left:5, Right:5 }, //单元格四周间距
            Font:{ Size:15, Name:"微软雅黑"},
            BarMergin:{ Top:2, Left:3, Right:3, Bottom:2 },//单元格字体
            NameFont:{ Size:14, Name:"微软雅黑" },
            SymbolFont:{ Size:12, Name:"微软雅黑" }
        },

        //固定行
        FixedItem:
        {
            Font:{ Size:15, Name:"微软雅黑"},
        },

        LimitBorder:
        {
            Color:"rgb(180,180,180)",
            Mergin:{ Top:1, Bottom:1,Left:0, Right:0 },
        },

        //涨停 跌停背景色
        LimitColor:
        {
            UpColor:"rgb(255,0,0)",
            DownColor:"rgb(0,128,0)",
            TextColor:"rgb(250,250,250)",
        },

        FieldColor:
        {
            Index:"rgb(60,60,60)",  //序号
            Symbol:"rgb(60,60,60)",
            Name:"rgb(60,60,60)",
            Vol:"rgb(90,90,90)",    //成交量
            Amount:"rgb(90,90,90)", //成交金额
            Text:"rgb(60,60,60)",   //默认文本
        },

        UpTextColor:"rgb(238,21,21)",      //上涨文字颜色
        DownTextColor:"rgb(25,158,0)",     //下跌文字颜色
        UnchagneTextColor:"rgb(90,90,90)",     //平盘文字颜色 

        CloseLine:
        {
            CloseColor:"rgb(30,144,255)",
            YCloseColor:"rgba(105,105,105,0.5)",  //昨收线
            AreaColor:'rgba(0,191,255,0.2)',
        },

        KLine:
        {
            UpColor:"rgb(255,0,0)",
            DownColor:"rgb(0,128,0)",
            UnchagneColor:'rgb(90,90,90)',
            DataWidth:16,
            DistanceWidth:3
        },
        
        Tab:
        {
            Font:{ Size:12, Name:"微软雅黑" },
            ScrollBarWidth:100,
            ButtonColor:"rgb(252,252,252)",
            BarColor:"rgb(180,180,180)",
            BorderColor:'rgb(180,180,180)',
            Mergin:{ Left:5, Right:5, Top:4, Bottom:2 },

            TabTitleColor:'rgb(60,60,60)',
            TabSelectedTitleColor:'rgb(255,255,255)',
            TabSelectedBGColor:"rgb(234,85,4)",
            TabMoveOnTitleColor:"rgb(234,85,4)",
            TabBGColor:"rgb(220,220,220)"
        },

        PageInfo:
        {
            Font:{ Size:15, Name:"微软雅黑"},
            TextColor:"rgb(0,0,0)",
            BGColor:"rgba(180,180,180,0.5)",
            Mergin:{ Left:5, Right:5, Top:4, Bottom:2 },
        },

        DragRow:
        {
            Color:"rgba(190,190,190,0.8)",
            TextColor:'rgba(0,0, 0, 0.8)',

            MoveRowColor:'rgb(240,128,128)',
            SrcRowColor:'rgb(180,240,240)',
        },

        VScrollbar:
        {
            ScrollBarHeight:60,
            ButtonColor:"rgba(252,252,252,0.8)",
            BarColor:"rgba(168,168,168,0.9)",
            BorderColor:'rgba(180,180,180,0.9)',
            BGColor:"rgba(234,239,248,0.9)",
            BarWidth:{ Size:12 }
        },

        CheckBox:
        {
            Family:"iconfont", Size:15,
            Checked:{ Color:"rgb(69,147,238)", Symbol:"\ue6b3", DisableColor:"rgb(230,230,230)", MouseOnColor:"rgb(69,147,238)" },
            Unchecked:{ Color:"rgb(120,120,120)", Symbol:"\ue6b4", DisableColor:"rgb(230,230,230)", MouseOnColor:"rgb(69,147,238)" },

            Margin:{ Left:5, Right:5, Bottom:2, Top:4 },
        },

        Link:
        {
            Font:`${12*GetDevicePixelRatio()}px 微软雅黑`,
            TextColor:"rgb(30,144,255)",

            Disable:{ TextColor:"rgb(211,211,211)" },
            MouseOn:{ TextColor:"rgb(30,144,255)" },
        },

        ProgressBar:
        {
            BGColor:"rgb(229,231,238)",
            BarColor:"rgb(26,125,255)",
            Margin:{ Left:2, Right:2, Bottom:2, Top:2 },
            BarMargin:{ Left:2, Right:2, Bottom:2, Top:2 },
            TextColor:"rgb(0,0,0)",
            Font:`${12*GetDevicePixelRatio()}px 微软雅黑`,
            TextMargin:{ Left:40, Right:2, Bottom:2, Top:2},
            Disable:{ BGColor:"rgb(229,231,238)", BarColor:"rgb(131,131,131)", TextColor:"rgb(159,161,159)"}
        },

        Button:
        {
            BGColor:"rgb(61,134,180)",
            TextColor:"rgb(255,255,255)",
            BorderColor:"rgb(200,200,200)",

            Disable:{ BGColor:"rgb(105,105,105)", TextColor:"rgb(169,169,169)"},
            MouseOn:{ BGColor:"rgb(57,125,169)", TextColor:"rgb(230,230,230)" },

            Margin:{ Left:5, Right:5, Bottom:2, Top:2 },
            TextMargin:{ Bottom:2 },

            Font:`${12*GetDevicePixelRatio()}px 微软雅黑`
        }
    },

    //报价列表
    this.TReport=
    {
        BorderColor:'rgb(192,192,192)',    //边框线
        SelectedColor:"rgb(3,89,245)",  //选中行
        Header:
        {
            Color:"rgb(60,60,60)",      //表头文字颜色
            SortColor:"rgb(255,0,0)",   //排序箭头颜色
            Mergin:{ Left:5, Right:5, Top:4, Bottom:2},    //表头四周间距
            Font:{ Size:14, Name:"微软雅黑" }   //表头字体
        },

        Item:
        {
            Mergin:{ Top:2, Bottom:0,Left:5, Right:5 }, //单元格四周间距
            Font:{ Size:15, Name:"微软雅黑"},
            BarMergin:{ Top:2, Left:3, Right:3, Bottom:2 },//单元格字体
            NameFont:{ Size:14, Name:"微软雅黑" },
            SymbolFont:{ Size:12, Name:"微软雅黑" }
        },

        CenterItem:
        {
            TextColor:"rgb(60,60,83)",
            BaseTextColor:"rgb(60,60,83)",
            BGColor:"rgb(180,180,180)"
        },

        FieldColor:
        {
            Index:"rgb(60,60,60)",  //序号
            Symbol:"rgb(60,60,60)",
            Name:"rgb(60,60,60)",
            Vol:"rgb(90,90,90)",        //成交量
            Position:"rgb(90,90,90)",   //持仓量
            Amount:"rgb(90,90,90)", //成交金额
            Text:"rgb(60,60,60)",   //默认文本
        },

        UpTextColor:"rgb(238,21,21)",      //上涨文字颜色
        DownTextColor:"rgb(25,158,0)",     //下跌文字颜色
        UnchangeTextColor:"rgb(90,90,90)",     //平盘文字颜色 

        UpBGColor:"rgb(255,220,220)",
        DownBGColor:"rgb(190,220,190)",

        MarkBorder:
        {
            MaxPositionColor:"rgb(192,192,192)"
        },
    },

    //键盘精灵
    this.Keyboard=
    {
        BorderColor:'rgb(192,192,192)',    //边框线
        SelectedColor:"rgb(180,240,240)",  //选中行
        TextColor:"rgb(0,0,0)",

        Item:
        {
            Mergin:{ Top:2, Bottom:0,Left:1, Right:1 }, //单元格四周间距
            Font:{ Size:15, Name:"微软雅黑"},
            BarMergin:{ Top:2, Left:0, Right:0, Bottom:2 },//单元格字体
            NameFont:{ Size:14, Name:"微软雅黑" },
            SymbolFont:{ Size:12, Name:"微软雅黑" }
        },

        VScrollbar:
        {
            ScrollBarHeight:50,
            ButtonColor:"rgba(252,252,252,0.8)",
            BarColor:"rgba(168,168,168,0.9)",
            BorderColor:'rgba(180,180,180,0.9)',
            BGColor:"rgba(234,239,248,0.9)",
            BarWidth:{ Size:8 }
        },
    },

    //滚动条
    this.ScrollBar=
    {
        BorderColor:'rgb(192,192,192)',
       
        XSplitTextFont:`${12*GetDevicePixelRatio()}px 微软雅黑`,
        XSplitTextColor:"rgb(0,0,0)",
        XSplitLineColor:"rgba(0,0,0,0.8)",

        BGChart:
        {
            Color:"rgb(135,206,250)",
            LineWidth:1,
            AreaColor:"rgba(135,206,250,0.5)",
        },

        Slider:
        {
            DateFont:`${14*GetDevicePixelRatio()}px 微软雅黑`,
            DateColor:'rgb(0,0,0)',
            BarColor:"rgb(207,207,207)",
            BarAreaColor:"rgba(232,232,232,0.65)",

            BarWidth:10,
            BarPadding:15,  //上下留白
            MinCenterWidth:15
        }
    },

    this.FrameButtomToolbar=
    {
        BGColor:"rgb(235,235,235)",
        BorderColor:"rgb(204,204,204)",
        Button:
        {
            Font:{ Family:"微软雅黑", Size:12*GetDevicePixelRatio() },
            TitleColor: { Selected:"rgb(255,255,255)", Default:"rgb(125,125,125)", MoveOn:"rgb(234,85,4)" },
            BGColor: {  Selected:"rgb(234,85,4)", Default:"rgb(235,235,235)", MoveOn:"rgb(242,242,242)" },
            BorderColor:"rgb(204,204,204)",

            Mergin: { Left:5*GetDevicePixelRatio(), Right:5*GetDevicePixelRatio(), Top:4*GetDevicePixelRatio(), Bottom:2*GetDevicePixelRatio() },

            SVG:{ Family:"iconfont", Size:12*GetDevicePixelRatio(), MerginLeft:4*GetDevicePixelRatio() }
        }
    }


    //自定义风格
    this.SetStyle=function(style)
    {
        var T_SetButtonStyle=function(item, dest)
        {
            if (!item) return;

            if (item.Color) dest.Color=item.Color;
            if (item.MoveOnColor) dest.MoveOnColor=item.MoveOnColor;
            if (item.SelectedColor) dest.SelectedColor=item.SelectedColor;
            if (item.Family) dest.Family=item.Family;
            if (item.Text) dest.Text=item.Text;
            if (IFrameSplitOperator.IsNumber(item.Size)) dest.Size=item.Size;
            if (IFrameSplitOperator.IsNumber(item.MerginLeft)) dest.MerginLeft=item.MerginLeft;
        }

        if (style.TooltipBGColor) this.TooltipBGColor = style.TooltipBGColor;
        if (style.TooltipAlpha) this.TooltipAlpha = style.TooltipAlpha;
        if (style.SelectRectBGColor) this.SelectRectBGColor = style.SelectRectBGColor;
        if (style.UpBarColor) this.UpBarColor = style.UpBarColor;
        if (style.DownBarColor) this.DownBarColor = style.DownBarColor;
        if (style.UnchagneBarColor) this.UnchagneBarColor = style.UnchagneBarColor;
        if (style.EmptyBarBGColor) this.EmptyBarBGColor=style.EmptyBarBGColor;
        if (style.HighLowBarColor) this.HighLowBarColor=style.HighLowBarColor;
        if (style.HighLowText)
        {
            var dest=this.HighLowText;
            var item=style.HighLowText;
            if (item.FontName) dest.FontName=item.FontName;
            if (item.Color) dest.Color=item.Color;
            if (item.MaxText) dest.MaxText=item.MaxText;
            if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) dest.MaxSize=item.MaxSize;
            if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) dest.MinSize=item.MinSize;
        }

        if (style.SplashScreen)
        {
            var item=style.SplashScreen;
            if (item.BGColor) this.SplashScreen.BGColor=item.BGColor;
            if (item.Title) this.SplashScreen.Title=item.Title;
            if (item.TextColor) this.SplashScreen.TextColor=item.TextColor;
            if (item.Font) this.SplashScreen.Font=item.Font;
        }

        if (style.HLCArea)
        {
            var item=style.HLCArea;
            if (item.HighLineColor) this.HLCArea.HighLineColor=item.HighLineColor;
            if (item.LowLineColor) this.HLCArea.LowLineColor=item.LowLineColor;
            if (item.CloseLineColor) this.HLCArea.CloseLineColor=item.CloseLineColor;
            if (item.UpAreaColor) this.HLCArea.UpAreaColor=item.UpAreaColor;
            if (item.DownAreaColor) this.HLCArea.DownAreaColor=item.DownAreaColor;
            if (IFrameSplitOperator.IsNumber(item.LineWidth)) this.HLCArea.LineWidth=item.LineWidth;
        }
        
        if (style.Minute) 
        {
            if (style.Minute.VolBarColor) this.Minute.VolBarColor = style.Minute.VolBarColor;
            if (style.Minute.VolTitleColor) this.Minute.VolTitleColor = style.Minute.VolTitleColor;
            if (style.Minute.PriceColor) this.Minute.PriceColor = style.Minute.PriceColor;
            if (IFrameSplitOperator.IsNumber(style.Minute.PriceLineWidth)) this.Minute.PriceLineWidth=style.Minute.PriceLineWidth;
            if (style.Minute.AvPriceColor) this.Minute.AvPriceColor = style.Minute.AvPriceColor;
            if (style.Minute.AreaPriceColor) this.Minute.AreaPriceColor = style.Minute.AreaPriceColor;
            if (style.Minute.PositionColor) this.Minute.PositionColor = style.Minute.PositionColor;
            if (style.Minute.FrameSplitTextColor) this.Minute.FrameSplitTextColor = style.Minute.FrameSplitTextColor;
            if (style.Minute.Before)
            {
                var item=style.Minute.Before;
                if (item.BGColor) this.Minute.Before.BGColor=item.BGColor;
                if (item.LineColor) this.Minute.Before.LineColor=item.LineColor;
                if (item.VolColor) this.Minute.Before.VolColor=item.VolColor;
                if (item.AvPriceColor) this.Minute.Before.AvPriceColor=item.AvPriceColor;
                if (item.CloseIcon) T_SetButtonStyle(item.CloseIcon, this.Minute.Before.CloseIcon);
                if (item.Point) 
                {
                    if (item.Point.Color)  this.Minute.Before.Point.Color=item.Point.Color;
                    if (item.Point.Radius)  this.Minute.Before.Point.Radius=item.Point.Radius;
                }
            }

            if (style.Minute.After)
            {
                var item=style.Minute.After;
                if (item.BGColor) this.Minute.After.BGColor=item.BGColor;
                if (item.LineColor) this.Minute.After.LineColor=item.LineColor;
                if (item.VolColor) this.Minute.After.VolColor=item.VolColor;
                if (item.AvPriceColor) this.Minute.After.AvPriceColor=item.AvPriceColor;
                if (item.Point) 
                {
                    if (item.Point.Color)  this.Minute.After.Point.Color=item.Point.Color;
                    if (item.Point.Radius)  this.Minute.After.Point.Radius=item.Point.Radius;
                }
            }

            if (style.Minute.NightDay)
            {
                var item=style.Minute.NightDay;
                if (item.NightBGColor) this.Minute.NightDay.NightBGColor=item.NightBGColor;
                if (item.Font) this.Minute.NightDay.Font=item.Font;
                if (item.Day)
                {
                    var subItem=item.Day;
                    if (subItem.Color) this.Minute.NightDay.Day.Color=subItem.Color;
                    if (subItem.BGColor) this.Minute.NightDay.Day.BGColor=subItem.BGColor;
                    if (subItem.BorderColor) this.Minute.NightDay.Day.BorderColor=subItem.BorderColor;
                    CopyMarginConfig(this.Minute.NightDay.Day.Margin,subItem.Margin);
                }
                if (item.Night)
                {
                    var subItem=item.Night;
                    if (subItem.Color) this.Minute.NightDay.Night.Color=subItem.Color;
                    if (subItem.BGColor) this.Minute.NightDay.Night.BGColor=subItem.BGColor;
                    if (subItem.BorderColor) this.Minute.NightDay.Night.BorderColor=subItem.BorderColor;
                    CopyMarginConfig(this.Minute.NightDay.Night.Margin,subItem.Margin);
                }
            }
        }

        if (style.PopMinuteChart)
        {
            var item=style.PopMinuteChart;
            if (item.BGColor) this.PopMinuteChart.BGColor=item.BGColor;
            if (item.BorderColor) this.PopMinuteChart.BorderColor=item.BorderColor;
        }

        if (style.DefaultTextColor) this.DefaultTextColor = style.DefaultTextColor;
        if (style.DefaultTextFont) this.DefaultTextFont = style.DefaultTextFont;
        if (style.TitleFont) this.TitleFont = style.TitleFont;
        if (style.IndexTitleBGColor) this.IndexTitleBGColor=style.IndexTitleBGColor;
        if (style.IndexTitleBorderColor) this.IndexTitleBorderColor=style.IndexTitleBorderColor;
        if (style.IndexTitleBorderMoveOnColor) this.IndexTitleBorderMoveOnColor=style.IndexTitleBorderMoveOnColor;
        if (IFrameSplitOperator.IsNumber(style.IndexTitleBorderStyle)) this.IndexTitleBorderStyle=style.IndexTitleBorderStyle;
        if (style.IndexTitleColor) this.IndexTitleColor=style.IndexTitleColor;
        if (style.IndexTitleSelectedColor) this.IndexTitleSelectedColor=style.IndexTitleSelectedColor;
        if (style.OverlayIndexTitleBGColor) this.OverlayIndexTitleBGColor=style.OverlayIndexTitleBGColor;
        if (style.UpTextColor) this.UpTextColor = style.UpTextColor;
        if (style.DownTextColor) this.DownTextColor = style.DownTextColor;
        if (style.UnchagneTextColor) this.UnchagneTextColor = style.UnchagneTextColor;
        if (style.CloseLineColor) this.CloseLineColor = style.CloseLineColor;
        if (style.CloseLineAreaColor) this.CloseLineAreaColor = style.CloseLineAreaColor;
        if (style.CloseLineWidth) this.CloseLineWidth=style.CloseLineWidth;
        if (style.FrameBorderPen) this.FrameBorderPen = style.FrameBorderPen;
        if (style.MultiDayBorderPen) this.MultiDayBorderPen = style.MultiDayBorderPen;
        if (style.FrameSplitPen) this.FrameSplitPen = style.FrameSplitPen;
        if (style.FrameDotSplitPen) this.FrameDotSplitPen = style.FrameDotSplitPen;
        if (style.FrameSplitTextColor) this.FrameSplitTextColor = style.FrameSplitTextColor;
        if (style.FrameSplitTextFont) this.FrameSplitTextFont = style.FrameSplitTextFont;
        if (style.FrameTitleBGColor) this.FrameTitleBGColor = style.FrameTitleBGColor;
        if (style.SelFrameBorderColor) this.SelFrameBorderColor=style.SelFrameBorderColor;
        if (IFrameSplitOperator.IsNumber(style.IndexTitleMerginLeft)) this.IndexTitleMerginLeft = style.IndexTitleMerginLeft;

        if (style.IndexTitle)
        {
            var item=style.IndexTitle;
            if (item.UpDownArrow)
            {
                var subItem=item.UpDownArrow;
                if (subItem.UpColor) this.IndexTitle.UpDownArrow.UpColor = subItem.UpColor;
                if (subItem.DownColor) this.IndexTitle.UpDownArrow.DownColor = subItem.DownColor;
                if (subItem.UnchangeColor) this.IndexTitle.UpDownArrow.UnchangeColor = subItem.UnchangeColor;
            }

            if (IFrameSplitOperator.IsNumber(item.ArrowType)) this.IndexTitle.ArrowType=item.ArrowType;
            if (IFrameSplitOperator.IsBool(item.EnableIndexArrow)) this.IndexTitle.EnableIndexArrow=item.EnableIndexArrow;

            if (item.NameArrow)
            {
                var subItem=item.NameArrow;
                if (subItem.Color) this.IndexTitle.NameArrow.Color = subItem.Color;
                if (subItem.Symbol) this.IndexTitle.NameArrow.Symbol = subItem.Symbol;
                if (IFrameSplitOperator.IsNumber(subItem.Space)) this.IndexTitle.NameArrow.Space = subItem.Space;
            }
        }

        if (style.Frame)
        {
            if (style.Frame.XBottomOffset) this.Frame.XBottomOffset=style.Frame.XBottomOffset;
            if (style.Frame.YTopOffset) this.Frame.YTopOffset=style.Frame.YTopOffset;
            if (style.Frame.PercentageText)
            {
                var item=style.Frame.PercentageText;
                if (item.PriceColor) this.Frame.PercentageText.PriceColor=item.PriceColor;
                if (item.PercentageColor) this.Frame.PercentageText.PercentageColor=item.PercentageColor;
                if (item.SplitColor) this.Frame.PercentageText.SplitColor=item.SplitColor;
                if (item.Font) this.Frame.PercentageText.Font=item.Font;
            }
        }

        if (IFrameSplitOperator.IsNumber(style.ToolbarButtonStyle)) this.ToolbarButtonStyle=style.ToolbarButtonStyle;
        if (IFrameSplitOperator.IsBool(style.IsDOMFrameTitle)) this.IsDOMFrameTitle=style.IsDOMFrameTitle;

        if (style.FrameLatestPrice) 
        {
            var item=style.FrameLatestPrice;
            if (style.FrameLatestPrice.TextColor) this.FrameLatestPrice.TextColor = style.FrameLatestPrice.TextColor;
            if (style.FrameLatestPrice.UpBarColor) this.FrameLatestPrice.UpBarColor = style.FrameLatestPrice.UpBarColor;
            if (style.FrameLatestPrice.DownBarColor) this.FrameLatestPrice.DownBarColor = style.FrameLatestPrice.DownBarColor;
            if (style.FrameLatestPrice.UnchagneBarColor) this.FrameLatestPrice.UnchagneBarColor = style.FrameLatestPrice.UnchagneBarColor;
            if (style.FrameLatestPrice.BGAlpha) this.FrameLatestPrice.BGAlpha = style.FrameLatestPrice.BGAlpha;
            if (style.FrameLatestPrice.OverlayTextColor) this.FrameLatestPrice.OverlayTextColor = style.FrameLatestPrice.OverlayTextColor;
            if (item.EmptyBGColor) this.FrameLatestPrice.EmptyBGColor = item.EmptyBGColor;
        }

        if (style.OverlayFrame)
        {
            var item=style.OverlayFrame;
            if (style.OverlayFrame.BolderPen) this.OverlayFrame.BolderPen = style.OverlayFrame.BolderPen;
            if (style.OverlayFrame.TitleColor) this.OverlayFrame.TitleColor = style.OverlayFrame.TitleColor;
            if (style.OverlayFrame.TitleFont) this.OverlayFrame.TitleFont = style.OverlayFrame.TitleFont;
        }

        if (style.CorssCursorBGColor) this.CorssCursorBGColor = style.CorssCursorBGColor;
        if (style.CorssCursorTextColor) this.CorssCursorTextColor = style.CorssCursorTextColor;
        if (style.CorssCursorTextFont) this.CorssCursorTextFont = style.CorssCursorTextFont;
        if (style.CorssCursorVPenColor) this.CorssCursorVPenColor = style.CorssCursorVPenColor;
        if (style.CorssCursorHPenColor) this.CorssCursorHPenColor = style.CorssCursorHPenColor;
        if (style.CorssCursorBorderColor) this.CorssCursorBorderColor=style.CorssCursorBorderColor;
        if (style.CorssCursorXRangeBGColor) this.CorssCursorXRangeBGColor=style.CorssCursorXRangeBGColor;
        if (style.CorssCursor && style.CorssCursor.RightButton)
        {
            var item=style.CorssCursor.RightButton;
            if (item.BGColor) this.CorssCursor.RightButton.BGColor=item.BGColor;
            if (item.PenColor) this.CorssCursor.RightButton.PenColor=item.PenColor;
            if (item.Icon) this.CorssCursor.RightButton.Icon=item.Icon;
        }
        
        if (style.KLine) this.KLine = style.KLine;
        if (style.VirtualKLine)
        {
            var item=style.VirtualKLine;
            if (item.Color) this.VirtualKLine.Color=item.Color;
            if (item.LineDash) this.VirtualKLine.LineDash=item.LineDash;
        }

        if (style.PriceGapStyple)
        {
            var item=style.PriceGapStyple;
            if (item.Line && item.Line.Color) this.PriceGapStyple.Line.Color=item.Line.Color;
            if (item.Text)
            {
                if (item.Text.Color) this.PriceGapStyple.Text.Color=item.Text.Color;
                if (item.Text.Font) this.PriceGapStyple.Text.Font=item.Text.Font;
            }
        }

        if (style.Index) 
        {
            if (style.Index.LineColor) this.Index.LineColor = style.Index.LineColor;
            if (style.Index.NotSupport) this.Index.NotSupport = style.Index.NotSupport;
        }
        
        if (style.ColorArray) this.ColorArray = style.ColorArray;

        if (style.DrawPicture)
        {
            var item=style.DrawPicture;
            if (item.LineColor) this.DrawPicture.LineColor = item.LineColor;
            if (item.PointColor) this.DrawPicture.PointColor = item.PointColor;
            if (item.XYCoordinate) this.DrawPicture.XYCoordinate=item.XYCoordinate;
            if (IFrameSplitOperator.IsNumber(item.PointType)) this.DrawPicture.PointType=item.PointType;
            if (IFrameSplitOperator.IsBool(item.IsShowPoint)) this.DrawPicture.IsShowPoint=item.IsShowPoint;
        }

        if (style.TooltipPaint)
        {
            if (style.TooltipPaint.BGColor) this.TooltipPaint.BGColor=style.TooltipPaint.BGColor;
            if (style.TooltipPaint.BorderColor) this.TooltipPaint.BorderColor=style.TooltipPaint.BorderColor;
            if (style.TooltipPaint.TitleColor) this.TooltipPaint.TitleColor=style.TooltipPaint.TitleColor;
            if (style.TooltipPaint.TitleFont) this.TooltipPaint.TitleFont=style.TooltipPaint.TitleFont;

            if (style.TooltipPaint.DateTimeColor) this.TooltipPaint.DateTimeColor=style.TooltipPaint.DateTimeColor;
            if (style.TooltipPaint.VolColor) this.TooltipPaint.VolColor=style.TooltipPaint.VolColor;
            if (style.TooltipPaint.AmountColor) this.TooltipPaint.AmountColor=style.TooltipPaint.AmountColor;
        }

        if (style.PCTooltipPaint)
        {
            var item=style.PCTooltipPaint;
            if (item.BGColor) this.PCTooltipPaint.BGColor=item.BGColor;
            if (item.BorderColor) this.PCTooltipPaint.BorderColor=item.BorderColor;
            if (item.TitleColor) this.PCTooltipPaint.TitleColor=item.TitleColor;
            if (item.TitleFont) this.PCTooltipPaint.TitleFont=item.TitleFont;

            if (item.DateTimeColor) this.PCTooltipPaint.DateTimeColor=item.DateTimeColor;
            if (item.VolColor) this.PCTooltipPaint.VolColor=item.VolColor;
            if (item.AmountColor) this.PCTooltipPaint.AmountColor=item.AmountColor;
        }

        if (style.MinuteInfo)
        {
            var item=style.MinuteInfo;
            if (style.MinuteInfo.TextColor) this.MinuteInfo.TextColor=style.MinuteInfo.TextColor;
            if (style.MinuteInfo.Font) this.MinuteInfo.Font=style.MinuteInfo.Font;
            if (style.MinuteInfo.PointColor) this.MinuteInfo.PointColor=style.MinuteInfo.PointColor;
            if (style.MinuteInfo.LineColor) this.MinuteInfo.LineColor=style.MinuteInfo.LineColor;
            if (style.MinuteInfo.TextBGColor) this.MinuteInfo.TextBGColor=style.MinuteInfo.TextBGColor;
            if (IFrameSplitOperator.IsNumber(item.PointRadius)) this.MinuteInfo.PointRadius=item.PointRadius;
        }

        if (style.Title)
        {
            if (style.Title.TradeIndexColor) this.Title.TradeIndexColor=style.Title.TradeIndexColor;
            if (style.Title.ColorIndexColor) this.Title.ColorIndexColor=style.Title.ColorIndexColor;

            if (style.Title.VolColor) this.Title.VolColor=style.Title.VolColor;
            if (style.Title.AmountColor) this.Title.AmountColor=style.Title.AmountColor;
            if (style.Title.DateTimeColor) this.Title.DateTimeColor=style.Title.DateTimeColor;
            if (style.Title.NameColor) this.Title.NameColor=style.Title.NameColor;
            if (style.Title.SettingColor) this.Title.SettingColor=style.Title.SettingColor;
            if (style.Title.TurnoverRateColor) this.Title.TurnoverRateColor=style.Title.TurnoverRateColor;
            if (style.Title.PositionColor) this.Title.PositionColor=style.Title.PositionColor;
        }

        if (style.DRAWICON) 
        {
            if (style.DRAWICON.Icon)
            {
                var item=style.DRAWICON.Icon;
                if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) this.DRAWICON.Icon.MaxSize=item.MaxSize;
                if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) this.DRAWICON.Icon.MinSize=item.MinSize;
                if (item.Zoom) this.DRAWICON.Icon.Zoom=item.Zoom;
                if (IFrameSplitOperator.IsNumber(item.YOffset)) this.DRAWICON.Icon.YOffset=item.YOffset;
            }

            if (style.DRAWICON.Text)
            {
                var item=style.DRAWICON.Text;
                if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) this.DRAWICON.Text.MaxSize=item.MaxSize;
                if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) this.DRAWICON.Text.MinSize=item.MinSize;
                if (item.Zoom) this.DRAWICON.Text.Zoom=item.Zoom;
                if (item.FontName) this.DRAWICON.Text.FontName=item.FontName;
                if (IFrameSplitOperator.IsNumber(item.YOffset)) this.DRAWICON.Text.YOffset=item.YOffset;
            }
        }

        if (style.DRAWTEXT)
        {
            var item=style.DRAWTEXT;
            if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) this.DRAWICON.MaxSize=item.MaxSize;
            if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) this.DRAWICON.MinSize=item.MinSize;
            if (item.Zoom) this.DRAWTEXT.Zoom=item.Zoom;
            if (item.FontName) this.DRAWTEXT.FontName=item.FontName;
            if (IFrameSplitOperator.IsNumber(item.YOffset)) this.DRAWTEXT.YOffset=item.YOffset;
        }

        if (style.DRAWTEXT_FIX)
        {
            var item=style.DRAWTEXT_FIX;
            if (item.Font) this.DRAWTEXT_FIX.Font=item.Font;
        }

        if (style.DRAWNUMBER_FIX)
        {
            var item=style.DRAWNUMBER_FIX;
            if (item.Font) this.DRAWNUMBER_FIX.Font=item.Font;
        }

        if (style.DRAWNUMBER)
        {
            var item=style.DRAWNUMBER;
            if (IFrameSplitOperator.IsPlusNumber(item.MaxSize)) this.DRAWNUMBER.MaxSize=item.MaxSize;
            if (IFrameSplitOperator.IsPlusNumber(item.MinSize)) this.DRAWNUMBER.MinSize=item.MinSize;
            if (item.Zoom) this.DRAWNUMBER.Zoom=item.Zoom;
            if (item.FontName) this.DRAWNUMBER.FontName=item.FontName;
            if (IFrameSplitOperator.IsNumber(item.YOffset)) this.DRAWNUMBER.YOffset=item.YOffset;
        }

        if (style.DRAWABOVE)
        {
            var item=style.DRAWABOVE;
            if (IFrameSplitOperator.IsNumber(item.YOffset)) this.DRAWABOVE.YOffset=item.YOffset;
        }

        if (style.DOTLINE) this.DOTLINE=style.DOTLINE;
        if (style.DRAWSL) this.DOTLINE=style.DRAWSL;

        if (style.DragSubFrameBorder) this.DragSubFrameBorder=style.DragSubFrameBorder;

        if (style.DepthMapPaint)
        {
            var item=style.DepthMapPaint;
            if (item.LineColor) this.DepthMapPaint.LineColor=item.LineColor;
            if (item.AreaColor) this.DepthMapPaint.AreaColor=item.AreaColor;
            if (item.TextColor) this.DepthMapPaint.TextColor=item.TextColor;
            if (item.TextBGColor) this.DepthMapPaint.TextBGColor=item.TextBGColor;
        }

        if (style.KLineYAxisBGPaint)
        {
            var item=style.KLineYAxisBGPaint;
            if (item.Font) this.KLineYAxisBGPaint.Font=item.Font;
            if (item.LineColor) this.KLineYAxisBGPaint.LineColor=item.LineColor;

            if (item.DiffValutTextColor) this.KLineYAxisBGPaint.DiffValutTextColor=item.DiffValutTextColor;
            if (item.DiffValueBGColor) this.KLineYAxisBGPaint.DiffValueBGColor=item.DiffValueBGColor;
        }

        if (style.StockChip)
        {
            var item=style.StockChip;
            if (item.InfoColor) this.StockChip.InfoColor=item.InfoColor;
            if (item.DayInfoColor) this.StockChip.DayInfoColor=item.DayInfoColor;

            if (item.DefaultButton) T_SetButtonStyle(item.DefaultButton, this.StockChip.DefaultButton);
            if (item.LongButton) T_SetButtonStyle(item.LongButton, this.StockChip.LongButton);
            if (item.RecentButton) T_SetButtonStyle(item.RecentButton, this.StockChip.RecentButton);
        }

        if (style.DepthChart)
        {
            var item=style.DepthChart;
            if (item.BidColor)
            {
                if (item.BidColor.Line) this.DepthChart.BidColor.Line=item.BidColor.Line;
                if (item.BidColor.Area) this.DepthChart.BidColor.Area=item.BidColor.Area;
            }
            if (item.AskColor)
            {
                if (item.AskColor.Line) this.DepthChart.AskColor.Line=item.AskColor.Line;
                if (item.AskColor.Area) this.DepthChart.AskColor.Area=item.AskColor.Area;
            }

            if (item.LineWidth) this.DepthChart.LineWidth=item.LineWidth;
        }

        if (style.DepthCorss)
        {
            var item=style.DepthCorss;
            if (item.BidColor)
            {
                if (item.BidColor.Line) this.DepthCorss.BidColor.Line=item.BidColor.Line;
            }

            if (item.AskColor)
            {
                if (item.AskColor.Line) this.DepthCorss.AskColor.Line=item.AskColor.Line;
            }

            if (item.LineWidth) this.DepthCorss.LineWidth=item.LineWidth;
            if (item.LineDash) this.DepthCorss.LineDash=item.LineDash;

            if (item.Tooltip)
            {
                var tooltip=item.Tooltip;
                if (tooltip.BGColor) this.DepthCorss.Tooltip.BGColor=tooltip.BGColor;
                if (tooltip.TextColor) this.DepthCorss.Tooltip.TextColor=tooltip.TextColor;
                if (tooltip.Font) this.DepthCorss.Tooltip.Font=tooltip.Font;
                if (tooltip.LineHeight) this.DepthCorss.Tooltip.LineHeight=tooltip.LineHeight;

                var border=tooltip.Border;
                if (IFrameSplitOperator.IsNumber(border.Top)) this.DepthCorss.Tooltip.Border.Top=border.Top;
                if (IFrameSplitOperator.IsNumber(border.Bottom)) this.DepthCorss.Tooltip.Border.Bottom=border.Bottom;
                if (IFrameSplitOperator.IsNumber(border.Left)) this.DepthCorss.Tooltip.Border.Left=border.Left;
                if (IFrameSplitOperator.IsNumber(border.Right)) this.DepthCorss.Tooltip.Border.Right=border.Right;
                if (IFrameSplitOperator.IsNumber(border.ItemSpace)) this.DepthCorss.Tooltip.Border.ItemSpace=border.ItemSpace;
            }
        }

        if (style.CIRCLEDOT)
        {
            var item=style.CIRCLEDOT;
            if (IFrameSplitOperator.IsNumber(item.Radius)) this.CIRCLEDOT.Radius=item.Radius;
        }

        if (style.POINTDOT)
        {
            var item=style.POINTDOT;
            if (IFrameSplitOperator.IsNumber(item.Radius)) this.POINTDOT.Radius=item.Radius;
        }

        if (style.RectSelect)
        {
            var item=style.RectSelect;
            if (item.LineColor) this.RectSelect.LineColor=item.LineColor;
            if (item.LineWidth>0) this.RectSelect.LineWidth=item.LineWidth;
            if (item.LineDotted) this.RectSelect.LineDotted=item.LineDotted;
            if (item.AreaColor) this.RectSelect.AreaColor=item.AreaColor;
            if (item.SubAreaColor) this.RectSelect.SubAreaColor=item.SubAreaColor;

            if (item.RangeTextColor) this.RectSelect.RangeTextColor=item.RangeTextColor;
            if (item.RangeTextFont) this.RectSelect.RangeTextFont=item.RangeTextFont;
            if (item.RangeTextBGColor) this.RectSelect.RangeTextBGColor=item.RangeTextBGColor;

            if (item.RangeTextSubColor) this.RectSelect.RangeTextSubColor=item.RangeTextSubColor;
            if (item.RangeTextSubFont) this.RectSelect.RangeTextSubFont=item.RangeTextSubFont;
            if (item.RangeTextSubBGColor) this.RectSelect.RangeTextSubBGColor=item.RangeTextSubBGColor;
        }

        if (style.RectDrag)
        {
            var item=style.RectDrag;
            var dest=this.RectDrag;

            if (item.LineColor) dest.LineColor=item.LineColor;
            if (IFrameSplitOperator.IsPlusNumber(item.LineWidth)) dest.LineWidth=item.LineWidth;
            if (item.BGColor) dest.BGColor=item.BGColor;
        }

        if (style.OrderFlow)
        {
            item=style.OrderFlow;
            if (item.UpColor) this.OrderFlow.UpColor=item.UpColor;
            if (item.DownColor) this.OrderFlow.DownColor=item.DownColor;
            if (item.UnchagneColor) this.OrderFlow.UnchagneColor=item.UnchagneColor;
            if (item.Text) this.OrderFlow.Text=item.Text;
            if (item.Line) this.OrderFlow.Line=item.Line;
        }

        if (style.OrderFlow_Style2)
        {
            item=style.OrderFlow_Style2;
            if (item.UpColor) this.OrderFlow_Style2.UpColor=item.UpColor;
            if (item.DownColor) this.OrderFlow_Style2.DownColor=item.DownColor;
            if (item.UnchagneColor) this.OrderFlow_Style2.UnchagneColor=item.UnchagneColor;
            if (IFrameSplitOperator.IsNumber(item.BarWidth)) this.OrderFlow_Style2.BarWidth=item.BarWidth;
        }

        if (style.ChartOX)
        {
            var item=style.ChartOX;
            if (item.Family) this.ChartOX.Family=item.Family;
            if (item.Up) this.ChartOX.Up=item.Up;
            if (item.Down) this.ChartOX.Down=item.Down;
            if (item.SquareLineColor) this.ChartOX.SquareLineColor=item.SquareLineColor;
        }

        if (style.DealList)
        {
            var item=style.DealList;
            if (item.BorderColor) this.DealList.BorderColor=item.BorderColor;
            if (item.UpTextColor) this.DealList.UpTextColor=item.UpTextColor;
            if (item.DownTextColor) this.DealList.DownTextColor=item.DownTextColor;
            if (item.UnchagneTextColor) this.DealList.UnchagneTextColor=item.UnchagneTextColor;
            if (item.CloseLineColor) this.DealList.CloseLineColor=item.CloseLineColor;

            if (item.Header)
            {
                var header=item.Header;
                if (header.Color) this.DealList.Header.Color=header.Color;
                if (header.Mergin)
                {
                    var mergin=header.Mergin;
                    if (IFrameSplitOperator.IsNumber(mergin.Left)) this.DealList.Header.Mergin.Left=mergin.Left;
                    if (IFrameSplitOperator.IsNumber(mergin.Right)) this.DealList.Header.Mergin.Left=mergin.Right;
                    if (IFrameSplitOperator.IsNumber(mergin.Top)) this.DealList.Header.Mergin.Top=mergin.Top;
                    if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.DealList.Header.Mergin.Bottom=mergin.Bottom;
                }
                if (header.Font)
                {
                    var font=header.Font;
                    if (font.Name) this.DealList.Header.Font.Name=font.Name;
                    if (IFrameSplitOperator.IsNumber(font.Size)) this.DealList.Header.Font.Size=font.Size;
                }
            }

            if (item.Row)
            {
                var row=item.Row;
                if (row.Mergin)
                {
                    var mergin=row.Mergin;
                    if (IFrameSplitOperator.IsNumber(mergin.Top)) this.DealList.Row.Mergin.Top=mergin.Top;
                    if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.DealList.Row.Mergin.Bottom=mergin.Bottom;
                }

                if (row.Font)
                {
                    var font=row.Font;
                    if (font.Name) this.DealList.Row.Font.Name=font.Name;
                    if (IFrameSplitOperator.IsNumber(font.Size)) this.DealList.Row.Font.Size=font.Size;
                }

                if (row.BarMergin)
                {
                    var mergin=row.BarMergin;
                    if (IFrameSplitOperator.IsNumber(mergin.Left)) this.DealList.Row.BarMergin.Left=mergin.Left;
                    if (IFrameSplitOperator.IsNumber(mergin.Top)) this.DealList.Row.BarMergin.Top=mergin.Top;
                    if (IFrameSplitOperator.IsNumber(mergin.Right)) this.DealList.Row.BarMergin.Right=mergin.Right;
                    if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.DealList.Row.BarMergin.Bottom=mergin.Bottom;
                }
            }

            if (item.FieldColor)
            {
                var filed=item.FieldColor;
                if (filed.Vol) this.DealList.FieldColor.Vol=filed.Vol;
                if (filed.Time) this.DealList.FieldColor.Time=filed.Time;
                if (filed.Deal) this.DealList.FieldColor.Deal=filed.Deal;
                if (filed.Index) this.DealList.FieldColor.Index=filed.Index;
                if (filed.BarTitle) this.DealList.FieldColor.BarTitle=filed.BarTitle;
                if (filed.Text) this.DealList.FieldColor.Text=filed.Text;

                if (IFrameSplitOperator.IsNonEmptyArray(filed.Bar))
                {
                    for(var i=0;i<filed.Bar.length;++i)
                        this.DealList.FieldColor.Bar[i]=filed.Bar[i];
                }
            }
        }

        if (style.Report) this.SetReportStyle(style.Report);
       
        if (style.TReport) this.SetTReportStyle(style.TReport);

        if (style.SelectedChart)
        {
            var item=style.SelectedChart;
            if (IFrameSplitOperator.IsNumber(item.LineWidth)) this.SelectedChart.LineWidth=item.LineWidth;
            if (IFrameSplitOperator.IsNumber(item.Radius)) this.SelectedChart.Radius=item.Radius;
            if (IFrameSplitOperator.IsNumber(item.MinSpace)) this.SelectedChart.MinSpace=item.MinSpace;
            if (item.LineColor) this.SelectedChart.LineColor=item.LineColor;
            if (item.LineColor) this.SelectedChart.BGColor=item.BGColor;
        }

        if (style.DragMovePaint)
        {
            var item=style.DragMovePaint;
            if (item.TextColor) this.DragMovePaint.TextColor=item.TextColor;
            if (item.Font) this.DragMovePaint.Font=item.Font;
        }

        if (style.SessionBreaksPaint)
        {
            var item=style.SessionBreaksPaint;
            if (IFrameSplitOperator.IsNonEmptyArray(item.BGColor)) this.SessionBreaksPaint.BGColor=item.BGColor.slice();
            if (item.SplitLine)
            {
                var subItem=item.SplitLine;
                if (subItem.Color) this.SessionBreaksPaint.SplitLine.Color=subItem.Color;
                if (IFrameSplitOperator.IsNumber(subItem.Width)) this.SessionBreaksPaint.SplitLine.Width=subItem.Width;
                this.SessionBreaksPaint.SplitLine.Dash=subItem.Dash;
            }
        }

        if (IFrameSplitOperator.IsNumber(style.ToolbarButtonStyle)) this.ToolbarButtonStyle=style.ToolbarButtonStyle;

        if (style.Buttons)
        {
            var buttons=style.Buttons;
            
            T_SetButtonStyle(buttons.CloseOverlayIndex, this.Buttons.CloseOverlayIndex);
            T_SetButtonStyle(buttons.CloseWindow, this.Buttons.CloseWindow);
            T_SetButtonStyle(buttons.ChangeIndex, this.Buttons.ChangeIndex);
            T_SetButtonStyle(buttons.OverlayIndex, this.Buttons.OverlayIndex);
            T_SetButtonStyle(buttons.ModifyIndexParam, this.Buttons.ModifyIndexParam);
            T_SetButtonStyle(buttons.MaxMinWindow, this.Buttons.MaxMinWindow);
            T_SetButtonStyle(buttons.TitleWindow, this.Buttons.TitleWindow);
            T_SetButtonStyle(buttons.ExportData, this.Buttons.ExportData);

            if (buttons.Tooltip)
            {
                var item=buttons.Tooltip;
                var src=this.Buttons.Tooltip;
                if (item.Font) src.Font=item.Font;
                if (item.Color) src.Color=item.Color;
                if (item.ColorBG) src.ColorBG=item.ColorBG;
                if (item.ColorBorder) src.ColorBorder=item.ColorBorder;
                if (item.BorderRadius) src.BorderRadius=item.BorderRadius;
                if (item.Margin)
                {
                    if (IFrameSplitOperator.IsNumber(item.Margin.Left)) src.Margin.Left=item.Margin.Left;
                    if (IFrameSplitOperator.IsNumber(item.Margin.Top)) src.Margin.Top=item.Margin.Top;
                    if (IFrameSplitOperator.IsNumber(item.Margin.Bottom)) src.Margin.Bottom=item.Margin.Bottom;
                    if (IFrameSplitOperator.IsNumber(item.Margin.Right)) src.Margin.Right=item.Margin.Right;
                }
            }
        }

        if (style.ChartDrawVolProfile)
        {
            var item=style.ChartDrawVolProfile;
            if (item.UpVolColor) this.ChartDrawVolProfile.UpVolColor=item.UpVolColor;
            if (item.DownVolColor) this.ChartDrawVolProfile.DownVolColor=item.DownVolColor;
            if (item.AreaUpColor) this.ChartDrawVolProfile.AreaUpColor=item.AreaUpColor;
            if (item.AreaDonwColor) this.ChartDrawVolProfile.AreaDonwColor=item.AreaDonwColor;

            if (item.BGColor) this.ChartDrawVolProfile.BGColor=item.BGColor;
            if (item.BorderColor) this.ChartDrawVolProfile.BorderColor=item.BorderColor;
            if (item.VolLineColor) this.ChartDrawVolProfile.VolLineColor=item.VolLineColor;

            if (item.Text)
            {
                if (item.Text.Color) this.ChartDrawVolProfile.Text.Color=item.Text.Color;
                if (item.Text.Family) this.ChartDrawVolProfile.Text.Family=item.Text.Family;
                if (IFrameSplitOperator.IsNumber(item.Text.FontMaxSize)) this.ChartDrawVolProfile.Text.FontMaxSize=item.Text.FontMaxSize;
                if (IFrameSplitOperator.IsNumber(item.Text.FontMinSize)) this.ChartDrawVolProfile.Text.FontMinSize=item.Text.FontMinSize;
            }
        }

        if (style.DisableLogo===true)
        {
            if (this.FrameLogo) this.FrameLogo.Text=null;
        }

        if (style.ScrollBar)
        {
            var item=style.ScrollBar;
            if (item.BorderColor) this.ScrollBar.BorderColor=item.BorderColor;
            if (item.XSplitTextFont) this.ScrollBar.XSplitTextFont=item.XSplitTextFont;
            if (item.XSplitTextColor) this.ScrollBar.XSplitTextColor=item.XSplitTextColor;
            if (item.XSplitLineColor) this.ScrollBar.XSplitLineColor=item.XSplitLineColor;

            if (item.Slider)
            {
                var subItem=item.Slider;
                if (subItem.DateFont) this.ScrollBar.Slider.DateFont=subItem.DateFont;
                if (subItem.DateColor) this.ScrollBar.Slider.DateColor=subItem.DateColor;
                if (subItem.BarColor) this.ScrollBar.Slider.BarColor=subItem.BarColor;
                if (subItem.BarAreaColor) this.ScrollBar.Slider.BarAreaColor=subItem.BarAreaColor;
                if (IFrameSplitOperator.IsNumber(subItem.BarWidth)) this.ScrollBar.Slider.BarWidth=subItem.BarWidth;
                if (IFrameSplitOperator.IsNumber(subItem.BarPadding)) this.ScrollBar.Slider.BarPadding=subItem.BarPadding;
                if (IFrameSplitOperator.IsNumber(subItem.MinCenterWidth)) this.ScrollBar.Slider.MinCenterWidth=subItem.MinCenterWidth;
            }

            if (item.BGChart)
            {
                var subItem=item.BGChart;
                if (subItem.Color) this.ScrollBar.BGChart.Color=subItem.Color;
                if (subItem.AreaColor) this.ScrollBar.BGChart.AreaColor=subItem.AreaColor;
                if (IFrameSplitOperator.IsPlusNumber(subItem.LineWidth)) this.ScrollBar.BGChart.LineWidth=subItem.LineWidth;
            }
            
        }

        if (style.FrameButtomToolbar)
            this.SetFrameButtomToolbar(style.FrameButtomToolbar);
    }

    this.SetReportStyle=function(style)
    {
        var item=style;
        var dest=this.Report;

        if (item.BorderColor) this.Report.BorderColor=item.BorderColor;
        if (item.UpTextColor) this.Report.UpTextColor=item.UpTextColor;
        if (item.DownTextColor) this.Report.DownTextColor=item.DownTextColor;
        if (item.UnchagneTextColor) this.Report.UnchagneTextColor=item.UnchagneTextColor;
        if (item.BorderColor) this.Report.SelectedColor=item.SelectedColor;
           

        if (item.CloseLine)
        {
            var closeLine=item.CloseLine;
            if (closeLine.CloseColor) this.Report.CloseLine.CloseColor=closeLine.CloseColor;
            if (closeLine.YCloseColor) this.Report.CloseLine.YCloseColor=closeLine.YCloseColor;
            if (closeLine.AreaColor) this.Report.CloseLine.AreaColor=closeLine.AreaColor;
        }

        if (item.KLine)
        {
            var kline=item.KLine;
            if (kline.UpColor) this.Report.KLine.UpColor=kline.UpColor;
            if (kline.DownColor) this.Report.KLine.DownColor=kline.DownColor;
            if (kline.UnchagneColor) this.Report.KLine.UnchagneColor=kline.UnchagneColor;

            if (IFrameSplitOperator.IsNumber(kline.DataWidth)) this.Report.KLine.DataWidth=kline.DataWidth;
            if (IFrameSplitOperator.IsNumber(kline.DistanceWidth)) this.Report.KLine.DistanceWidth=kline.DistanceWidth;
        }

        if (item.Header)
        {
            var header=item.Header;
            if (header.Color) this.Report.Header.Color=header.Color;
            if (header.Mergin)
            {
                var mergin=header.Mergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) this.Report.Header.Mergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) this.Report.Header.Mergin.Left=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) this.Report.Header.Mergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.Report.Header.Mergin.Bottom=mergin.Bottom;
            }
            if (header.Font)
            {
                var font=header.Font;
                if (font.Name) this.Report.Header.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.Header.Font.Size=font.Size;
            }
        }

        if (item.Item)
        {
            var row=item.Item;
            if (row.Mergin)
            {
                var mergin=row.Mergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) this.Report.Item.Mergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) this.Report.Item.Mergin.Right=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) this.Report.Item.Mergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.Report.Item.Mergin.Bottom=mergin.Bottom;
            }

            if (row.Font)
            {
                var font=row.Font;
                if (font.Name) this.Report.Item.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.Item.Font.Size=font.Size;
            }

            if (row.BarMergin)
            {
                var mergin=row.BarMergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) this.Report.Item.BarMergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) this.Report.Item.BarMergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) this.Report.Item.BarMergin.Right=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.Report.Item.BarMergin.Bottom=mergin.Bottom;
            }

            if (row.NameFont)
            {
                var font=row.NameFont;
                if (font.Name) this.Report.Item.NameFont.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.Item.NameFont.Size=font.Size;
            }

            if (row.SymbolFont)
            {
                var font=row.SymbolFont;
                if (font.Name) this.Report.Item.SymbolFont.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.Item.SymbolFont.Size=font.Size;
            }
        }

        if (item.FixedItem)
        {
            var row=item.FixedItem;
            if (row.Font)
            {
                var font=row.Font;
                if (font.Name) this.Report.FixedItem.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.FixedItem.Font.Size=font.Size;
            }
        }

        if (item.LimitBorder)
        {
            var limit=item.LimitBorder;
            if (limit.Color) this.Report.LimitBorder.Color=limit.Color;
            if (limit.Mergin)
            {
                var mergin=limit.Mergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) this.Report.LimitBorder.Mergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) this.Report.LimitBorder.Mergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) this.Report.LimitBorder.Mergin.Right=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.Report.LimitBorder.Mergin.Bottom=mergin.Bottom;
            }
        }

        if (item.LimitColor)
        {
            var limit=item.LimitColor;
            if (limit.UpColor) this.Report.LimitColor.UpColor=limit.UpColor;
            if (limit.DownColor) this.Report.LimitColor.DownColor=limit.DownColor;
            if (limit.TextColor) this.Report.LimitColor.UpColor=limit.TextColor;
        }

        if (item.FieldColor)
        {
            var filed=item.FieldColor;
            if (filed.Name) this.Report.FieldColor.Name=filed.Name;
            if (filed.Symbol) this.Report.FieldColor.Symbol=filed.Symbol;
            if (filed.Vol) this.Report.FieldColor.Vol=filed.Vol;
            if (filed.Amount) this.Report.FieldColor.Amount=filed.Amount;
            if (filed.Index) this.Report.FieldColor.Index=filed.Index;
            if (filed.BarTitle) this.Report.FieldColor.BarTitle=filed.BarTitle;
            if (filed.Text) this.Report.FieldColor.Text=filed.Text;

            if (IFrameSplitOperator.IsNonEmptyArray(filed.Bar))
            {
                for(var i=0;i<filed.Bar.length;++i)
                    this.Report.FieldColor.Bar[i]=filed.Bar[i];
            }
        }

        if (item.Tab)
        {
            var tab=item.Tab;
            if (tab.Font)
            {
                var font=tab.Font;
                if (font.Name) this.Report.Tab.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.Tab.Font.Size=font.Size;
            }

            if (IFrameSplitOperator.IsNumber(tab.ScrollBarWidth)) this.Report.Tab.ScrollBarWidth=tab.ScrollBarWidth;
            if (tab.ButtonColor) this.Report.Tab.ButtonColor=tab.ButtonColor;
            if (tab.BarColor) this.Report.Tab.BarColor=tab.BarColor;
            if (tab.BorderColor) this.Report.Tab.BorderColor=tab.BorderColor;

            if (tab.TabTitleColor) this.Report.Tab.TabTitleColor=tab.TabTitleColor;
            if (tab.TabSelectedTitleColor) this.Report.Tab.TabSelectedTitleColor=tab.TabSelectedTitleColor;
            if (tab.TabSelectedBGColor) this.Report.Tab.TabSelectedBGColor=tab.TabSelectedBGColor;
            if (tab.TabMoveOnTitleColor) this.Report.Tab.TabMoveOnTitleColor=tab.TabMoveOnTitleColor;
            if (tab.TabBGColor) this.Report.Tab.TabBGColor=tab.TabBGColor;
        }

        if (item.PageInfo)
        {
            var pageinfo=item.PageInfo;
            if (pageinfo.Font)
            {
                var font=pageinfo.Font;
                if (font.Name) this.Report.PageInfo.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) this.Report.PageInfo.Font.Size=font.Size;
            }

            if (pageinfo.TextColor) this.Report.PageInfo.TextColor=pageinfo.TextColor;
            if (pageinfo.BGColor) this.Report.PageInfo.BGColor=pageinfo.BGColor;

            if (pageinfo.Mergin)
            {
                var mergin=pageinfo.Mergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) this.Report.PageInfo.Mergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) this.Report.PageInfo.Mergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) this.Report.PageInfo.Mergin.Right=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) this.Report.PageInfo.Mergin.Bottom=mergin.Bottom;
            }
        }

        if (item.DragRow)
        {
            var dragRow=item.DragRow;
            if (dragRow.Color) this.Report.DragRow.Color=dragRow.Color;
            if (dragRow.TextColor) this.Report.DragRow.TextColor=dragRow.TextColor;
            if (dragRow.MoveRowColor) this.Report.DragRow.MoveRowColor=dragRow.MoveRowColor;
            if (dragRow.SrcRowColor) this.Report.DragRow.SrcRowColor=dragRow.SrcRowColor;
        }

        if (item.VScrollbar)
        {
            var subItem=item.VScrollbar;
            if (IFrameSplitOperator.IsNumber(subItem.ScrollBarHeight)) dest.VScrollbar.ScrollBarHeight=subItem.ScrollBarHeight;
            if (subItem.ButtonColor) dest.VScrollbar.ButtonColor=subItem.ButtonColor;
            if (subItem.BarColor) dest.VScrollbar.BarColor=subItem.BarColor;
            if (subItem.BorderColor) dest.VScrollbar.BorderColor=subItem.BorderColor;
            if (subItem.BGColor) dest.VScrollbar.BGColor=subItem.BGColor;
        }

        if (item.CheckBox)
        {
            var subItem=item.CheckBox;
            if (subItem.Family) dest.CheckBox.Family=subItem.Family;
            if (IFrameSplitOperator.IsNumber(subItem.Size)) dest.CheckBox.Size=subItem.Size;

            if (subItem.Checked)
            {
                var child=subItem.Checked;
                if (child.Color) dest.CheckBox.Checked.Color=child.Color;
                if (child.Symbol) dest.CheckBox.Checked.Symbol=child.Symbol;
                if (child.DisableColor) dest.CheckBox.Checked.DisableColor=child.DisableColor;
            }

            if (subItem.Unchecked)
            {
                var child=subItem.Unchecked;
                if (child.Color) dest.CheckBox.Unchecked.Color=child.Color;
                if (child.Symbol) dest.CheckBox.Unchecked.Symbol=child.Symbol;
                if (child.DisableColor) dest.CheckBox.Unchecked.DisableColor=child.DisableColor;

               
            }

            CopyMarginConfig(dest.CheckBox.Margin, subItem.Margin);
        }

        if (item.Link)
        {
            var subItem=item.Link;
            if (subItem.Font) dest.Link.Font=subItem.Font;
            if (subItem.TextColor) dest.Link.TextColor=subItem.TextColor;
            if (subItem.Disable && subItem.Disable.TextColor) dest.Link.Disable.TextColor=subItem.Disable.TextColor;
            if (subItem.MouseOn && subItem.MouseOn.TextColor) dest.Link.MouseOn.TextColor=subItem.MouseOn.TextColor;
        }

        if (item.ProgressBar)
        {
            var subItem=item.ProgressBar;
            if (subItem.BGColor) dest.ProgressBar.BGColor=subItem.BGColor;
            if (subItem.BarColor) dest.ProgressBar.BarColor=subItem.BarColor;
            if (subItem.TextColor) dest.ProgressBar.TextColor=subItem.TextColor;
            if (subItem.Font) dest.ProgressBar.Font=subItem.Font;
            if (subItem.Disable)
            {
                if (subItem.Disable.BGColor) dest.ProgressBar.Disable.BGColor=subItem.Disable.BGColor;
                if (subItem.Disable.BarColor) dest.ProgressBar.Disable.BarColor=subItem.Disable.BarColor;
                if (subItem.Disable.TextColor) dest.ProgressBar.Disable.TextColor=subItem.Disable.TextColor;
            }

            CopyMarginConfig(dest.ProgressBar.Margin, subItem.Margin);
            CopyMarginConfig(dest.ProgressBar.BarMargin, subItem.BarMargin);
            CopyMarginConfig(dest.ProgressBar.TextMargin, subItem.TextMargin);
        }

        if (item.Buttom)
        {
            var subItem=item.Buttom;
            if (subItem.BGColor) dest.Buttom.BGColor=subItem.BGColor;
            if (subItem.TextColor) dest.Buttom.TextColor=subItem.TextColor;
            if (subItem.BorderColor) dest.Buttom.BorderColor=subItem.BorderColor;
            if (subItem.Font) dest.Buttom.Font=subItem.Font;

            if (subItem.Disable)
            {
                if (subItem.Disable.BGColor) dest.Buttom.Disable.BGColor=subItem.Disable.BGColor;
                if (subItem.Disable.TextColor) dest.Buttom.Disable.TextColor=subItem.Disable.TextColor;
            }

            if (subItem.MouseOn)
            {
                if (subItem.MouseOn.BGColor) dest.Buttom.MouseOn.BGColor=subItem.MouseOn.BGColor;
                if (subItem.MouseOn.TextColor) dest.Buttom.MouseOn.TextColor=subItem.MouseOn.TextColor;
            }

            CopyMarginConfig(dest.Buttom.Margin, subItem.Margin);
            CopyMarginConfig(dest.Buttom.TextMargin, subItem.TextMargin);
        }
        
    }

    this.SetTReportStyle=function(style)
    {
        var item=style;
        var dest=this.TReport;

        if (item.BorderColor) dest.BorderColor=item.BorderColor;
        if (item.UpTextColor) dest.UpTextColor=item.UpTextColor;
        if (item.DownTextColor) dest.DownTextColor=item.DownTextColor;
        if (item.UnchangeTextColor) dest.UnchangeTextColor=item.UnchangeTextColor;
        if (item.BorderColor) dest.SelectedColor=item.SelectedColor;

        if (item.UpBGColor) dest.UpBGColor=item.UpBGColor;
        if (item.DownBGColor) dest.DownBGColor=item.DownBGColor;

        if (item.Header)
        {
            var header=item.Header;
            if (header.Color) dest.Header.Color=header.Color;
            if (header.SortColor) dest.Header.SortColor=header.SortColor;
            if (header.Mergin)
            {
                var mergin=header.Mergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) dest.Header.Mergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) dest.Header.Mergin.Left=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) dest.Header.Mergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) dest.Header.Mergin.Bottom=mergin.Bottom;
            }
            if (header.Font)
            {
                var font=header.Font;
                if (font.Name) dest.Header.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) dest.Header.Font.Size=font.Size;
            }
        }

        if (item.CenterItem)
        {
            var cell=item.CenterItem;
            if (cell.TextColor) dest.CenterItem.TextColor=cell.TextColor;
            if (cell.BaseTextColor) dest.CenterItem.BaseTextColor=cell.BaseTextColor;
            if (cell.BGColor) dest.CenterItem.BGColor=cell.BGColor;
        }

        if (item.Item)
        {
            var row=item.Item;
            if (row.Mergin)
            {
                var mergin=row.Mergin;
                if (IFrameSplitOperator.IsNumber(mergin.Left)) dest.Item.Mergin.Left=mergin.Left;
                if (IFrameSplitOperator.IsNumber(mergin.Right)) dest.Item.Mergin.Right=mergin.Right;
                if (IFrameSplitOperator.IsNumber(mergin.Top)) dest.Item.Mergin.Top=mergin.Top;
                if (IFrameSplitOperator.IsNumber(mergin.Bottom)) dest.Item.Mergin.Bottom=mergin.Bottom;
            }

            if (row.Font)
            {
                var font=row.Font;
                if (font.Name) dest.Item.Font.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) dest.Item.Font.Size=font.Size;
            }

            if (row.NameFont)
            {
                var font=row.NameFont;
                if (font.Name) dest.Item.NameFont.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) dest.Item.NameFont.Size=font.Size;
            }

            if (row.SymbolFont)
            {
                var font=row.SymbolFont;
                if (font.Name) dest.Item.SymbolFont.Name=font.Name;
                if (IFrameSplitOperator.IsNumber(font.Size)) dest.Item.SymbolFont.Size=font.Size;
            }
        }

        if (item.FieldColor)
        {
            var filed=item.FieldColor;
            if (filed.Name) dest.FieldColor.Name=filed.Name;
            if (filed.Symbol) dest.FieldColor.Symbol=filed.Symbol;
            if (filed.Vol) dest.FieldColor.Vol=filed.Vol;
            if (filed.Amount) dest.FieldColor.Amount=filed.Amount;
            if (filed.Index) dest.FieldColor.Index=filed.Index;
            if (filed.Text) dest.FieldColor.Text=filed.Text;
            if (filed.Position) dest.FieldColor.Position=filed.Position;
        }

        if (item.MarkBorder)
        {
            var subIem=item.MarkBorder;
            if (subIem.MaxPositionColor) dest.MarkBorder.MaxPositionColor=subIem.MaxPositionColor;
        }
            
    }

    this.SetFrameButtomToolbar=function(style)
    {
        var dest=this.FrameButtomToolbar;

        if (style.BGColor) dest.BGColor=style.BGColor;
        if (style.BorderColor) dest.BorderColor=style.BorderColor;
        if (style.Button)
        {
            var button=style.Button;
            if (button.BorderColor) dest.Button.BorderColor=button.BorderColor;

            if (button.Font)
            {
                var item=button.Font;
                var destItem=this.FrameButtomToolbar.Button.Font;
                if (item.Family) destItem.Family=item.Family;
                if (IFrameSplitOperator.IsNumber(item.Size)) destItem.Size=item.Size;
            }

            if (button.TitleColor)
            {
                var item=button.TitleColor;
                var destItem=this.FrameButtomToolbar.Button.TitleColor;
                if (item.Selected) destItem.Selected=item.Selected;
                if (item.Default) destItem.Default=item.Default;
                if (item.MoveOn) destItem.MoveOn=item.MoveOn;
            }

            if (button.BGColor)
            {
                var item=button.BGColor;
                var destItem=this.FrameButtomToolbar.Button.BGColor;
                if (item.Selected) destItem.Selected=item.Selected;
                if (item.Default) destItem.Default=item.Default;
                if (item.MoveOn) destItem.MoveOn=item.MoveOn;
            }

            if (button.Mergin)
            {
                var item=button.Mergin;
                var destItem=this.FrameButtomToolbar.Button.Mergin;
                if (IFrameSplitOperator.IsNumber(item.Left)) destItem.Left=item.Left;
                if (IFrameSplitOperator.IsNumber(item.Right)) destItem.Left=item.Right;
                if (IFrameSplitOperator.IsNumber(item.Top)) destItem.Top=item.Top;
                if (IFrameSplitOperator.IsNumber(item.Bottom)) destItem.Bottom=item.Bottom;
            }

            if (button.SVG)
            {
                var item=button.SVG;
                var destItem=this.FrameButtomToolbar.Button.SVG;
                if (IFrameSplitOperator.IsNumber(item.Size)) destItem.Size=item.Size;
                if (IFrameSplitOperator.IsNumber(item.MerginLeft)) destItem.MerginLeft=item.MerginLeft;
                if (item.Family) destItem.Family=item.Family;
            }
        }
        
    }

}

var g_JSChartResource=new JSChartResource();


/////////////////////////////////////////////////////////////////////////////////
//
//
//
var JSCHART_LANGUAGE_ID=
{
    LANGUAGE_CHINESE_ID:0,  //简体中文 CN
    LANGUAGE_ENGLISH_ID:1,  //英文 EN
    LANGUAGE_TRADITIONAL_CHINESE_ID:2,  //繁体中文 TC
};

function JSChartLocalization()
{
    this.TextResource=new Map([
        //内部tooltip
        ['Tooltip-Open', {CN:'开:', EN:'O:', TC:'開'}],
        ['Tooltip-High', {CN:'高:', EN:'H:', TC:'高'}],
        ['Tooltip-Low', {CN:'低:', EN:'L:', TC:'低'}],
        ['Tooltip-Close', {CN:'收:', EN:'C:', TC:'收'}],
        ['Tooltip-Increase', {CN:'幅:', EN:'I:', TC:'幅'}],
        ['Tooltip-Vol', {CN:'量:', EN:'V:', TC:'量'}],
        ['Tooltip-Amount', {CN:'额:', EN:'A:', TC:'額'}],
        ['Tooltip-AvPrice', {CN:'均:', EN:'AP:', TC:'均'}],
        ['Tooltip-Price', {CN:'价:', EN:'P:', TC:'價'}],
        ['Tooltip-Exchange', {CN:'换:', EN:'E:', TC:'換'}],
        ['Tooltip-Position',{CN:'持:', EN:'P:', TC:'持'}],

        ['DivTooltip-Open', {CN:'开盘:', EN:'Open:', TC:'開盤'}],
        ['DivTooltip-High', {CN:'最高:', EN:'High:', TC:'最高'}],
        ['DivTooltip-Low', {CN:'最低:', EN:'Low:', TC:'最低'}],
        ['DivTooltip-Close', {CN:'收盘:', EN:'Close:', TC:'收盤'}],
        ['DivTooltip-Increase', {CN:'涨幅:', EN:'Increase:', TC:'漲幅'}],
        ['DivTooltip-Vol', {CN:'数量:', EN:'Volume:', TC:'數量'}],
        ['DivTooltip-Amount', {CN:'金额:', EN:'Amount:', TC:'金額'}],
        ['DivTooltip-Exchange', {CN:'换手:', EN:'Exchange:', TC:'換手'}],
        ['DivTooltip-Position', {CN:'持仓:', EN:'Position:', TC:'持倉'}],
        ['DivTooltip-Price', {CN:'价格:', EN:'Open:', TC:'價格'}],

        //走势图PC tooltip
        ['PCTooltip-Date', {CN:'日期', EN:'Date', TC:"日期"}],
        ['PCTooltip-Time', {CN:'时间', EN:'Time', TC:"時間"}],
        ['PCTooltip-Price', {CN:'价格', EN:'Price:', TC:'價格'}],
        ['PCTooltip-AvPrice', {CN:'均价', EN:'AVPrice:', TC:'均價'}],
        ['PCTooltip-Increase', {CN:'涨幅', EN:'Increase:', TC:'漲幅'}],
        ['PCTooltip-Vol', {CN:'成交量', EN:'Volume:', TC:'成交量'}],
        ['PCTooltip-Amount', {CN:'成交额', EN:'Amount:', TC:'成交額'}],
        ['PCTooltip-AC-Price', {CN:'匹配价:', EN:'Price:', TC:'匹配價'}],
        ['PCTooltip-AC-Increase', {CN:'竞价涨幅:', EN:'Increase:', TC:'競價漲幅'}],
        ['PCTooltip-AC-Vol', {CN:'匹配量:', EN:'V:', TC:'匹配量'}],
        ['PCTooltip-AC-NotMatchVol', {CN:'未匹配量:', EN:'NV:', TC:'未匹配量'}],

        //K线动态标题
        ['KTitle-Open', {CN:'开:', EN:'O:', TC:'開'}],
        ['KTitle-High', {CN:'高:', EN:'H:', TC:'高'}],
        ['KTitle-Low', {CN:'低:', EN:'L:', TC:'低'}],
        ['KTitle-Close', {CN:'收:', EN:'C:', TC:'收'}],
        ['KTitle-Increase', {CN:'幅:', EN:'I:', TC:'幅'}],
        ['KTitle-Vol', {CN:'量:', EN:'V:', TC:'量'}],
        ['KTitle-Amount', {CN:'额:', EN:'A:', TC:'額'}],
        ['KTitle-Exchange', {CN:'换:', EN:'E:', TC:'換'}],
        ['KTitle-Position', {CN:'持:', EN:'P:', TC:'持'}],
        ['KTitle-Price', {CN:'价:', EN:'Price:', TC:'價'}],
        
        //走势图动态标题
        ['MTitle-AC-Price', {CN:'匹配价:', EN:'C:', TC:'匹配價'}],
        ['MTitle-AC-AvPrice', {CN:'匹配均价:', EN:'C:', TC:'匹配均價'}],
        ['MTitle-AC-Increase', {CN:'竞价涨幅:', EN:'I:', TC:'競價漲幅'}],
        ['MTitle-AC-Vol', {CN:'匹配量:', EN:'V:', TC:'匹配量'}],
        ['MTitle-AC-NotMatchVol', {CN:'未匹配量:', EN:'NV:', TC:'未匹配量'}],
        ['MTitle-AC-Amount', {CN:'匹配量金额:', EN:'A:', TC:'匹配量金额'}],
        ['MTitle-AC-NotMatchAmount', {CN:'未匹配量金额:', EN:'NA:', TC:'未匹配量金额'}],

        //走势图标题
        ['MTitle-Close', {CN:'价:', EN:'C:', TC:'價'}],
        ['MTitle-AvPrice', {CN:'均:', EN:'AC:', TC:'均'}],
        ['MTitle-Increase', {CN:'幅:', EN:'I:', TC:'幅'}],
        ['MTitle-Vol', {CN:'量:', EN:'V:', TC:'量'}],
        ['MTitle-Amount', {CN:'额:', EN:'A:', TC:'額'}],
        ['MTitle-Position', {CN:'持:', EN:'P:', TC:'持'}],
        ["MTitle-UpdateTime", {CN:"更新:", EN:"Update:", TC:"更新:"}],

       

        //周期
        ['日线', {CN:'日线', EN:'1D', TC:'日綫'}],
        ['周线', {CN:'周线', EN:'1W', TC:'周綫'}],
        ['双周', {CN:'双周', EN:"2W", TC:'雙周'}],
        ['月线', {CN:'月线', EN:'1M', TC:'月綫'}],
        ["半年", {CN:'半年', EN:'HY', TC:'半年'}],
        ['年线', {CN:'年线', EN:'1Y', TC:'年綫'}],
        ['1分', {CN:'1分', EN:'1Min', TC:'1分'}],
        ['5分', {CN:'5分', EN:'5Min', TC:'5分'}],
        ['15分', {CN:'15分', EN:'15Min', TC:'15分'}],
        ['30分', {CN:'30分', EN:'30Min', TC:'30分'}],
        ['60分', {CN:'60分', EN:'60Min', TC:'60分'}],
        ['季线', {CN:'季线', EN:'1Q', TC:'季綫'}],
        ['分笔', {CN:'分笔', EN:'Tick', TC:'分筆'}],
        ['2小时', {CN:'2小时', EN:'2H', TC:'2小時'}],
        ['4小时', {CN:'4小时', EN:'4H', TC:'4小時'}],

        //复权
        ['不复权', {CN:'不复权', EN:'No Right', TC:'不復權'}],
        ['前复权', {CN:'前复权', EN:'Pro Right', TC:'前復權'}],
        ['后复权', {CN:'后复权', EN:'Post Right', TC:'后復權'}],

        //week
        ['日', {CN:'日', EN:'Sun.', TC:'日'}],
        ['一', {CN:'一', EN:'Mon.', TC:'壹'}],
        ['二', {CN:'二', EN:'Tues.', TC:'貳'}],
        ['三', {CN:'三', EN:'Wed.', TC:'叁'}],
        ['四', {CN:'四', EN:'Thur.', TC:'肆'}],
        ['五', {CN:'五', EN:'Fri.', TC:'伍'}],
        ['六', {CN:'六', EN:'Sat.', TC:'陸'}],

        ['1月', {CN:'1月', EN:'Jan', TC:'1月'}],
        ['2月', {CN:'2月', EN:'Feb', TC:'2月'}],
        ['3月', {CN:'3月', EN:'Mar', TC:'3月'}],
        ['4月', {CN:'4月', EN:'Apr', TC:'4月'}],
        ['5月', {CN:'5月', EN:'May', TC:'5月'}],
        ['6月', {CN:'6月', EN:'Jun', TC:'6月'}],
        ['7月', {CN:'7月', EN:'Jul', TC:'7月'}],
        ['8月', {CN:'8月', EN:'Aug', TC:'8月'}],
        ['9月', {CN:'9月', EN:'Sept', TC:'9月'}],
        ['10月', {CN:'10月', EN:'Oct', TC:'10月'}],
        ['11月', {CN:'11月', EN:'Nov', TC:'11月'}],
        ['12月', {CN:'12月', EN:'Dec', TC:'12月'}],

        ['自定义分钟', {CN:'分', EN:'Min', TC:'分'}],
        ['自定义日线', {CN:'日', EN:'D', TC:'日'}],
        ['自定义秒', {CN:'秒', EN:'S', TC:'秒'}],
        ['自定义毫秒', {CN:'毫秒', EN:'MS', TC:'毫秒'}],

        ["MVol-Vol", {CN:"成交量", EN:"Volume", TC:'成交量'} ],
        ["MVol-Position", {CN:"持仓量", EN:"Position", TC:'持倉量'} ],

        //深度图
        ["Depth-Price", {CN:"委托价", EN:"Price", TC:'委托價'}],
        ["Depth-Sum", {CN:"累计", EN:"Sum", TC:'累計'}],

        //工具栏提示信息
        ["Toolbar-"+JSCHART_BUTTON_ID.MODIFY_INDEX_PARAM, {CN:"调整指标参数", EN:"Change indicator parameters", TC:"调整指标参数"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.CHANGE_INDEX, {CN:"选择指标", EN:"Change indicator", TC:"切换指标"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.CLOSE_INDEX_WINDOW, {CN:"关闭窗口", EN:"Delete window", TC:"关闭指标窗口"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.OVERLAY_INDEX, {CN:"叠加指标", EN:"Overlay indicator", TC:"叠加指标"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.MODIFY_OVERLAY_INDEX_PARAM, {CN:"调整叠加指标参数", EN:"Change overlay indicator parameters", TC:"调整叠加指标参数"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.MAX_MIN_WINDOW, {CN:"最大化", EN:"Maximize", TC:"最大化"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.TITLE_WINDOW, {CN:"折叠窗口", EN:"Collapse window", TC:"折叠窗口"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.EXPORT_DATA, {CN:"数据导出", EN:"Export data", TC:"数据导出"}],

        ["Toolbar-"+JSCHART_BUTTON_ID.CLOSE_BEFOREOPEN_ID, {CN:"关闭集合竞价", EN:"Close call auction", TC:"关闭集合竞价"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.CLOSE_OVERLAY_INDEX, {CN:"关闭叠加指标", EN:"Delte overlay indicator", TC:"关闭叠加指标"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.CHIP_RECENT, {CN:"近期成本分布", EN:"Recent chip", TC:"近期成本分布"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.CHIP_LONG, {CN:"远期成本分布", EN:"Long chip", TC:"远期成本分布"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.CHIP_DEFULT, {CN:"默认筹码分布", EN:"Default chip", TC:"默认筹码分布"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.DRAW_PICTURE_DELETE, {CN:"删除", EN:"Delete", TC:"删除"}],
        ["Toolbar-"+JSCHART_BUTTON_ID.DRAW_PICTURE_SETTING, {CN:"设置", EN:"Setting", TC:"设置"}],

        //日盘|夜盘
        ["日盘",{CN:'日盘', EN:'Day', TC:'日盤'}],
        ["夜盘",{CN:'夜盘', EN:'Night', TC:'夜盤'} ]
    ]);

    this.GetText=function(key,language)
    {
        var item=this.TextResource.get(key);
        if (!item) return '';

        switch(language)
        {
            case JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID:
                return item.CN;
            case JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID:
                return item.EN;
            case JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID:
                return item.TC;
            default:
                return item.CN;
        }
    }

    this.SetTextResource=function(key,value)
    {
        this.TextResource.set(key,value)
    }

    this.GetLanguageID=function(languageName)
    {
        var languageID=null;
        switch(languageName)
        {
            case 'EN':
                languageID=JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID;
                break;
            case 'CN':
                languageID=JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID;
                break;
            case "TC":
                languageID=JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID;
                break;
            default:
                break;
        }

        return languageID;
    }

    this.GetLanguageName=function(id)
    {
        switch(id)
        {
            case JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID:
                return "EN";
            case JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID:
                return "CN";
            case JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID:
                return "TC"
            default:
                return null;
        }
    }
};

var g_JSChartLocalization=new JSChartLocalization();



/*
    指标列表 指标信息都在这里,不够后面再加字段
*/
function JSIndexMap()
{

}

JSIndexMap.Get=function(id)
{
    var indexMap=new Map(
    [
        ['CJL',  { IsMainIndex:false,  Create:function(){ return new JSIndex_CJL(); }  } ],    //期货指标

        ["OX", { IsMainIndex:false, Create:function() { return new JSIndex_OX(); } } ],

        ["可视范围成交量分布图", { IsMainIndex:true, Create:function(option) { return new VolProfileVisibleRangeIndex(option); } } ],
    ]
    );

    return indexMap.get(id);
}

// 定制K线计算
function KLineCustomCalulate()
{
    this.DataMap=new Map(
        [
            ["RenkoCalculate",      { Create:function() { return new RenkoCalculate(); }  }],
            ["HeikinAshiCalculate", { Create:function() { return new HeikinAshiCalculate(); }  }],
            ["LineBreakCalcuate",   { Create:function() { return new LineBreakCalcuate(); }  }],
            ["KagiCalculate",       { Create:function(){ return new KagiCalculate(); } }]
        ]
    );

    this.Create=function(name)
    {
        if (!this.DataMap.has(name)) return null;

        var item=this.DataMap.get(name);
        return item.Create();
    }
}

var g_KLineCustomCalulate=new KLineCustomCalulate();

///////////////////////////////////////////////////////////////////
// renko candle
//
function RenkoCalculate()
{
    this.BrickSize=0.05;    //固定大小
    this.SourceData;
    this.LastData;
    this.ATR={ Count:14, BrickSize:0.05 };  //使用ATR计算砖块大小
    this.BrickSizeType=1;  //0=固定 1=ATR动态计算
    this.Symbol;
    this.FloatPrecision=2;  //品种小数位数
    this.ClassName="RenkoCalculate";

    this.SetOption=function(option)
    {
        if (!option) return;

        if (IFrameSplitOperator.IsNumber(option.BrickSize)) this.BrickSize=option.BrickSize;
        if (IFrameSplitOperator.IsNumber(option.BrickSizeType)) this.BrickSizeType=option.BrickSizeType;
        if (option.ATR)
        {
            var item=option.ATR;
            if (IFrameSplitOperator.IsNumber(item.Count)) this.ATR.Count=item.Count;
        }
    }

    this.CalculateByClose=function(sourceData)    //使用收盘价计算
    {
        var bindData=new ChartData();
        bindData.Data=[]
        bindData.Right=sourceData.Right;
        bindData.Period=sourceData.Period;
        bindData.DataType=sourceData.DataType;
        bindData.Symbol=sourceData.symbol;

        if (!IFrameSplitOperator.IsNonEmptyArray(sourceData.Data)) return bindData;

        var brickSize=this.BrickSize;
        if (this.BrickSizeType==1) brickSize=this.ATR.BrickSize;

        var kItem=sourceData.Data[0];
        this.LastData=HistoryData.Copy(kItem);
        for(var i=1; i<sourceData.Data.length; )    
        {
            var kItem=sourceData.Data[i];

            var movementFromClose=kItem.Close - this.LastData.Close;
            var movementFromOpen=kItem.Close - this.LastData.Open;
            if (Math.abs(movementFromClose)>= brickSize && Math.abs(movementFromOpen)>=brickSize) 
            {
                var vol=0;
                if (movementFromClose>0 || movementFromOpen>0)
                {
                    var yClose=this.LastData.Close;
                    var open=Math.max(this.LastData.Close,this.LastData.Open);
                    var close=open+brickSize;
                    var high=close;
                    var low=open;
                    vol=kItem.Vol;
                }
                else
                {
                    var yClose=this.LastData.Close;
                    var open=Math.min(this.LastData.Close,this.LastData.Open);
                    var close=open-brickSize;
                    var high=open;
                    var low=close;
                    vol=kItem.Vol;
                }
                
                var item=new HistoryData();
                item.Date=kItem.Date;
                item.Time=kItem.Time;
                item.YClose=yClose;
                item.Open=open;
                item.High=high;
                item.Low=low;
                item.Close=close;
                item.Vol=this.LastData.Vol+vol;

                bindData.Data.push(item);

                this.LastData.YClose=item.YClose;
                this.LastData.Open = item.Open;
                this.LastData.High = item.High;
                this.LastData.Low = item.Low;
                this.LastData.Close = item.Close;
                this.LastData.Date=item.Date;
                this.LastData.Time=item.Time;
                this.LastData.Vol=0;
            }
            else 
            {
                this.LastData.Vol+=kItem.Vol;    //量需要累加
                ++i;
            }
        }

        return bindData;
    }

    this.RecvHistoryData=function(sourceData, option)  //历史日线数据
    {
        this.Symbol=option.Symbol;
        this.SourceData=sourceData;
        this.FloatPrecision=GetfloatPrecision(this.Symbol);
        if (this.BrickSizeType==1) this.CalculateATR();
        return this.CalculateByClose(sourceData);
    }

    this.Clear=function()
    {
        this.SourceData=null;
        this.LastData=null;
        this.Symbol=null;
    }

    //获取配置信息
    this.GetTitle=function()
    {
        if (this.BrickSizeType==1)
        {
            var text=`Renko [ATR(${this.ATR.Count}), ${this.ATR.BrickSize}]`;
        }
        else
        {
            var text=`Renko [Traditional, ${this.BrickSize}]`;
        }

        return text;
    }

    //通过ATR计算砖块大小
    //真实范围 = MAX（最高价 (1) – 最低价 (1)；最高价 (1) – 收盘价 (2)；收盘价 (2) – 最低价 (1)）
    this.CalculateATR=function()
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data)) return;

        var kData=this.SourceData.Data;
        var count=kData.length;
        var aryData=[];
        for(var i=count-1, j=0; i>=0 && j<this.ATR.Count; --i, ++j)
        {
            var item=kData[i];
            var value=Math.max(item.High-item.Low, item.High-item.Close, item.Close-item.Low);
            aryData.push(value);
        }

        //使用MA计算，也可以使用SMA计算
        var total=0;
        for(var i=0; i<aryData.length; ++i)
        {
            total+=aryData[i];
        }

        var brickSize=total/aryData.length;
        var value=brickSize.toFixed(this.FloatPrecision);
        this.ATR.BrickSize=parseFloat(value);
    }
}


/////////////////////////////////////////////////////////////////////////
//kagi candle
//
function KagiCalculate()
{
    this.newMethod=RenkoCalculate;   //派生
    this.newMethod();
    delete this.newMethod;
   
    this.ClassName="KagiCalculate";
    this.BrickSizeType=0;   
    this.BrickSize=0.5;    //固定大小

    this.RecvHistoryData=function(sourceData, option)  //历史日线数据
    {
        this.Symbol=option.Symbol;
        this.SourceData=sourceData;
        this.FloatPrecision=GetfloatPrecision(this.Symbol);
        if (this.BrickSizeType==1) this.CalculateATR();
        return this.CalculateByClose(sourceData);
    }

    this.CalculateByClose=function(sourceData)
    {
        var bindData=new ChartData();
        bindData.Data=[]
        bindData.Right=sourceData.Right;
        bindData.Period=sourceData.Period;
        bindData.DataType=sourceData.DataType;
        bindData.Symbol=sourceData.symbol;

        if (!IFrameSplitOperator.IsNonEmptyArray(sourceData.Data)) return bindData;

        var brickSize=this.BrickSize;
        if (this.BrickSizeType==1) brickSize=this.ATR.BrickSize;

        var kItem=sourceData.Data[0];
        var kagiItem=HistoryData.Copy(kItem);
        
        kagiItem.High=kagiItem.Low=kItem.Close;
        kagiItem.StartItem=kItem;
        kagiItem.Direction=0;   //1 上 2=下

        var T_MergeKData=function(dest, src)
        {
            dest.Vol+=src.Vol;
            dest.Amount+=src.Amount;
        }

        var index=1;
        for( ;index<sourceData.Data.length;++index) //确定好方向
        {
            var kItem=sourceData.Data[index];
            if (kItem.Close>kagiItem.Close) 
            {
                kagiItem.Direction=1;
                kagiItem.Close=kItem.Close;
                kagiItem.EndItem=kItem;
                kagiItem.High=kItem.Close;
                break;
            }
            else if (kItem.Close<kagiItem.Close) 
            {
                kagiItem.Direction=2;
                kagiItem.Close=kItem.Close;
                kagiItem.EndItem=kItem;
                kagiItem.Low=kItem.Close;
                break;
            }
        }

        var changeItem=null;
        for(++index; index<sourceData.Data.length;++index )    
        {
            var kItem=sourceData.Data[index];
            if (kagiItem.Direction==1)  //上
            {
                if (kItem.Close>=kagiItem.High) 
                {
                    kagiItem.Close=kItem.Close;
                    kagiItem.High=kItem.Close;
                    kagiItem.EndItem=kItem;
                    changeItem=null;
                }
                else
                {
                    if (!changeItem) 
                    {
                        changeItem=HistoryData.Copy(kItem);
                        changeItem.High=changeItem.Low=kItem.Close;
                    }
                    else
                    {
                        changeItem.Close=kItem.Close;
                        if (changeItem.Low>kItem.Close) changeItem.Low=kItem.Close;
                    }

                    if (Math.abs(changeItem.Low-kagiItem.High)>brickSize)   //达到变盘点
                    {
                        bindData.Data.push(kagiItem);

                        var newItem=HistoryData.Copy(kItem);
                        newItem.High=kagiItem.High;
                        newItem.Low=kItem.Close;
                        newItem.Direction=2;   //1 上 2=下
                        newItem.StartItem=kItem;

                        kagiItem=newItem;
                        changeItem=null;
                    }
                }
            }
            else if (kagiItem.Direction==2) //下
            {
                if (kItem.Close<=kagiItem.Low) 
                {
                    kagiItem.Close=kItem.Close;
                    kagiItem.Low=kItem.Close;
                    kagiItem.EndItem=kItem;
                }
                else
                {
                    if (!changeItem) 
                    {
                        changeItem=HistoryData.Copy(kItem);
                        changeItem.High=changeItem.Low=kItem.Close;
                    }
                    else
                    {
                        changeItem.Close=kItem.Close;
                        if (changeItem.High<kItem.Close) changeItem.High=kItem.Close;
                    }

                    if (Math.abs(changeItem.High-kagiItem.Low)>brickSize)   //达到变盘点
                    {
                        bindData.Data.push(kagiItem);

                        var newItem=HistoryData.Copy(kItem);
                        newItem.High=kItem.Close;
                        newItem.Low=kagiItem.Low;
                        newItem.Direction=1;   //1 上 2=下
                        newItem.StartItem=kItem;

                        kagiItem=newItem;
                        changeItem=null;
                    }
                }
            }
        }

        return bindData;
    }

    //获取配置信息
    this.GetTitle=function()
    {
        if (this.BrickSizeType==1)
        {
            var text=`Kagi [ATR(${this.ATR.Count}), ${this.ATR.BrickSize}]`;
        }
        else
        {
            var text=`Kagi [Traditional]`;
        }

        return text;
    }
}

//////////////////////////////////////////////////////////////////
//   HeikinAshi
//
function HeikinAshiCalculate()
{
    this.SourceData;
    this.Symbol;
    this.FloatPrecision=2;  //品种小数位数
    this.ClassName="HeikinAshiCalculate";

    this.Clear=function()
    {
        this.SourceData=null;
        this.LastData=null;
        this.Symbol=null;
    }

    this.RecvHistoryData=function(sourceData, option)  //历史日线数据
    {
        this.Symbol=option.Symbol;
        this.SourceData=sourceData;
        this.FloatPrecision=GetfloatPrecision(this.Symbol);

        return this.Calculate(sourceData);
    }

    this.GetTitle=function()
    {
        return "Heikin Ashi";
    }

    this.Calculate=function(sourceData)
    {
        var bindData=new ChartData();
        bindData.Data=[]
        bindData.Right=sourceData.Right;
        bindData.Period=sourceData.Period;
        bindData.DataType=sourceData.DataType;
        bindData.Symbol=sourceData.symbol;

        if (!IFrameSplitOperator.IsNonEmptyArray(sourceData.Data)) return bindData;

        var lastKItem=null;
        var yClose=null;
        for(var i=0;i<sourceData.Data.length;++i)
        {
            var kItem=sourceData.Data[i];
            var newItem=HistoryData.Copy(kItem);
            if (!lastKItem)
            {
                newItem.Open=(kItem.Close+kItem.Open)/2;
                newItem.Close=(kItem.Close+kItem.Open+kItem.High+kItem.Low)/4;
                yClose=newItem.Close;
            }
            else
            {
                newItem.Close=(kItem.Close+kItem.Open+kItem.High+kItem.Low)/4;
                newItem.Open=(lastKItem.Close+lastKItem.Open)/2;
                newItem.YClose=yClose;
                newItem.High=Math.max(newItem.Close, newItem.Open, kItem.High);
                newItem.Low=Math.min(newItem.Close, newItem.Open, kItem.Low);

                yClose=newItem.Close;
            }

            lastKItem=kItem;

            bindData.Data.push(newItem);
        }

        return bindData;
    }
}

//////////////////////////////////////////////////////////////////
//  line break
// 
function LineBreakCalcuate()
{
    this.SourceData;
    this.Symbol;
    this.FloatPrecision=2;  //品种小数位数
    this.LineCount=3;
    this.ClassName="LineBreakCalcuate";

    this.Clear=function()
    {
        this.SourceData=null;
        this.LastData=null;
        this.Symbol=null;
    }

    this.GetTitle=function()
    {
        return `Line Break [${this.LineCount}]`;
    }

    this.RecvHistoryData=function(sourceData, option)  //历史日线数据
    {
        this.Symbol=option.Symbol;
        this.SourceData=sourceData;
        this.FloatPrecision=GetfloatPrecision(this.Symbol);
        return this.CalculateByClose(sourceData);
    }

    //计算前N个周期的最大最小值
    this.CalculatePreviousKLine=function(preKLine)
    {
        for(var i=0;i<preKLine.Data.length;++i)
        {
            var item=preKLine.Data[i];
            if (i==0)
            {
                preKLine.High=item.High;
                preKLine.Low=item.Low;
            }
            else
            {
                if (preKLine.High<item.High) preKLine.High=item.High;
                if (preKLine.Low<item.Low) preKLine.Low=item.Low;
            }

            preKLine.Date=item.Date;
            preKLine.Time=item.Time;
            preKLine.Vol+=item.Vol;
            preKLine.Amount+=item.Amount;
        }
    }

    //使用收盘价计算
    /*
        If the close of the daily bar is higher than the high of the previous white line, draw a new white line with the open equal to the previous line’s high, and the close equal to the close of the current daily bar.
        If the close of the daily bar is lower than the low of the last three lines, draw a new red line with the open equal to the previous line’s low and the close equal to the close of the current daily bar.
        If neither of the above two conditions are met, no new line is produced.
    */
    this.CalculateByClose=function(sourceData)
    {
        var bindData=new ChartData();
        bindData.Data=[]
        bindData.Right=sourceData.Right;
        bindData.Period=sourceData.Period;
        bindData.DataType=sourceData.DataType;
        bindData.Symbol=sourceData.symbol;

        if (!IFrameSplitOperator.IsNonEmptyArray(sourceData.Data)) return bindData;

        var index=0;
        var preItem={ High:null, Low:null, Date:null, Time:null, Direction:0 };
        for(; index<sourceData.Data.length && index<this.LineCount ;++index)
        {
            var kItem=sourceData.Data[index];
            if (i==0)
            {
                preItem.High=kItem.High;
                preItem.Low=kItem.Low;
            }
            else
            {
                if (preItem.High<kItem.High) preItem.High=kItem.High;
                if (preItem.Low>kItem.Low) preItem.Low=kItem.Low;
            }

            preItem.Date=kItem.Date;
            preItem.Time=kItem.Time;
            preItem.Vol+=kItem.Vol;
            preItem.Amount+=kItem.Amount;
        }

        for(var i=index;i<sourceData.Data.length;++i)
        {
            var kItem=sourceData.Data[i];
           
            if (kItem.Close>preItem.High)  //阳线
            {
                var item=new HistoryData();
                item.YClose=preItem.Low;
                if (preItem) item.Open=preItem.High;
                else item.Open=preItem.High;
                item.Close=kItem.Close;
                item.Low=Math.min(item.Open,item.Close);
                item.High=Math.max(item.Open,item.Close);
                item.Date=kItem.Date;
                item.Time=kItem.Time;
                item.Vol=kItem.Vol;
                item.Amount=kItem.Amount;
                item.Direction=1;   //阳线
                bindData.Data.push(item);

                //if (preItem && preItem.Direction==1) preItem.Close=preItem.High;
                //else if (preItem && preItem.Direction==2) preItem.Close=preItem.Low;

                preItem=item;
            }
            else if (kItem.Close<preItem.Low)  //阴线
            {
                var item=new HistoryData();
                item.YClose=preItem.High;
                if (preItem) item.Open=preItem.Low;
                else item.Open=preItem.Low;
                item.Close=kItem.Close;
                item.Low=Math.min(item.Open,item.Close);
                item.High=Math.max(item.Open,item.Close);
                item.Date=kItem.Date;
                item.Time=kItem.Time;
                item.Vol=kItem.Vol;
                item.Amount=kItem.Amount;
                item.Direction=2;   //阴线
                bindData.Data.push(item);

                //if (preItem && preItem.Direction==1) preItem.Close=preItem.High;
                //else if (preItem && preItem.Direction==2) preItem.Close=preItem.Low;

                preItem=item;
            }
            else
            {
                if (preItem)
                {
                    if (preItem.Direction==1)
                    {
                        //if (preItem.High<kItem.High) preItem.High=kItem.High;
                    }
                    else if (preItem.Direction==2)
                    {
                        //if (preItem.Low>kItem.Low) preItem.Low=kItem.Low;
                    }

                    preItem.Vol+=kItem.Vol;
                    preItem.Amount+=kItem.Amount;
                }
            }
        }

        return bindData;
    }
} 

/////////////////////////////////////////////////////////////////////////////////////////////
//  K线图 控件
//  this.ChartPaint[0] K线画法 这个不要修改
//
//
function KLineChartContainer(uielement,OffscreenElement, cacheElement)
{
    var _self =this;
    this.newMethod=JSChartContainer;   //派生
    this.newMethod(uielement,OffscreenElement,cacheElement);
    delete this.newMethod;

    this.ClassName='KLineChartContainer';
    this.WindowIndex=new Array();
    this.ColorIndex;                    //五彩K线
    this.TradeIndex;                    //交易指标/专家系统
    this.Symbol;
    this.Name;
    this.Period=0;                      //周期 0=日线 1=周线 2=月线 3=年线 4=1分钟 5=5分钟 6=15分钟 7=30分钟 8=60分钟 9=季线 10=分笔线 11=120分钟 12=240分钟
    this.IsApiPeriod=false;             //使用API计算周期
    this.Right=0;                       //复权 0 不复权 1 前复权 2 后复权
    this.RightFormula=0                 //复权公式 0=简单复权, 1=复权因子复权
    this.SourceData;                    //原始的历史数据
    this.MaxRequestDataCount=3000;      //数据个数
    this.MaxRequestMinuteDayCount=5;    //分钟数据请求的天数
    this.PageSize=200;                  //每页数据个数
    this.KLineDrawType=0;
    this.ScriptErrorCallback;           //脚本执行错误回调
    this.FlowCapitalReady=false;        //流通股本是否下载完成
    this.EnableFlowCapital={};          //强制现在流通股 { BIT:数据货币true/false, }
    this.EnableZoomUpDown=null;         //是否手势/键盘/鼠标允许缩放{ Touch:true/false, Mouse:true/false, Keyboard:true/false, Wheel:true/false }
    this.ChartDrawStorage=new ChartDrawStorage();
    this.ChartDrawStorageCache=null;    //首次需要创建的画图工具数据
    this.RightSpaceCount=0;             //右侧空白个数
    this.SourceDataLimit=new Map();     //每个周期缓存数据最大个数 key=周期 value=最大个数 
    this.CtrlMoveStep=5;                //Ctrl+(Left/Right) 移动数据个数  

    this.CustomShow=null;               //首先显示的K线的起始日期 { Date:日期, Time:时间, PageSize:}
    this.ZoomType=0;                    //缩放模式 0=最右边固定缩放, 1=十字光标两边缩放
    this.IsZoomLockRight=false;         
    this.KLineSize=null;                //{ DataWidth:, }
    //this.EnableYDrag={ Left:false, Right:true };

    this.Page= { 
        Day:{ Enable:false, Index:0, Finish:false },    //日线
        Minute:{ Enable:false, Index:0, Finish:false }  //分钟
    };  //分页下载 Enable:是否分页下载 Index:已下载到第几页 Finish：是否所有分页完成  

    this.DragDownload= { 
        Day:{ Enable:false, IsEnd:false, Status:0 },        //日线数据拖拽下载 Status: 0空闲 1 下载中
        Minute: { Enable:false, IsEnd:false, Status:0 },    //分钟/秒数据拖拽下载
        Tick: { Enable:false, IsEnd:false, Status:0 }       //分笔
    };

    this.ZoomDownload=
    {
        Day:{ Enable:false, IsEnd:false, Status:0 },        //日线数据缩放下载 Status: 0空闲 1 下载中
        Minute: { Enable:false, IsEnd:false, Status:0 },    //分钟/秒数据缩放下载
        Tick: { Enable:false, IsEnd:false, Status:0 }       //分笔
    }

    //自动更新设置
    this.IsAutoUpdate=false;                    //是否自动更新行情数据
    this.AutoUpdateFrequency=30000;             //30秒更新一次数据
    this.AutoUpdateTimer;                       //自动更新定时器

    //this.KLineApiUrl="http://opensource.zealink.com/API/KLine2";                  //历史K线api地址
    this.KLineApiUrl=g_JSChartResource.Domain+"/API/KLine2";                        //历史K线api地址
    this.MinuteKLineApiUrl=g_JSChartResource.Domain+'/API/KLine3';                  //历史分钟数据
    this.DragMinuteKLineApiUrl=g_JSChartResource.Domain+'/API/KLine4';              //拖动1分钟K数据下载
    this.DragKLineApiUrl=g_JSChartResource.Domain+'/API/KLine5';                    //拖动日K数据下载
    this.ZoomMinuteKLineApiUrl=g_JSChartResource.Domain+'/API/KLine4';              //拖动1分钟K数据下载
    this.ZoomKLineApiUrl=g_JSChartResource.Domain+'/API/KLine5';                    //拖动日K数据下载
    this.RealtimeApiUrl=g_JSChartResource.Domain+"/API/Stock";                      //实时行情api地址
    this.KLineMatchUrl=g_JSChartResource.Domain+"/API/KLineMatch";                  //形态匹配
    this.StockHistoryDayApiUrl= g_JSChartResource.Domain+'/API/StockHistoryDay';    //股票历史数据
    this.TickApiUrl=g_JSChartResource.Domain+'/API/StockDetail';                    //当天分笔数据

    this.PopMinuteChart=null;   //双击历史K线 弹出分钟走势图

    this.BeforeBindMainData=null;   //function(funcName)   在BindMainData() 调用前回调用
    this.AfterBindMainData=null;    //function(funcName)   在BindMainData() 调用前后调用

    this.KLineCalculate=null;               //K线定制指标计算
    this.KLineCalcOption=new Map();         //K线定制指标配置

    this.ScrollBar=null;            //横向滚动条
    this.IsAutoSyncDataOffset=true; //增量更新时,是否移动当前屏数据
    this.IsShowKLineDivTooltip=true;    //是否显示K线tooltip

    this.GetKLineCalulate=function()
    {
        var kLineDrawType=this.GetKLineDrawType();
        var className;
        if (kLineDrawType==10) className="RenkoCalculate";
        else if (kLineDrawType==11) className="HeikinAshiCalculate";
        else if (kLineDrawType==12) className="LineBreakCalcuate";
        else if (kLineDrawType==16) className="KagiCalculate";
        else return null;

        if (!this.KLineCalculate || this.KLineCalculate.ClassName!=className)
        {
            this.KLineCalculate=g_KLineCustomCalulate.Create(className);
            if (this.KLineCalculate.SetOption && this.KLineCalcOption.has(className))
            {
                var option=this.KLineCalcOption.get(className);
                this.KLineCalculate.SetOption(option);
            }
        }
        
        return this.KLineCalculate;
    }

    this.SetKLineCalcOption=function(className, option)
    {
        this.KLineCalcOption.set(className, option);
        if (this.KLineCalculate && this.KLineCalculate.ClassName==className && this.KLineCalculate.SetOption)
        {
            this.KLineCalculate.SetOption(option);
        }
    }

    this.ClearKLineCaluate=function()
    {
        if (!this.KLineCalculate) return;
        if (!this.KLineCalculate.Clear) return;

        this.KLineCalculate.Clear();
    }

    this.ResetDragDownload=function()
    {
        this.DragDownload.Day.Status=0;
        this.DragDownload.Day.IsEnd=false;

        this.DragDownload.Minute.Status=0;
        this.DragDownload.Minute.IsEnd=false;

        this.DragDownload.Tick.Status=0;
        this.DragDownload.Tick.IsEnd=false;
    }

    this.ResetZoomDownload=function()
    {
        this.ZoomDownload.Day.Status=0;
        this.ZoomDownload.Day.IsEnd=false;

        this.ZoomDownload.Minute.Status=0;
        this.ZoomDownload.Minute.IsEnd=false;

        this.ZoomDownload.Tick.Status=0;
        this.ZoomDownload.Tick.IsEnd=false;
    }

    this.ResetPage=function()   //重置分页下载
    {
        this.Page.Day.Finish=false;
        this.Page.Day.Index=0;

        this.Page.Minute.Finish=false;
        this.Page.Minute.Index=0;
    }

    this.AddCustomKLine=function(kline, option)
    {
        var klineChart=this.ChartPaint[0];
        if (!klineChart) return;

        if (!kline) return;

        if (!klineChart.CustomKLine) klineChart.CustomKLine=new Map();

        if (Array.isArray(kline))
        {
            for(var i=0;i<kline.length;++i)
            {
                var item=kline[i];
                klineChart.CustomKLine.set(item.Key, item.Data);
            }
        }
        else if (kline)
        {
            klineChart.CustomKLine.set(kline.Key, kline.Data);
        }
        
        if (option && option.Draw==true) this.Draw();
    }

    this.ClearCustomKLine=function(option)
    {
        var klineChart=this.ChartPaint[0];
        if (!klineChart) return;

        klineChart.ClearCustomKLine();

        if (option && option.Draw==true) this.Draw();
    }

    this.StopAutoUpdate=function()
    {
        this.CancelAutoUpdate();
        this.AutoUpdateEvent(false,'KLineChartContainer::StopAutoUpdate');
        if (!this.IsAutoUpdate) return;
        this.IsAutoUpdate=false;
    }

    //沙盘操作 { ID: 1=开始, Data:绑定K线数据(可选)
    //          ID: 2=更新数据, Data:绑定K线数据
    //          ID: 3=结束, IsAutoUpdate:是否启动自动更新(可选) }
    this.SandTableOperator=function(obj)
    {
        switch(obj.ID)
        {
            case 1:
                this.StopAutoUpdate();
                if (obj.Data) this.ManualUpdateKData(obj);
                break;
            case 2:
                this.ManualUpdateKData(obj);
                break;
            case 3:
                if (obj.IsAutoUpdate) this.IsAutoUpdate=obj.IsAutoUpdate;
                this.ChangeSymbol(this.Symbol);
                break;
        }
    }

    //外部手动更新K线数据, 内部不计算周期和复权
    this.ManualUpdateKData=function(obj)
    {
        var kData=obj.Data;
        var lastDataCount=kData.length;
        var bindData=new ChartData();
        bindData.Data=kData;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.Symbol=this.Symbol;

        this.UpdateMainData(bindData,lastDataCount);//更新主图数据
        this.BindInstructionIndexData(bindData);    //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        //更新当前屏K线索引
        if (IFrameSplitOperator.IsNumber(obj.DataOffset) && obj.DataOffset>=0)
        {
            var data=null;
            if (this.Frame.Data)
                data=this.Frame.Data;
            else
                data=this.Frame.SubFrame[0].Frame.Data;
            if (data) data.DataOffset=obj.DataOffset;
        }

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex(1);  //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();                        //刷新画图

        this.SendManualKLineUpdateEvent(bindData);
    }

    //获取k线数据
    this.GetKDataInfo=function()
    {
        if (!this.ChartPaint[0]) return null;

        var chartKLine=this.ChartPaint[0];
        var obj={};
        if (chartKLine.Data && chartKLine.Data.Data)
            obj.Data=chartKLine.Data.CloneData("HistoryData");
        obj.ShowRange=chartKLine.ShowRange;
        obj.Period=this.Period;
        obj.RightSpaceCount=this.RightSpaceCount;

        return obj;
    }

    this.ChartOperator=function(obj) //图形控制函数 {ID:JSCHART_OPERATOR_ID, ...参数 }
    {
        var id=obj.ID;
        if (id===JSCHART_OPERATOR_ID.OP_SCROLL_LEFT || id===JSCHART_OPERATOR_ID.OP_SCROLL_RIGHT )    //左右移动 { Step:移动数据个数 }
        {
            var isLeft=(id===JSCHART_OPERATOR_ID.OP_SCROLL_LEFT ? true:false);
            var step=1;
            if (obj.Step>0) step=obj.Step;
            var oneStepWidth=this.GetMoveOneStepWidth();
            if(this.DataMove(step*oneStepWidth,isLeft))    //每次移动一个数据
            {
                this.UpdataDataoffset();
                this.UpdatePointByCursorIndex();
                this.UpdateFrameMaxMin();
                this.ResetFrameXYSplit();
                this.Draw();
            }
            else
            {
                if (id===JSCHART_OPERATOR_ID.OP_SCROLL_RIGHT && this.DragDownloadData) 
                    this.DragDownloadData();
            }
        }
        else if (id===JSCHART_OPERATOR_ID.OP_ZOOM_IN || id===JSCHART_OPERATOR_ID.OP_ZOOM_OUT)       //缩放
        {
            var cursorIndex={};
            cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
            if (id===JSCHART_OPERATOR_ID.OP_ZOOM_IN)
            {
                if (!this.Frame.ZoomUp(cursorIndex)) return;
            }
            else
            {
                if (!this.Frame.ZoomDown(cursorIndex)) return;
            }
            this.CursorIndex=cursorIndex.Index;
            this.UpdataDataoffset();
            this.UpdatePointByCursorIndex();
            this.UpdateFrameMaxMin();
            this.ResetFrameXSplit();
            this.Draw();
        }
        else if (id===JSCHART_OPERATOR_ID.OP_GOTO_HOME)
        {
            var hisData=this.ChartOperator_Temp_GetHistroyData();;
            if (!hisData) return;  //数据还没有到达

            var showCount=this.Frame.SubFrame[0].Frame.XPointCount; //获取一屏显示的数据个数
            showCount-=this.RightSpaceCount;
            var index=hisData.Data.length-showCount;
            hisData.DataOffset=index;
            this.CursorIndex=0;

            this.LastPoint.X=null;
            this.LastPoint.Y=null;

            JSConsole.Chart.Log(`[KLineChartContainer::ChartOperator] OP_GOTO_HOME, dataOffset=${hisData.DataOffset} CursorIndex=${this.CursorIndex} PageSize=${showCount}`);

            this.ChartOperator_Temp_Update();
        }
        else if (id===JSCHART_OPERATOR_ID.OP_GOTO_END)
        {
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return;  //数据还没有到达

            hisData.DataOffset=0;
            this.CursorIndex=0;

            this.LastPoint.X=null;
            this.LastPoint.Y=null;

            JSConsole.Chart.Log(`[KLineChartContainer::ChartOperator] OP_GOTO_END `);

            this.ChartOperator_Temp_Update();
        }
        else if (id==JSCHART_OPERATOR_ID.OP_LEFT_ZOOM_IN || id==JSCHART_OPERATOR_ID.OP_LEFT_ZOOM_OUT)   //{ Step：增加/减少数量 } 左边增加/减少显示个数
        {
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return;  //数据还没有到达

            var dataCount=hisData.Data.length;
            var showCount=this.Frame.SubFrame[0].Frame.XPointCount; //获取一屏显示的数据个数
            var dataOffset=hisData.DataOffset;

            if (id==JSCHART_OPERATOR_ID.OP_LEFT_ZOOM_IN)    //增加
            {
                if (IFrameSplitOperator.IsNumber(obj.Step))
                {
                    if (showCount>=dataCount) return;
                    var step=obj.Step;
                    if (step>dataOffset) step=dataOffset;
                    if (showCount+step>dataCount) step=dataCount-showCount;
                    if (step<=0) return;

                    showCount+=step;
                    hisData.DataOffset-=step;
                }
            }
            else if (id==JSCHART_OPERATOR_ID.OP_LEFT_ZOOM_OUT)  //减少
            {
                var pageSize = this.GetMaxMinPageSize();
                var minShowCount=pageSize.Min;
                if (IFrameSplitOperator.IsNumber(obj.Step))
                {
                    if (showCount<minShowCount) return;
                    var step=obj.Step;
                    if (showCount-step<minShowCount) step=showCount-minShowCount;
                    if (step<=0) return;

                    showCount-=step;
                    hisData.DataOffset+=step;
                }
            }
            
            for(var i in this.Frame.SubFrame)   //设置一屏显示的数据个数
            {
                var item =this.Frame.SubFrame[i].Frame;
                item.XPointCount=showCount;
            }

            if (hisData.DataOffset<0) hisData.DataOffset=0;
            this.ChartOperator_Temp_Update();
        }
        else if (id==JSCHART_OPERATOR_ID.OP_RIGHT_ZOOM_IN || id==JSCHART_OPERATOR_ID.OP_RIGHT_ZOOM_OUT) //{ Step：增加/减少数量 , ShowCount:显示个数 } 右边增加/减少显示个数
        {
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return;  //数据还没有到达

            var dataCount=hisData.Data.length;
            var showCount=this.Frame.SubFrame[0].Frame.XPointCount; //获取一屏显示的数据个数
            var dataOffset=hisData.DataOffset;

            if (id==JSCHART_OPERATOR_ID.OP_RIGHT_ZOOM_IN)   //增加
            {
                if (IFrameSplitOperator.IsNumber(obj.Step))
                {
                    if (showCount>=dataCount) return;
                    var endPos=dataOffset+showCount;
                    var rightCount=dataCount-endPos;
                    if (rightCount<=0) return;

                    var step=obj.Step;
                    if (step>rightCount) step=rightCount;
                    if (step<=0) return;

                    showCount+=step;
                }
            }
            else if (id==JSCHART_OPERATOR_ID.OP_RIGHT_ZOOM_OUT) //减少
            {
                var pageSize = this.GetMaxMinPageSize();
                var minShowCount=pageSize.Min;
                if (IFrameSplitOperator.IsNumber(obj.Step))
                {
                    if (showCount<minShowCount) return;
                    var step=obj.Step;
                    if (step>showCount) step=showCount;
                    if (showCount-step<minShowCount) step=showCount-minShowCount;
                    if (step<=0) return;

                    showCount-=step;
                }
            }

            for(var i in this.Frame.SubFrame)   //设置一屏显示的数据个数
            {
                var item =this.Frame.SubFrame[i].Frame;
                item.XPointCount=showCount;
            }

            if (hisData.DataOffset<0) hisData.DataOffset=0;
            this.ChartOperator_Temp_Update();
        }
        else if (id==JSCHART_OPERATOR_ID.OP_SET_SELECTRECT)    //区间选择 {Start:{ Date:, Time:}, End:{ Date:, Time }, SubClient:{ Start:{ Date: }, End:{Date: }},}
        {
            if (!this.ChartPaint[0]) return false;
            if (!this.ChartPaint[0].Data) return false;
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!IFrameSplitOperator.IsNonEmptyArray(hisData.Data)) return false;
            var paint=this.GetRectSelectPaint();
            if (!paint) return false;

            if (!ChartData.IsDayPeriod(this.Period,true)) return false; //TODO:暂时只支持日线的
            var firstPoint, secondPoint, subFirstPoint, subSecondPoint;
            for(var i=0;i<hisData.Data.length;++i)
            {
                var item=hisData.Data[i];
                if (item.Date==obj.Start.Date)
                {
                    firstPoint={ KItem:item, DataIndex:i };
                }

                if (item.Date==obj.End.Date)
                {
                    secondPoint={ KItem:item, DataIndex:i };
                }

                if (obj.SubClient && obj.SubClient.Start && item.Date==obj.SubClient.Start.Date)
                {
                    subFirstPoint={ KItem:item, DataIndex:i };
                }

                if (obj.SubClient && obj.SubClient.End && item.Date==obj.SubClient.End.Date)
                {
                    subSecondPoint={ KItem:item, DataIndex:i };
                }

                if (firstPoint && secondPoint)
                    break;
            }

            if (!firstPoint || !secondPoint) 
            {
                JSConsole.Chart.Warn("[KLineChartContainer::ChartOperator][OP_SET_SELECTRECT] can't find date. firstPoint, secondPoint, obj", firstPoint, secondPoint, obj);
                return false;
            }

            paint.SetPoint(firstPoint.KItem, {Index:0, DataIndex:firstPoint.DataIndex });
            paint.SetPoint(secondPoint.KItem, {Index:1, DataIndex:secondPoint.DataIndex });

            if (subFirstPoint && subSecondPoint)
            {
                paint.SetPoint(subFirstPoint.KItem, {Index:3, DataIndex:subFirstPoint.DataIndex });
                paint.SetPoint(subSecondPoint.KItem, {Index:4, DataIndex:subSecondPoint.DataIndex });
            }
            
            if (IFrameSplitOperator.IsBool(obj.PreventClose)) paint.PreventClose=obj.PreventClose;

            //当前屏的K线范围, 如果区间不在当前屏移动K线
            var bMoveKLine=false;   //是否需要移动K线
            var drawKRange=this.ChartPaint[0].DrawKRange;
            if (drawKRange)
            {
                //左边
                if ( (drawKRange.Start>=firstPoint.DataIndex &&  drawKRange.Start>=secondPoint.DataIndex) ||
                    (drawKRange.End<=firstPoint.DataIndex &&  drawKRange.End<=secondPoint.DataIndex) )
                {
                    var offset=firstPoint.DataIndex;;
                    var dataCount=hisData.Data.length;
                    var showCount=this.ChartPaint[0].ShowRange.ShowCount;   //显示个数
                    if (offset+showCount>dataCount) offset=dataCount-showCount;
                    if (offset<0) offset=0;

                    hisData.DataOffset=offset;
                    bMoveKLine=true;
                }
            }

            if (bMoveKLine)
            {
                this.ChartOperator_Temp_Update();
            }
            else
            {
                this.Draw();
            }
           
            return true;
        }
        else if (id==JSCHART_OPERATOR_ID.OP_SET_SUB_SELECTRECT) // {Start:{ Date:, Time:}, End:{ Date:, Time }
        {
            if (!this.ChartPaint[0]) return false;
            if (!this.ChartPaint[0].Data) return false;
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!IFrameSplitOperator.IsNonEmptyArray(hisData.Data)) return false;
            var paint=this.GetRectSelectPaint();
            if (!paint) return false;

            if (!ChartData.IsDayPeriod(this.Period,true)) return false; //TODO:暂时只支持日线的
            var firstPoint, secondPoint, subFirstPoint, subSecondPoint;
            for(var i=0;i<hisData.Data.length;++i)
            {
                var item=hisData.Data[i];
                if (item.Date==obj.Start.Date)
                {
                    firstPoint={ KItem:item, DataIndex:i };
                }

                if (item.Date==obj.End.Date)
                {
                    secondPoint={ KItem:item, DataIndex:i };
                }

                if (firstPoint && secondPoint)
                    break;
            }

            if (!firstPoint || !secondPoint) 
            {
                JSConsole.Chart.Warn("[KLineChartContainer::ChartOperator][OP_SET_SUB_SELECTRECT] can't find date. firstPoint, secondPoint, obj", firstPoint, secondPoint, obj);
                return false;
            }

            paint.SetPoint(firstPoint.KItem, {Index:3, DataIndex:firstPoint.DataIndex });
            paint.SetPoint(secondPoint.KItem, {Index:4, DataIndex:secondPoint.DataIndex });

            this.Draw();

            return true;
        }
        else if (id==JSCHART_OPERATOR_ID.OP_SCROOLBAR_SLIDER_CHANGED)
        {
            var hisData=this.ChartOperator_Temp_GetHistroyData();;
            if (!hisData) return;  //数据还没有到达

            if (obj.Type==0)    //滑块移动
            {
                hisData.DataOffset=obj.Start.Index;
                this.CursorIndex=0;

                this.LastPoint.X=null;
                this.LastPoint.Y=null;

                this.ChartOperator_Temp_Update();
            }
            else if (obj.Type==1 || obj.Type==2)   //左,右
            {
                var startIndex=obj.Start.Index;
                var showCount=(obj.End.Index-obj.Start.Index)+1;

                var start=hisData.Data[obj.Start.Index];
                var end=hisData.Data[obj.End.Index];

                //设置X轴显示数据个数
                this.Frame.SetXShowCount(showCount);

                hisData.DataOffset=obj.Start.Index;
                this.CursorIndex=0;
                this.LastPoint.X=null;
                this.LastPoint.Y=null;

                this.ChartOperator_Temp_Update();
            }
        }
        else if (id==JSCHART_OPERATOR_ID.OP_GOTO) //{ Date:日期, Time:, PageSize:可选 }
        {
            if (!IFrameSplitOperator.IsNumber(obj.Date)) return;

            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return;  //数据还没有到达

            var index=this.ChartOperator_GetIndex_ByDateTime(hisData, obj, this.Period, 0);

            if (index===null) 
            {
                JSConsole.Chart.Log(`[KLineChartContainer::ChartOperator] OP_GOTO can't find date=${obj.Date} time=${obj.Time}`);
                return;
            }

            var oldXPointCount=this.Frame.SubFrame[0].Frame.XPointCount;
            var xPointCount=oldXPointCount;
            if (obj.PageSize>0) //调整一屏显示的个数
            {
                xPointCount=obj.PageSize;
            }

            if (xPointCount!=oldXPointCount)
            {
                //设置X轴显示数据个数
                this.Frame.SetXShowCount(xPointCount);
            }

            hisData.DataOffset=index;
            this.CursorIndex=0;
            this.LastPoint.X=null;
            this.LastPoint.Y=null;

            this.ChartOperator_Temp_Update();
        }
        else if (id==JSCHART_OPERATOR_ID.OP_GOTO_BY_DATAINDEX)  //{PageSize:可选, DataIndex:起始位置数据索引}
        {
            if (!IFrameSplitOperator.IsNumber(obj.DataIndex)) return;
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return;  //数据还没有到达
            if (obj.DataIndex<0 || obj.DataIndex>=hisData.Data.length)
            {
                JSConsole.Chart.Log(`[KLineChartContainer::ChartOperator] OP_GOTO_BY_DATAINDEX obj.DataIndex=${obj.DataIndex} error.}`);
                return;
            }

            var oldXPointCount=this.Frame.SubFrame[0].Frame.XPointCount;
            var xPointCount=oldXPointCount;
            if (obj.PageSize>0) xPointCount=obj.PageSize; //调整一屏显示的个数
            if (xPointCount!=oldXPointCount) this.Frame.SetXShowCount(xPointCount);  //设置X轴显示数据个数

            hisData.DataOffset=obj.DataIndex;
            this.CursorIndex=0;
            this.LastPoint.X=null;
            this.LastPoint.Y=null;

            this.ChartOperator_Temp_Update();
        }
        else if (id==JSCHART_OPERATOR_ID.OP_CORSSCURSOR_GOTO)   //移动十字光标{ Date:, Time }
        {
            if (!IFrameSplitOperator.IsNumber(obj.Date)) return;
            var bTime=IFrameSplitOperator.IsNumber(obj.Time);

            var pageInfo=this.GetChartStatus();
            if (!pageInfo) return;

            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return;  //数据还没有到达
            
            var start=hisData.DataOffset;
            var findIndex=-1, findItem=null, dataIndex=-1;
            for(var i=start, j=0; i<hisData.Data.length && j<pageInfo.KLine.PageSize; ++i, ++j)
            {
                var item=hisData.Data[i];

                if (bTime)
                {
                    if (item.Date==obj.Date && item.Time==obj.Time)
                    {
                        findItem=item;
                        findIndex=j;
                        dataIndex=i;
                        break;
                    }
                }
                else
                {
                    if (item.Date==obj.Date)
                    {
                        findItem=item;
                        findIndex=j;
                        dataIndex=i;
                        break;
                    }
                }
            }

            if (findIndex<0) 
            {
                return;
            }

            if (!this.Frame || !this.Frame.SubFrame[0] || !this.Frame.SubFrame[0].Frame) return false;
            var frame=this.Frame.SubFrame[0].Frame;

            var x=frame.GetXFromIndex(findIndex);
            var y=frame.GetYFromData(item.Close);

            //保存最后一次鼠标移动信息
            var MoveStatus={ X:x, Y:y, IsInClient: this.IsMouseOnClient(x,y) };
            this.LastMouseStatus.OnMouseMove=MoveStatus;
            this.LastMouseStatus.MoveOnPoint={X:x, Y:y};    //鼠标移动的位置

            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MOUSE_MOVE);
            var titleChart=this.TitlePaint[0];
            if (event && titleChart) titleChart.OnMouseMoveEvent=event;

            var pixelTatio = GetDevicePixelRatio(); 

            var e={};
            e.clientX=(x/pixelTatio)+this.UIElement.getBoundingClientRect().left;
            e.clientY=(y/pixelTatio)+this.UIElement.getBoundingClientRect().top;
            this.MoveOnPoint={X:x, Y:y};
            this.OnMouseMove(x,y,e);
            this.LastMouseStatus.MoveOnPoint=null;
            if (titleChart) titleChart.OnMouseMoveEvent=null;
        }
    }

    //内部函数
    this.ChartOperator_Temp_GetHistroyData=function()
    {
        var hisData=null;
        if (!this.Frame.Data) hisData=this.Frame.Data;
        else hisData=this.Frame.SubFrame[0].Frame.Data;
        if (!hisData) return null;  //数据还没有到达

        return hisData;
    }

    this.ChartOperator_Temp_Update=function()
    {
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.ResetFrameXSplit();
        this.Frame.SetSizeChage(true);
        this.Draw();
        this.UpdatePointByCursorIndex();   //更新十字光标位子
    }

    //定位K线的索引
    //searchType 0模糊匹配  1=精确匹配
    this.ChartOperator_GetIndex_ByDateTime=function(hisData, dateTime, period, searchType)
    {
        if (!hisData) return null;  //数据还没有到达
        if (!IFrameSplitOperator.IsNonEmptyArray(hisData.Data)) return null;
        if (!IFrameSplitOperator.IsPlusNumber(dateTime.Date) || dateTime.Date<19810101) return null;

        if (ChartData.IsDayPeriod(period, true))
        {
            for(var i=0;i<hisData.Data.length;++i)
            {
                var item=hisData.Data[i];
                if (searchType==1)
                {
                    if (item.Date==dateTime.Date) return i;
                }
                else
                {
                    if (item.Date>=dateTime.Date) return i;
                }
            }

            return null;
        }

        if (ChartData.IsMinutePeriod(period,true) || ChartData.IsMilliSecondPeriod(period))
        {
            var findTime=null;
            if (IFrameSplitOperator.IsNumber(dateTime.Time)) findTime=dateTime.Time;
            for(var i=0;i<hisData.Data.length;++i)
            {
                var item=hisData.Data[i];
                if (searchType==1)  //精确匹配
                {
                    if (findTime==null) return null;
                    if (item.Date==dateTime.Date && item.Time==findTime) return i;
                }
                else
                {
                    if (findTime==null) //只有日期
                    {
                        if (item.Date>=dateTime.Date) return i;
                    }
                    else
                    {
                        if (item.Date>dateTime.Date || (item.Date==dateTime.Date && item.Time>=findTime)) return i;
                    }
                }
            }

            return null;
        }

        return null;
    }

    this.OnWheel=function(e)
    {
        JSConsole.Chart.Log('[KLineChartContainer::OnWheel]',e);
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        var pixelTatio = GetDevicePixelRatio();
        var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
        var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;

        var isInClient=false;
        this.Canvas.beginPath();
        this.Canvas.rect(this.Frame.ChartBorder.GetLeft(),this.Frame.ChartBorder.GetTop(),this.Frame.ChartBorder.GetWidth(),this.Frame.ChartBorder.GetHeight());
        isInClient=this.Canvas.isPointInPath(x,y);

        var wheelValue=e.wheelDelta;
        if (!IFrameSplitOperator.IsObjectExist(e.wheelDelta))
            wheelValue=e.deltaY* -0.01;
        
        var enableZoomUpDown=true;  //是否允许缩放
        if (this.EnableZoomUpDown && this.EnableZoomUpDown.Wheel===false) enableZoomUpDown=false;
        
        if (this.SourceData && this.SourceData.Data)
        {
            if (isInClient && wheelValue<0 && enableZoomUpDown)       //缩小
            {
                var cursorIndex={ ZoomType:this.ZoomType, IsLockRight:this.IsZoomLockRight };
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (e.ctrlKey) cursorIndex.ZoomType=1;  //ctrl+滚轴 十字中心缩放
                if (this.Frame.ZoomDown(cursorIndex, { ZoomDownloadDataCallback:(requestData)=>{ this.ZoomDownloadData(requestData) } } ))
                {
                    this.CursorIndex=cursorIndex.Index;
                    this.UpdataDataoffset();
                    this.UpdatePointByCursorIndex();
                    this.UpdateFrameMaxMin();
                    this.ResetFrameXSplit();
                    if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true)
                    {

                    }
                    else
                    {
                        this.Draw();
                    }
                    this.OnKLinePageChange("wheel");
                }
            }
            else if (isInClient && wheelValue>0 && enableZoomUpDown)  //放大
            {
                var cursorIndex={ ZoomType:this.ZoomType, IsLockRight:this.IsZoomLockRight };
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (e.ctrlKey) cursorIndex.ZoomType=1;  //ctrl+滚轴 十字中心缩放
                if (this.Frame.ZoomUp(cursorIndex))
                {
                    JSConsole.Chart.Log("[KLineChartContainer::OnWheel] cursorIndex ",cursorIndex)

                    this.CursorIndex=cursorIndex.Index;
                    this.UpdatePointByCursorIndex();
                    this.UpdataDataoffset();
                    this.UpdateFrameMaxMin();
                    this.ResetFrameXSplit();
                    this.Draw();
                    this.OnKLinePageChange("wheel");
                }
            }
        }

        if (!isInClient) 
        {
           if (!this.OnWheel_ZoomUpDownFrameY(e,x,y)) return;
        }

        if(e.preventDefault) e.preventDefault();
        else e.returnValue = false;
    }

    //通过滚轴缩放Y轴
    this.OnWheel_ZoomUpDownFrameY=function(e, x, y)
    {
        if (!this.EnableYDrag.Wheel) return false;

        var dragY=this.TryYDrag(x,y);
        if (!dragY) return false;
       
        if ((dragY.Left && !dragY.IsOverlay) || dragY.Right)
        {
            
        }
        else
        {
            return false;
        }

        var wheelValue=e.wheelDelta;
        if (!IFrameSplitOperator.IsObjectExist(e.wheelDelta))
            wheelValue=e.deltaY* -0.01;

        var yMove=this.EnableYDrag.WheelYMove;
        if (wheelValue>0) yMove*=-1;
        dragY.Position=0;   //只能两边缩放
        if (!this.Frame.OnZoomUpDownFrameY(dragY, yMove)) return false;

        this.Frame.SetSizeChage(true);
        this.Draw();

        return true;
    }

    //创建
    //windowCount 窗口个数
    this.Create=function(windowCount, option)
    {
        this.UIElement.JSChartContainer=this;

        //创建十字光标
        this.ChartCorssCursor=new ChartCorssCursor();
        this.ChartCorssCursor.Canvas=this.Canvas;
        this.ChartCorssCursor.StringFormatX=g_DivTooltipDataForamt.Create("CorssCursor_XStringFormat");
        this.ChartCorssCursor.StringFormatX.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.StringFormatX.LanguageID=this.LanguageID;
        this.ChartCorssCursor.StringFormatY=g_DivTooltipDataForamt.Create("CorssCursor_YStringFormat");
        this.ChartCorssCursor.StringFormatY.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.StringFormatY.LanguageID=this.LanguageID;
        this.ChartCorssCursor.StringFormatY.ExtendChartPaint=this.ExtendChartPaint;
        this.ChartCorssCursor.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

        //创建等待提示
        this.ChartSplashPaint = new ChartSplashPaint();
        this.ChartSplashPaint.Canvas = this.Canvas;
        this.ChartSplashPaint.HQChart=this;

        //创建框架容器
        this.Frame=new HQTradeFrame();
        this.Frame.ChartBorder=new ChartBorder();
        this.Frame.ChartBorder.UIElement=this.UIElement;
        this.Frame.ChartBorder.Top=30;
        this.Frame.ChartBorder.Left=5;
        this.Frame.ChartBorder.Bottom=20;
        this.Frame.Canvas=this.Canvas;
        this.Frame.GetExtendChartRightWidth=()=> { return this.GetExtendChartRightWidth() }
        this.Frame.GetExtendChartByClassName=(name)=> { return this.GetExtendChartByClassName(name); }
        this.Frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.Frame=this.Frame; //十字光标绑定框架
        this.ChartSplashPaint.Frame = this.Frame;

        this.CreateChildWindow(windowCount);
        this.CreateMainKLine();
        this.CreateExtendChart("RectSelectPaint", option? option.SelectRect:null);  //区间统计
        if (this.EnableIndexChartDrag) this.CreateExtendChart("DragMovePaint");
        this.CreateDragSelectRect(option? option.DragSelectRect:null);

        //子窗口动态标题
        for(var i in this.Frame.SubFrame)
        {
            var titlePaint=new DynamicChartTitlePainting();
            titlePaint.Frame=this.Frame.SubFrame[i].Frame;
            titlePaint.Canvas=this.Canvas;
            titlePaint.LanguageID=this.LanguageID;
            titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            titlePaint.SelectedChart=this.SelectedChart;

            this.TitlePaint.push(titlePaint);
        }

        this.ChartCorssCursor.StringFormatX.Frame=this.Frame.SubFrame[0].Frame;
        this.ChartCorssCursor.StringFormatY.Frame=this.Frame;

        var bRegisterKeydown=true;
        var bRegisterWheel=true;

        if (option && option.Listener)
        {
            var item=option.Listener;
            if (item.KeyDown===false) 
            {
                bRegisterKeydown=false;
                JSConsole.Chart.Log('[KLineChartContainer::Create] not register keydown event.');
            }

            if (item.Wheel===false) 
            {
                bRegisterWheel=false;
                JSConsole.Chart.Log('[KLineChartContainer::Create] not register wheel event.');
            }
        }

        if (bRegisterKeydown) this.UIElement.addEventListener("keydown", (e)=>{ this.OnKeyDown(e); }, true);            //键盘消息
        if (bRegisterWheel) this.UIElement.addEventListener("wheel", (e)=>{ this.OnWheel(e); }, true);                  //上下滚动消息

        this.InitalPopMinuteChart(option);
    }

    this.InitalPopMinuteChart=function(option)
    {
        if (!option || !option.KLine) return false;
        var item=option.KLine;
        if (item.KLineDoubleClick===true)
        {
            this.PopMinuteChart=new JSPopMinuteChart();
            this.PopMinuteChart.Inital(this);
            return true;
        }
        
        return false;
    }

    this.DestroyPopMinuteChart=function()
    {
        if (!this.PopMinuteChart) return;

        this.PopMinuteChart.Destroy();
        this.PopMinuteChart=null;
    }

    this.ShowMinuteChartDialog=function(data, x,y)
    {
        if (!this.PopMinuteChart) return;
        if (!data.Tooltip || !data.Chart) return;

        var rtClient=this.UIElement.getBoundingClientRect();
        var rtScroll=GetScrollPosition();

        x+=(rtClient.left+rtScroll.Left);
        y+=(rtClient.top+rtScroll.Top);

        var date=data.Tooltip.Data.Date;
        var symbol=data.Chart.Symbol;

        this.PopMinuteChart.Show({ Date:date, Symbol:symbol, Data:data.Tooltip.Data }, x,y);
    }

   
    this.OnCustomKeyDown=function(keyID, e) //自定义键盘事件
    {
        if (keyID==37 && e.ctrlKey) //Ctrl+Left
        {
            this.MoveCorssCursorLeft(this.CtrlMoveStep);
            return true;
        }
        else if (keyID==39 && e.ctrlKey)    //Ctrl+Right
        {
            this.MoveCorssCursorRight(this.CtrlMoveStep);
            return true;
        }
        else
        {
            return false;
        }
    }

    this.MoveCorssCursorLeft=function(step)
    {
        var data=null;
        if (this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return;

        if (data.DataOffset<=0 && this.CursorIndex<=0) //数据到头了
        {
            if (this.DragDownloadData) this.DragDownloadData();
            return;
        }

        if (this.CursorIndex-step<0)  //当前屏到头了
        {
            data.DataOffset-=step;
            if (data.DataOffset<0) 
            {
                data.DataOffset=0;
                this.CursorIndex=0;
            }
            this.UpdataDataoffset();
            this.UpdatePointByCursorIndex();
            this.UpdateFrameMaxMin();
            this.Draw();
            this.ShowTooltipByKeyDown();
            this.OnKLinePageChange("keydown");
            return;
        }

        this.CursorIndex-=step;
        this.UpdatePointByCursorIndex();
        this.DrawDynamicInfo();
        this.ShowTooltipByKeyDown();
    }

    this.MoveCorssCursorRight=function(step)
    {
        var data=null;
        if (this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return;

        var xPointcount=0;  //当前屏显示个数
        if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
        else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;

        if (this.CursorIndex+data.DataOffset+1>=data.Data.length) return;   //最右边了

        var bMoveEnd=false; //最后一个
        if (this.CursorIndex+step+data.DataOffset+1>data.Data.length)   //数据不够步长
        {
            step=data.Data.length-1-data.DataOffset-this.CursorIndex;
            bMoveEnd=true;
        }

        if (this.CursorIndex+step>=xPointcount) //当前屏最右边了
        {
            var lMoveStep=(this.CursorIndex+step)-(xPointcount-1);
            data.DataOffset+=lMoveStep;
            if (bMoveEnd) this.CursorIndex=xPointcount-1;
            this.UpdataDataoffset();
            this.UpdatePointByCursorIndex();
            this.UpdateFrameMaxMin();
            this.Draw();
            this.ShowTooltipByKeyDown();
            this.OnKLinePageChange("keydown");
            return;
        }

        this.CursorIndex+=step;
        this.UpdatePointByCursorIndex();
        this.DrawDynamicInfo();
        this.ShowTooltipByKeyDown();
    }

    //获取K线图实例
    this.GetKLineChart=function()
    {
        if (!this.ChartPaint[0]) return null;

         return this.ChartPaint[0];
    }

    //创建子窗口
    this.CreateChildWindow=function(windowCount)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_FRAME);

        for(var i=0;i<windowCount;++i)
        {
            var border=new ChartBorder();
            border.UIElement=this.UIElement;

            var frame=g_ChartFrameFactory.Create("KLineFrame", { ID:i });
            frame.Canvas=this.Canvas;
            frame.GetExtraCanvas=(name)=>{ return this.GetExtraCanvas(name); };
            frame.ChartBorder=border;
            frame.Identify=i;                           //窗口序号
            frame.RightSpaceCount=this.RightSpaceCount; //右边
            frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
            frame.GlobalOption=this.GlobalOption;

            if (this.ModifyIndexDialog) frame.ModifyIndexEvent=this.ModifyIndexDialog.DoModal;        //绑定菜单事件
            if (this.ChangeIndexDialog) frame.ChangeIndexEvent=this.ChangeIndexDialog.DoModal;

            frame.HorizontalMax=20;
            frame.HorizontalMin=10;

            if (i==0)
            {
                frame.YSplitOperator=new FrameSplitKLinePriceY();
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('price');
                frame.YSplitOperator.FrameSplitData2=this.FrameSplitData.get('double');
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                frame.YSplitOperator.GetKLineChartCallback=()=> { return this.GetKLineChart(); }
                frame.YSplitOperator.HQChart=this;
                var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
                border.BottomSpace=15*pixelTatio;  //主图上下留空间
                border.TopSpace=15*pixelTatio;

                frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            }
            else
            {
                frame.YSplitOperator=new FrameSplitY();
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
                frame.YSplitOperator.LanguageID=this.LanguageID;
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
                frame.YSplitOperator.GetKLineChartCallback=()=> { return this.GetKLineChart(); }
                frame.YSplitOperator.HQChart=this;
                //frame.IsLocked = true;
            }

            frame.YSplitOperator.Frame=frame;
            frame.YSplitOperator.ChartBorder=border;
            frame.XSplitOperator=new FrameSplitKLineX();
            frame.XSplitOperator.Frame=frame;
            frame.XSplitOperator.ChartBorder=border;
            frame.XSplitOperator.LanguageID=this.LanguageID;
            frame.XSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

            if (i!=windowCount-1) frame.XSplitOperator.ShowText=false;

            for(var j=frame.HorizontalMin;j<=frame.HorizontalMax;j+=1)
            {
                frame.HorizontalInfo[j]= new CoordinateInfo();
                frame.HorizontalInfo[j].Value=j;
                if (i==0 && j==frame.HorizontalMin) continue;

                frame.HorizontalInfo[j].Message[1]=j.toString();
                frame.HorizontalInfo[j].Font="14px 微软雅黑";
            }

            var subFrame=new SubFrameItem();
            frame.FrameData.SubFrameItem=subFrame;
            subFrame.Frame=frame;
            if (i==0)
                subFrame.Height=20;
            else
                subFrame.Height=10;

            this.Frame.SubFrame[i]=subFrame;

            if (event && event.Callback)
            {
                var sendData={ SubFrame:this.Frame.SubFrame[i], WindowIndex:i };
                event.Callback(event, sendData, this);
            }
        }
    }

    this.CreateSubFrameItem=function(id)
    {
        var border=new ChartBorder();
        border.UIElement=this.UIElement;
       
        var frameClassName="KLineFrame";
        if (this.ClassName=="KLineChartHScreenContainer") frameClassName="KLineHScreenFrame";
        var frame=g_ChartFrameFactory.Create(frameClassName, { ID:id });
        
        frame.Canvas=this.Canvas;
        frame.GetExtraCanvas=(name)=>{ return this.GetExtraCanvas(name); };
        frame.ChartBorder=border;
        frame.Identify=id;                   //窗口序号
        frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        frame.GlobalOption=this.GlobalOption;

        if (this.ModifyIndexDialog) frame.ModifyIndexEvent=this.ModifyIndexDialog.DoModal;        //绑定菜单事件
        if (this.ChangeIndexDialog) frame.ChangeIndexEvent=this.ChangeIndexDialog.DoModal;

        frame.HorizontalMax=20;
        frame.HorizontalMin=10;
        frame.YSplitOperator=new FrameSplitY();
        frame.YSplitOperator.LanguageID=this.LanguageID;
        frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
        frame.YSplitOperator.Frame=frame;
        frame.YSplitOperator.ChartBorder=border;
        frame.XSplitOperator=new FrameSplitKLineX();
        frame.XSplitOperator.Frame=frame;
        frame.XSplitOperator.ChartBorder=border;
        frame.XSplitOperator.ShowText=false;
        frame.XSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        frame.YSplitOperator.GetKLineChartCallback=()=> { return this.GetKLineChart(); };
        frame.YSplitOperator.HQChart=this;
        frame.XSplitOperator.Symbol=this.Symbol;
        frame.XSplitOperator.Period=this.Period;

        //K线数据绑定
        var xPointCouont=this.Frame.SubFrame[0].Frame.XPointCount;
        frame.XPointCount=xPointCouont;
        frame.Data=this.ChartPaint[0].Data;

        for(var j=frame.HorizontalMin;j<=frame.HorizontalMax;j+=1)
        {
            frame.HorizontalInfo[j]= new CoordinateInfo();
            frame.HorizontalInfo[j].Value=j;
            frame.HorizontalInfo[j].Message[1]=j.toString();
            frame.HorizontalInfo[j].Font="14px 微软雅黑";
        }

        var subFrame=new SubFrameItem();
        frame.FrameData.SubFrameItem=subFrame;
        subFrame.Frame=frame;
        subFrame.Height=10;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_FRAME);
        if (event && event.Callback)
        {
            var sendData={ SubFrame:subFrame, WindowIndex:id };
            event.Callback(event, sendData, this);
        }

        return subFrame;
    }

    //创建主图K线画法
    this.CreateMainKLine=function()
    {
        var kline=g_ChartPaintFactory.Create("ChartKLine");
        kline.Canvas=this.Canvas;
        kline.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        kline.ChartFrame=this.Frame.SubFrame[0].Frame;
        kline.Name="Main-KLine";
        kline.DrawType=this.KLineDrawType;
        kline.Identify="Main-KLine";
        kline.GetEventCallback=(id)=>{ return this.GetEventCallback(id); };

        this.ChartPaint[0]=kline;

        this.TitlePaint[0]=new DynamicKLineTitlePainting();
        this.TitlePaint[0].Frame=this.Frame.SubFrame[0].Frame;
        this.TitlePaint[0].Canvas=this.Canvas;
        this.TitlePaint[0].OverlayChartPaint=this.OverlayChartPaint;    //绑定叠加
        this.TitlePaint[0].LanguageID=this.LanguageID;
        this.TitlePaint[0].HQChart=this;
        this.TitlePaint[0].GetEventCallback=(id)=>{ return this.GetEventCallback(id); };
    }

    //绑定主图K线数据
    this.BindMainData=function(hisData, showCount, chartOperator)
    {
        var isShowAll=false;    //全部显示
        if (chartOperator && chartOperator.IsShowAll===true) isShowAll=true;
        this.ChartPaint[0].Data=hisData;
        this.ChartPaint[0].Symbol=this.Symbol;

        if (this.KLineSize)
        {
            if (!IFrameSplitOperator.IsNumber(this.KLineSize.DataWidth))
            {
                showCount=this.Frame.SubFrame[0].Frame.XPointCount-this.RightSpaceCount;
            }
            else
            {
                var obj=this.Frame.SetDataWidth(this.KLineSize.DataWidth);
                showCount=obj.XPointCount-this.RightSpaceCount;
                this.KLineSize.DataWidth=null;
            }
        }

        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item =this.Frame.SubFrame[i].Frame;
            if (isShowAll) item.XPointCount=hisData.Data.length+this.RightSpaceCount;
            else item.XPointCount=showCount+this.RightSpaceCount;

            item.Data=this.ChartPaint[0].Data;
            item.XSplitOperator.Symbol=this.Symbol;
            item.XSplitOperator.Period=this.Period;
        }

        this.TitlePaint[0].Data=this.ChartPaint[0].Data;                    //动态标题
        this.TitlePaint[0].Symbol=this.Symbol;
        this.TitlePaint[0].Name=this.Name;
        this.TitlePaint[0].Period=this.Period;

        this.ChartCorssCursor.StringFormatX.Data=this.ChartPaint[0].Data;   //十字光标
        this.Frame.Data=this.ChartPaint[0].Data;

        for(var i=0; i<this.OverlayChartPaint.length; ++i)   //K线叠加 主图股票数据绑定到叠加上
        {
            var item=this.OverlayChartPaint[i];
            item.MainData=this.ChartPaint[0].Data;
        }        

        if (isShowAll)
        {
            var dataOffset=0;
            this.CursorIndex=0;
        }
        else
        {
            var dataOffset=hisData.Data.length-showCount;
            if (dataOffset<0) dataOffset=0;
            this.ChartPaint[0].Data.DataOffset=dataOffset;
    
            this.CursorIndex=showCount;
            if (this.CursorIndex+dataOffset>=hisData.Data.length) this.CursorIndex=hisData.Data.length-1-dataOffset;
            if (this.CursorIndex<0) this.CursorIndex=0; //不一定对啊
        }

        this.ChartPaint[0].Period=this.Period;
        this.ChartCorssCursor.StringFormatY.Symbol=this.Symbol;

        if (this.CustomShow) //定制显示 1次有效
        {
            this.SetCustomShow(this.CustomShow,hisData);
            this.CustomShow=null;
        }
    }

    this.ShowAllKLine=function()
    {
        var chart=this.ChartPaint[0];
        if (!chart) return false;
        var kData=chart.Data;
        if (!kData || !IFrameSplitOperator.IsNonEmptyArray(kData.Data)) return false;

        var xCount=kData.Data.length+this.RightSpaceCount;
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item =this.Frame.SubFrame[i].Frame;
            item.XPointCount=xCount;
        }

        kData.DataOffset=0;
        this.CursorIndex=0;

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.UpdatePointByCursorIndex(2);   //取消十字光标
        this.Draw();
    }

    this.UpdateMainData=function(hisData, lastDataCount)
    {
        var frameHisdata=null;
        if (!this.Frame.Data) frameHisdata=this.Frame.Data;
        else if (this.Frame.SubFrame && this.Frame.SubFrame[0]) frameHisdata=this.Frame.SubFrame[0].Frame.Data;
        if (!frameHisdata) return;
        var xPointCount=this.Frame.SubFrame[0].Frame.XPointCount;   //当前一屏能显示的数据个数

        var newDataCount=0;
        if (IFrameSplitOperator.IsNumber(lastDataCount))
        {
            if (lastDataCount>0 && hisData.Data.length>lastDataCount)
            {
                newDataCount=hisData.Data.length-lastDataCount;
                JSConsole.Chart.Log(`[KLineChartContainer::UpdateMainData]  [count=${lastDataCount}->${hisData.Data.length}], [newDataCount=${newDataCount}], [Pagesize=${xPointCount}]`);
            }
            else if (lastDataCount==0 && hisData.Data.length>xPointCount)   //历史数据为空,当前收到数据大于一屏的数据,显示最新数据
            {
                newDataCount=hisData.Data.length-xPointCount;
                JSConsole.Chart.Log(`[KLineChartContainer::UpdateMainData] history data is empty. [count=${lastDataCount}->${hisData.Data.length}], [newDataCount=${newDataCount}], [Pagesize=${xPointCount}]`);
            }
        }

        this.ChartPaint[0].Data=hisData;
        this.ChartPaint[0].Symbol=this.Symbol;
        if (hisData.Data.length>xPointCount) //不满一屏的, 不需要调整索引
            this.ChartPaint[0].Data.DataOffset=frameHisdata.DataOffset+newDataCount;    //加上数据增加的个数
        for(var i in this.Frame.SubFrame)
        {
            var item =this.Frame.SubFrame[i].Frame;
            item.Data=this.ChartPaint[0].Data;

            if (i==0)   //更新Y轴K线数据
            {
                item.YSplitOperator.Symbol=this.Symbol;
                item.YSplitOperator.Data=this.ChartPaint[0].Data;          //K线数据
                item.YSplitOperator.Period=this.Period;                    //周期
            }
        }

        this.TitlePaint[0].Data=this.ChartPaint[0].Data;                    //动态标题
        this.TitlePaint[0].Symbol=this.Symbol;
        this.TitlePaint[0].Name=this.Name;

        this.ChartCorssCursor.StringFormatX.Data=this.ChartPaint[0].Data;   //十字光标
        this.Frame.Data=this.ChartPaint[0].Data;

        for(var i in this.OverlayChartPaint)    //主图股票数据绑定到叠加股票上
        {
            var item=this.OverlayChartPaint[i];
            item.MainData=this.ChartPaint[0].Data;
        }

        this.ChartCorssCursor.StringFormatY.Symbol=this.Symbol;
    }

    this.SetCustomShow=function(customShow,hisData)
    {
        var index=this.ChartOperator_GetIndex_ByDateTime(hisData,customShow, this.Period, 0);
        if (index===null) 
        {
            JSConsole.Chart.Log("[KLineChartContainer::SetCustomShow] Can't find index by customShow=",customShow);
            return;
        }

        if (IFrameSplitOperator.IsPlusNumber(customShow.PageSize))  //调整一屏显示个数 否则使用默认的
        {
            var showCount=customShow.PageSize;
            for(var i=0;i<this.Frame.SubFrame.length; ++i)
            {
                var item =this.Frame.SubFrame[i].Frame;
                item.XPointCount=showCount;
            }
        }
        
        this.ChartPaint[0].Data.DataOffset=index;
        this.CursorIndex=0;
    }

    this.OnDragSelectRectMouseUp=function(e)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return;
        
        var selectData=paint.GetSelectRectData();
        if (!selectData) return;

        var pixelTatio = GetDevicePixelRatio();
        var corssCursor=this.ChartCorssCursor;  //十字光标
        var x=corssCursor.LastPoint.X/pixelTatio;
        var y=corssCursor.LastPoint.Y/pixelTatio;
        var isShowMenu=true;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAG_SELECT_RECT_MOUSEUP);
        if (event)
        {
            var data=
            { 
                X:x,
                Y:y,
                SelectData:selectData,    //区间选择的数据
                RectSelectPaint:paint,    //区间选择背景
                IsShowMenu:false,
            };
            event.Callback(event,data,this);
            isShowMenu=data.IsShowMenu;
        }
       
        if (isShowMenu)
        {
            var data=
            {
                Chart:this,
                X:x,
                Y:y,
                SelectData:selectData,          //区间选择的数据
                RectSelectPaint:paint           //区间选择背景
            };
            e.data=data;

            this.PopupSelectRectMenuV2(data, e);
        }    
    }

    this.OnDragSubSelectRectMouseUp=function(e)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return;

        var selectData=paint.GetSelectRectData();
        if (!selectData) return;

        var pixelTatio = GetDevicePixelRatio();
        var corssCursor=this.ChartCorssCursor;  //十字光标
        var x=corssCursor.LastPoint.X/pixelTatio;
        var y=corssCursor.LastPoint.Y/pixelTatio;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAG_SUB_SELECT_RECT_MOUSEUP);
        if (event)
        {
            var subRectData={ Start:paint.SubClient.FirstPoint, End: paint.SubClient.SecondPoint };
            var data=
            { 
                X:x,
                Y:y,
                SubSelectData:subRectData,    //子区域数据
                RectSelectPaint:paint,        //区间选择背景
            };
            event.Callback(event,data,this);
        }
    }

    this.ShowSelectData=function(selectData)
    {
        this.HideSelectRect();

        JSConsole.Chart.Log('[KLineChartContainer::ShowSelectData] selectData', selectData);
        var dataOffset=selectData.Start;
        var showCount=(selectData.End-selectData.Start)+1;

        JSConsole.Chart.Log(`[KLineChartContainer::ShowSelectData] DataOffset=${dataOffset}, ShowCount=${showCount}`);

        for(var i in this.Frame.SubFrame)
        {
            var item =this.Frame.SubFrame[i].Frame;
            item.XPointCount=showCount;
        }
        this.ChartPaint[0].Data.DataOffset=dataOffset;
        this.CursorIndex=0;

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
        this.UpdatePointByCursorIndex();   //更新十字光标位子
    }

    this.OnMarkRectSelect=function(e)
    {
        var corssCursor=this.ChartCorssCursor;  //十字光标
        if (!corssCursor || corssCursor.Status==0) return;
        if (!IFrameSplitOperator.IsNumber(corssCursor.CursorIndex)) return;
        if (!this.ChartPaint[0] || !this.ChartPaint[0].Data) return;
        var paint=this.GetRectSelectPaint();
        if (!paint) return;

        var cursorIndex=corssCursor.CursorIndex;
        JSConsole.Chart.Log("[KLineChartContainer::OnMarkRectSelect] dataIndex", cursorIndex);

        var kData=this.ChartPaint[0].Data;
        cursorIndex=parseInt(cursorIndex.toFixed(0));
        var index=cursorIndex+kData.DataOffset;
        if (index>=kData.Data.length) index=kData.Data.length-1;

        var item = kData.Data[index];

        JSConsole.Chart.Log("[KLineChartContainer::OnMarkRectSelect] item", item);

        if (!this.SetRectSelectData(item, index)) return;

        var pointCount=paint.GetPointCount();
        var pixelTatio = GetDevicePixelRatio();
        if (pointCount==1)      //第1个位置
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_KEYDOWN_SELECT_RECT_FIRST);
            if (event && event.Callback)
            {
                var data=
                { 
                    X:corssCursor.LastPoint.X/pixelTatio,
                    Y:corssCursor.LastPoint.Y/pixelTatio,
                    Item:item,
                    Index:index,
                    RectSelectPaint:paint,    //区间选择背景
                    e:e,
                };
                event.Callback(event,data,this);
            }
        }
        else if (pointCount==2)
        {
            var selectData=paint.GetSelectRectData();
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_KEYDOWN_SELECT_RECT);
            var isShowMenu=true;
            if (event && event.Callback)
            {
                var data=
                { 
                    X:corssCursor.LastPoint.X/pixelTatio,
                    Y:corssCursor.LastPoint.Y/pixelTatio,
                    SelectData:selectData,   //区间选择的数据
                    RectSelectPaint:paint,    //区间选择背景
                    IsShowMenu:true,
                    e:e,
                };
                event.Callback(event,data,this);
                isShowMenu=data.IsShowMenu;
            }

            if (isShowMenu)
            {
                var data=
                {
                    Chart:this,
                    X:corssCursor.LastPoint.X/pixelTatio,
                    Y:corssCursor.LastPoint.Y/pixelTatio,
                    SelectData:selectData,          //区间选择的数据
                    RectSelectPaint:paint           //区间选择背景
                };
                e.data=data
                
                this.PopupSelectRectMenuV2(data, e);
            }
        }
        

        this.Draw();
    }

    //创建指定窗口指标
    this.CreateWindowIndex=function(windowIndex)
    {
        this.WindowIndex[windowIndex].Create(this,windowIndex);
    }

    this.BindIndexData=function(windowIndex, hisData, option)
    {
        if (!this.WindowIndex[windowIndex]) return;

        var item=this.WindowIndex[windowIndex];
        if (typeof(item.RequestData)=="function")  //数据需要另外下载的.
        {
            item.RequestData(this,windowIndex,hisData, option);
            return;
        }

        if (typeof(item.ExecuteScript)=='function')
        {
            if (option && option.CheckRunCount)
                if (item.IsExcessRunCount()) return;

            item.ExecuteScript(this,windowIndex,hisData);
            return;
        }

        item.BindData(this,windowIndex,hisData);
    }

    //叠加指标 option={ CheckRunCount:执行次数检测 ,SyncExecute:同步|异步检测 }
    this.BindOverlayIndexData=function(overlayItem, windowIndex, hisData, option)
    {
        if (!overlayItem.Script) return;

        if (typeof(overlayItem.Script.RequestData)=='function')
        {
            overlayItem.Script.RequestData(this,windowIndex,hisData);
            return;
        }

        if (typeof(overlayItem.Script.ExecuteScript)=='function')
        {
            if (option) 
            {
                if (option.CheckRunCount)   //检测执行次数
                {
                    if (overlayItem.Script.IsExcessRunCount()) 
                        return;
                }

                if (IFrameSplitOperator.IsBool(option.SyncExecute)) //异步|同步
                {
                    if (overlayItem.Script.IsSync!=option.SyncExecute) 
                        return;
                }
            }
                
            overlayItem.Script.ExecuteScript(this,windowIndex,hisData);
            return;
        }

        overlayItem.Script.BindData(this,windowIndex,hisData);
    }

    //执行指示(专家指示 五彩K线)
    this.BindInstructionIndexData=function(hisData)
    {
        if (this.ColorIndex && typeof(this.ColorIndex.ExecuteScript)=='function')   //五彩K线
        {
            this.ColorIndex.ExecuteScript(this,0,hisData);
        }

        if (this.TradeIndex && typeof(this.TradeIndex.ExecuteScript)=='function')   //交易指标
        {
            this.TradeIndex.ExecuteScript(this,0,hisData);
        }
    }

    //获取子窗口的所有画法
    this.GetChartPaint=function(windowIndex)
    {
        var paint=new Array();
        for(var i in this.ChartPaint)
        {
            if (i==0) continue; //第1个K线数据除外

            var item=this.ChartPaint[i];
            if (item.ChartFrame==this.Frame.SubFrame[windowIndex].Frame)
                paint.push(item);
        }

        return paint;
    }

    this.AutoUpdateEvent=function(bStart, explain)   //自定更新事件, 是给websocket使用
    {
        var eventID=bStart ? JSCHART_EVENT_ID.RECV_START_AUTOUPDATE:JSCHART_EVENT_ID.RECV_STOP_AUTOUPDATE;
        if (!this.mapEvent.has(eventID)) return;

        var self=this;
        var event=this.mapEvent.get(eventID);
        var data={ Stock:{ Symbol:this.Symbol, Name:this.Name, Right:this.Right, Period:this.Period  }, Explain: explain };
        if (bStart) 
        {
            data.Callback=function(data) //数据到达更新回调
            { 
                if (ChartData.IsDayPeriod(self.Period,true)) self.RecvRealtimeData(data); 
                else if (ChartData.IsMinutePeriod(self.Period,true)) self.RecvMinuteRealtimeData(data);
                else if (ChartData.IsSecondPeriod(self.Period)) self.RecvMinuteRealtimeData(data);
                else if (ChartData.IsMilliSecondPeriod(self.Period)) self.RecvMinuteRealtimeData(data);
            }
        }
        event.Callback(event,data,this);
    }

    this.SendKLineUpdateEvent=function(bindData)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.RECV_KLINE_UPDATE_DATA);
        if (event && event.Callback)
        {
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
            return true;
        }

        return false;
    }

    this.SendManualKLineUpdateEvent=function(bindData)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.RECV_KLINE_MANUAL_UPDATE_DATA);
        if (event && event.Callback)
        {
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
            return true;
        }

        return false;
    }
    
    this.GetKLineDrawType=function()
    {
       return this.KLineDrawType;
    }

    this.RequestHistoryData=function()
    {
        var self=this;
        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
        this.ChartSplashPaint.EnableSplash(true);
        this.FlowCapitalReady=false;
        this.ResetPage(); //重置分页
        this.ResetDragDownload();
        this.ResetZoomDownload();
        this.Draw();

        if (this.NetworkFilter)
        {
            var kLineDrawType=this.GetKLineDrawType();
            var obj=
            {
                Name:'KLineChartContainer::RequestHistoryData', //类名::
                Explain:'日K数据',
                Request:{ Url:self.KLineApiUrl,  Type:'POST' ,
                    Data: 
                    { 
                        symbol:self.Symbol, count:self.MaxRequestDataCount, 
                        field: ["name","symbol","yclose","open","price","high","low","vol"],
                        period:this.Period, right:this.Right, klineDrawType:kLineDrawType
                    } }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryData(data);
                var page=self.Page.Day;
                if (page.Enable==true && page.Finish==false)
                {
                    self.RequestHistoryPageData();
                }
                else
                {
                    self.AutoUpdateEvent(true,'KLineChartContainer::RequestHistoryData');
                    self.AutoUpdate();
                }
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: this.KLineApiUrl,
            data:
            {
                "field": ["name","symbol","yclose","open","price","high","low","vol"],
                "symbol": self.Symbol,
                "start": -1,
                "count": self.MaxRequestDataCount
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryData(data);
                var page=self.Page.Day;
                if (page.Enable==true && page.Finish==false)
                {
                    self.RequestHistoryPageData();
                }
                else
                {
                    self.AutoUpdateEvent(true,'KLineChartContainer::RequestHistoryData');
                    self.AutoUpdate();
                }
            }
        });
    }

    this.BindAllOverlayIndexData=function(hisData, option)
    {
        if (!this.Frame || !this.Frame.SubFrame) return;

        //叠加指标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                this.BindOverlayIndexData(overlayItem,i,hisData,option)
            }
        }
    }

    this.RecvHistoryData=function(data)
    {
        if (this.EnableVerifyRecvData && data.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[KLineChartContainer::RecvHistoryData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        var aryDayData=KLineChartContainer.JsonDataToHistoryData(data);

        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=aryDayData;
        sourceData.DataType=0;      //0=日线数据 1=分钟数据
        sourceData.Symbol=data.symbol;
        this.SourceData=sourceData;

        if (this.BeforeBindMainData) this.BeforeBindMainData("RecvHistoryData");

        //显示的数据
        var bindData=new ChartData();
        bindData.Data=aryDayData;
        bindData.Right=this.Right;
        bindData.Period=this.Period;
        bindData.DataType=0;
        bindData.Symbol=data.symbol;

        if (bindData.Right>0 && !this.IsApiPeriod)    //复权
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula } );
            bindData.Data=rightData;
        }

        if (ChartData.IsDayPeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:"RecvHistoryData" });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        //绑定数据
        this.Symbol=data.symbol;
        this.Name=data.name;

        this.BindMainData(bindData,this.PageSize);
        if (this.AfterBindMainData) this.AfterBindMainData("RecvHistoryData");
        this.Frame.SetSizeChage(true);
        
        var firstSubFrame;
        if (this.Frame.SubFrame[0]) firstSubFrame=this.Frame.SubFrame[0].Frame;
        if (firstSubFrame && firstSubFrame.YSplitOperator)
        {
            firstSubFrame.YSplitOperator.Symbol=this.Symbol;
            firstSubFrame.YSplitOperator.Data=this.ChartPaint[0].Data;          //K线数据
            firstSubFrame.YSplitOperator.Period=this.Period;                    //周期
        }

        var page=this.Page.Day;
        if (page.Enable==false || (page.Enable==true && page.Finish==true))  //分页下载 这些数据迁移到分页下载完以后下载
        {
            this.ReqeustKLineInfoData({ FunctionName:"RecvHistoryData" });            //请求信息地雷
            this.RequestFlowCapitalData();          //请求流通股本数据 (主数据下载完再下载)
            this.RequestOverlayHistoryData();       //请求叠加数据 (主数据下载完再下载)
            this.CreateChartDrawPictureByStorage(); //创建画图工具
        }

        if (page.Enable) page.Index=1;    //第一页下载完成

        this.BindInstructionIndexData(bindData);        //执行指示脚本
        for(var i=0; i<this.Frame.SubFrame.length; ++i) //执行指标
        {
            this.BindIndexData(i,bindData);
        }

        this.BindAllOverlayIndexData(bindData, { SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.UpdatePointByCursorIndex(2);   //取消十字光标
        this.Draw();

        
        this.BindAllOverlayIndexData(bindData,{ SyncExecute:false } );  //异步模式叠加指标

        if (this.mapEvent.has(JSCHART_EVENT_ID.RECV_HISTROY_DATA))
        {
            var event=this.mapEvent.get(JSCHART_EVENT_ID.RECV_HISTROY_DATA);
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
        }
    }

    this.RequestHistoryPageData=function()  //请求分页
    {
        var self=this;
        if (this.NetworkFilter)
        {
            var firstItem=this.SourceData.Data[0];   //最新的一条数据
            var obj=
            {
                Name:'KLineChartContainer::RequestHistoryPageData', //类名::
                Explain:'日K数据分页',
                Request:{ Url:'none',  Type:'POST' ,
                    Data: { symbol:self.Symbol, index:self.Page.Day.Index, field: ["name","symbol","yclose","open","price","high","low","vol"], firstDate:firstItem.Date, first:{ date: firstItem.Date } } }, 
                Page:self.Page.Day,
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.RecvHistoryPageData(data);
                var page=self.Page.Day;
                if (page.Enable==true && page.Finish==false)
                    self.RequestHistoryPageData();  //继续下载
                else
                    self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        //模拟异步请求
        setTimeout(function()
        {
            var page=self.Page.Day;
            page.Finish=true;
            var data= //测试数据
            { 
                data: 
                [
                    [ 20150218, 12.54, 12.5, 12.74, 11.95, 12.27, 117632441, 1459671045 ],
                    [ 20150219, 12.27, 12.1, 12.23, 11.9, 12.23, 95889423, 1157078548 ],
                    [ 20150220, 12.23, 12.17, 12.17, 11.9, 12.05, 67763439, 815652761] 
                ],
                symbol:self.Symbol,
                name:self.Name
            };
    
            self.RecvHistoryPageData(data);
            if (page.Enable==true && page.Finish==false)
                self.RequestHistoryPageData();
            else
                self.AutoUpdate();

        },500)
    }

    this.RecvHistoryPageData=function(data)
    {
        if (this.EnableVerifyRecvData && data.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[KLineChartContainer::RecvHistoryPageData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        var aryDayData=KLineChartContainer.JsonDataToHistoryData(data);
        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数

        for(var i in aryDayData)    //数据往前插
        {
            var item=aryDayData[i];
            this.SourceData.Data.splice(i,0,item);
        }
        
        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;

        if (bindData.Right>0 && bindData.Period<=3)    //复权(日线数据才复权)
        {
            var rightData=bindData.GetRightData(bindData.Right,{ AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        //绑定数据
        this.UpdateMainData(bindData,lastDataCount);
        this.BindInstructionIndexData(bindData);    //执行指示脚本
        
        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        var page=this.Page.Day;
        ++page.Index;

        if (page.Enable==true && page.Finish==true)  //分页下载 这些数据迁移到分页下载完以后下载
        {
            this.RequestFlowCapitalData();          //请求流通股本数据 (主数据下载完再下载)
            this.RequestOverlayHistoryData();       //请求叠加数据 (主数据下载完再下载)
            this.CreateChartDrawPictureByStorage(); //创建画图工具
        }

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex();   //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    this.RequestHistoryMinuteData=function()
    {
        var self=this;
        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
        this.ChartSplashPaint.EnableSplash(true);
        this.FlowCapitalReady=false;
        this.ResetPage(); //重置分页
        this.ResetDragDownload();
        this.ResetZoomDownload();
        this.Draw();

        if (this.NetworkFilter)
        {
            var kLineDrawType=this.GetKLineDrawType();
            var obj=
            {
                Name:'KLineChartContainer::ReqeustHistoryMinuteData', //类名::
                Explain:'1分钟K线数据',
                Request:{ Url:self.MinuteKLineApiUrl,  Type:'POST',
                    Data: 
                    { 
                        symbol:self.Symbol, count:self.MaxRequestMinuteDayCount, 
                        field: ["name","symbol", "yclose","open","price","high","low","vol"],
                        period:this.Period, right:this.Right, klineDrawType:kLineDrawType
                    }  
                }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvMinuteHistoryData(data);
                var page=self.Page.Minute;
                if (page.Enable==true && page.Finish==false)
                {
                    self.ReqeustHistoryMinutePageData();
                }
                else
                {
                    self.AutoUpdateEvent(true,'KLineChartContainer::ReqeustHistoryMinuteData');
                    self.AutoUpdate();
                }
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: this.MinuteKLineApiUrl,
            data:
            {
                "field": ["name","symbol", "yclose","open","price","high","low","vol"],
                "symbol": self.Symbol,
                "start": -1,
                "count": self.MaxRequestMinuteDayCount
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvMinuteHistoryData(data);
                var page=self.Page.Minute;
                if (page.Enable==true && page.Finish==false)
                {
                    self.ReqeustHistoryMinutePageData();
                }
                else 
                {
                    self.AutoUpdateEvent(true,'KLineChartContainer::ReqeustHistoryMinuteData');
                    self.AutoUpdate();
                }
            }
        });
    }

    //支持老版本
    this.ReqeustHistoryMinuteData=this.RequestHistoryMinuteData;

    this.RecvMinuteHistoryData=function(data)
    {
        if (this.EnableVerifyRecvData && data.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[KLineChartContainer::RecvMinuteHistoryData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        var aryDayData=KLineChartContainer.JsonDataToMinuteHistoryData(data);
        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=aryDayData;
        sourceData.DataType=1;      //0=日线数据 1=分钟数据
        sourceData.Symbol=data.symbol;
        this.SourceData=sourceData;
        if (this.BeforeBindMainData) this.BeforeBindMainData("RecvMinuteHistoryData");

        //显示的数据
        var bindData=new ChartData();
        bindData.Data=aryDayData;
        bindData.Right=this.Right;
        bindData.Period=this.Period;
        bindData.DataType=1; 
        bindData.Symbol=data.symbol;

        if (bindData.Right>0 && !this.IsApiPeriod && this.RightFormula>=1)    //复权
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula } );
            bindData.Data=rightData;
        }

        if (ChartData.IsMinutePeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:"RecvMinuteHistoryData" });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        //绑定数据
        this.Symbol=data.symbol;
        this.Name=data.name;

        var chartOperator=null; //额外的图形控制
        if (data && data.ChartOperator)
        {
            var item=data.ChartOperator;
            chartOperator={ };
            if (item.IsShowAll===true) chartOperator.IsShowAll=true; //全部显示
        }
        
        this.BindMainData(bindData,this.PageSize,chartOperator);
        if (this.AfterBindMainData) this.AfterBindMainData("RecvMinuteHistoryData");
        this.Frame.SetSizeChage(true);
        
        var firstSubFrame;
        if (this.Frame.SubFrame[0]) firstSubFrame=this.Frame.SubFrame[0].Frame;
        if (firstSubFrame && firstSubFrame.YSplitOperator)
        {
            firstSubFrame.YSplitOperator.Symbol=this.Symbol;
            firstSubFrame.YSplitOperator.Data=this.ChartPaint[0].Data;         //K线数据
            firstSubFrame.YSplitOperator.Period=this.Period;                    //周期
        }

        for(var i in this.OverlayChartPaint)    //分钟数据不支持叠加 清空
        {
            var item=this.OverlayChartPaint[i];
            item.Data=null;
            //item.Status=OVERLAY_STATUS_ID.STATUS_NONE_ID;
        }

        var page=this.Page.Minute;
        if (page.Enable==false || (page.Enable==true && page.Finish==true) )
        {
            this.ReqeustKLineInfoData({ FunctionName:"RecvMinuteHistoryData" });            //请求信息地雷
            this.RequestFlowCapitalData();              //请求流通股本数据 (主数据下载完再下载)
            this.RequestOverlayHistoryMinuteData();     //请求叠加数据 (主数据下载完再下载)
            this.CreateChartDrawPictureByStorage();     //创建画图工具
        }

        if (page.Enable) ++page.Index;

        this.BindInstructionIndexData(bindData);        //执行指示脚本
        for(var i=0; i<this.Frame.SubFrame.length; ++i) //执行指标
        {
            this.BindIndexData(i,bindData);
        }

        this.BindAllOverlayIndexData(bindData, { SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex(2);  //切换周期了取消十字光标
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
        
        //叠加指标
        this.BindAllOverlayIndexData(bindData, { SyncExecute:false } );  //异步模式叠加指标

        if (this.mapEvent.has(JSCHART_EVENT_ID.RECV_HISTROY_DATA))
        {
            var event=this.mapEvent.get(JSCHART_EVENT_ID.RECV_HISTROY_DATA);
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
        }
    }

    this.ReqeustHistoryMinutePageData=function()
    {
        var self=this;
        if (this.NetworkFilter)
        {
            var firstItem=this.SourceData.Data[0];   //最新的一条数据
            var obj=
            {
                Name:'KLineChartContainer::RecvHistoryMinutePageData', //类名::
                Explain:'1分钟K线数据分页',
                Request:{ Url:'none',  Type:'POST' ,
                    Data: { symbol:self.Symbol, index:self.Page.Minute.Index, field: ["name","symbol","yclose","open","price","high","low","vol"], firstDate:firstItem.Date, first:{ date: firstItem.Date, time:firstItem.Time } } }, 
                Page:self.Page.Minute,
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.RecvHistoryMinutePageData(data);
                var page=self.Page.Minute;
                if (page.Enable==true && page.Finish==false)
                    self.ReqeustHistoryMinutePageData();  //继续下载
                else
                    self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        //模拟异步请求
        setTimeout(function()
        {
            var page=self.Page.Minute;
            page.Finish=true;
            var data= //测试数据
            { 
                data: 
                [
                    [ 20190906,14.58,14.71,14.71,14.71,14.71,1096425,16128411,925],
                    [ 20190906,14.71,14.73,14.74,14.71,14.71,2154859,31731820,930],
                    [ 20190906,14.71,14.71,14.71,14.68,14.69,1427516,20989208,931],
                    [ 20190906,14.69,14.69,14.71,14.68,14.7, 1680503,24694143,932],
                    [ 20190906,14.7,14.69,14.7,14.65,14.65,1315900,19310964,933],
                    [ 20190906,14.65,14.66,14.69,14.65,14.68,702955,10313842,934],
                    [ 20190906,14.68,14.7,14.71,14.67, 14.67,1735266,25495875,935],
                    [ 20190906,14.67,14.68,14.7,14.67,14.67,739000,10845398,936],
                    [ 20190906,14.67,14.67,14.68,14.67,14.68,389800,5721266,937],
                    [ 20190906,14.68,14.68,14.7,14.68,14.69,648477,9527859,938],
                    [ 20190906,14.69,14.7,14.71,14.69,14.7,1128400,16589794,939],
                    [ 20190906,14.7,14.7,14.71,14.69,14.71,714858,10509708,940],
                    [ 20190906,14.71,14.71,14.71,14.69,14.69,401500,5900477,941],
                    [ 20190906,14.69,14.69,14.71,14.69,14.69,1165684,17131034,942],
                    [ 20190906,14.69, 14.69,14.7,14.67,14.67,498516, 7321024,943],
                    [ 20190906,14.67,14.68,14.68,14.67,14.67,350126,5139012,944],
                    [ 20190906,14.67,14.67,14.69,14.67,14.69,561600,8246789,945]
                ],
                //symbol:'600000.sh',
                //name:'浦发行情'
            };
    
            self.RecvHistoryMinutePageData(data);
            if (page.Enable==true && page.Finish==false)
                self.ReqeustHistoryMinutePageData();
            else
                self.AutoUpdate();

        },500)
    }

    this.RecvHistoryMinutePageData=function(data)
    {
        if (this.EnableVerifyRecvData && data.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[KLineChartContainer::RecvHistoryMinutePageData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        var aryDayData=KLineChartContainer.JsonDataToMinuteHistoryData(data);
        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数

        for(var i in aryDayData)    //数据往前插
        {
            var item=aryDayData[i];
            this.SourceData.Data.splice(i,0,item);
        }

        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;

        if (bindData.Right>0 && ChartData.IsDayPeriod(bindData.Period,false))    //复权(日线数据才复权)
        {
            var rightData=bindData.GetRightData(bindData.Right,{ AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        //绑定数据
        this.UpdateMainData(bindData,lastDataCount);
        this.BindInstructionIndexData(bindData);    //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        var page=this.Page.Minute;
        if (page.Enable==false || (page.Enable==true && page.Finish==true) )
        {
            this.RequestFlowCapitalData();          //请求流通股本数据 (主数据下载完再下载)
            this.CreateChartDrawPictureByStorage(); //创建画图工具
        }

        if (page.Enable) ++page.Index;

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex();   //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    //请求实时行情数据
    this.RequestRealtimeData=function()
    {
        var self=this;
        var arySymbol=[self.Symbol];
        for(var i in this.OverlayChartPaint)    //叠加的股票更新
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Symbol) continue;
            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;
            arySymbol.push(item.Symbol);
        }

        if (this.NetworkFilter)
        {
            var kLineDrawType=this.GetKLineDrawType();
            var obj=
            {
                Name:'KLineChartContainer::RequestRealtimeData', //类名::函数名
                Explain:'当天最新日线数据',
                Request:
                { 
                    Url:self.RealtimeApiUrl, 
                    Data:
                    { 
                        symbol: arySymbol, 
                        field:["name","symbol","yclose","open","price","high","low","vol","amount","date","time"],
                        period:this.Period, right:this.Right, klineDrawType:kLineDrawType
                    }, 
                    Type:'POST' 
                }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.RecvRealtimeData(data);
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: this.RealtimeApiUrl,
            data:
            {
                "field": ["name","symbol","yclose","open","price","high","low","vol","amount","date","time"],
                "symbol": arySymbol,
                "start": -1
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.RecvRealtimeData(data);
                self.AutoUpdate();
            }
        });
    }

    this.RecvRealtimeData=function(data)
    {
        if (this.IsOnTouch==true) return;   //正在操作中不更新数据
        var realtimeData=KLineChartContainer.JsonDataToRealtimeData(data,this.Symbol);
        if (!realtimeData) return;

        var item=this.SourceData.Data[this.SourceData.Data.length-1];   //最新的一条数据
        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数

        if (this.SourceData.Data.length==0) //第1条数据
        {
            var newItem =new HistoryData();
            HistoryData.CopyTo(newItem,realtimeData);
            this.SourceData.Data.push(newItem);
        }
        else if (item.Date==realtimeData.Date)   //实时行情数据更新
        {
            JSConsole.Chart.Log('[KLineChartContainer::RecvRealtimeData] update kline by realtime data',realtimeData);
            HistoryData.CopyTo(item,realtimeData);
        }
        else if (item.Date<realtimeData.Date)   //新增加数据
        {
            JSConsole.Chart.Log('[KLineChartContainer::RecvRealtimeData] insert kline by realtime data',realtimeData);
            
            var newItem =new HistoryData();
            HistoryData.CopyTo(newItem,realtimeData);

            if (!IFrameSplitOperator.IsNumber(newItem.YClose) && this.SourceData.Data.length>0)
                newItem.YClose=this.SourceData.Data[this.SourceData.Data.length-1].YClose;

            this.SourceData.Data.push(newItem);
        }
        else
        {
            var bFind=false;
            var aryKData=this.SourceData.Data;
            for(var i=aryKData.length-1;i>=0; --i)
            {
                var kItem=aryKData[i];
                if (kItem.Date==realtimeData.Date)
                {
                    HistoryData.CopyTo(kItem,realtimeData);
                    bFind=true;
                    break;
                }
            }

            if (!bFind) return;
        }
        
        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;
        bindData.Symbol=this.Symbol;

        if (bindData.Right>0 && ChartData.IsDayPeriod(bindData.Period,true) && MARKET_SUFFIX_NAME.IsSHSZStockA(this.Symbol) && !this.IsApiPeriod)    //复权(A股日线数据才复权)
        {
            var rightData=bindData.GetRightData(bindData.Right,{ AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if (!this.IsApiPeriod)
        {
            if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据 (0= 日线,4=1分钟线 不需要处理)
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:"RecvRealtimeData" });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        this.UpdateMainData(bindData,lastDataCount);//更新主图数据
        this.UpdateOverlayRealtimeData(data);       //更新叠加股票数据
        this.BindInstructionIndexData(bindData);    //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData, { CheckRunCount:true });
        }

        this.BindAllOverlayIndexData(bindData, {  CheckRunCount:true, SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex(1);  //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        this.SendKLineUpdateEvent(bindData);    
        this.UpdateDOMTooltip(0, bindData);

        //叠加指标计算
        this.BindAllOverlayIndexData(bindData, { CheckRunCount:true,SyncExecute:false });     //异步模式叠加指标

        if (this.mapEvent.has(JSCHART_EVENT_ID.ON_RECV_REALTIME_DATA))
        {
            var event=this.mapEvent.get(JSCHART_EVENT_ID.ON_RECV_REALTIME_DATA);
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
        }
    }

    this.UpdateOverlayRealtimeData=function(data)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint)) return;

        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Symbol) continue;
            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;
            var realtimeData=KLineChartContainer.JsonDataToRealtimeData(data,item.Symbol);  //获取叠加股票的最新数据
            if (!realtimeData) continue;
            var sourceData=item.SourceData; //叠加股票的所有数据
            var latestData=sourceData.Data[sourceData.Data.length-1];   //最新的一条数据

            if (latestData.Date==realtimeData.Date)   //实时行情数据更新
            {
                JSConsole.Chart.Log('[KLineChartContainer::UpdateOverlayRealtimeData] update kline by minute data',realtimeData);

                latestData.Close=realtimeData.Close;
                latestData.High=realtimeData.High;
                latestData.Low=realtimeData.Low;
                latestData.Vol=realtimeData.Vol;
                latestData.Amount=realtimeData.Amount;
            }
            else if (item.Date<realtimeData.Date)   //新增加数据
            {
                JSConsole.Chart.Log('[KLineChartContainer::UpdateOverlayRealtimeData] insert kline by minute data',realtimeData);

                var newItem =new HistoryData();
                newItem.YClose=realtimeData.YClose;
                newItem.Open=realtimeData.Open;
                newItem.Close=realtimeData.Close;
                newItem.High=realtimeData.High;
                newItem.Low=realtimeData.Low;
                newItem.Vol=realtimeData.Vol;
                newItem.Amount=realtimeData.Amount;
                newItem.Date=realtimeData.Date;
                sourceData.Data.push(newItem);
            }
            else 
            {
                continue;
            }

            var bindData=new ChartData();
            bindData.Data=sourceData.Data;
            bindData.Period=this.Period;
            bindData.Right=this.Right;
            bindData.DataType=0;

            if (bindData.Right>0 && MARKET_SUFFIX_NAME.IsSHSZStockA(data.symbol) && !this.IsApiPeriod)    //复权数据 ,A股才有有复权
            {
                var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                bindData.Data=rightData;
            }

            var aryOverlayData=this.SourceData.GetOverlayData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
            bindData.Data=aryOverlayData;

            if (ChartData.IsDayPeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }

            item.Data=bindData;
        }
    }

    this.RequestMinuteRealtimeData=function()
    {
        var self=this;
        var arySymbol=[self.Symbol];
        for(var i in this.OverlayChartPaint)    //叠加的股票更新
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Symbol) continue;
            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;
            arySymbol.push(item.Symbol);
        }

        if (this.NetworkFilter)
        {
            var kLineDrawType=this.GetKLineDrawType();
            var obj=
            {
                Name:'KLineChartContainer::RequestMinuteRealtimeData', //类名::
                Explain:'当天1分钟K线数据',
                Request:
                { 
                    Url:self.RealtimeApiUrl, 
                    Data:
                    { 
                        symbol: arySymbol, 
                        field:["name","symbol","price","yclose","minutecount","minute","date","time"],
                        period:this.Period, right:this.Right, klineDrawType:kLineDrawType
                    }, 
                    Type:'POST' 
                }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.RecvMinuteRealtimeData(data);
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: this.RealtimeApiUrl,
            data:
            {
                "field": ["name","symbol","price","yclose","minutecount","minute","date","time"],
                "symbol": arySymbol,
                "start": -1
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.RecvMinuteRealtimeData(data);
                self.AutoUpdate();
            }
        });
    }

    this.SetSourceDatatLimit=function(aryLimit)
    {
        this.SourceDataLimit=new Map();
        for(var i in aryLimit)
        {
            var item=aryLimit[i];
            this.SourceDataLimit.set(item.Period, item.MaxCount); //每个周期缓存数据最大个数 key=周期 value=最大个数 
            
            JSConsole.Chart.Log(`[KLineChartContainer::SetSourceDatatLimit] Period=${item.Period}, MaxCount=${item.MaxCount}`);
        }
    }       

    this.ReduceSourceData=function()
    {
        if (!this.SourceDataLimit) return;
        if (!this.SourceDataLimit.has(this.Period)) return;

        var limitCount=this.SourceDataLimit.get(this.Period);

        var frameHisdata=null;
        if (!this.Frame.Data) frameHisdata=this.Frame.Data;
        else if (this.Frame.SubFrame && this.Frame.SubFrame[0]) frameHisdata=this.Frame.SubFrame[0].Frame.Data;
        if (!frameHisdata) return;

        if (limitCount<50) return;
        var dataOffset=frameHisdata.DataOffset;
        var removeCount=0;
        while(this.SourceData.Data.length>limitCount)
        {
            this.SourceData.Data.shift();
            --dataOffset;
            ++removeCount;
        }

        if (removeCount>0)
        {
            if (dataOffset<0) dataOffset=0;
            frameHisdata.DataOffset=dataOffset;
            JSConsole.Chart.Log(`[KLineChartContainer::ReduceSourceData] remove data ${removeCount}, dataOffset=${dataOffset}`);
        }
    }

    this.RecvMinuteRealtimeDataV2=function(data)    //新版本的
    {
        if (this.IsOnTouch==true) return;   //正在操作中不更新数据
        if (this.EnableVerifyRecvData && data.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[KLineChartContainer::RecvMinuteRealtimeDataV2] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.symbol}]`);
            return;
        }
        var aryMinuteData=KLineChartContainer.JsonDataToMinuteHistoryData(data);
        if (!aryMinuteData || aryMinuteData.length<=0) return;
        if (this.IsApiPeriod) this.ReduceSourceData();  //减少数据
        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数
        if (!this.SourceData) return;
        if (!this.SourceData.MergeMinuteData(aryMinuteData)) return;

        JSConsole.Chart.Log(`[KLineChartContainer::RecvMinuteRealtimeDataV2] update kline by 1 minute data [${lastDataCount}->${this.SourceData.Data.length}], IsAutoSyncDataOffset=${this.IsAutoSyncDataOffset}`);

        if (this.IsAutoSyncDataOffset===false)  lastDataCount=null; //维持当前的屏位置

        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;
        bindData.Symbol=this.Symbol;


        if (bindData.Right>0 && !this.IsApiPeriod && this.RightFormula>=1)    //复权  复权系数
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if ((ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false)) && !this.IsApiPeriod)   //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:"RecvMinuteRealtimeDataV2" });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        //绑定数据
        this.UpdateMainData(bindData,lastDataCount);
        this.UpdateOverlayMinuteRealtimeData(data);     //更新叠加股票数据
        this.BindInstructionIndexData(bindData);        //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        this.BindAllOverlayIndexData(bindData, {  CheckRunCount:true, SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex(1);  //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        this.SendKLineUpdateEvent(bindData);
        this.UpdateDOMTooltip(0, bindData);

        //更新叠加指标
        this.BindAllOverlayIndexData(bindData, { CheckRunCount:true,SyncExecute:false });     //异步模式叠加指标

        if (this.mapEvent.has(JSCHART_EVENT_ID.ON_RECV_REALTIME_DATA))
        {
            var event=this.mapEvent.get(JSCHART_EVENT_ID.ON_RECV_REALTIME_DATA);
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
        }
    }

    this.RecvMinuteRealtimeData=function(data)
    {
        if (this.IsOnTouch==true) return;   //正在操作中不更新数据

        if (data.ver==2.0) 
        {
            this.RecvMinuteRealtimeDataV2(data);
            return;
        }

        var realtimeData=KLineChartContainer.JsonDataToMinuteRealtimeData(data, this.Symbol);
        if (!realtimeData) return;
        if (this.IsApiPeriod) this.ReduceSourceData();  //减少数据
        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数
        var lastSourceDataCount=this.SourceData.Data.length;
        if (!this.SourceData.MergeMinuteData(realtimeData)) return;

        JSConsole.Chart.Log(`[KLineChartContainer::RecvMinuteRealtimeData] update kline by 1 minute data [${lastSourceDataCount}->${this.SourceData.Data.length}]`);

        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;
        bindData.Symbol=this.Symbol;

        if (bindData.Right>0 && !this.IsApiPeriod && this.RightFormula>=1)       //复权 复权系数
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if ( (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false)) && !this.IsApiPeriod)   //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:"RecvMinuteRealtimeData" });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        //绑定数据
        this.UpdateMainData(bindData,lastDataCount);
        this.UpdateOverlayMinuteRealtimeData(data);       //更新叠加股票数据
        this.BindInstructionIndexData(bindData);          //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        this.BindAllOverlayIndexData(bindData, { CheckRunCount:true, SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex(1);  //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        this.SendKLineUpdateEvent(bindData);

        //更新叠加指标
        this.BindAllOverlayIndexData(bindData, { CheckRunCount:true, SyncExecute:false });  //异步模式叠加指标
    }

    //更新当天的全量分钟数据
    this.UpdateOverlayMinuteRealtimeData=function(data) 
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Symbol) continue;
            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;
            if (data.ver==2.0) 
                var realtimeData=KLineChartContainer.JsonDataToMinuteRealtimeDataV2(data,item.Symbol);  //获取叠加股票的最新数据
            else 
                var realtimeData=KLineChartContainer.JsonDataToMinuteRealtimeData(data,item.Symbol);  //获取叠加股票的最新数据
            if (!realtimeData) continue;
            var sourceData=item.SourceData; //叠加股票的所有数据
            if (!sourceData.MergeMinuteData(realtimeData)) return;

            var bindData=new ChartData();
            bindData.Data=sourceData.Data;
            bindData.Period=this.Period;
            bindData.Right=this.Right;
            bindData.DataType=0;

            var aryOverlayData=this.SourceData.GetOverlayMinuteData(bindData.Data,this.IsApiPeriod);      //和主图数据拟合以后的数据
            bindData.Data=aryOverlayData;

            if (ChartData.IsMinutePeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }

            item.Data=bindData;
        }
    }

    this.GetHistoryDataCount=function()
    {
        var frameHisdata=null;
        if (!this.Frame.Data) frameHisdata=this.Frame.Data;
        else if (this.Frame.SubFrame && this.Frame.SubFrame[0]) frameHisdata=this.Frame.SubFrame[0].Frame.Data;
        if (!frameHisdata) return -1;
        var lastDataCount=frameHisdata.Data.length;  //上一个的数据长度
        return lastDataCount;
    }

    this.GetRequestDataCount=function() //K线请求数据个数　(由于可以拖拽下载历史数据,所有原来固定个数的就不能用了)
    {
        var result={MaxRequestDataCount:this.MaxRequestDataCount, MaxRequestMinuteDayCount:this.MaxRequestMinuteDayCount };
        
        if (!this.SourceData || !this.SourceData.Data || this.SourceData.Data.length<=0) return result;

        if (ChartData.IsDayPeriod(this.Period,true))
        {
            var lCount=this.SourceData.Data.length;
            if (lCount>result.MaxRequestDataCount) result.MaxRequestDataCount=lCount;
        }
        else if (ChartData.IsMinutePeriod(this.Period,true))
        {
            var date;
            var lCount=0;
            for(var i in this.SourceData.Data)
            {
                var item=this.SourceData.Data[i];
                if (item.Date!=date) ++lCount;
                date=item.Date;
            }
            if (lCount>result.MaxRequestMinuteDayCount) result.MaxRequestMinuteDayCount=lCount;
        }

        return result;
    }

    //分笔数据
    this.RequestTickData=function()
    {
        var self=this;
        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
        self.ChartSplashPaint.EnableSplash(true);
        self.Draw();
        
        //下载缓存文件
        var cacheUrl=g_JSChartResource.CacheDomain+'/cache/dealday/today/'+self.Symbol+'.json'
        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'KLineChartContainer::RequestTickData', //类名::
                Explain:'当天分笔数据',
                Request:{ Url:cacheUrl, Data:{ symbol: self.Symbol }, Type:'GET' }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvTickData(data);
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: cacheUrl,
            data:{"symbol":self.Symbol},
            type:"get",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvTickData(data);
                self.AutoUpdate(1);
            },
            error: function(http,e)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.AutoUpdate();
                //self.RecvError(http,e,param);;
            }
        });
       
    }

    this.RecvTickData=function(data)
    {
        if (data.ver==2.0) 
            var aryDayData=KLineChartContainer.JsonDataToTickDataV2(data);
        else
            var aryDayData=KLineChartContainer.JsonDataToTickData(data);

        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=aryDayData;
        sourceData.DataType=2;      //0=日线数据 1=分钟数据 2=分笔数据
        this.SourceData=sourceData;
        if (this.BeforeBindMainData) this.BeforeBindMainData("RecvTickData");

        //显示的数据
        var bindData=new ChartData();
        bindData.Data=aryDayData;
        bindData.Right=this.Right;
        bindData.Period=this.Period;
        bindData.DataType=2;

        //绑定数据
        
        this.Symbol=data.symbol;
        this.Name=data.name;
        this.BindMainData(bindData,this.PageSize);
        if (this.AfterBindMainData) this.AfterBindMainData("RecvTickData");

        this.BindInstructionIndexData(bindData);    //执行指示脚本

        var firstSubFrame;
        for(var i=0; i<this.Frame.SubFrame.length; ++i) //执行指标
        {
            if (i==0) firstSubFrame=this.Frame.SubFrame[i].Frame;
            this.BindIndexData(i,bindData);
        }

        if (firstSubFrame && firstSubFrame.YSplitOperator)
        {
            firstSubFrame.YSplitOperator.Symbol=this.Symbol;
            firstSubFrame.YSplitOperator.Data=this.ChartPaint[0].Data;         //K线数据
            firstSubFrame.YSplitOperator.Period=this.Period;                   //周期
            firstSubFrame.YSplitOperator.KLineChart=this.ChartPaint[0];        //绑定K线图形
        }

        //this.CreateChartDrawPictureByStorage(); //创建画图工具

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
        this.UpdatePointByCursorIndex();   //更新十字光标位子

        //叠加指标
        this.BindAllOverlayIndexData(bindData);

        if (this.mapEvent.has(JSCHART_EVENT_ID.RECV_HISTROY_DATA))
        {
            var event=this.mapEvent.get(JSCHART_EVENT_ID.RECV_HISTROY_DATA);
            var data={ HistoryData:bindData, Stock:{Symbol:this.Symbol, Name:this.Name } }
            event.Callback(event,data,this);
        }
    }

    //请求最新的分笔数据
    this.RequestTickRealtimeData=function()
    {
        var self=this;
        var start=0;
        if (this.SourceData && this.SourceData.Data) start=this.SourceData.Data.length;
        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'KLineChartContainer::RequestTickRealtimeData', //类名::
                Explain:'当天最新分笔数据',
                Request:{ Url:self.TickApiUrl, Data:{ symbol: self.Symbol, start:start, end:start+1000 }, Type:'POST' }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvTickRealtimeData(data);
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: self.TickApiUrl,
            data:{"symbol":self.Symbol, start:start-10, end:start+1000 },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvTickRealtimeData(data);
                self.AutoUpdate();
            }
        });
    }

    this.RecvTickRealtimeData=function(data)
    {
        if (data.ver==2.0)
            var aryDayData=KLineChartContainer.JsonDataToTickDataV2(data);    //增量数据
        else
            var aryDayData=KLineChartContainer.JsonDataToTickData(data);    //增量数据
        if (!aryDayData || aryDayData.length<=0) return;

        var redraw=false;   //强制重绘
        if (data.redraw==true) redraw=true;
        //更新原始数据
        var source=this.SourceData.Data;
        var lastDataCount=this.SourceData.Data.length;  //上一个的数据长度
        var lastTime=0;
        if (source.length>0) lastTime=source[source.length-1].Time;
        var newCount=0;
        for(var i in aryDayData)
        {
            var item=aryDayData[i];
            if (item.Time<=lastTime) continue;
            source.push(item);
            ++newCount;
        }
        if (newCount<=0 && redraw==false) return;

        //显示的数据
        var bindData=new ChartData();
        bindData.Data=source;
        bindData.Right=this.Right;
        bindData.Period=this.Period;
        bindData.DataType=2;

        //绑定数据
        this.Symbol=data.symbol;
        this.Name=data.name;
        this.UpdateMainData(bindData,lastDataCount);
        this.BindInstructionIndexData(bindData);    //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }
        
        //this.CreateChartDrawPictureByStorage(); //创建画图工具

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
        this.UpdatePointByCursorIndex();   //更新十字光标位子

        //更新叠加指标
        this.BindAllOverlayIndexData(bindData);
    }


    this.ClearIndexPaint=function()
    {
        //清空指标
        if (this.Frame && this.Frame.SubFrame)
        {
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                this.DeleteIndexPaint(i, true);
                var item=this.Frame.SubFrame[i];
                if (IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex))
                {
                    for(var j=0; j<item.OverlayIndex.length; ++j ) //清空叠加指标
                    {
                        var overlayItem=item.OverlayIndex[j];
                        for(var k=0;k< overlayItem.ChartPaint.length;++k)
                        {
                            var overlayChart=overlayItem.ChartPaint[k];
                            if (overlayChart && overlayChart.OnDestroy) overlayChart.OnDestroy();
                        }
                        overlayItem.ChartPaint=[];
                    }
                }
            }
        }

        //清空叠加标题
        for(var i=1;i<this.TitlePaint.length;++i)
        {
            var item=this.TitlePaint[i];
            item.OverlayIndex=new Map();
        }
    }

    //周期切换
    this.ChangePeriod=function(period,option)
    {
        var oldData={ Period:this.Period, Right:this.Right, KLineDrawType:this.KLineDrawType };

        var isChangeKLineDrawType=false;
        var isReload=false; //是否重新请求数据
        var right=null; //复权
        if (option)
        {
            if (option.KLine)
            {
                if (IFrameSplitOperator.IsNumber(option.KLine.DrawType)) isChangeKLineDrawType=true;
                if (IFrameSplitOperator.IsNumber(option.KLine.Right)) right=option.KLine.Right;
            }

            if (option.Reload==true) isReload=true;
        };

        if (this.Period==period && isReload==false) 
        {
            if (isChangeKLineDrawType) this.ChangeKLineDrawType(option.KLine.DrawType);
            return;
        }

        if (isChangeKLineDrawType) this.ChangeKLineDrawType(option.KLine.DrawType,false);   //切换K线类型, 不重绘

        var isDataTypeChange=true;
        if (this.SourceData)
        {
            var isDataTypeChange=false;
            if (period>CUSTOM_DAY_PERIOD_START && period<=CUSTOM_DAY_PERIOD_END)
            {
                if (this.SourceData.DataType!=0) isDataTypeChange=true;
            }
            else if ((period>CUSTOM_MINUTE_PERIOD_START && period<=CUSTOM_MINUTE_PERIOD_END) || 
                        (period>CUSTOM_SECOND_PERIOD_START && period<=CUSTOM_SECOND_PERIOD_END) || 
                        (period>CUSTOM_MILLISECOND_PERIOD_START && period<=CUSTOM_MILLISECOND_PERIOD_END) )
            {
                if (this.SourceData.DataType!=1) isDataTypeChange=true;
                else if (ChartData.IsSecondPeriod(period)) isDataTypeChange=true;
                else if (ChartData.IsMilliSecondPeriod(period)) isDataTypeChange=true;
            }
            else
            {
                switch(period)
                {
                    case 0:     //日线
                    case 1:     //周
                    case 2:     //月
                    case 3:     //年
                    case 9:     //季线
                    case 21:    //双周
                        if (this.SourceData.DataType!=0) isDataTypeChange=true;
                        break;
                    case 4:     //1分钟
                    case 5:     //5分钟
                    case 6:     //15分钟
                    case 7:     //30分钟
                    case 8:     //60分钟
                    case 11:    //2小时
                    case 12:    //4小时
                        if (this.SourceData.DataType!=1) isDataTypeChange=true;
                        break;
                    case 10:    //分笔线
                        if (this.SourceData.DataType!=2) isDataTypeChange=true;
                        break;
                }
            }
        }

       
       
        this.Period=period;
        if (right!=null) this.Right=right;
        this.ReloadChartDrawPicture();   //切换周期了 清空画图工具
        this.ClearRectSelect(true);
        this.Frame.ClearUpDonwFrameYData();
        this.ClearCustomKLine();
        this.ClearKLineCaluate();
       

        var kLineDrawType=this.GetKLineDrawType();
        if (kLineDrawType==10 || kLineDrawType==11 || kLineDrawType==12 || kLineDrawType==16) isDataTypeChange=true;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CHANGE_KLINE_PERIOD);
        if (event && event.Callback)
        {
            var sendData=
            { 
                IsApiPeriod:this.IsApiPeriod, 
                Old:oldData, 
                Now:{ Period:this.Period, Right:this.Right, KLineDrawType:this.KLineDrawType }, 
                IsDataTypeChange:isDataTypeChange,  //数据类型是否改变  true 重新请求数据
            }
            event.Callback(event, sendData, this);
            
            isDataTypeChange=sendData.IsDataTypeChange;
        }

        if (isDataTypeChange==false && !this.IsApiPeriod)
        {
            this.ClearIndexRunCount();
            this.Update( {UpdateCursorIndexType:2} ); //更新的时候 取消显示十字光标
            return;
        }

        this.ClearIndexPaint();

        if (ChartData.IsDayPeriod(this.Period,true))
        {
            this.CancelAutoUpdate();                    //先停止定时器
            this.AutoUpdateEvent(false,'KLineChartContainer::ChangePeriod');                //切换周期先停止更新
            this.ResetScrollBar();
            this.ResetOverlaySymbolStatus();
            this.ClearIndexRunCount();
            this.Frame.ClearYCoordinateMaxMin();
            this.RequestHistoryData();                  //请求日线数据
            //this.ReqeustKLineInfoData();
        }
        else if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period) || ChartData.IsMilliSecondPeriod(this.Period))
        {
            this.CancelAutoUpdate();                    //先停止定时器
            this.AutoUpdateEvent(false,'KLineChartContainer::ChangePeriod');                //切换周期先停止更新
            this.ResetScrollBar();
            this.ResetOverlaySymbolStatus();
            this.ClearIndexRunCount();
            this.Frame.ClearYCoordinateMaxMin();
            this.RequestHistoryMinuteData();            //请求分钟数据
        }  
        else if (ChartData.IsTickPeriod(this.Period))
        {
            this.CancelAutoUpdate();                    //先停止定时器
            this.AutoUpdateEvent(false,'KLineChartContainer::ChangePeriod');
            this.ResetScrollBar();
            this.ClearIndexRunCount();
            this.Frame.ClearYCoordinateMaxMin();
            this.RequestTickData();                     //请求分笔数据
        }
    }

    //复权切换
    this.ChangeRight=function(right)
    {
        if (!MARKET_SUFFIX_NAME.IsEnableRight(this.Period,this.Symbol, this.RightFormula)) return;

        var upperSymbol=this.Symbol.toUpperCase();
        if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol)) return;

        if (right<0 || right>2) return;

        if (this.Right==right) return;

        this.Right=right;

        if (!this.IsApiPeriod)
        {
            this.Update();
            return;
        }
        else    //API周期数据 重新请求数据
        {
            if (ChartData.IsDayPeriod(this.Period,true))
            {
                this.CancelAutoUpdate();                    //先停止定时器
                this.AutoUpdateEvent(false,'KLineChartContainer::ChangeRight');                //切换复权先停止更新
                this.ClearIndexPaint();
                this.ResetOverlaySymbolStatus();
                this.ResetScrollBar();
                this.RequestHistoryData();                  //请求日线数据
            }
            else if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period) || ChartData.IsMilliSecondPeriod(this.Period))
            {
                this.CancelAutoUpdate();                    //先停止定时器
                this.AutoUpdateEvent(false,'KLineChartContainer::ChangeRight');                //切换复权先停止更新
                this.ClearIndexPaint();
                this.ResetOverlaySymbolStatus();
                this.ResetScrollBar();
                this.RequestHistoryMinuteData();            //请求分钟数据
            }  
        }
    }

    //设置第1屏的起始日期
    this.SetFirstShowDate=function(obj)
    {
        if (!obj || !obj.Date) return;

        var option={ ID:JSCHART_OPERATOR_ID.OP_GOTO, Date:obj.Date };
        if (IFrameSplitOperator.IsNumber(obj.Time)) option.Time=obj.Time;
        if (IFrameSplitOperator.IsNumber(obj.PageSize)) option.PageSize=obj.PageSize;

        this.ChartOperator(option);
    }

    //删除某一个窗口的指标, bCallDestory=是否调用图形销毁函数
    this.DeleteIndexPaint=function(windowIndex, bCallDestroy)
    {
        if (!this.Frame.SubFrame[windowIndex]) return;
        var subFrame=this.Frame.SubFrame[windowIndex].Frame;
        if (!subFrame) return;

        var paint=[];  //踢出当前窗口的指标画法
        for(var i=0;i<this.ChartPaint.length; ++i)
        {
            var item=this.ChartPaint[i];
            var bFind=(item.ChartFrame.Guid==subFrame.Guid || item.ChartFrame==subFrame);

            if (i==0 || !bFind)
            {
                paint.push(item);
            }
            else
            {
                if (bCallDestroy===true)
                {
                    if (item && item.OnDestroy) item.OnDestroy();   //图形销毁
                }
            }
        }
        
        
        subFrame.YSpecificMaxMin=null;    //清空指定最大最小值
        subFrame.IsLocked=false;          //解除上锁
        subFrame.YSplitScale = null;      //清空固定刻度
        subFrame.YSplitOperator.SplitType=subFrame.YSplitOperator.DefaultSplitType;  //还原Y坐标分割模式

        this.ChartPaint=paint;

        //清空东条标题
        var titleIndex=windowIndex+1;
        this.TitlePaint[titleIndex].Data=[];
        this.TitlePaint[titleIndex].Title=null;
    }

    //显示隐藏主图K线
    this.ShowKLine=function(isShow)
    {
        if (this.ChartPaint.length<=0 || !this.ChartPaint[0]) return;
        this.ChartPaint[0].IsShow=isShow;
    }

    this.SetInstructionData=function(type,instructionData)
    {
        if (this.ChartPaint.length<=0 || !this.ChartPaint[0]) return;

        var title=this.TitlePaint[1];
        if (type==2) //五彩K线
        {
            this.ChartPaint[0].ColorData=instructionData.Data;
            if (title) title.ColorIndex={Name:instructionData.Name, Param:instructionData.Param };
        }
        else if (type==1)   //专家指示
        {
            this.ChartPaint[0].TradeData={Sell:instructionData.Sell, Buy:instructionData.Buy, Name:instructionData.Name, Param:instructionData.Param };
            if (title) title.TradeIndex={ Name:instructionData.Name, Param:instructionData.Param };
        }
    }

    this.ChangeInstructionIndex=function(indexName, option)
    {
        let scriptData = new JSIndexScript();
        let indexInfo = scriptData.Get(indexName);
        if (!indexInfo) return;
        if(indexInfo.InstructionType!=1 && indexInfo.InstructionType!=2) return;

        if (option)
        {
            if (option.Args) indexInfo.Args=option.Args;
        }

        indexInfo.ID=indexName;
        this.ChangeInstructionScriptIndex(indexInfo);
        
    }

    this.ChangeInstructionScriptIndex=function(indexData)
    {
        if (indexData.InstructionType==1)       //交易系统
        {
            this.TradeIndex=new ScriptIndex(indexData.Name,indexData.Script,indexData.Args,indexData);    //脚本执行
        }
        else if (indexData.InstructionType==2)  //五彩K线
        {
            this.ColorIndex=new ScriptIndex(indexData.Name,indexData.Script,indexData.Args,indexData);    //脚本执行
        }
        else
        {
            return;
        }

        var bindData=this.ChartPaint[0].Data;
        this.BindInstructionIndexData(bindData);

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.CancelInstructionIndex=function()  //取消指示数据
    {
        if (this.ChartPaint.length<=0 || !this.ChartPaint[0]) return;

        this.ColorIndex=null;
        this.TradeIndex=null;
        this.ChartPaint[0].ColorData=null;  //五彩K线数据取消掉
        this.ChartPaint[0].TradeData=null;  //交易系统数据取消

        var title=this.TitlePaint[1];
        if (title)
        {
            title.TradeIndex=null;
            title.ColorIndex=null;
        }

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.SetFrameToolbar=function(windowIndex,window)
    {
        if (!window || !this.Frame.SubFrame[windowIndex] || !this.Frame.SubFrame[windowIndex].Frame) return;

        var frame=this.Frame.SubFrame[windowIndex].Frame;
        var bChanged=false;
        if (IFrameSplitOperator.IsBool(window.Modify)) 
        {
            frame.ModifyIndex=window.Modify;
            bChanged=true;
        }

        if (IFrameSplitOperator.IsBool(window.Change)) 
        {
            frame.ChangeIndex=window.Change;
            bChanged=true;
        }

        if (IFrameSplitOperator.IsBool(window.Close)) 
        {
            frame.CloseIndex=window.Close;
            bChanged=true;
        }

        if (IFrameSplitOperator.IsBool(window.Overlay)) 
        {
            frame.OverlayIndex=window.Overlay;
            bChanged=true;
        }

        //工具栏变 先刷新工具栏
        if (bChanged)
        {
            frame.SizeChange=true;
            frame.ToolbarRect=null; //清空工具栏缓存
            frame.DrawToolbar();
        }
    }

    this.SetFrameAttribute=function(windowIndex, attr)
    {
        if (!window || !this.Frame.SubFrame[windowIndex] || !this.Frame.SubFrame[windowIndex].Frame) return;
        if (!attr) return;

        var frame=this.Frame.SubFrame[windowIndex].Frame;

        if (!IFrameSplitOperator.IsUndefined(attr.HorizontalReserved)) frame.HorizontalReserved=attr.HorizontalReserved;    //Y轴上下预留
        if (IFrameSplitOperator.IsNumber(attr.TitleHeight)) frame.ChartBorder.TitleHeight=attr.TitleHeight;                 //指标标题高度
    }

    this.ResetFrameAttribute=function(windowIndex)
    {
        if (!window || !this.Frame.SubFrame[windowIndex] || !this.Frame.SubFrame[windowIndex].Frame) return;
        var frame=this.Frame.SubFrame[windowIndex].Frame;

        frame.HorizontalReserved=null;
    }


    //切换成 脚本指标
    this.ChangeScriptIndex=function(windowIndex,indexData,option)
    {
        this.DeleteIndexPaint(windowIndex, true);
        this.WindowIndex[windowIndex]=new ScriptIndex(indexData.Name,indexData.Script,indexData.Args,indexData);    //脚本执行
        this.ResetFrameAttribute(windowIndex);
        this.Frame.ClearYCoordinateMaxMin(windowIndex);

        if (option)
        {
            if (option.Window) 
            {
                this.SetFrameToolbar(windowIndex,option.Window);
                this.SetFrameAttribute(windowIndex,option.Window);   //窗口属性
            }
        }

        this.OnChangeIndexEvent(windowIndex, { ID:indexData.ID, Name:indexData.Name, FunctionName:"ChangeScriptIndex" });

        this.Frame.ClearUpDonwFrameYData({ Index:windowIndex });
        var bindData=this.ChartPaint[0].Data;
        this.BindIndexData(windowIndex,bindData);   //执行脚本

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }


    this.OnKLinePageChange=function(eventid)
    {
        if (!this.ChartPaint[0]) return;

        var bindData=this.ChartPaint[0].Data;
        for(var i=0;i<this.WindowIndex.length;++i)
        {
            var item=this.WindowIndex[i];
            if (!item) continue;
            if (item.IsUsePageData===true) this.BindIndexData(i,bindData, { Type:1 });   //执行脚本
        }

        //叠加指标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem && overlayItem.Script && overlayItem.Script.IsUsePageData==true)
                    this.BindOverlayIndexData(overlayItem,i,bindData);
            }
        }
    }

    //切换api指标
    this.ChangeAPIIndex=function(windowIndex,indexData)
    {
        this.DeleteIndexPaint(windowIndex, true);
        //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
        var apiItem=indexData.API;
        this.WindowIndex[windowIndex]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,indexData);
        this.ResetFrameAttribute(windowIndex);
        this.Frame.ClearYCoordinateMaxMin(windowIndex);

        this.OnChangeIndexEvent(windowIndex, { ID:indexData.ID, Name:indexData.Name, FunctionName:"ChangeAPIIndex" });

        if (indexData)
        {
            if (indexData.Window) 
            {
                this.SetFrameToolbar(windowIndex,indexData.Window);
                this.SetFrameAttribute(windowIndex,indexData.Window);   //窗口属性
            }
        }
        
        this.Frame.ClearUpDonwFrameYData({ Index:windowIndex });
        var bindData=this.ChartPaint[0].Data;
        this.BindIndexData(windowIndex,bindData);   //执行脚本

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.OnChangeIndexEvent=function(windowIndex, indexInfo)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CHANGE_INDEX);
        if (event && event.Callback)
        {
            var data={ IndexInfo:indexInfo, WindowIndex:windowIndex  };
            event.Callback(event,data,this);
        }
    }

    //切换指标 指定切换窗口指标
    this.ChangeIndex=function(windowIndex,indexName,option)
    {
        if (option && option.API)   //切换api指标
            return this.ChangeAPIIndex(windowIndex,option);

        var indexItem=JSIndexMap.Get(indexName);
        if (!indexItem) 
        {
            //查找系统指标
            let scriptData = new JSIndexScript();
            let indexInfo = scriptData.Get(indexName);
            if (!indexInfo) return;
            if (indexInfo.IsMainIndex) 
            {
                windowIndex = 0;  //主图指标只能在主图显示
            }
            else 
            {
                if (windowIndex == 0) windowIndex = 1;  //幅图指标,不能再主图显示
            }

            JSIndexScript.ModifyAttribute(indexInfo, option);
            return this.ChangeScriptIndex(windowIndex, indexInfo, option);
        }

        //主图指标
        if (indexItem.IsMainIndex)
        {
            if (windowIndex>0)  windowIndex=0;  //主图指标只能在主图显示
        }
        else
        {
            if (windowIndex==0) windowIndex=1;  //幅图指标,不能再主图显示
        }

        var paint=new Array();  //踢出当前窗口的指标画法
        for(var i in this.ChartPaint)
        {
            var item=this.ChartPaint[i];

            if (i==0 || item.ChartFrame!=this.Frame.SubFrame[windowIndex].Frame)
                paint.push(item);
        }

        
        this.Frame.SubFrame[windowIndex].Frame.YSpecificMaxMin=null;    //清空指定最大最小值
        this.Frame.SubFrame[windowIndex].Frame.IsLocked=false;          //解除上锁
        this.Frame.SubFrame[windowIndex].Frame.YSplitScale = null;      //清空固定刻度

        this.ChartPaint=paint;

        //清空东条标题
        var titleIndex=windowIndex+1;
        this.TitlePaint[titleIndex].Data=[];
        this.TitlePaint[titleIndex].Title=null;

        this.WindowIndex[windowIndex]=indexItem.Create(option);
        this.CreateWindowIndex(windowIndex);

        var bindData=this.ChartPaint[0].Data;
        this.BindIndexData(windowIndex,bindData);

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.ChangePyScriptIndex=function(windowIndex,indexData)
    {
        this.DeleteIndexPaint(windowIndex);
        this.WindowIndex[windowIndex]=new PyScriptIndex(indexData.Name,indexData.Script,indexData.Args,indexData);    //脚本执行

        var bindData=this.ChartPaint[0].Data;
        this.BindIndexData(windowIndex,bindData);   //执行脚本

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.AddOverlayIndex=function(obj) 
    {
        var overlay=this.CreateOverlayWindowsIndex(obj);
        if (!overlay) return;

        var bindData=this.ChartPaint[0].Data;
        this.BindOverlayIndexData(overlay,obj.WindowIndex,bindData);
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    //创建一个叠加指标
    this.CreateOverlayWindowsIndex=function(obj) // {WindowIndex:, IndexName:, Identify:, ShowRightText:, API:}
    {
        let indexName=obj.IndexName;
        let windowIndex=obj.WindowIndex;
        var apiItem=null, indexInfo=null, indexCustom=null;
        if (obj.API)
        {
            apiItem=obj.API;
        }
        else if (obj.Script)    //动态执行脚本
        {
            indexInfo={ Script:obj.Script, ID:obj.indexName, Name:obj.indexName};
            if (obj.Name) indexInfo.Name=obj.Name;
        }
        else
        {
            let scriptData = new JSIndexScript();
            indexInfo = scriptData.Get(indexName);  //系统指标
            if (!indexInfo) 
            {
                indexCustom=JSIndexMap.Get(indexName);  //定制指标
                if (!indexCustom)
                {
                    console.warn(`[KLineChartContainer::CreateOverlayIndex] can not find index[${indexName}]`);
                    return null;
                }
            }
        }

        var subFrame=this.Frame.SubFrame[windowIndex];
        var overlayFrame=new OverlayIndexItem();
        if (obj.Identify) overlayFrame.Identify=obj.Identify;   //由外部指定id
        //var frame= this.ClassName==='KLineChartHScreenContainer' ? new OverlayKLineHScreenFrame() : new OverlayKLineFrame();
        var frame=this.CreateOverlayFrame();
        frame.Canvas=this.Canvas;
        frame.MainFrame=subFrame.Frame;
        frame.ChartBorder=subFrame.Frame.ChartBorder;
        frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        if (obj.ShowRightText===true) frame.IsShow=true;
        else if (obj.ShowRightText===false) frame.IsShow=false;
        if (IFrameSplitOperator.IsBool(obj.ShowToolbar)) frame.IsShowToolbar=obj.ShowToolbar;   //废弃
        if (IFrameSplitOperator.IsBool(obj.IsShareY)) frame.IsShareY=obj.IsShareY;
        if (IFrameSplitOperator.IsNumber(obj.IsShowMainFrame)) frame.IsShowMainFrame=obj.IsShowMainFrame;
        //if (IFrameSplitOperator.IsBool(obj.IsShowIndexTitle)) frame.IsShowIndexTitle=obj.IsShowIndexTitle;
        if (IFrameSplitOperator.IsBool(obj.IsCalculateYMaxMin)) frame.IsCalculateYMaxMin=obj.IsCalculateYMaxMin;   //是否计算Y最大最小值

        frame.YSplitOperator=new FrameSplitY();
        frame.YSplitOperator.LanguageID=this.LanguageID;
        frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
        frame.YSplitOperator.Frame=frame;
        frame.YSplitOperator.ChartBorder=frame.ChartBorder;
        frame.YSplitOperator.SplitCount=subFrame.Frame.YSplitOperator.SplitCount;
        frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        frame.YSplitOperator.GetKLineChartCallback=()=> { return this.GetKLineChart(); }
        frame.YSplitOperator.OverlayIndex=overlayFrame;
        frame.YSplitOperator.HQChart=this;
        frame.YSplitOperator.OverlayIdentify=overlayFrame.Identify;

        if (obj.Frame)
        {
            var item=obj.Frame;
            if (item.Custom) frame.YSplitOperator.Custom=item.Custom;
            if (IFrameSplitOperator.IsBool(item.IsYDrawMainFrame)) frame.IsYDrawMainFrame=item.IsYDrawMainFrame;    //自定义刻度绘制在主图上
            if (IFrameSplitOperator.IsBool(item.IsShowToolbar)) frame.IsShowToolbar=item.IsShowToolbar;             //是否显示工具栏
        }
        
        overlayFrame.Frame=frame;

        if (apiItem)
        {
            var apiIndex=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,obj, true);
            apiIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame };    //叠加指标信息
            overlayFrame.Script=apiIndex;
        }
        else if (indexInfo)
        {
            JSIndexScript.ModifyAttribute(indexInfo, obj);
            var scriptIndex=new OverlayScriptIndex(indexInfo.Name,indexInfo.Script,indexInfo.Args,indexInfo);    //脚本执行
            scriptIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame };    //叠加指标信息
            overlayFrame.Script=scriptIndex;
        }
        else 
        {
            var scriptIndex=indexCustom.Create();
            scriptIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame };    //叠加指标信息
            scriptIndex.Create(this,windowIndex);
            overlayFrame.Script=scriptIndex;
        }

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_OVERLAY_FRAME);
        if (event && event.Callback)
        {
            var sendData={ OverlayFrame:overlayFrame, WindowIndex:windowIndex, SubFrame:subFrame };
            event.Callback(event, sendData, this);
        }

        subFrame.OverlayIndex.push(overlayFrame);
        return overlayFrame;
    }

    this.DeleteOverlayWindowsIndex=function(identify) //删除叠加指标
    {
        if (!this.DeleteOverlayIndex(identify, null)) return;

        this.UpdateFrameMaxMin();   //重新计算坐标范围
        this.Frame.ResetXYSplit(true);
        this.Draw();
    }
    
    this.ChangeKLineDrawType=function(drawType, isDraw, option)
    {
        if (this.KLineDrawType==drawType && !option) return;

        var oldKLineType=this.KLineDrawType;
        this.KLineDrawType=drawType;
        var setKLineType=new Set([5,7,8,10,11,12,17]);

        if (setKLineType.has(oldKLineType) || setKLineType.has(drawType))
        {
            var chart=this.ChartPaint[0];
            if (chart) chart.DrawType=this.KLineDrawType;

            this.CancelAutoUpdate();    //先停止定时器
            this.AutoUpdateEvent(false,'KLineChartContainer::ChangeKLineDrawType');

            if (ChartData.IsDayPeriod(this.Period,true))
            {
                this.ResetOverlaySymbolStatus();
                this.RequestHistoryData();                  //请求日线数据
            }
            else if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period) || ChartData.IsMilliSecondPeriod(this.Period))
            {
                this.ResetOverlaySymbolStatus();
                this.RequestHistoryMinuteData();            //请求分钟数据
            }

            return;
        }

        for(var i=0; i<this.ChartPaint.length; ++i)
        {
            var item=this.ChartPaint[i];
            if (i==0) 
            {
                item.DrawType=this.KLineDrawType;
                if (option)
                {
                    if (IFrameSplitOperator.IsBool(option.IsThinAKBar)) item.IsThinAKBar=option.IsThinAKBar;
                }
            }
            else if (item.ClassName=='ChartVolStick') 
            {
                item.KLineDrawType=this.KLineDrawType;
            }
        }

        for(var i in this.OverlayChartPaint)    //叠加K线样式修改
        {
            var item=this.OverlayChartPaint[i];
            item.DrawType=this.KLineDrawType;
        } 

        if (isDraw==false) return;

        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    //修改坐标类型 
    //{ Type:  0=普通坐标  1=百分比坐标 (右边坐标刻度) 2=对数对标 3=等比坐标, IsReverse:是否反转坐标 }
    this.ChangeCoordinateType=function(obj) 
    {
        if (!this.Frame) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.Frame.SubFrame)) return;
        if (!this.Frame.SubFrame[0]) return;

        var frame=this.Frame.SubFrame[0].Frame;
        if (IFrameSplitOperator.IsNumber(obj))  //老版本
        {
            var type=obj;
            if (type==2) //反转坐标
            {
                frame.CoordinateType=1;
            }
            else if(type==1)
            {
                frame.YSplitOperator.CoordinateType=type;
            }
            else if (type==0)
            {
                frame.CoordinateType=0;
                frame.YSplitOperator.CoordinateType=0;
            }
            else if (type==3)   //对数坐标
            {
                frame.Frame.YSplitOperator.CoordinateType=2;
            }
            else
            {
                return;
            }
        }
        else
        {
            if (obj.Type>=0 && obj.Type<=5) frame.YSplitOperator.CoordinateType=obj.Type;
            if (obj.IsReverse===true) frame.CoordinateType=1;
            else if (obj.IsReverse==false) frame.CoordinateType=0;
        }

        //请求缓存的最大最小值
        frame.YMaxMin.Max=null;
        frame.YMaxMin.Min=null;
        
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    //设置指标窗口个数
    this.ChangeIndexWindowCount=function(count,option)
    {
        if (count<=0) return;
        if (this.Frame.SubFrame.length==count) return;

        this.Frame.RestoreIndexWindows();
       
        var currentLength=this.Frame.SubFrame.length;
        if (currentLength>count)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DELETE_FRAME);
            for(var i=currentLength-1;i>=count;--i)
            {
                this.DeleteIndexPaint(i);
                this.DeleteChartPaintExtend({WindowIndex:i});
                this.Frame.SubFrame[i].Frame.ClearToolbar();
                if (event && event.Callback)
                {
                    var sendData={ SubFrame:this.Frame.SubFrame[i], WindowIndex:i };
                    event.Callback(event, sendData, this);
                }
            }

            this.Frame.SubFrame.splice(count,currentLength-count);
            this.WindowIndex.splice(count,currentLength-count);
            this.TitlePaint.splice(count+1,currentLength-count);

            //最后一个显示X轴坐标
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                var item=this.Frame.SubFrame[i].Frame;
                if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
                else item.XSplitOperator.ShowText=false;
            }

            this.Frame.SetSizeChage(true);
            this.ResetFrameXYSplit();
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Draw();
        }
        else
        {
            //创建新的指标窗口
            var pixelRatio=GetDevicePixelRatio();
            for(var i=currentLength;i<count;++i)
            {
                var subFrame=this.CreateSubFrameItem(i);
                subFrame.Frame.ChartBorder.TitleHeight*=pixelRatio;
                this.Frame.SubFrame[i]=subFrame;
                var titlePaint=new DynamicChartTitlePainting();
                titlePaint.Frame=this.Frame.SubFrame[i].Frame;
                titlePaint.Canvas=this.Canvas;
                titlePaint.LanguageID=this.LanguageID;
                titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                titlePaint.SelectedChart=this.SelectedChart;
                this.TitlePaint[i+1]=titlePaint;
            }

            //最后一个显示X轴坐标
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                var item=this.Frame.SubFrame[i].Frame;
                if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
                else item.XSplitOperator.ShowText=false;
            }

            this.Frame.SetSizeChage(true);
            this.ResetFrameXYSplit();
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Draw();

            //创建指标
            var indexName= [ {Index:"RSI"}, {Index:"MACD"}, {Index:"VOL"}, {Index:"UOS"}, {Index:"CHO"}, {Index:"BRAR"} ];  //增加的指标名字
            if (option && option.Windows.length>0)
                indexName=option.Windows;   //外部设置增加窗口的默认指标

            let scriptData = new JSIndexScript();
            for(var i=currentLength;i<count;++i)
            {
                var item=indexName[i%indexName.length];
                var name=item.Index;
                let indexInfo = scriptData.Get(name);
                var args=indexInfo.Args;
                if (item.Args) args=item.Args;
                let indexData = 
                { 
                    Name:indexInfo.Name, Script:indexInfo.Script, Args: args, ID:item.Index,
                    //扩展属性 可以是空
                    KLineType:indexInfo.KLineType,  YSpecificMaxMin:indexInfo.YSpecificMaxMin,  YSplitScale:indexInfo.YSplitScale,
                    FloatPrecision:indexInfo.FloatPrecision, Condition:indexInfo.Condition,
                    OutName:indexInfo.OutName
                };
    
                this.WindowIndex[i]=new ScriptIndex(indexData.Name,indexData.Script,indexData.Args,indexData);    //脚本执行

                var subFrame=this.Frame.SubFrame[i];
                if (item.Modify!=null) this.Frame.SubFrame[i].Frame.ModifyIndex=item.Modify;
                if (item.Change!=null) this.Frame.SubFrame[i].Frame.ChangeIndex=item.Change;
                if (item.Close!=null) this.Frame.SubFrame[i].Frame.CloseIndex=item.Close;
                if (item.Overlay!=null) chart.Frame.SubFrame[i].Frame.OverlayIndex=item.Overlay;
                if (item.IsDrawTitleBG==true)  this.Frame.SubFrame[i].Frame.IsDrawTitleBG=item.IsDrawTitleBG;
                if (IFrameSplitOperator.IsBool(item.IsShowNameArrow)) this.Frame.SubFrame[i].Frame.IsShowNameArrow=item.IsShowNameArrow;

                if (IFrameSplitOperator.IsNumber(item.TitleHeight)) this.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight=item.TitleHeight;
                else item.TitleHeight=this.Frame.SubFrame[i].Frame.ChartBorder.TitleHeight;
                if (IFrameSplitOperator.IsBool(item.IsShowTitleArrow)) subFrame.Frame.IsShowTitleArrow=item.IsShowTitleArrow;
                if (IFrameSplitOperator.IsNumber(item.TitleArrowType)) subFrame.Frame.TitleArrowType=item.TitleArrowType;
                if (item.IsShowIndexName==false) this.Frame.SubFrame[i].Frame.IsShowIndexName=false;
                if (item.IsShowOverlayIndexName==false) this.Frame.SubFrame[i].Frame.IsShowOverlayIndexName=false;
                if (IFrameSplitOperator.IsNumber(item.IndexParamSpace)) this.Frame.SubFrame[i].Frame.IndexParamSpace=item.IndexParamSpace;
                if (IFrameSplitOperator.IsNumber(item.IndexTitleSpace)) this.Frame.SubFrame[i].Frame.IndexTitleSpace=item.IndexTitleSpace;
                
                if (item.IsShowXLine==false) this.Frame.SubFrame[i].Frame.IsShowXLine=false;
                if (item.IsShowYLine==false) this.Frame.SubFrame[i].Frame.IsShowYLine=false;
                if (IFrameSplitOperator.IsBool(item.IsShowIndexTitle)) this.Frame.SubFrame[i].Frame.IsShowIndexTitle=item.IsShowIndexTitle;
                

                if (IFrameSplitOperator.IsBool(item.IsShowLeftText)) 
                {
                    subFrame.Frame.IsShowYText[0]=item.IsShowLeftText;
                    subFrame.Frame.YSplitOperator.IsShowLeftText=item.IsShowLeftText;            //显示左边刻度
                }
                if (IFrameSplitOperator.IsBool(item.IsShowRightText)) 
                {
                    subFrame.Frame.IsShowYText[1]=item.IsShowRightText;
                    subFrame.Frame.YSplitOperator.IsShowRightText=item.IsShowRightText;         //显示右边刻度
                }

                if (item.OverlayIndexType)
                {
                    if (IFrameSplitOperator.IsNumber(item.OverlayIndexType.Position)) subFrame.Frame.OverlayIndexType.Position=item.OverlayIndexType.Position;
                    if (IFrameSplitOperator.IsNumber(item.OverlayIndexType.LineSpace)) subFrame.Frame.OverlayIndexType.LineSpace=item.OverlayIndexType.LineSpace;
                }

                var bindData=this.ChartPaint[0].Data;
                this.BindIndexData(i,bindData);   //执行脚本
            }

            //this.UpdataDataoffset();           //更新数据偏移
        }
    }

    this.ChangeIndexTemplate=function(option)   //切换指标模板 可以设置指标窗口个数 每个窗口的指标
    {
        if (!option.Windows) return;
        var count=option.Windows.length;
        if (count<=0) return;
        var currentLength=this.Frame.SubFrame.length;

        var period=null, right=null, symbol=null;
        if (option.Symbol) symbol=option.Symbol;
        if (option.KLine)
        {
            if (IFrameSplitOperator.IsNumber(option.KLine.Period) && option.KLine.Period!=this.Period) period=option.KLine.Period;  //周期
            if (IFrameSplitOperator.IsNumber(option.KLine.Right) && option.KLine.Right!=this.Right) right=option.KLine.Right;       //复权
        }

        var bRefreshData= (period!=null || right!=null || symbol!=null);

        //清空所有的指标图型
        for(var i=0;i<currentLength;++i)
        {
            this.DeleteIndexPaint(i);
            var frame=this.Frame.SubFrame[i];
            frame.YSpecificMaxMin=null;
            frame.IsLocked=false;
            frame.YSplitScale = null;
        }
        
        if (currentLength>count)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DELETE_FRAME);
            for(var i=currentLength-1;i>=count;--i)
            {
                this.Frame.SubFrame[i].Frame.ClearToolbar();

                if (event && event.Callback)
                {
                    var sendData={ SubFrame:this.Frame.SubFrame[i], WindowIndex:i };
                    event.Callback(event, sendData, this);
                }
            }

            this.Frame.SubFrame.splice(count,currentLength-count);
            this.WindowIndex.splice(count,currentLength-count);
            this.TitlePaint.splice(count+1,currentLength-count);
        }
        else
        {
            for(var i=currentLength;i<count;++i)  //创建新的指标窗口
            {
                var subFrame=this.CreateSubFrameItem(i);
                this.Frame.SubFrame[i]=subFrame;
                var titlePaint=new DynamicChartTitlePainting();
                titlePaint.Frame=this.Frame.SubFrame[i].Frame;
                titlePaint.Canvas=this.Canvas;
                titlePaint.LanguageID=this.LanguageID;
                titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                titlePaint.SelectedChart=this.SelectedChart;
                this.TitlePaint[i+1]=titlePaint;
            } 
        }
        
        for(var i=0;i<count;++i)
        {
            var windowIndex=i;
            var item=option.Windows[i];
            var frameItem=null;
            if(option.Frame && option.Frame.length>i) frameItem=option.Frame[i];
            var titleIndex=windowIndex+1;
            this.TitlePaint[titleIndex].Data=[];
            this.TitlePaint[titleIndex].Title=null;
            var frame=this.Frame.SubFrame[i];

            this.DeleteWindowsOverlayIndex(i);  //清空叠加指标
           
            if (item.Script)    //自定义指标脚本
            {
                this.WindowIndex[i]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
            }
            else if (item.API)  //后台指标
            {
                var apiItem=item.API;
                this.WindowIndex[windowIndex]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,item);
            }
            else
            {
                var indexID=item.Index;
                var indexItem=JSIndexMap.Get(indexID);
                if (indexItem)
                {
                    this.WindowIndex[i]=indexItem.Create();
                    this.CreateWindowIndex(windowIndex);
                }
                else
                {
                    var systemScript = new JSIndexScript();
                    var indexInfo = systemScript.Get(indexID);
                    if (indexInfo)
                    {
                        JSIndexScript.ModifyAttribute(indexInfo,item);
                        this.WindowIndex[i]=new ScriptIndex(indexInfo.Name,indexInfo.Script,indexInfo.Args,indexInfo);    //脚本执行
                    }
                }
            }

            this.SetSubFrameAttribute(frame, item, frameItem);
        }

        //最后一个显示X轴坐标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;
        }

        //叠加指标
        var aryOverlayIndex=[];
        if (IFrameSplitOperator.IsNonEmptyArray(option.OverlayIndex))
        {
            for(var i=0;i<option.OverlayIndex.length;++i)
            {
                var item=option.OverlayIndex[i];
                if (item.Index) item.IndexName=item.Index;
                if (item.Windows>=0) item.WindowIndex=item.Windows;

                var overlay=this.CreateOverlayWindowsIndex(item);
                if (!overlay) continue;

                aryOverlayIndex.push({ WindowsIndex:item.WindowIndex, Overlay:overlay });
            }
        }

        this.Frame.SetSizeChage(true);

        if (!bRefreshData)
        {
            var bindData=this.ChartPaint[0].Data;
            for(var i=0;i<count;++i)    //请求指标
            {
                this.BindIndexData(i,bindData);
            }

            for(var i=0;i<aryOverlayIndex.length;++i)
            {
                var item=aryOverlayIndex[i];
                this.BindOverlayIndexData(item.Overlay,item.WindowsIndex,bindData);
            }

            this.UpdataDataoffset();           //更新数据偏移
            this.ResetFrameXYSplit();
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Draw();
        }
        else
        {
           if (!symbol) symbol=this.Symbol;
           var optionData={ KLine:{} };
           if (IFrameSplitOperator.IsNumber(period)) optionData.KLine.Period=period;
           if (IFrameSplitOperator.IsNumber(right)) optionData.KLine.Right=right;

           this.ChangeSymbol(symbol, optionData);
        }
    }

    this.RemoveIndexWindow=function(id, option)
    {
        JSConsole.Chart.Log('[KLineChartContainer::RemoveIndexWindow] remove id', id);
        if (id==0) 
        {
            if (option && option.DeleteMainIndex)   //删除指标
            {
                this.DeleteIndexPaint(id);
                this.WindowIndex[id]=null;

                this.Frame.SetSizeChage(true);
                this.UpdateFrameMaxMin();
                this.ResetFrameXYSplit();
                this.Draw();
            }
            return;
        }

        if (!this.Frame.SubFrame) return;
        if (id>=this.Frame.SubFrame.length) return;

        this.Frame.RestoreIndexWindows();

        var delFrame=this.Frame.SubFrame[id].Frame;
        this.DeleteIndexPaint(id);
        this.DeleteChartPaintExtend({WindowIndex:id});
        this.Frame.SubFrame[id].Frame.ClearToolbar();

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DELETE_FRAME);
        if (event && event.Callback)
        {
            var sendData={ SubFrame:this.Frame.SubFrame[id], WindowIndex:id };
            event.Callback(event, sendData, this);
        }

        this.Frame.SubFrame.splice(id,1);
        this.WindowIndex.splice(id,1);
        this.TitlePaint.splice(id+1,1); //删除对应的动态标题

        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;

            item.Identify=i;
        }

        if (this.ChartDrawPicture.length>0)
        {
            var aryDrawPicture=[];
            for(var i in this.ChartDrawPicture)
            {
                var item=this.ChartDrawPicture[i];
                if (item.Frame==delFrame) continue;
                aryDrawPicture.push(item);
            }
            this.ChartDrawPicture=aryDrawPicture;
        }

        this.Frame.SetSizeChage(true);
        this.UpdateFrameMaxMin();
        this.ResetFrameXYSplit();
        this.Draw();
    }

    this.CreateExtendChart=function(name, option)   //创建扩展图形
    {
        var chart;
        switch(name)
        {
            case '筹码分布':
                chart=new StockChip();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.Left=this.Frame.ChartBorder.Right;    //左边间距使用当前框架间距
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                this.Frame.ChartBorder.Right+=chart.Width;  //创建筹码需要增加右边的间距
                return chart;
            case 'KLineTooltip':
                if (option.Create && typeof(option.Create)=='function') chart=option.Create();
                else chart=new KLineTooltipPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                option.LanguageID=this.LanguageID;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            case "深度图":
                chart=new DepthMapPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            case "K线Y轴背景图":
                chart=new KLineYAxisBGPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            case '背景图':
                chart=new BackgroundPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            case "FrameSplitPaint": //框架分割
                chart=new FrameSplitPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            default:
                chart=g_ExtendChartPaintFactory.Create(name);
                if (!chart) return null;

                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
        }
    }

    this.OnTouchFinished=function()
    {
        if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
        {
            if (this.TouchStatus.CorssCursorShow==true && this.TouchDrawCount>0) return;

            this.TouchStatus.CorssCursorShow=false;
            this.DrawDynamicInfo();
            return;
        }

        if (this.EnableClickModel===true)
        {
            if (this.ClickModel.IsShowCorssCursor==true && this.TouchDrawCount>0) return;

            this.ClickModel.IsShowCorssCursor=false;
            this.DrawDynamicInfo();
            return;
        }

        if (this.CorssCursorTouchEnd===true)    //手势离开十字光标消失
        {
            if (this.TouchDrawCount>0) this.DrawDynamicInfo();
            return;
        }

        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName==='KLineTooltipPaint')
            {
                this.DrawDynamicInfo();
            }
        }
    }

    //锁|解锁指标 { Index:指标名字,IsLocked:是否要锁上,Callback:回调 }
    this.LockIndex=function(lockData)
    {
        if (!lockData) return;
        if (!lockData.IndexName) return;

        for(let i in this.WindowIndex)
        {
            let item=this.WindowIndex[i];
            if (!item) conintue;
            if (item.Name==lockData.IndexName)
            {
                item.SetLock(lockData);
                this.Update();
                break;
            }
        }
    }

    this.TryClickLock=function(x,y)
    {
        for(var i=0;i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            if (!item.Frame.IsLocked) continue;
            if (!item.Frame.LockPaint) continue;

            var tooltip=new TooltipData();
            if (!item.Frame.LockPaint.GetTooltipData(x,y,tooltip)) continue;

            tooltip.HQChart=this;
            if (tooltip.Data.Callback) tooltip.Data.Callback(tooltip);
            return true;
        }

        return false;
    }

    this.TryClickIndexTitle=function(x,y)
    {
        for(var i in this.TitlePaint)
        {
            var item=this.TitlePaint[i];
            if (!item.IsClickTitle) continue;
            if (!item.IsClickTitle(x,y)) continue;

            var data={ Point:{X:x, Y:y}, Title:item.Title, FrameID:item.Frame.Identify };
            JSConsole.Chart.Log('[KLineChartContainer::TryClickIndexTitle] click title ', data);

            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_INDEXTITLE);
            if (event && event.Callback) event.Callback(event,data,this);
            
            return true;
        }

        return false;
    }

    this.SetSizeChange=function(bChanged)
    {
        this.Frame.SetSizeChage(bChanged);
        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            item.SizeChange=bChanged;
        }
    }
    this.SetSizeChage=this.SetSizeChange;   //单词拼错了， 还没替换完

    this.Update=function(option) //option: { UpdateCursorIndexType:更新十字光标方式 }
    {
        if (!this.SourceData) return;
        if (this.BeforeBindMainData) this.BeforeBindMainData('Update');

        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;
        bindData.Symbol=this.Symbol;

        if (bindData.Right>0 && ChartData.IsDayPeriod(bindData.Period,true))    //复权(日线数据复权)
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }
        else if (bindData.Right>0 && ChartData.IsMinutePeriod(bindData.Period,true) && this.RightFormula>=1) //复权(分钟数据复权, 复权因子模式)
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据 (0= 日线,4=1分钟线 不需要处理)
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        //绑定数据
        this.BindMainData(bindData,this.PageSize);
        if (this.AfterBindMainData) this.AfterBindMainData("Update");

        var firstSubFrame;
        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            if (i==0) firstSubFrame=this.Frame.SubFrame[i].Frame;
            this.BindIndexData(i,bindData);
        }

        if (firstSubFrame && firstSubFrame.YSplitOperator)
        {
            firstSubFrame.YSplitOperator.Symbol=this.Symbol;
            firstSubFrame.YSplitOperator.Data=this.ChartPaint[0].Data;          //K线数据
            firstSubFrame.YSplitOperator.Period=this.Period;                    //周期
        }

        //叠加数据周期调整
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.SourceData) continue;
        
            if(ChartData.IsMinutePeriod(this.Period,true))  //分钟不支持 清空掉
            {   
                var bindData=new ChartData();
                bindData.Data=item.SourceData.Data;
                bindData.Period=this.Period;
                bindData.Right=this.Right;

                var aryOverlayData=this.SourceData.GetOverlayMinuteData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
                bindData.Data=aryOverlayData;

                if (ChartData.IsMinutePeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
                {
                    var periodData=bindData.GetPeriodData(bindData.Period);
                    bindData.Data=periodData;
                }

                item.Data=bindData;
            }
            else    //日线叠加
            {   
                var bindData=new ChartData();
                bindData.Data=item.SourceData.Data;
                bindData.Period=this.Period;
                bindData.Right=this.Right;

                if (bindData.Right>0 && MARKET_SUFFIX_NAME.IsSHSZStockA(item.Symbol))       //复权数据
                {
                    var rightData=bindData.GetRightData(bindData.Right,{ AlgorithmType: this.RightFormula });
                    bindData.Data=rightData;
                }

                var aryOverlayData=this.SourceData.GetOverlayData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
                bindData.Data=aryOverlayData;

                if (ChartData.IsDayPeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
                {
                    var periodData=bindData.GetPeriodData(bindData.Period);
                    bindData.Data=periodData;
                }

                item.Data=bindData;
            }
        }

        this.ReqeustKLineInfoData( {FunctionName:"Update"} );
        
        this.CreateChartDrawPictureByStorage(); //创建画图工具
        
        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        if (option && option.UpdateCursorIndexType>0) this.UpdatePointByCursorIndex(option.UpdateCursorIndexType);
        else this.UpdatePointByCursorIndex();   //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        //叠加指标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            for(var j in item.OverlayIndex)
            {
                var overlayItem=item.OverlayIndex[j];
                this.BindOverlayIndexData(overlayItem,i,bindData)
            }
        }
    }

    //切换股票代码
    this.ChangeSymbol=function(symbol, option)
    {
        this.CancelAutoUpdate();    //先停止定时器
        this.AutoUpdateEvent(false,'KLineChartContainer::ChangeSymbol');
        this.ClearRectSelect(true);
        this.ClearCustomKLine();
        this.ClearKLineCaluate();
        this.HideTooltip();
        this.ResetScrollBar();
        this.ClearIndexRunCount();
        this.Frame.ClearYCoordinateMaxMin();
        
        
        this.Symbol=symbol;
        if (!symbol)
        {
            this.DrawEmpty();
            return;
        }

        if (option)
        {
            if (option.KLine)
            {
                var item=option.KLine;
                if (IFrameSplitOperator.IsNumber(item.Right)) this.Right=item.Right;
                if (IFrameSplitOperator.IsNumber(item.Period)) this.Period=item.Period;
            }
        }
       
        if (MARKET_SUFFIX_NAME.IsSHSZIndex(symbol)) this.Right=0;    //指数没有复权

        this.ClearIndexPaint(); //清空指标
        
        if (option)
        {
            if (IFrameSplitOperator.IsNonEmptyArray(option.Windows))
            {
                var windows=option.Windows;
                
                for(var i=0; i<windows.length; ++i)
                {
                    if (i>=this.WindowIndex.length) break; //暂时不支持 动态增加/减少
                    var item=windows[i];
                    if (!item) continue;

                    if (item.Script)
                    {
                        this.WindowIndex[i]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
                    }
                    else if (item.API)
                    {
                        var apiItem=item.API;
                        this.WindowIndex[i]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,item);
                    }
                    else
                    {
                        var indexID=item.Index;
                        var systemScript = new JSIndexScript();
                        var indexInfo = systemScript.Get(indexID);
                        if (indexInfo)
                        {
                            JSIndexScript.ModifyAttribute(indexInfo,item);
                            indexInfo.ID=indexID;
                            this.WindowIndex[i]=new ScriptIndex(indexInfo.Name,indexInfo.Script,indexInfo.Args,indexInfo);    //脚本执行
                        }
                    }
                }
            }

            if (option.CustomShow && IFrameSplitOperator.IsPlusNumber(option.CustomShow.Date))
            {
                var item=option.CustomShow;
                this.CustomShow={ Date:item.Date };
                if (IFrameSplitOperator.IsNumber(item.Time)) this.CustomShow.Time=item.Time;
                if (IFrameSplitOperator.IsPlusNumber(item.PageSize)) this.CustomShow.PageSize=item.PageSize;
            }
        }

        this.ReloadChartDrawPicture();
        this.Frame.ClearUpDonwFrameYData();
        if (ChartData.IsDayPeriod(this.Period,true))
        {
            this.ClearStockCache();
            this.RequestHistoryData();                  //请求日线数据
            //this.ReqeustKLineInfoData();
        }
        else if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period) || ChartData.IsMilliSecondPeriod(this.Period))
        {
            this.ClearStockCache();
            this.RequestHistoryMinuteData();            //请求分钟数据
        } 
        else if (ChartData.IsTickPeriod(this.Period))
        {
            this.ClearStockCache();
            this.RequestTickData();
        } 
    }

    this.ReqeustKLineInfoData=function(obj)
    {
        if (obj && obj.FunctionName=="RecvDragDayData") //增量更新
        {
            obj.Update=true;
        }
        else
        {
            if (this.ChartPaint.length>0)
            {
                var klinePaint=this.ChartPaint[0];
                klinePaint.InfoData=new Map();
            }
            obj.Update=false;
        }

        //信息地雷信息
        if (!IFrameSplitOperator.IsNonEmptyArray(this.ChartInfo)) return;
        
        for(var i=0;i<this.ChartInfo.length; ++i)
        {
            this.ChartInfo[i].RequestData(this,obj);
        }
    }

    //设置K线信息地雷
    this.SetKLineInfo=function(aryInfo,bUpdate)
    {
        this.ChartInfo=[];  //先清空
        for(var i in aryInfo)
        {
            var infoItem=JSKLineInfoMap.Get(aryInfo[i]);
            if (!infoItem) continue;
            var item=infoItem.Create();
            item.MaxRequestDataCount=this.MaxRequestDataCount;
            this.ChartInfo.push(item);
        }

        if (bUpdate==true) this.ReqeustKLineInfoData({ FunctionName:"SetKLineInfo" });
    }

    //添加信息地雷
    this.AddKLineInfo=function(infoName,bUpdate)
    {
        var classInfo=JSKLineInfoMap.GetClassInfo(infoName);
        if (!classInfo)
        {
            console.warn("[KLineChartContainer::AddKLineInfo] can't find infoname=", infoName);
            return;
        }

        for(var i in this.ChartInfo)
        {
            var item=this.ChartInfo[i];
            if (item.ClassName==classInfo.ClassName)    //已经存在
                return;
        }

        var infoItem=JSKLineInfoMap.Get(infoName);
        if (!infoItem) return;

        var item=infoItem.Create();
        item.MaxRequestDataCount=this.MaxRequestDataCount;
        this.ChartInfo.push(item);

        if (bUpdate==true) 
        {
            item.RequestData(this);  //信息地雷信息
        }
    }

    //删除信息地理
    this.DeleteKLineInfo=function(infoName)
    {
        var classInfo=JSKLineInfoMap.GetClassInfo(infoName);
        if (!classInfo)
        {
            console.warn("[KLineChartContainer::DeleteKLineInfo] can't find infoname=", infoName);
            return;
        }

        for(var i in this.ChartInfo)
        {
            var item=this.ChartInfo[i];
            if (item.ClassName==classInfo.ClassName)
            {
                this.ChartInfo.splice(i,1);
                this.UpdataChartInfo();
                this.Draw();
                break;
            }
        }
    }

    //清空所有的信息地理
    this.ClearKLineInfo=function()
    {
        if (!this.ChartInfo || this.ChartInfo.length<=0) return;

        this.ChartInfo=[];

        var klinePaint=this.ChartPaint[0];
        klinePaint.InfoData=null;
        this.Draw();
    }

    //增加叠加股票
    this.OverlaySymbol=function(symbol,option)
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            if (item.Symbol===symbol)
            {
                console.warn(`[KLineChartContainer::OverlaySymbol] overlay symbol=${symbol} exist.`)
                return false;
            }
        }

        var paint=new ChartOverlayKLine();
        paint.Canvas=this.Canvas;
        paint.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        paint.ChartFrame=this.Frame.SubFrame[0].Frame;
        paint.Name="Overlay-KLine";
        paint.DrawType=this.KLineDrawType;
        paint.Symbol=symbol;
        paint.Identify=`Overlay-KLine-${symbol}`;
        if (option && option.Color) paint.Color=option.Color;
        else paint.Color=g_JSChartResource.OverlaySymbol.Color[g_JSChartResource.OverlaySymbol.Random%g_JSChartResource.OverlaySymbol.Color.length];
        paint.SetOption(option);
        ++g_JSChartResource.OverlaySymbol.Random;
        if (this.ChartPaint[0] && this.ChartPaint[0].Data && this.SourceData) paint.MainData=this.ChartPaint[0].Data;         //绑定主图数据
        
        this.OverlayChartPaint.push(paint);

        if (ChartData.IsDayPeriod(this.Period, true)) this.RequestOverlayHistoryData();                   //请求日线数据
        else if (ChartData.IsMinutePeriod(this.Period,true)) this.RequestOverlayHistoryMinuteData();      //请求分钟历史数据   

        return true;
    }

    this.RequestOverlayHistoryData=function()
    {
        if (!this.OverlayChartPaint.length) return;
        if (!this.SourceData || !this.SourceData.Data) return;  //主图数据还没有到完

        var self = this;
        var dataCount=this.GetRequestDataCount();
        var firstDate=this.SourceData.Data[0].Date;
        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            let item=this.OverlayChartPaint[i];
            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_NONE_ID) continue;
            let symbol=item.Symbol;
            if (!symbol) continue;

            item.Status=OVERLAY_STATUS_ID.STATUS_REQUESTDATA_ID;

            if (this.NetworkFilter)
            {
                var obj=
                {
                    Name:'KLineChartContainer::RequestOverlayHistoryData', //类名::
                    Explain:'叠加股票日K线数据',
                    Request:{ Url:self.KLineApiUrl, Data: { symbol: symbol, count: dataCount.MaxRequestDataCount,"first":{ date: firstDate },
                        field:["name","symbol","yclose","open","price","high",'vol','amount'] }, Type:'POST' }, 
                    Self:this,
                    PreventDefault:false
                };
                this.NetworkFilter(obj, function(data) 
                { 
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOverlayHistoryData(data,item);
                });

                if (obj.PreventDefault==true) continue;   //已被上层替换,不调用默认的网络请求
            }

            //请求数据
            JSNetwork.HttpRequest({
                url: this.KLineApiUrl,
                data:
                {
                    "field": ["name","symbol","yclose","open","price","high"],
                    "symbol": symbol,
                    "start": -1,
                    "count": dataCount.MaxRequestDataCount
                },
                type:"post",
                dataType: "json",
                async:true,
                success: function (data)
                {
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOverlayHistoryData(data,item);
                }
            });
        }
    }

    this.RecvOverlayHistoryData=function(data,paint)
    {
        if (paint.IsDelete) return;

        var aryDayData=KLineChartContainer.JsonDataToHistoryData(data);

        //原始叠加数据
        var sourceData=new ChartData();
        sourceData.Data=aryDayData;
        sourceData.DataType=0;

        var bindData=new ChartData();
        bindData.Data=aryDayData;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=0;

        if (bindData.Right>0 && MARKET_SUFFIX_NAME.IsSHSZStockA(data.symbol) && !this.IsApiPeriod)    //复权数据 ,A股才有有复权
        {
            var rightData=bindData.GetRightData(bindData.Right,{ AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        var aryOverlayData=this.SourceData.GetOverlayData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
        bindData.Data=aryOverlayData;

        if (ChartData.IsDayPeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        paint.Data=bindData;
        paint.SourceData=sourceData;
        paint.Title=data.name;
        paint.Symbol=data.symbol;
        paint.Status=OVERLAY_STATUS_ID.STATUS_FINISHED_ID;

        this.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType=1; //调整为百份比坐标

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

    }

    this.RequestOverlayHistoryMinuteData=function()
    {
        if (!this.OverlayChartPaint.length) return;
        if (!this.SourceData || !this.SourceData.Data) return;  //主图数据还没有到完

        var self = this;
        var dataCount=this.GetRequestDataCount();
        var firstDate=this.SourceData.Data[0].Date;
        var firstTime=this.SourceData.Data[0].Time;
        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            let item=this.OverlayChartPaint[i];
            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_NONE_ID) continue;
            let symbol=item.Symbol;
            if (!symbol) continue;

            item.Status=OVERLAY_STATUS_ID.STATUS_REQUESTDATA_ID;

            if (this.NetworkFilter)
            {
                var obj=
                {
                    Name:'KLineChartContainer::RequestOverlayHistoryMinuteData', //类名::
                    Explain:'叠加股票分钟K线数据',
                    Request:{ Url:self.MinuteKLineApiUrl, Data: { symbol: symbol, count: dataCount.MaxRequestMinuteDayCount,"first":{ date: firstDate, time:firstTime },
                        field:["name","symbol","yclose","open","price","high",'vol','amount'] }, Type:'POST' }, 
                    Self:this,
                    PreventDefault:false
                };
                this.NetworkFilter(obj, function(data) 
                { 
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOveralyHistoryMinuteData(data,item);
                });

                if (obj.PreventDefault==true) continue;   //已被上层替换,不调用默认的网络请求
            }

            //请求数据
            JSNetwork.HttpRequest({
                url: this.MinuteKLineApiUrl,
                data:
                {
                    "field": ["name","symbol","yclose","open","price","high",'vol','amount'],
                    "symbol": symbol,
                    "start": -1,
                    "count": dataCount.MaxRequestMinuteDayCount
                },
                type:"post",
                dataType: "json",
                async:true,
                success: function (data)
                {
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOveralyHistoryMinuteData(data,item);
                }
            });
        }
    }

    this.RecvOveralyHistoryMinuteData=function(data,paint)
    {
        if (this.EnableVerifyRecvData && data.symbol!=paint.Symbol)
        {
            JSConsole.Chart.Warn(`[MinuteChartContainer::RecvOveralyHistoryMinuteData] recv data symbol not match. paint[${paint.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        var aryDayData=KLineChartContainer.JsonDataToMinuteHistoryData(data);
        if (!aryDayData) return;

        //原始叠加数据
        var sourceData=new ChartData();
        sourceData.Data=aryDayData;
        sourceData.DataType=1;  //0=日线数据 1=分钟数据

        var bindData=new ChartData();
        bindData.Data=aryDayData;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=1;

        var aryOverlayData=this.SourceData.GetOverlayMinuteData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
        bindData.Data=aryOverlayData;

        if (ChartData.IsMinutePeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据, API周期数据不用计算
        {
            var periodData=bindData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        paint.Data=bindData;
        paint.SourceData=sourceData;
        paint.Title=data.name;
        paint.Symbol=data.symbol;
        paint.Status=OVERLAY_STATUS_ID.STATUS_FINISHED_ID;  //数据下载完成

        this.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType=1; //调整为百份比坐标
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    this.ResetOverlaySymbolStatus=function()
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            item.Status=OVERLAY_STATUS_ID.STATUS_NONE_ID;
        }
    }

    //取消叠加股票
    this.ClearOverlaySymbol=function()
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            item.IsDelete=true;
        }

        this.OverlayChartPaint=[];
        this.TitlePaint[0].OverlayChartPaint=this.OverlayChartPaint;    //绑定叠加
        this.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType=0; //调整一般坐标
        this.UpdateFrameMaxMin();
        this.Draw();
    }

    //删除一个叠加股票
    this.DeleteOverlaySymbol=function(symbol)
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            if (item.Symbol===symbol)
            {
                item.IsDelete=true;
                this.OverlayChartPaint.splice(i,1);
                if (this.OverlayChartPaint.length<=0) this.Frame.SubFrame[0].Frame.YSplitOperator.CoordinateType=0; //调整一般坐标
                this.UpdateFrameMaxMin();
                this.Draw();
                return true;
            }
        }

        console.warn(`[KLineChartContainer::DeleteOverlaySymbol] overlay symbol=${symbol} not exist.`)
        return false;
    }

    this.RequestFlowCapitalData=function()
    {
        if (!this.Symbol) return;
        if (this.FlowCapitalReady==true) return;

        var upperSymbol=this.Symbol.toUpperCase();

        var bNeedDonloadData=true;
        if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol) || MARKET_SUFFIX_NAME.IsFutures(upperSymbol)) //数字货币, 期货 不需要下载流通股本
            bNeedDonloadData=false;

        if (this.EnableFlowCapital) //强制下载流通股
        {
            if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol)) 
            {
                if (this.EnableFlowCapital.BIT==true) bNeedDonloadData=true;
            }
        }

        if (!bNeedDonloadData)
        {
            JSConsole.Chart.Log(`[KLineChartContainer::RequestFlowCapitalData] symbol=${this.Symbol} not need download data.`);
            this.FlowCapitalReady=true;
            return;
        }

        var self = this;
        let fieldList=["name","date","symbol","capital.a"];

        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'KLineChartContainer::RequestFlowCapitalData', //类名::
                Explain:'流通股本数据',
                Request:{ Url:self.StockHistoryDayApiUrl, Data: { symbol: [this.Symbol], orderfield:'date',field:fieldList }, Type:'POST' }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.RecvFlowCapitalData(data);
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }
        
        //请求数据
        JSNetwork.HttpRequest({
            url: this.StockHistoryDayApiUrl,
            data:
            {
                "field": fieldList,
                "symbol": [this.Symbol],
                "orderfield":"date"
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvFlowCapitalData(recvData);
            }
        });
    }

    this.RecvFlowCapitalData=function(data)
    {
        if (!data.stock || data.stock.length!=1) return;

        let stock=data.stock[0];

        if (this.EnableVerifyRecvData && stock.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[MinuteChartContainer::RecvFlowCapitalData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${stock.symbol}]`);
            return;
        }

        var aryData=new Array();
        for(let i in stock.stockday)
        {
            var item=stock.stockday[i];
            let indexData=new SingleData();
            indexData.Date=item.date;
            var financeData=item.capital;
            if (!financeData) continue;
            if (financeData.a>0)
            {
                indexData.Value=financeData.a;    //流通股本（股）
                aryData.push(indexData);
            }
        }

        if (this.IsApiPeriod)
        {
            var klineData=this.ChartPaint[0].Data;
            var aryFixedData=null;
            if (ChartData.IsMinutePeriod(this.Period,true)) //分钟数据
            {
                aryFixedData=klineData.GetMinuteFittingFinanceData(aryData);
            }
            else if (ChartData.IsDayPeriod(this.Period,true)) //日线数据
            {
                aryFixedData=klineData.GetFittingFinanceData(aryData);
            }

            if (aryFixedData && klineData.Data && aryFixedData.length==klineData.Data.length)
            {
                for(var i in klineData.Data)
                {
                    var item=klineData.Data[i];
                    if (aryFixedData[i] && IFrameSplitOperator.IsNumber(aryFixedData[i].Value))
                        item.FlowCapital=aryFixedData[i].Value;
                }
            }
        }
        else
        {
            if (ChartData.IsMinutePeriod(this.Period,true)) //分钟数据
            {
                var aryFixedData=this.SourceData.GetMinuteFittingFinanceData(aryData);
                for(var i=0; i<this.SourceData.Data.length; ++i)
                {
                    var item=this.SourceData.Data[i];
                    if (aryFixedData[i] && IFrameSplitOperator.IsNumber(aryFixedData[i].Value))
                        item.FlowCapital=aryFixedData[i].Value;
                }

                var bindData=this.ChartPaint[0].Data;
                var newBindData=new ChartData();
                newBindData.Data=this.SourceData.Data;

                if (bindData.Right>0 && this.RightFormula>=1)    //复权
                {
                    var rightData=newBindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                    newBindData.Data=rightData;
                }

                if (ChartData.IsMinutePeriod(bindData.Period,false)) //周期数据
                {
                    var periodData=newBindData.GetPeriodData(bindData.Period);  
                    newBindData.Data=periodData;
                }
                bindData.Data=newBindData.Data;
            }
            else
            {
                var aryFixedData=this.SourceData.GetFittingFinanceData(aryData);
                for(let i in this.SourceData.Data)
                {
                    var item=this.SourceData.Data[i];
                    if (aryFixedData[i] && IFrameSplitOperator.IsNumber(aryFixedData[i].Value))
                        item.FlowCapital=aryFixedData[i].Value;
                }

                var bindData=this.ChartPaint[0].Data;
                var newBindData=new ChartData();
                newBindData.Data=this.SourceData.Data;

                if (bindData.Right>0)    //复权
                {
                    var rightData=newBindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                    newBindData.Data=rightData;
                }

                if (ChartData.IsDayPeriod(bindData.Period,false)) //周期数据
                {
                    var periodData=newBindData.GetPeriodData(bindData.Period);  
                    newBindData.Data=periodData;
                }

                bindData.Data=newBindData.Data;
            }
        }

        this.FlowCapitalReady=true;
        var bDraw=false;
        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName=='StockChip')
            {
                bDraw=true;
                break;
            }
        }

        if (bDraw) this.Draw();
    }

    //创建画图工具
    this.CreateChartDrawPicture=function(name, option, callback)
    {
        var drawPicture=null;
        var item=IChartDrawPicture.GetDrawPictureByName(name);
        if (item)
        {
            drawPicture=item.Create();
            if (drawPicture.ClassName=='ChartDrawPictureText' || drawPicture.ClassName=="ChartDrawVolProfile") drawPicture.HQChart=this;
        }

        if (!drawPicture)    //iconfont图标
        {
            if (IChartDrawPicture.MapIonFont.has(name))
            {
                var iconItem=IChartDrawPicture.MapIonFont.get(name);
                drawPicture=new ChartDrawPictureIconFont();
                drawPicture.FontOption.Family=iconItem.Family
                drawPicture.Text=iconItem.Text;
                if (iconItem.Color) drawPicture.LineColor=iconItem.Color;
            }
        }

        if (!drawPicture) return false;
        
        drawPicture.Canvas=this.Canvas;
        drawPicture.Status=0;
        drawPicture.Symbol=this.Symbol;
        drawPicture.Period=this.Period;
        drawPicture.Right=this.Right;
        drawPicture.Option=this.ChartDrawOption;
        
        if (callback) drawPicture.FinishedCallback=callback;    //完成通知上层回调
        if (option) drawPicture.SetOption(option);
        var self=this;
        drawPicture.Update=function()   //更新回调函数
        {
            self.DrawDynamicInfo();
        };
        drawPicture.GetActiveDrawPicture=function() { return self.GetActiveDrawPicture(); }
        this.CurrentChartDrawPicture=drawPicture;
        //JSConsole.Chart.Log("[KLineChartContainer::CreateChartDrawPicture] ", name,this.CurrentChartDrawPicture);
        return true;
    }

    this.AddChartDrawPicture=function(obj)
    {
        if (!obj) return null;
        if (obj.FrameID<0 || obj.FrameID>=this.Frame.SubFrame.length) return null;
        var self=this;
        var item=IChartDrawPicture.GetDrawPictureByClassName(obj.ClassName);
        if (!item) return null;
        var drawPicture=item.Create();

        drawPicture.Canvas=this.Canvas;
        drawPicture.Status=10;
        drawPicture.Frame=this.Frame.SubFrame[obj.FrameID].Frame;  //绑定框架坐标
        drawPicture.Symbol=this.Symbol;
        drawPicture.Period=this.Period;
        drawPicture.Right=this.Right;
        drawPicture.Option=this.ChartDrawOption;
        if (obj.Value) drawPicture.Value=obj.Value;
        if (obj.Guid) drawPicture.Guid=obj.Guid;

        if (drawPicture.ImportStorageData) drawPicture.ImportStorageData(obj);
        drawPicture.SetOption(obj);

        if (obj.EnableUpdateXValue) drawPicture.UpdateXValue();
        drawPicture.ValueToPoint();

        drawPicture.GetActiveDrawPicture=function() { return self.GetActiveDrawPicture(); }

        if (drawPicture.ClassName==='ChartDrawPictureText') drawPicture.IsInitialized=true;
        this.ChartDrawPicture.push(drawPicture);

        this.DrawDynamicInfo();

        return drawPicture;
    }

    this.PasteChartDrawPicture=function(data, frameID, option)
    {
        if (!data || !data.ClassName) return null;
        if (frameID<0 || frameID>=this.Frame.SubFrame.length) return null;

        var item=IChartDrawPicture.GetDrawPictureByClassName(data.ClassName);
        if (!item) return null;
        var drawPicture=item.Create();
        if (!drawPicture) return null;

        var self=this;

        drawPicture.Canvas=this.Canvas;
        drawPicture.Status=10;
        drawPicture.Frame=this.Frame.SubFrame[frameID].Frame;  //绑定框架坐标
        drawPicture.Symbol=this.Symbol;
        drawPicture.Period=this.Period;
        drawPicture.Right=this.Right;
        drawPicture.Option=this.ChartDrawOption;
        drawPicture.GetActiveDrawPicture=function() { return self.GetActiveDrawPicture(); }

        if (drawPicture.SetOption) drawPicture.SetOption(data);

        this.RandomDrawPictureValue(drawPicture, data);
        drawPicture.PointToValue();

        if (drawPicture.ClassName==='ChartDrawPictureText') drawPicture.IsInitialized=true;
        this.ChartDrawPicture.push(drawPicture);

        //存盘
        if (this.ChartDrawStorage) this.ChartDrawStorage.SaveDrawData(drawPicture);

        this.DrawDynamicInfo();

        return drawPicture;
    }

    //随机生成画图的点
    this.RandomDrawPictureValue=function(chart, data)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Value)) return;
        var kData=this.GetKLineChart();
        if (!kData || !kData.Data || !IFrameSplitOperator.IsNumber(kData.Data.DataOffset) || kData.Data.DataOffset<0) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(kData.Data.Data)) return null;

        var aryKData=kData.Data.Data;
        var startIndex=kData.Data.DataOffset;
        var endIndex=kData.Data.DataOffset+kData.ChartFrame.XPointCount-1;
        if (endIndex>=aryKData.length) endIndex=aryKData.length-1;
        var frameHeight=chart.Frame.ChartBorder.GetHeight();

        var max=chart.Frame.HorizontalMax;
        var min=chart.Frame.HorizontalMin;

        var y=chart.Frame.ChartBorder.GetBottomEx()-(frameHeight)*data.YFristScale;

        const range={Max:5, Min:2};
        const xRandomOffset=Math.floor(Math.random() * (range.Max - range.Min + 1)) + range.Min;

        var xValue=data.Value[0].XIndex+xRandomOffset;

        var firstPoint=null;
        chart.Value=[];
        for(var i=0; i<data.Value.length; ++i)
        {
            var item=data.Value[i];
            chart.Value[i]=
            {
                XValue:xValue+item.XOffset,
            }

            chart.Point[i]=
            {
                Y:y+item.YOffset,
                X:chart.Frame.GetXFromIndex((xValue+item.XOffset),false)
            }
        }
    }

    //xStep,yStep 移动的偏移量
    this.MoveChartDrawPicture=function(x,y,isPhone,drag)
    {
        var drawPicture=this.CurrentChartDrawPicture;
        if (!drawPicture) return false;

        var pixelTatio = GetDevicePixelRatio(); //x,y 需要乘以放大倍速
        if (isPhone) pixelTatio=1;
        var xStep=x*pixelTatio;
        var yStep=y*pixelTatio;
        //JSConsole.Chart.Log("xStep="+xStep+" yStep="+yStep);
        drawPicture.Move(xStep,yStep,drag);

        return true;
    }


    //数据长度变化 需要更新画图工具X轴索引
    this.UpdateChartDrawXValue=function()
    {
        for(var i in this.ChartDrawPicture)
        {
            var item=this.ChartDrawPicture[i];
            item.UpdateXValue();
        }
    }

    //注册鼠标右键事件
    this.OnRightMenu=function(x,y,e)
    {
        var pixelTatio = GetDevicePixelRatio(); //x,y 需要乘以放大倍速
        var frameId=this.Frame.PtInFrame(x*pixelTatio,y*pixelTatio);
        this.PopupRightMenuV2({X:e.offsetX, Y:e.offsetY, FrameID:frameId}, e);
        
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CONTEXT_MENU);
        if (event)
        {
            var data={ X:x, Y:y, Event:e, FrameID:frameId };
            event.Callback(event,data,this);
        }
    }

    //右键菜单数据
    this.GetRightMenuData=function(frameID)
    {
        var windowCount=this.Frame.SubFrame.length; //窗口个数
        var klineChart=this.ChartPaint[0];
        var klineType=klineChart.DrawType;
        var bThinAKBar=klineChart.IsThinAKBar;
        var priceGap=klineChart.PriceGap;                   //缺口配置信息
        var coordinateType=null, yCoordinateType=null;      //坐标类型
        var mainFrame=null;
        if (this.Frame.SubFrame[0] && this.Frame.SubFrame[0].Frame) mainFrame=this.Frame.SubFrame[0].Frame;
        if (mainFrame) 
        {
            coordinateType=mainFrame.CoordinateType;
            if (mainFrame.YSplitOperator) yCoordinateType=mainFrame.YSplitOperator.CoordinateType;
        }

        var aryKLineInfo=[];    //信息地雷
        for(var i=0;i<this.ChartInfo.length;++i)
        {
            var item=this.ChartInfo[i];
            if (item && item.ClassName) aryKLineInfo.push(item.ClassName);
        }

        var aryOverlaySymbol=[];    //叠加的股票列表
        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            if (item && item.Symbol) aryOverlaySymbol.push(item.Symbol)
        }

        var bBGSpit=false, bShowStockChip=false;
        if (this.GetExtendChartByClassName("SessionBreaksPaint")) bBGSpit=true;
        if (this.GetExtendChartByClassName('StockChip')) bShowStockChip=true;       //筹码

        var bShowCorss=false;   //十字光标十字线
        if (this.ChartCorssCursor) bShowCorss=this.ChartCorssCursor.IsShowCorss;

        var bPopMinuteChart=false;
        if (this.PopMinuteChart) bPopMinuteChart=true;

        var aryMenu=
        [
            { 
                Name:"分析周期", 
                SubMenu:
                [
                    { Name:"日线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[0] }, Checked:this.Period==0 },
                    { Name:"周线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[1] }, Checked:this.Period==1 },
                    { Name:"双周线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[21]}, Checked:this.Period==21   },
                    { Name:"月线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[2]}, Checked:this.Period==2 },
                    { Name:"季线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[9]}, Checked:this.Period==9  },
                    { Name:"半年", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[22]}, Checked:this.Period==22  },
                    { Name:"年线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[3]}, Checked:this.Period==3  },
                    { Name:"1分", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[4]}, Checked:this.Period==4  },
                    { Name:"5分", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[5]}, Checked:this.Period==5  },
                    { Name:"15分", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[6]}, Checked:this.Period==6  },
                    { Name:"30分", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[7]}, Checked:this.Period==7  },
                    { Name:"60分", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[8]}, Checked:this.Period==8  },
                    { Name:"2小时", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[11]}, Checked:this.Period==11  },
                    { Name:"4小时", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[12]}, Checked:this.Period==12  },
                    { Name:"分笔", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[10]}, Checked:this.Period==10  },
                    { Name:"自定义周期:3分钟", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[20003]}, Checked:this.Period==20003  },
                    { Name:"自定义周期:35分钟", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[20035]}, Checked:this.Period==20035  },
                    { Name:"自定义周期:8日", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_PERIOD_ID, Args:[40008]}, Checked:this.Period==40008  },
                ]
            },
            { 
                Name:"指标切换", 
                SubMenu:
                [
                    { Name:"均线", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "均线"]}},
                    { Name:"BOLL", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "BOLL"]}},
                    { Name:"MACD", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "MACD"]}},
                    { Name:"MACD(粗)", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "MACD2"]}},
                    { Name:"KDJ", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "KDJ"]}},
                    { Name:"VOL", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "VOL"]}},
                    { Name:"RSI", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "RSI"]}},
                    { Name:"BRAR", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "BRAR"]}},
                    { Name:"WR", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "WR"]}},
                ]
            },
            { 
                Name:"五彩K线", 
                SubMenu:
                [
                    { Name:"十字星", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID, Args:["五彩K线-十字星"]}},
                    { Name:"早晨之星", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID, Args:["五彩K线-早晨之星"]}},
                    { Name:"垂死十字", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID, Args:["五彩K线-垂死十字"]}},
                    { Name:"三只乌鸦", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID, Args:["五彩K线-三只乌鸦"]}},
                    { Name:"光脚阴线", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID, Args:["五彩K线-光脚阴线"]}},
                    { Name:"黄昏之星", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COLOR_INDEX_ID, Args:["五彩K线-黄昏之星"]}},
                ]

            },
            { 
                Name:"专家系统", 
                SubMenu:
                [
                    { Name:"BIAS", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID, Args:["交易系统-BIAS"]}},
                    { Name:"CCI", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID, Args:["交易系统-CCI"]}},
                    { Name:"DMI", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID, Args:["交易系统-DMI"]}},
                    { Name:"KD", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID, Args:["交易系统-KD"]}},
                    { Name:"BOLL", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID, Args:["交易系统-BOLL"]}},
                    { Name:"KDJ", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_TRADE_INDEX_ID, Args:["交易系统-KDJ"]}},
                ]
            },
            { 
                Name:"信息地雷", 
                SubMenu:
                [
                    { Name:"公告", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID, Args:["公告", !aryKLineInfo.includes("AnnouncementInfo")]}, Checked:aryKLineInfo.includes("AnnouncementInfo") },
                    { Name:"业绩预告", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID, Args:["业绩预告", !aryKLineInfo.includes("PforecastInfo")]}, Checked:aryKLineInfo.includes("PforecastInfo") },
                    { Name:"调研", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID, Args:["调研", !aryKLineInfo.includes("ResearchInfo") ]}, Checked:aryKLineInfo.includes("ResearchInfo") },
                    { Name:"大宗交易", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID, Args:["大宗交易", !aryKLineInfo.includes("BlockTrading")]}, Checked:aryKLineInfo.includes("BlockTrading") },
                    { Name:"龙虎榜", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID, Args:["龙虎榜", !aryKLineInfo.includes("TradeDetail")]}, Checked:aryKLineInfo.includes("TradeDetail") },
                    { Name:"互动易", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_INFO_ID, Args:["互动易", !aryKLineInfo.includes("InvestorInfo")]}, Checked:aryKLineInfo.includes("InvestorInfo") },
                ]
            },
            { 
                Name:"缺口提示", 
                SubMenu:
                [
                    { Name:"显示1个缺口", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_PRICE_GAP_ID, Args:[true, 1]}, Checked:(priceGap.Enable==true && priceGap.Count==1) },
                    { Name:"显示2个缺口", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_PRICE_GAP_ID, Args:[true, 2]}, Checked:(priceGap.Enable==true && priceGap.Count==2) },
                    { Name:"显示3个缺口", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_PRICE_GAP_ID, Args:[true, 3]}, Checked:(priceGap.Enable==true && priceGap.Count==3) },
                    { Name:"隐藏缺口", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_PRICE_GAP_ID, Args:[false]}, Checked:priceGap.Enable==false },
                ]
            },
            { 
                Name:"叠加品种", 
                SubMenu:
                [
                    { Name:"上证指数", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["000001.sh", !aryOverlaySymbol.includes("000001.sh")]}, Checked:aryOverlaySymbol.includes("000001.sh") },
                    { Name:"深证成指", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["399001.sz", !aryOverlaySymbol.includes("399001.sz")]}, Checked:aryOverlaySymbol.includes("399001.sz") },
                    { Name:"中小板指", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["399005.sz", !aryOverlaySymbol.includes("399005.sz")]}, Checked:aryOverlaySymbol.includes("399005.sz") },
                    { Name:"创业板指", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["399006.sz", !aryOverlaySymbol.includes("399006.sz")]}, Checked:aryOverlaySymbol.includes("399006.sz") },
                    { Name:"沪深300", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["000300.sh", !aryOverlaySymbol.includes("000300.sh")]}, Checked:aryOverlaySymbol.includes("000300.sh")},
                ]
            },
            { 
                Name:"主图线型", 
                SubMenu:
                [
                    { Name:"K线(空心阳线)", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[3]}, Checked:klineType==3 },
                    { Name:"K线(实心阳线)", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[0]}, Checked:klineType==0 },
                    { Name:"美国线", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[2, true, { IsThinAKBar:false }]}, Checked:(klineType==2&&!bThinAKBar) },
                    { Name:"美国线(细)", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[2, true, { IsThinAKBar:true }]}, Checked:(klineType==2&&bThinAKBar) },
                    { Name:"收盘线", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[1]}, Checked:klineType==1},
                    { Name:"收盘面积", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[4]}, Checked:klineType==4 },
                    { Name:"K线(空心阳线阴线)", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[6]}, Checked:klineType==6 },
                    { Name:"Heikin Ashi", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[11]}, Checked:klineType==11 },
                    { Name:"Line Break", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[12]}, Checked:klineType==12 },
                    { Name:"High-low", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[13]}, Checked:klineType==13 },
                    { Name:"HLC Area", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_KLINE_TYPE_ID, Args:[15]}, Checked:klineType==15 },
                ]
            },
            { 
                Name:"坐标类型", 
                SubMenu:
                [
                    { Name:"反转坐标", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ IsReverse:coordinateType==0 }]}, Checked:coordinateType==1 },
                    { Name:JSPopMenu.SEPARATOR_LINE_NAME },

                    { Name:"普通坐标", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ Type:0 }]}, Checked:yCoordinateType==0 },
                    { Name:"百分比坐标", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ Type:1 }]}, Checked:yCoordinateType==1 },
                    { Name:"对数坐标", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ Type:2 }]}, Checked:yCoordinateType==2 },
                    { Name:"等比坐标", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ Type:3 }]}, Checked:yCoordinateType==3 },
                    { Name:"等分坐标", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ Type:4 }]}, Checked:yCoordinateType==4 },
                    { Name:"黄金分割", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_COORDINATETYPE_ID, Args:[{ Type:5 }]}, Checked:yCoordinateType==5},

                ]
            },
            { 
                Name:"指标窗口个数",
                SubMenu:
                [
                    { Name:"1个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[2]}, Checked:2==windowCount },
                    { Name:"2个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[3]}, Checked:3==windowCount },
                    { Name:"3个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[4]}, Checked:4==windowCount },
                    { Name:"4个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[5]}, Checked:5==windowCount },
                    { Name:"5个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[6]}, Checked:6==windowCount },
                ]
            },
            {
                Name:"其他设置",
                SubMenu:
                [
                    
                    { Name:"禁止拖拽", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_MODE_ID, Args:[0]}, Checked:0==this.DragMode },
                    { Name:"启动拖拽", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_MODE_ID, Args:[1]}, Checked:1==this.DragMode },
                    { Name:"左键区间选择", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_MODE_ID, Args:[2]}, Checked:2==this.DragMode },
                    { Name:JSPopMenu.SEPARATOR_LINE_NAME },

                    { Name:"背景分割", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_BG_SPLIT_ID, Args:[!bBGSpit]}, Checked:bBGSpit},

                    { Name:"画图工具", Data:{ ID:JSCHART_MENU_ID.CMD_SHOW_DRAWTOOL_ID, Args:[]}, Checked:this.IsShowDrawToolDialog() },

                    { Name:"移动筹码图", Data:{ ID:bShowStockChip?JSCHART_MENU_ID.CMD_HIDE_STOCKCHIP_ID:JSCHART_MENU_ID.CMD_SHOW_STOCKCHIP_ID, Args:[]}, Checked:bShowStockChip},

                    { Name:"十字光标线", Data:{ ID:JSCHART_MENU_ID.CMD_SHOW_CORSS_LINE_ID, Args:[!bShowCorss]}, Checked:bShowCorss },

                    { Name:"双击弹分时图", Data:{ ID:JSCHART_MENU_ID.CMD_ENABLE_POP_MINUTE_CHART_ID, Args:[!bPopMinuteChart]}, Checked:bPopMinuteChart},

                    { Name:JSPopMenu.SEPARATOR_LINE_NAME },
                    { 
                        Name:"鼠标形状", 
                        SubMenu:
                        [
                            { Name:"默认", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DEFAULTCURSOR_ID, Args:["default"]}, Checked:this.DefaultCursor=="default" },
                            { Name:"十字线", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DEFAULTCURSOR_ID, Args:["crosshair"]}, Checked:this.DefaultCursor=="crosshair" },
                        ]
                    },
                    { 
                        Name:"语言设置", 
                        SubMenu:
                        [
                            { Name:"中文", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID, Args:["CN"]}, Checked:this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID  },
                            { Name:"英语", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID, Args:["EN"]}, Checked:this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID },
                            { Name:"繁体", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID, Args:["TC"]}, Checked:this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID },
                        ]
                    },
                    {
                        Name:"区间选择样式", 
                        SubMenu:
                        [
                            { Name:"样式1(默认)", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID, Args:[0]}, Checked:0==this.ChartDragSelectRect.ShowMode },
                            { Name:"样式2", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID, Args:[1]}, Checked:1==this.ChartDragSelectRect.ShowMode },
                            { Name:"样式3", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID, Args:[2]}, Checked:2==this.ChartDragSelectRect.ShowMode },
                        ]
                    }
                ]
            }
        ];

        //复权
        if(!MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol) && !MARKET_SUFFIX_NAME.IsBIT(this.Symbol))
        {
            var rightMenu=
            {
                Name:"复权处理",
                SubMenu:
                [
                    { Name:"不复权", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_RIGHT_ID, Args:[0]}, Checked:0==this.Right },
                    { Name:"前复权", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_RIGHT_ID, Args:[1]}, Checked:1==this.Right },
                    { Name:"后复权", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_RIGHT_ID, Args:[2]}, Checked:2==this.Right }
                ]
            };

            aryMenu.splice(1,0,rightMenu);
        }

        //删除菜单
        for(var i=0;i<aryMenu.length;++i)
        {
            var item=aryMenu[i];
            if (item.Name=="五彩K线")
            {
                if (this.ColorIndex) 
                {   
                    item.SubMenu.push({ Name:JSPopMenu.SEPARATOR_LINE_NAME });
                    item.SubMenu.push({ Name:"删除五彩K线", Data:{ ID: JSCHART_MENU_ID.CMD_DELETE_COLOR_INDEX_ID} });
                }
            }
            else if (item.Name=="专家系统")
            {
                if (this.TradeIndex) 
                {
                    item.SubMenu.push({ Name:JSPopMenu.SEPARATOR_LINE_NAME });
                    item.SubMenu.push({ Name:"删除专家系统", Data:{ ID: JSCHART_MENU_ID.CMD_DELETE_TRADE_INDEX_ID} });
                }
            }
            else if (item.Name=="叠加品种")
            {
                for(var j=0;j<item.SubMenu.length;++j)
                {
                    if (item.SubMenu[j].Checked)
                    {
                        item.SubMenu.push({ Name:JSPopMenu.SEPARATOR_LINE_NAME });
                        item.SubMenu.push({ Name:"取消叠加", Data:{ ID: JSCHART_MENU_ID.CMD_DELETE_ALL_OVERLAY_SYMBOL_ID} });
                        break;
                    }
                }
            }
            else if (item.Name=="信息地雷")
            {
                for(var j=0;j<item.SubMenu.length;++j)
                {
                    if (item.SubMenu[j].Checked)
                    {
                        item.SubMenu.push({ Name:JSPopMenu.SEPARATOR_LINE_NAME });
                        item.SubMenu.push({ Name:"删除所有", Data:{ ID: JSCHART_MENU_ID.CMD_DELETE_ALL_KLINE_INFO_ID} });
                        break;
                    }
                }
            }
        }

        return aryMenu;
    }



    this.PopupSelectRectMenuV2=function(data, e)
    {
        var aryMenu=
        [
            { Name:"区间统计", Data:{ ID:JSCHART_MENU_ID.CMD_SELECTED_SUMMARY_ID, Args:[e] }},
            { Name:"区间放大", Data:{ ID:JSCHART_MENU_ID.CMD_SELECTED_ZOOM_ID, Args:[data.SelectData] }}
        ];
        
        var menuData={ Menu:aryMenu, Position:JSPopMenu.POSITION_ID.RIGHT_MENU_ID };
        menuData.ClickCallback=(data)=>{ this.OnClickRightMenu(data); }
        var x=data.X, y=data.Y;
        this.PopupMenuByRClick(menuData, x, y);
    }

    //重新加载画图工具(切换股票|周期)
    this.ReloadChartDrawPicture=function()
    {
        this.ChartDrawPicture=[];
        if (this.SelectChartDrawPicture)  this.SelectChartDrawPicture.IsSelected=false; 
        this.SelectChartDrawPicture=null;
        this.CurrentChartDrawPicture=null;

        if (this.ChartDrawStorage)
        {
            this.ChartDrawStorageCache=this.ChartDrawStorage.GetDrawData( {Symbol:this.Symbol, Period:this.Period} );
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_LOAD_DRAWPICTURE);
            if (event && event.Callback)
            {
                var sendData={ Symbol:this.Symbol, Period:this.Period, DrawStorage:this.ChartDrawStorage, ChartDrawStorageCache:this.ChartDrawStorageCache };
                event.Callback(event,sendData,this);
            }
        }
    }

    this.CreateChartDrawPictureByStorage=function() //把缓存(this.ChartDrawStorageCache) 画图工具创建出来
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.ChartDrawStorageCache)) return;

        for(var i=0; i<this.ChartDrawStorageCache.length; ++i)
        {
            var item=this.ChartDrawStorageCache[i];
            if (item.FrameID<0 || !this.Frame.SubFrame || this.Frame.SubFrame.length<item.FrameID) continue;

            var drawPicture=IChartDrawPicture.CreateChartDrawPicture(item);
            if (!drawPicture) continue;

            drawPicture.Canvas=this.Canvas;
            drawPicture.Status=10;
            drawPicture.Frame=this.Frame.SubFrame[item.FrameID].Frame;  //绑定框架坐标
            drawPicture.Option=this.ChartDrawOption;
            
            if (drawPicture.ImportStorageData) drawPicture.ImportStorageData(item);
            drawPicture.UpdateXValue();
            drawPicture.ValueToPoint();

            var self=this;
            drawPicture.GetActiveDrawPicture=function() { return self.GetActiveDrawPicture(); }

            if (drawPicture.ClassName==='ChartDrawPictureText') drawPicture.IsInitialized=true;

            this.ChartDrawPicture.push(drawPicture);
        }

        this.ChartDrawStorageCache=null;    //清空缓存
    }

    //形态匹配
    // scope.Plate 板块范围 scope.Symbol 股票范围
    // sample 样本数据
    this.RequestKLineMatch=function(sample,param)
    {
        var self =this;
        var scope=param.Scope;
        var waitDailog=param.WaitDialog;
        JSConsole.Chart.Log('[KLineChartContainer::RequestKLineMatch',sample,scope)

        var aryDate=new Array();
        var aryValue=new Array();

        for(var i=sample.Start;i<sample.End && i<sample.Data.Data.length;++i)
        {
            var item=sample.Data.Data[i];
            aryDate.push(item.Date);
            aryValue.push(item.Close);
        }

        var sampleData=
        {
            Stock:sample.Stock,
            Index:{Start:sample.Start, End:sample.End}, //数据索引
            Date:{Start:aryDate[0], End:aryDate[aryDate.length-1]}, //起始 结束日期
            Minsimilar:scope.Minsimilar,    //相似度
            Plate:scope.Plate,
            DayRegion:300
        };

        //请求数据
        $.ajax({
            url: this.KLineMatchUrl,
            data:
            {
                "userid": "guest",
                "plate": scope.Plate,
                "period": this.Period,
                "right": this.Right,
                "dayregion": sampleData.DayRegion,
                "minsimilar": scope.Minsimilar,
                "sampledate":aryDate,
                "samplevalue":aryValue
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                if (waitDailog) waitDailog.Close();
                self.RecvKLineMatchData(data,sampleData);
            },
            error:function(jqXHR, textStatus, errorThrown)
            {
                console.warn('[KLineChartContainer::RequestKLineMatch] failed',jqXHR,textStatus, errorThrown);
                if (waitDailog) waitDailog.Close();
            }
        });
    }

    //接收形态选股结果
    this.RecvKLineMatchData=function(data,sample)
    {
        JSConsole.Chart.Log('[KLineChartContainer::RecvKLineMatchData] recv',data,sample);
        var filterData=[]; //结果数据
        for(var i in data.match)
        {
            var item=data.match[i];
            if (item.symbol==sample.Stock.Symbol) continue;

            for(var j in item.data)
            {
                var dataItem=item.data[j];
                var newItem={Symbol:item.symbol, Name:item.name,Similar:dataItem.similar, Start:dataItem.start, End:dataItem.end};
                filterData.push(newItem);
            }
        }
        filterData.sort(function(a,b){return b.Similar-a.Similar;});    //排序
        JSConsole.Chart.Log('[KLineChartContainer::RecvKLineMatchData] filterData',filterData);

        if (this.mapEvent.has(JSCHART_EVENT_ID.RECV_KLINE_MATCH))
        {
            var item=this.mapEvent.get(JSCHART_EVENT_ID.RECV_KLINE_MATCH);
            var data={Sample:sample, Match:filterData, Source:data}
            item.Callback(item,data,this);
        }
        else
        {
            var dlg=new KLineMatchDialog(this.Frame.ChartBorder.UIElement.parentNode);

            var event={ data:{ Chart:this, MatchData:filterData, Sample:sample, Source:data} };
            dlg.DoModal(event);
        } 
    }

    //更新信息地雷
    this.UpdataChartInfo=function()
    {
        //TODO: 根据K线数据日期来做map, 不在K线上的合并到下一个k线日期里面
        var mapInfoData=null;
        if (this.Period==0) //日线数据 根据日期
        {
            mapInfoData=new Map();
            for(var i in this.ChartInfo)
            {
                var infoData=this.ChartInfo[i].Data;
                for(var j in infoData)
                {
                    var item=infoData[j];
                    if (mapInfoData.has(item.Date.toString()))
                    {
                        mapInfoData.get(item.Date.toString()).Data.push(item);
                    }
                    else
                    {
                        mapInfoData.set(item.Date.toString(),{Data:new Array(item)});
                    }
                }
            }
        }
        else if (ChartData.IsDayPeriod(this.Period,false))
        {
            mapInfoData=new Map();
            var hisData=this.ChartPaint[0].Data;
            if (hisData && hisData.Data && hisData.Data.length>0)
            {
                var fristKItem=hisData.Data[0];
                var aryInfo=[];
                for(var i in this.ChartInfo)
                {
                    var infoItem=this.ChartInfo[i];
                    for(var j in infoItem.Data)
                    {
                        var item=infoItem.Data[j];
                        if (item.Date>=fristKItem.Date) //在K线范围内的才显示
                            aryInfo.push(item);
                    }
                }
                aryInfo.sort(function(a,b) { return a.Date-b.Date });   //排序

                for(var i=0;i<hisData.Data.length;)
                {
                    var kItem=hisData.Data[i];  //K线数据

                    if (aryInfo.length<=0) 
                        break;

                    var infoItem=aryInfo[0];
                    if (kItem.Date<infoItem.Date) 
                    {
                        ++i;
                        continue;
                    }
                    
                    if (mapInfoData.has(kItem.Date.toString())) //信息地雷日期<K线上的日期 就是属于这个K线上的
                    {
                        mapInfoData.get(kItem.Date.toString()).Data.push(infoItem);
                    }
                    else
                    {
                        mapInfoData.set(kItem.Date.toString(),{Data:new Array(infoItem)});
                    }

                    aryInfo.shift();
                    //JSConsole.Chart.Log('[KLineChartContainer::UpdataChartInfo]',item);
                }
            }
        }
        else if (ChartData.IsMinutePeriod(this.Period, true))
        {
            mapInfoData=new Map();
            var hisData=this.ChartPaint[0].Data;
            if (hisData && hisData.Data && hisData.Data.length>0)
            {
                var firstKItem=hisData.Data[0];
                var aryInfo=[];
                for(var i=0, j=0; i<this.ChartInfo.length; ++i)
                {
                    var infoItem=this.ChartInfo[i];
                    for(j=0; j<infoItem.Data.length; ++j)
                    {
                        var item=infoItem.Data[j];
                        if (item.Date>=firstKItem.Date || (item.Date==firstKItem.Date && item.Time>=firstKItem.Time)) //在K线范围内的才显示
                            aryInfo.push(item);
                    }
                }

                aryInfo.sort(function(a,b) 
                { 
                    if (a.Date==b.Date) return a.Time-b.Time;
                    return a.Date-b.Date 
                });   //排序

                for(var i=0;i<hisData.Data.length;)
                {
                    var kItem=hisData.Data[i];  //K线数据

                    if (aryInfo.length<=0) 
                        break;

                    var infoItem=aryInfo[0];
                    if (kItem.Date<infoItem.Date || (kItem.Date==infoItem.Date && kItem.Time<infoItem.Time)) 
                    {
                        ++i;
                        continue;
                    }

                    var key=`${kItem.Date}-${kItem.Time}`;
                    if (mapInfoData.has(key)) //信息地雷日期<K线上的日期 就是属于这个K线上的
                    {
                        mapInfoData.get(key).Data.push(infoItem);
                    }
                    else
                    {
                        mapInfoData.set(key,{Data:new Array(infoItem)});
                    }

                    aryInfo.shift();
                    //JSConsole.Chart.Log('[KLineChartContainer::UpdataChartInfo]',item);
                }
            }
        }
            
        var klinePaint=this.ChartPaint[0];
        klinePaint.InfoData=mapInfoData;
    }

    //接收到窗口指标数据 订阅模式
    this.RecvWindowIndex=function(index, data)
    {
        var indexItem=this.WindowIndex[index];
        if (!indexItem) return;

        if (typeof(indexItem.RecvSubscribeData)=="function")
        {
            var hisData=this.ChartPaint[0].Data;
            indexItem.RecvSubscribeData(data,this,index,hisData);
        }
    }

    //更新窗口指标
    this.UpdateWindowIndex=function(index)
    {
        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;

        if (this.IsApiPeriod)
        {

        }
        else
        {
            if (bindData.Right>0)    //复权
            {
                var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                bindData.Data=rightData;
            }

            if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }
        }

        if (typeof(this.WindowIndex[index].ExecuteScript)=='function')
        {
            var hisData=this.ChartPaint[0].Data;
            this.WindowIndex[index].ExecuteScript(this,index,hisData);
        }
        else if (typeof(this.WindowIndex[index].RequestData)=="function")  //数据需要另外下载的.
        {
            var hisData=this.ChartPaint[0].Data;
            this.WindowIndex[index].RequestData(this, index, hisData, null);
        }
        else
        {
            this.WindowIndex[index].BindData(this,index,bindData);
        }

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.GetOverlayIndexByIdentify=function(identify)
    {
        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            if (!IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex)) continue;

            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Identify===identify)
                    return { OverlayItem:overlayItem, WindowIndex:i };
            }
        }

        return null;
    }

    this.RecvOverlayIndex=function(identify, data)
    {
        var overlayIndex=this.GetOverlayIndexByIdentify(identify);
        if (overlayIndex==null) 
        {
            console.warn(`[KLineChartContainer::RecvOverlayIndex] can't find overlay index. [identify=${identify}]`);
            return;
        }

        if (!overlayIndex.Script) return;
        if (typeof(overlayIndex.RecvSubscribeData)!="function") return;

        if (!this.ChartPaint[0]) return;
        var kData=this.ChartPaint[0].Data;
        if (!kData) return;

        overlayIndex.Script.RecvSubscribeData(data,this,overlayIndex.WindowIndex,kData);
    }

    //更新叠加指标
    this.UpdateOverlayIndex=function(identify)
    {
        var overlayIndex=this.GetOverlayIndexByIdentify(identify);

        if (overlayIndex==null) 
        {
            console.warn(`[KLineChartContainer::UpdateOverlayIndex] can't find overlay index. [identify=${identify}]`);
            return;
        }

        if (!this.ChartPaint[0]) return;
        var kData=this.ChartPaint[0].Data;
        if (!kData) return;

        this.BindOverlayIndexData(overlayIndex.OverlayItem, overlayIndex.WindowIndex, kData);
    }

    //修改参数指标
    this.ChangeWindowIndexParam=function(index)
    {
        this.WindowIndex[index].Index[0].Param+=1;
        this.WindowIndex[index].Index[1].Param+=1;

        this.UpdateWindowIndex(index);
    }


    this.OnDoubleClick=function(x,y,e)
    {
        if (this.EnableYDrag && (this.EnableYDrag.Left || this.EnableYDrag.Right) && this.Frame && this.Frame.PtInFrameY)
        {
            var pixelTatio = GetDevicePixelRatio();
            var x = (e.clientX-this.UIElement.getBoundingClientRect().left)*pixelTatio;
            var y = (e.clientY-this.UIElement.getBoundingClientRect().top)*pixelTatio;
            var dragY=this.Frame.PtInFrameY(x,y);
            if (dragY && dragY.Index>=0)
            {
                this.CancelZoomUpDownFrameY(dragY);
            }
        }
       
        var selectedChart;   //图形选中
        if (this.SelectedChart.EnableSelected)
        {
            selectedChart=this.PtInChart(x,y);
        }

        var dbClickInfo={ SelectedChart:selectedChart };
        this.DBClickEvent(dbClickInfo, e);
        
        if (!selectedChart && this.EnableZoomIndexWindow)   //双击放大缩小
        {
            var frameId=this.Frame.PtInFrame(x,y);
            JSConsole.Chart.Log("[KLineChartContainer::OnDoubleClick] frameId",frameId);
            if (frameId>=this.Frame.ZoomStartWindowIndex)
            {
                if (this.ZoomIndexWindow(frameId, {X:x, Y:y}))
                {
                    this.Frame.SetSizeChage(true);
                    this.Draw();
                    return true;
                }
            }
        }

        var tooltip=new TooltipData();
        if (!this.PtInChartPaintTooltip(x,y,tooltip)) return;
        if (!tooltip.Data) return;

        var event=null;
        if (this.mapEvent.has(JSCHART_EVENT_ID.DBCLICK_KLINE)) event=this.mapEvent.get(JSCHART_EVENT_ID.DBCLICK_KLINE);
        if (event)
        {
            if (this.ClickChartTimer!=null) //清空单击定时器
            {
                clearTimeout(this.ClickChartTimer);
                this.ClickChartTimer=null;
            }
            
            var data={ Tooltip:tooltip, Stock:{Symbol:this.Symbol, Name:this.Name }, X:e.clientX, Y:e.clientY, PreventDefault:false };
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }

        //内置弹分时图
        if (!this.PopMinuteChart) return;

        this.ShowMinuteChartDialog({ Chart:this,Tooltip:tooltip, e:e }, x,y);
    }

    this.CancelAutoUpdate=function()    //关闭停止更新
    {
        if (typeof (this.AutoUpdateTimer) == 'number') 
        {
            clearTimeout(this.AutoUpdateTimer);
            this.AutoUpdateTimer = undefined;
        }
    }

    //数据自动更新
    this.AutoUpdate=function(waitTime)  //waitTime 更新时间
    {
        this.CancelAutoUpdate();
        if (!this.IsAutoUpdate) return;
        if (!this.Symbol) return;

        var self = this;
        var marketStatus=MARKET_SUFFIX_NAME.GetMarketStatus(this.Symbol);
        if (marketStatus==0 || marketStatus==3)  //闭市,盘后
        {   //等待开盘
            this.AutoUpdateTimer=setTimeout(function() 
            { 
                self.AutoUpdate(); 
            },20000);
            return; 
        }

        var frequency=this.AutoUpdateFrequency;
        if (marketStatus==1) //盘前
        {
            this.AutoUpdateTimer=setTimeout(function() 
            { 
                self.AutoUpdate(); 
            },frequency);
        }
        else if (marketStatus==2) //盘中
        {
            this.AutoUpdateTimer=setTimeout(function()
            {
                if (ChartData.IsDayPeriod(self.Period,true))
                {
                    self.RequestRealtimeData();               //更新最新行情
                    //self.ReqeustKLineInfoData();
                }
                else if (ChartData.IsMinutePeriod(self.Period,true) || ChartData.IsSecondPeriod(self.Period) || ChartData.IsMilliSecondPeriod(self.Period))
                {
                    self.RequestMinuteRealtimeData();         //请求分钟数据
                }  
                else if (ChartData.IsTickPeriod(self.Period))
                {
                    self.RequestTickRealtimeData();           //请求最新分笔
                }
            },frequency);
        }
    }

    this.GetMaxMinPageSize = function () 
    {
        let pageSize={};
        let width = this.Frame.ChartBorder.GetWidth();
        let barWidth = (ZOOM_SEED[ZOOM_SEED.length - 1][0] + ZOOM_SEED[ZOOM_SEED.length - 1][1]);
        pageSize.Max=parseInt(width / barWidth) - 2;

        barWidth= (ZOOM_SEED[0][0] + ZOOM_SEED[0][1]);
        pageSize.Min=parseInt(width / barWidth) - 2;

        JSConsole.Chart.Log(`[KLineChartContainer::GetMaxMinPageSize] Max=${pageSize.Max} Min=${pageSize.Min}`);

        return pageSize;
    }

    //获取图形控件的状态
    this.GetChartStatus=function()
    {
        var subFrame=this.Frame.SubFrame[0].Frame;
        if (!subFrame) return null;
        var hisData=subFrame.Data;
        if (!hisData) return null;

        var status={ KLine:{ }, Zoom:{} };
        status.KLine.Count=hisData.Data.length;
        status.KLine.Offset=hisData.DataOffset;
        status.KLine.PageSize=subFrame.XPointCount;
        status.Zoom.Index=subFrame.ZoomIndex;
        status.Zoom.Max=ZOOM_SEED.length;
        return status;
    }

    //数据拖拽下载
    this.DragDownloadData=function()
    {
        var data=null;
        if (!this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return false;
        if (data.DataOffset>0) return;

        if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period)) //下载分钟/秒数据
        {
            JSConsole.Chart.Log(`[KLineChartContainer.DragDownloadData] Minute:[Enable=${this.DragDownload.Minute.Enable}, IsEnd=${this.DragDownload.Minute.IsEnd}, Status=${this.DragDownload.Minute.Status}, Period=${this.Period}]`);
            if (!this.DragDownload.Minute.Enable) return;
            if (this.DragDownload.Minute.IsEnd) return; //全部下载完了
            if (this.DragDownload.Minute.Status!=0) return;
            this.RequestDragMinuteData();
        }
        else if (ChartData.IsDayPeriod(this.Period,true))
        {
            JSConsole.Chart.Log(`[KLineChartContainer.DragDownloadData] Day:[Enable=${this.DragDownload.Minute.Enable}, IsEnd=${this.DragDownload.Minute.IsEnd}, Status=${this.DragDownload.Minute.Status}]`);
            if (!this.DragDownload.Day.Enable) return;
            if (this.DragDownload.Day.IsEnd) return; //全部下载完了
            if (this.DragDownload.Day.Status!=0) return;
            this.RequestDragDayData();
        }
        else if(ChartData.IsTickPeriod(this.Period))
        {
            JSConsole.Chart.Log(`[KLineChartContainer.DragDownloadData] Tick:[Enable=${this.DragDownload.Tick.Enable}, IsEnd=${this.DragDownload.Tick.IsEnd}, Status=${this.DragDownload.Tick.Status}]`);
            if (!this.DragDownload.Tick.Enable) return;
            if (this.DragDownload.Tick.IsEnd) return; //全部下载完了
            if (this.DragDownload.Tick.Status!=0) return;
            this.RequestDragTickData(); 
        }
    }

    //数据缩放下载
    this.ZoomDownloadData=function(requestData)
    {
        var data=null;
        if (!this.Frame.Data) data=this.Frame.Data;
        else data=this.Frame.SubFrame[0].Frame.Data;
        if (!data) return false;
        if (data.DataOffset>0) return;

        if (ChartData.IsMinutePeriod(this.Period,true) || ChartData.IsSecondPeriod(this.Period)) //下载分钟/秒数据
        {
            JSConsole.Chart.Log(`[KLineChartContainer.ZoomDownloadData] Minute:[Enable=${this.ZoomDownload.Minute.Enable}, IsEnd=${this.ZoomDownload.Minute.IsEnd}, Status=${this.DragDownload.Minute.Status}, Period=${this.Period}]`);
            if (!this.ZoomDownload.Minute.Enable) return;
            if (this.ZoomDownload.Minute.IsEnd) return; //全部下载完了
            if (this.ZoomDownload.Minute.Status!=0) return;
            this.RequestZoomMinuteData(requestData);
        }
        else if (ChartData.IsDayPeriod(this.Period,true))
        {
            JSConsole.Chart.Log(`[KLineChartContainer.ZoomDownloadData] Day:[Enable=${this.ZoomDownload.Minute.Enable}, IsEnd=${this.ZoomDownload.Minute.IsEnd}, Status=${this.DragDownload.Minute.Status}]`);
            if (!this.ZoomDownload.Day.Enable) return;
            if (this.ZoomDownload.Day.IsEnd) return; //全部下载完了
            if (this.ZoomDownload.Day.Status!=0) return;
            
            this.RequestZoomDayData(requestData);
        }
        else if(ChartData.IsTickPeriod(this.Period))
        {
            JSConsole.Chart.Log(`[KLineChartContainer.ZoomDownloadData] Tick:[Enable=${this.ZoomDownload.Tick.Enable}, IsEnd=${this.ZoomDownload.Tick.IsEnd}, Status=${this.DragDownload.Tick.Status}]`);
            if (!this.ZoomDownload.Tick.Enable) return;
            if (this.ZoomDownload.Tick.IsEnd) return; //全部下载完了
            if (this.ZoomDownload.Tick.Status!=0) return;
            this.RequestZoomTickData(requestData); 
        }
    }

    //TODO: 
    this.RequestDragTickData=function()
    {
        JSConsole.Chart.Log(`[KLineChartContainer.RequestDragTickData] not finished.`);
    }

    //请求拖动或缩放的分钟历史数据
    this.RequestPreviousMinuteData=function(option)
    {
        var funcName=option.FuncName;
        var funcExplain=option.FuncExplain;
        var download=option.Download;
        var url=option.Url;
        var count=option.Count; //请求数据个数

        var self=this;
        this.AutoUpdateEvent(false,funcName);   //停止自动更新
        this.CancelAutoUpdate();
        download.Status=1;
        var firstItem=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data))
            firstItem=this.SourceData.Data[0];   //最新的一条数据
        else 
            firstItem={Date:null, Time:null};
        
        var postData=
        {
            "field": ["name","symbol", "yclose","open","price","high","low","vol"],
            "symbol": self.Symbol,
            "enddate": firstItem.Date,
            "endtime" :firstItem.Time,
            "count": count,
            "first":{ date: firstItem.Date, time:firstItem.Time }
        };

        if (IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint))
        {
            postData.overlay=[];
            for(var i=0;i<this.OverlayChartPaint.length;++i)
            {
                var item=this.OverlayChartPaint[i];
                postData.overlay.push({ symbol:item.Symbol });
            }
        }

        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:funcName, //类名::函数
                Explain:funcExplain,
                Request:{ Url:url,  Type:'POST', Data: postData, Period:this.Period, Right:this.Right }, 
                DragDownload:download,
                Option:option,
                Self:this,
                PreventDefault:false,
                ZoomData:option.ZoomData
            };
            this.NetworkFilter(obj, function(data) 
            {
                self.RecvPreviousMinuteData(data,option);
                download.Status=0;
                self.AutoUpdateEvent(true,funcName);   //自动更新
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: url,
            data:postData,
            type:"post",
            dataType: "json",
            async:true,
            success: function(data)
            {
                self.RecvPreviousMinuteData(data, option);
                download.Status=0;
                self.AutoUpdateEvent(true,funcName);   //自动更新
                self.AutoUpdate();
            }
        });
    }

    this.RecvPreviousMinuteData=function(data, option)
    {
        var download=option.Download;
        var aryDayData=KLineChartContainer.JsonDataToMinuteHistoryData(data);
        if (!aryDayData || aryDayData.length<=0)
        {
            download.IsEnd=true; 
            JSConsole.Chart.Log(`[KLineChartContainer.RecvPreviousMinuteData] ${this.Symbol} data end. FuncName=${option.FuncName}`);
            this.Draw();
            return;
        }

        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数
        var endIndex=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data))
        {
            var firstData=this.SourceData.Data[0];
            for(var i=aryDayData.length-1;i>=0;--i)
            {
                var item=aryDayData[i];
                if (firstData.Date>item.Date || (firstData.Date==item.Date && firstData.Time>item.Time)) 
                {
                    endIndex=i;
                    break;
                }
                else if (firstData.Date==item.Date && firstData.Time==item.Time)
                {
                    firstData.YClose=item.YClose;
                    endIndex=i-1;
                    break;
                }
            }
        }
        else
        {
            endIndex=aryDayData.length-1;
        }
        
        if (endIndex==null && endIndex<0) return;
        
        for(var i=0;i<aryDayData.length && i<=endIndex;++i)    //数据往前插
        {
            var item=aryDayData[i];
            this.SourceData.Data.splice(i,0,item);
        }

        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;
        bindData.Symbol=this.Symbol;

        if (!this.IsApiPeriod)
        {
            if (bindData.Right>0 && this.RightFormula>=1)   //复权
            {
                var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula } );
                bindData.Data=rightData;
            }

            if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据 (0= 日线,4=1分钟线 不需要处理)
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:option.RecvFuncName });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        //绑定数据
        this.UpdateMainData(bindData,lastDataCount);
        if (option)  //缩放需要调整当前屏的位置
        {
            if (option.ZoomData)
            {
                var zoomData=option.ZoomData;
                var showCount=zoomData.PageSize-zoomData.RightSpaceCount;   //一屏显示的数据个数
                bindData.DataOffset= bindData.Data.length-showCount;
                if (bindData.DataOffset<0) bindData.DataOffset=0;
            }
            else if (IFrameSplitOperator.IsNumber(option.DataOffset))
            {
                bindData.DataOffset+=option.DataOffset;
                if (bindData.DataOffset<0) bindData.DataOffset=0;
            }
        }

        this.UpdateOverlayDragMinuteData(data);
        this.BindInstructionIndexData(bindData);    //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        this.BindAllOverlayIndexData(bindData, { SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex();   //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.UpdateChartDrawXValue();      //更新画图工具X轴索引
        this.Draw();

        //叠加指标计算
        this.BindAllOverlayIndexData(bindData, { SyncExecute:false });  //异步模式叠加指标
    }

    this.RequestZoomMinuteData=function(requestData)
    {
        var zoomData={ PageSize:requestData.PageSize, DataCount:requestData.DataCount, RightSpaceCount:requestData.RightSpaceCount };

        var option=
        {
            FuncName:'KLineChartContainer::RequestZoomMinuteData',
            FuncExplain:"缩放分钟|秒K线数据下载",
            RecvFuncName:"RecvZoomMinuteData",
            Download:this.ZoomDownload.Minute,
            Url:this.ZoomMinuteKLineApiUrl,
            Count:this.MaxRequestMinuteDayCount,
            XShowCount:this.Frame.GetXShowCount(),
            ZoomData:zoomData
        };

        this.RequestPreviousMinuteData(option);
    }

    this.RequestDragMinuteData=function()
    {
        var option=
        {
            FuncName:'KLineChartContainer::RequestDragMinuteData',
            FuncExplain:"拖拽分钟|秒K线数据下载",
            RecvFuncName:"RecvDragMinuteData",
            Download:this.DragDownload.Minute,
            Url:this.DragMinuteKLineApiUrl,
            Count:this.MaxRequestMinuteDayCount,
            XShowCount:this.Frame.GetXShowCount(),
        };

        this.RequestPreviousMinuteData(option);
    }

    this.UpdateOverlayDragMinuteData=function(data)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint)) return;
        var aryRecvOverlayData=data.overlay;
        if (!IFrameSplitOperator.IsNonEmptyArray(aryRecvOverlayData)) return;

        for(var i=0;i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Symbol) continue;

            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;

            var findData=null;
            for(var j=0;j<aryRecvOverlayData.length;++j)    //查找对应的叠加股票数据
            {
                var overlayItem=aryRecvOverlayData[j];
                if (overlayItem.symbol==item.Symbol)
                {
                    findData=overlayItem;
                    break;
                }
            }

            if (!findData) continue;

            var aryDayData=KLineChartContainer.JsonDataToMinuteHistoryData(findData);
            var sourceData=item.SourceData; //叠加股票的所有数据

            var firstData=sourceData.Data[0];
            var endIndex=null;
            for(var j=aryDayData.length-1;j>=0;--j)
            {
                var itemData=aryDayData[j];
                if (firstData.Date>itemData.Date) 
                {
                    endIndex=j;
                    break;
                }
                else if (firstData.Date==itemData.Date && firstData.Time>itemData.Time)
                {
                    endIndex=j;
                    break;
                }
                else if (firstData.Date==itemData.Date && firstData.Time==itemData.Time)
                {
                    firstData.YClose=itemData.YClose;
                    endIndex=j-1;
                    break;
                }
            }

            if (endIndex==null && endIndex<0) continue;
            
            for(var j=0; j<aryDayData.length && j<=endIndex;++j)    //数据往前插
            {
                var itemData=aryDayData[j];
                sourceData.Data.splice(j,0,itemData);
            }

            var bindData=new ChartData();
            bindData.Data=sourceData.Data;
            bindData.Period=this.Period;
            bindData.Right=this.Right;
            bindData.DataType=0;

            var aryOverlayData=this.SourceData.GetOverlayMinuteData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
            bindData.Data=aryOverlayData;

            if (ChartData.IsMinutePeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }

            item.Data=bindData;
        }
    }

    //请求拖动或缩放的日线历史数据
    this.RequestPreviousDayData=function(option)
    {
        var funcName=option.FuncName;
        var funcExplain=option.FuncExplain;
        var download=option.Download;
        var url=option.Url;
        var count=option.Count; //请求数据个数

        var self=this;
        this.AutoUpdateEvent(false,funcName);   //停止自动更新
        this.CancelAutoUpdate();
        download.Status=1;
        var firstItem=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data))
            firstItem=this.SourceData.Data[0];
        else
            firstItem={Date:null};

        var postData=
        {
            "field": ["name","symbol", "yclose","open","price","high","low","vol"],
            "symbol": self.Symbol,
            "enddate": firstItem.Date,
            "count": count,
            "first":{ date: firstItem.Date }
        };

        if (IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint))
        {
            postData.overlay=[];
            for(var i=0;i<this.OverlayChartPaint.length;++i)
            {
                var item=this.OverlayChartPaint[i];
                postData.overlay.push( { symbol:item.Symbol } );
            }
        }
        
        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:funcName, //类名::函数
                Explain:funcExplain,
                Request:{ Url:url,  Type:'POST' , Data: postData, Period:this.Period, Right:this.Right }, 
                DragDownload:download,
                Option:option,
                Self:this,
                PreventDefault:false,
                ZoomData:option.ZoomData
            };
            this.NetworkFilter(obj, function(data) 
            {
                self.RecvPreviousDayData(data,option);
                download.Status=0;
                self.AutoUpdateEvent(true,funcName);   //自动更新
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: url,
            data:postData,
            type:"post",
            dataType: "json",
            async:true,
            success: function(data)
            {
                self.RecvPreviousDayData(data, option);
                download.Status=0;
                self.AutoUpdateEvent(true,funcName);   //自动更新
                self.AutoUpdate();
            }
        });
    }

    this.RecvPreviousDayData=function(data, option)
    {
        var download=option.Download;
        var aryDayData=KLineChartContainer.JsonDataToHistoryData(data);
        if (!aryDayData || aryDayData.length<=0)
        {
            download.IsEnd=true;   //下完了
            JSConsole.Chart.Log(`[KLineChartContainer.RecvPreviousDayData] ${this.Symbol} data end. FuncName=${option.FuncName}`);
            return;
        }
        var lastDataCount=this.GetHistoryDataCount();   //保存下上一次的数据个数
        var endIndex=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data))
        { 
            var firstData=this.SourceData.Data[0];
            
            for(var i=aryDayData.length-1;i>=0;--i)
            {
                var item=aryDayData[i];
                if (firstData.Date>item.Date) 
                {
                    endIndex=i;
                    break;
                }
                else if (firstData.Date==item.Date)
                {
                    firstData.YClose=item.YClose;
                    endIndex=i-1;
                    break;
                }
            }
        }
        else
        {
            var firstData={ Date:null };
            endIndex=aryDayData.length-1;
        }

       
        if (endIndex==null && endIndex<0) return;
        
        for(var i=0; i<aryDayData.length && i<=endIndex;++i)    //数据往前插
        {
            var item=aryDayData[i];
            this.SourceData.Data.splice(i,0,item);
        }

        var bindData=new ChartData();
        bindData.Data=this.SourceData.Data;
        bindData.Period=this.Period;
        bindData.Right=this.Right;
        bindData.DataType=this.SourceData.DataType;
        bindData.Symbol=this.Symbol;

        if (!this.IsApiPeriod)
        {
            if (bindData.Right>0)    //复权
            {
                var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                bindData.Data=rightData;
            }

            if (ChartData.IsDayPeriod(bindData.Period,false) || ChartData.IsMinutePeriod(bindData.Period,false))   //周期数据 (0= 日线,4=1分钟线 不需要处理)
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }
        }

        var kLineCalculate=this.GetKLineCalulate();
        if (kLineCalculate) //额外的K线图形计算
        {
            var newBindData=kLineCalculate.RecvHistoryData(bindData, { Symbol:this.Symbol, Function:option.RecvFuncName });
            bindData=newBindData;
            this.FlowCapitalReady=true;
        }

        //绑定数据
        this.UpdateMainData(bindData,lastDataCount);
        if (option)  //缩放需要调整当前屏的位置
        {
            if (option.ZoomData)
            {
                var zoomData=option.ZoomData;
                var showCount=zoomData.PageSize-zoomData.RightSpaceCount;   //一屏显示的数据个数
                bindData.DataOffset= bindData.Data.length-showCount;
                if (bindData.DataOffset<0) bindData.DataOffset=0;
            }
            else if (IFrameSplitOperator.IsNumber(option.DataOffset))
            {
                bindData.DataOffset+=option.DataOffset;
                if (bindData.DataOffset<0) bindData.DataOffset=0;
            }
        }

        this.UpdateOverlayDragDayData(data);
        this.BindInstructionIndexData(bindData);    //执行指示脚本

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        this.BindAllOverlayIndexData(bindData, { SyncExecute:true });   //同步模式叠加指标

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex();   //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.UpdateChartDrawXValue();       //更新画图工具X轴索引
        this.Draw();   
        
        //更新信息地雷
        this.ReqeustKLineInfoData( { FunctionName:option.RecvFuncName, StartDate:firstData.Date } );

        //叠加指标计算
        this.BindAllOverlayIndexData(bindData, { SyncExecute:false });  //异步模式叠加指标
    }

    this.RequestZoomDayData=function(requestData)
    {
        var count=this.MaxRequestDataCount;
        if (requestData.Count>count) count=requestData.Count;
        var zoomData={ PageSize:requestData.PageSize, DataCount:requestData.DataCount, RightSpaceCount:requestData.RightSpaceCount };

        var option=
        {
            FuncName:'KLineChartContainer::RequestZoomDayData',
            FuncExplain:"缩放日K数据下载",
            RecvFuncName:"RecvZoomDayData",
            Download:this.ZoomDownload.Day,
            Url:this.ZoomKLineApiUrl,
            XShowCount:this.Frame.GetXShowCount(),
            Count:count,
            ZoomData:zoomData
        };

        this.RequestPreviousDayData(option);
    }


    this.RequestDragDayData=function()
    {
        var option=
        {
            FuncName:'KLineChartContainer::RequestDragDayData',
            FuncExplain:"拖拽日K数据下载",
            RecvFuncName:"RecvDragDayData",
            Download:this.DragDownload.Day,
            Url:this.DragKLineApiUrl,
            Count:this.MaxRequestDataCount,
            XShowCount:this.Frame.GetXShowCount(),
        };

        this.RequestPreviousDayData(option);
    }

    //更新叠加数据
    this.UpdateOverlayDragDayData=function(data)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.OverlayChartPaint)) return;
        var aryRecvOverlayData=data.overlay;
        if (!IFrameSplitOperator.IsNonEmptyArray(aryRecvOverlayData)) return;

        for(var i=0;i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            if (!item.Symbol) continue;

            if (!item.MainData) continue;   //等待主图股票数据未下载完
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_FINISHED_ID) continue;

            var findData=null;
            for(var j=0;j<aryRecvOverlayData.length;++j)    //查找对应的叠加股票数据
            {
                var overlayItem=aryRecvOverlayData[j];
                if (overlayItem.symbol==item.Symbol)
                {
                    findData=overlayItem;
                    break;
                }
            }

            if (!findData) continue;

            var aryDayData=KLineChartContainer.JsonDataToHistoryData(findData);
            var sourceData=item.SourceData; //叠加股票的所有数据

            var firstData=sourceData.Data[0];
            var endIndex=null;
            for(var j=aryDayData.length-1;j>=0;--j)
            {
                var itemData=aryDayData[j];
                if (firstData.Date>itemData.Date) 
                {
                    endIndex=j;
                    break;
                }
                else if (firstData.Date==itemData.Date)
                {
                    firstData.YClose=itemData.YClose;
                    endIndex=j-1;
                    break;
                }
            }

            if (endIndex==null && endIndex<0) continue;
            
            for(var j=0; j<aryDayData.length && j<=endIndex;++j)    //数据往前插
            {
                var itemData=aryDayData[j];
                sourceData.Data.splice(j,0,itemData);
            }

            var bindData=new ChartData();
            bindData.Data=sourceData.Data;
            bindData.Period=this.Period;
            bindData.Right=this.Right;
            bindData.DataType=0;

            if (bindData.Right>0 && MARKET_SUFFIX_NAME.IsSHSZStockA(findData.symbol) && !this.IsApiPeriod)    //复权数据 ,A股才有有复权
            {
                var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                bindData.Data=rightData;
            }

            var aryOverlayData=this.SourceData.GetOverlayData(bindData.Data, this.IsApiPeriod);      //和主图数据拟合以后的数据
            bindData.Data=aryOverlayData;

            if (ChartData.IsDayPeriod(bindData.Period,false) && !this.IsApiPeriod)   //周期数据
            {
                var periodData=bindData.GetPeriodData(bindData.Period);
                bindData.Data=periodData;
            }

            item.Data=bindData;
        }
    }

    this.SetCustomVerical=function(windowId, data)
    {
        if (!this.Frame) return;
        if (windowId>=this.Frame.SubFrame.length) return;

        var item=this.Frame.SubFrame[windowId];
        if (item.Frame) item.Frame.CustomVerticalInfo=data;
    }

    this.OnSize=function()
    {
        if (!this.Frame) return;
        if (!this.Frame.OnSize) return;

        //this.Frame.CalculateChartBorder();
        var obj=this.Frame.OnSize();
        this.Frame.SetSizeChage(true);
        if (obj.Changed)
        {
            this.UpdataDataoffset();
            this.UpdatePointByCursorIndex(2);
            this.UpdateFrameMaxMin();
        }

        this.Draw();
    }

    this.ClickFrameButton=function(button, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_FRAME_TOOLBAR);
        if (event && event.Callback)
        {
            var data={ Info:button, PreventDefault:false  };    //PreventDefault 是否阻止内置的点击处理
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }

        if (button.ID==JSCHART_BUTTON_ID.CLOSE_OVERLAY_INDEX)
        {
            var id=button.IndexID;
            if (id) this.DeleteOverlayWindowsIndex(id);
        }
        else if (button.ID==JSCHART_BUTTON_ID.MODIFY_OVERLAY_INDEX_PARAM)
        {
            var id=button.IndexID;
            var frame=button.Frame;
            e.data={ Chart:this, Identify:id, IsOverlay:true };
            if (frame.ModifyIndexEvent) 
                frame.ModifyIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.CLOSE_INDEX_WINDOW)
        {
            var frame=button.Frame;
            this.RemoveIndexWindow(frame.Identify);
        }
        else if (button.ID==JSCHART_BUTTON_ID.CHANGE_INDEX)
        {
            var frame=button.Frame;
            e.data={ Chart:this, Identify:frame.Identify, IsOverlay:false };
            if (frame.ChangeIndexEvent) 
                frame.ChangeIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.MODIFY_INDEX_PARAM)
        {
            var frame=button.Frame;
            e.data={ Chart:this, Identify:frame.Identify, IsOverlay:false };
            if (frame.ModifyIndexEvent) 
                frame.ModifyIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.OVERLAY_INDEX)
        {
            var frame=button.Frame;
            e.data={ Chart:this, Identify:frame.Identify, IsOverlay:true };
            if (frame.ChangeIndexEvent) 
                frame.ChangeIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.MAX_MIN_WINDOW)
        {
            var id=button.IndexID;
            var frame=button.Frame;
            var frameId=button.FrameID;
            if (frameId>=this.Frame.ZoomStartWindowIndex)
            {
                if (this.ZoomIndexWindow(frameId, null))
                {
                    this.Frame.SetSizeChage(true);
                    this.Draw();
                }
            }
        }
        else if (button.ID==JSCHART_BUTTON_ID.TITLE_WINDOW) //标题模式
        {
            var id=button.IndexID;
            var frame=button.Frame;
            var frameId=button.FrameID;
            if (this.ShowIndexTitleOnly(frameId))
            {
                this.Frame.SetSizeChage(true);
                this.Draw();
            }
        }
        else if (button.ID==JSCHART_BUTTON_ID.EXPORT_DATA)  //数据导出
        {
            var data=this.ExportData({Type:"CSV"});
            if (!data) return;
    
            var date=Date.now();
            var fileName = `hqchart_${this.Symbol}_${date}.csv`;
            var alink = document.createElement("a");
            var csvDataBlob = new Blob([data], { type: "text/csv" });
            alink.href = URL.createObjectURL(csvDataBlob);
            document.body.appendChild(alink);
            alink.setAttribute("download", fileName);
            alink.click();
            document.body.removeChild(alink);
        }
    }

    this.ClickTitleButton=function(button, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_TITLE_BUTTON);
        if (event && event.Callback)
        {
            var data={ Info:button, PreventDefault:false, e:e };    //PreventDefault 是否阻止内置的点击处理
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }
    }


    this.ClickExtendChartButton=function(button, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_EXTENDCHART_BUTTON);
        if (event && event.Callback)
        {
            var data={ Info:button, PreventDefault:false, e:e  };    //PreventDefault 是否阻止内置的点击处理
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }

        //筹码按钮
        if (button.ID==JSCHART_BUTTON_ID.CHIP_DEFULT)
        {
            button.Chart.ShowType=0;
            this.Draw();
        }
        else if (button.ID==JSCHART_BUTTON_ID.CHIP_LONG)
        {
            button.Chart.ShowType=1;
            this.Draw();
        }
        else if (button.ID==JSCHART_BUTTON_ID.CHIP_RECENT)
        {
            button.Chart.ShowType=2;
            this.Draw();
        }
    }

    //成交量分布图数据请求
    this.RequestVolumeProfileData=function(option)
    {
        var self=this;
        var chart=option.Chart;
        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'KLineChartContainer::RequestVolumeProfileData', //类名::函数
                Explain:'成交量分布图下载',
                Request:{ Period:this.Period, Right:this.Right, Start:option.Start, End:option.End, Symbol:this.Symbol, ValueAreaVol:option.ValueAreaVol }, 
                Self:this,
                VolProfile:chart,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            {
                self.RecvVolumeProfileData(data, chart);
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }
    }

    this.RecvVolumeProfileData=function(data, chart)
    {
        chart.OnRecvVolumeProfileData(data);
        this.Draw();
    }

    this.ExportMainData=function(data, option)
    {
        var aryData=data.ExportKLineData(option);   //导出K线
        return aryData;
    }


    this.UpdateScrollBar=function()
    {
        if (!this.ScrollBar) return;

        var data=this.GetChartStatus();
        if (!data) return;

        var kData=this.ChartPaint[0].Data;
        var start=data.KLine.Offset;
        var end=start+data.KLine.PageSize-1;
        //if (end>=kData.Data.length) end=kData.Data.length-1;

        var obj={ Start:start, End:end, Data:kData, Draw:true, RightSpaceCount:this.RightSpaceCount };
        if (this.Frame && this.Frame.ChartBorder)
        {
            var border=this.Frame.ChartBorder;
            obj.Border={ Left:border.Left, Right:border.Right };
        }
        
        this.ScrollBar.UpdateSlider(obj);
    }

    this.ResetScrollBar=function()
    {
        if (!this.ScrollBar) return;

        this.ScrollBar.Reset({Draw:true});
    }

    this.ChangePriceGap=function(obj)
    {
        if (!obj) return;
        var klineChart=this.ChartPaint[0];
        if (!klineChart) return;

        if (IFrameSplitOperator.IsNumber(obj.Count)) klineChart.PriceGap.Count=obj.Count;
        if (IFrameSplitOperator.IsBool(obj.Enable)) klineChart.PriceGap.Enable=obj.Enable;

        this.Draw();
    }
}

//API 返回数据 转化为array[]
KLineChartContainer.JsonDataToHistoryData=function(data)
{
    var aryDayData=[];
    if (!data.data) return aryDayData;

    var upperSymbol=null;
    if (data.symbol) upperSymbol=data.symbol.toUpperCase();
    var isFutures=false;    //是否是期货
    if (upperSymbol) isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);

    var list = data.data;
    var date = 0, yclose = 1, open = 2, high = 3, low = 4, close = 5, vol = 6, amount = 7, position=8;
    var fclose=9, yfclose=10;   //结算价, 前结算价
    var bfactor=11, afactor=12; //前, 后复权因子
    var bVirtual=13;            //虚拟数据
    var bNonTrade=14;           //非交易日
    var flowCapital=15;         //流通股本
    var orderFlow=JSCHART_DATA_FIELD_ID.KLINE_ORDERFLOW;
    var colorData=JSCHART_DATA_FIELD_ID.KLINE_COLOR_DATA;
    var heatMapIndex=JSCHART_DATA_FIELD_ID.KLINE_HEATMAP;
    var extendDataIndex=JSCHART_DATA_FIELD_ID.KLINE_DAY_EXTENDDATA; //k线扩展数据
    for (var i = 0; i < list.length; ++i)
    {
        var item = new HistoryData();
        var jsData=list[i];

        item.Date = jsData[date];
        item.Open = jsData[open];
        item.YClose = jsData[yclose];
        item.Close = jsData[close];
        item.High = jsData[high];
        item.Low = jsData[low];
        item.Vol = jsData[vol];    //原始单位股
        item.Amount = jsData[amount];
        if (IFrameSplitOperator.IsNumber(jsData[position])) item.Position=jsData[position];//期货持仓
        if (IFrameSplitOperator.IsNumber(jsData[fclose])) item.FClose=jsData[fclose];       //期货结算价
        if (IFrameSplitOperator.IsNumber(jsData[yfclose])) item.YFClose=jsData[yfclose];    //期货前结算价

        if (IFrameSplitOperator.IsNumber(jsData[flowCapital])) item.FlowCapital=jsData[flowCapital];   //流通股本

        if (IFrameSplitOperator.IsNumber(jsData[bfactor])) item.BFactor=jsData[bfactor];    //前复权因子
        if (IFrameSplitOperator.IsNumber(jsData[afactor])) item.AFactor=jsData[afactor];    //后复权因子

        if (IFrameSplitOperator.IsBool(jsData[bVirtual])) item.IsVirtual=jsData[bVirtual];  //虚拟数据
        if (IFrameSplitOperator.IsBool(jsData[bNonTrade])) item.IsNonTrade=jsData[bNonTrade];  //虚拟数据

        if (!IFrameSplitOperator.IsNumber(item.Open) && !(item.IsVirtual===true)) continue;

        if (jsData[orderFlow]) item.OrderFlow=jsData[orderFlow];
        if (jsData[colorData]) item.ColorData=jsData[colorData];
        if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
        if (jsData[heatMapIndex]) item.HeatMap=jsData[heatMapIndex];

        aryDayData.push(item);
    }

    return aryDayData;
}

KLineChartContainer.JsonDataToRealtimeData=function(data, symbol)
{
    if (!data.stock) return null;

    var stock;
    for(var i in data.stock)    //查找对应的股票数据
    {
        var stockItem=data.stock[i];
        if (stockItem && stockItem.symbol==symbol)
        {
            stock=stockItem;
            break;
        }
    }
    if (!stock) return null;

    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);

    var item=new HistoryData();
    item.Date=stock.date;
    item.Open=stock.open;
    item.YClose=stock.yclose;
    item.High=stock.high;
    item.Low=stock.low;
    item.Vol=stock.vol; //股
    item.Amount=stock.amount;
    item.Close=stock.price;
    if (IFrameSplitOperator.IsNumber(stock.position)) item.Position=stock.position;     //持仓量
    if (IFrameSplitOperator.IsNumber(stock.yclearing)) item.YFClose=stock.yclearing;    //前结算价
    if (IFrameSplitOperator.IsNumber(stock.clearing)) item.FClose=stock.clearing;       //结算价

    if (IFrameSplitOperator.IsNumber(stock.bfactor)) item.BFactor=stock.bfactor;    //前复权因子
    if (IFrameSplitOperator.IsNumber(stock.afactor)) item.AFactor=stock.afactor;    //后复权因子
    if (stock.colordata) item.ColorData=stock.colordata;    //自定义颜色
    if (stock.extendData) item.ExtendData=stock.extendData;
    if (stock.heatmapData) item.HeatMap=stock.heatmapData;

    if (IFrameSplitOperator.IsBool(stock.isvirtual)) item.IsVirtual=stock.isvirtual;  //虚拟数据
    if (IFrameSplitOperator.IsBool(stock.isnontrade)) item.IsNonTrade=stock.isnontrade;  //虚拟数据

    return item;
}

KLineChartContainer.JsonDataToMinuteRealtimeData=function(data,symbol)
{
    if (!data.stock) return null;
    var stock;
    for(var i in data.stock)    //查找对应的股票数据
    {
        var stockItem=data.stock[i];
        if (stockItem && stockItem.symbol==symbol)
        {
            stock=stockItem;
            break;
        }
    }
    if (!stock) return null;

    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);
    var aryMinuteData=new Array();
    var preClose=stock.yclose;      //前一个数据价格
    var date=stock.date;
    if (isFutures && stock.yclearing)preClose=stock.yclearing;  //期货使用昨结算价
    
    for(var i in stock.minute)
    {
        var jsData=stock.minute[i];
        var item = new HistoryData();

        item.Close=jsData.price;
        item.Open=jsData.open;
        item.High=jsData.high;
        item.Low=jsData.low;
        item.Vol=jsData.vol;   //股
        item.Amount=jsData.amount;
        if (jsData.date>0) item.Date=jsData.date;
        else item.Date=date;
        item.Time=jsData.time;
        item.YClose=preClose;

        if (IFrameSplitOperator.IsNumber(jsData.position)) item.Position=jsData.position; //持仓量

        if (!IFrameSplitOperator.IsNumber(item.Close)) //当前没有价格 使用上一个价格填充
        {
            item.Close=preClose;
            item.Open=item.High=item.Low=item.Close;
        }

        //价格是0的 都用空
        if (!IFrameSplitOperator.IsNumber(item.Open)) item.Open=null;
        if (!IFrameSplitOperator.IsNumber(item.Close)) item.Close=null;
        if (!IFrameSplitOperator.IsNumber(item.High)) item.High=null;
        if (!IFrameSplitOperator.IsNumber(item.Low)) item.Low=null;

        //上次价格
        if (IFrameSplitOperator.IsNumber(jsData.price)) preClose=jsData.price;

        aryMinuteData[i]=item;
    }

    return aryMinuteData;
}

//分钟K线叠加数据增量更新v2版本
KLineChartContainer.JsonDataToMinuteRealtimeDataV2=function(data,symbol)
{
    if (!data || !data.overlay || !symbol) return null;

    var overlayData=null;
    for(var i=0;i<data.overlay.length;++i) //overlay={ symbol:, name:, data:[] }
    {
        var item=data.overlay[i];
        if (item.symbol==symbol)
        {
            overlayData=item;
            break;
        }
    }

    if (!overlayData) return null;

    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //是否是期货

    var date = 0, yclose = 1, open = 2, high = 3, low = 4, close = 5, vol = 6, amount = 7, time = 8, position=9;
    var orderFlow=JSCHART_DATA_FIELD_ID.KLINE_ORDERFLOW;
    var yClose=null; 
    var aryMinuteData=[];
    for (var i = 0; i < overlayData.data.length; ++i)
    {
        var item = new HistoryData();
        var jsData=overlayData.data[i];
        item.Date = jsData[date];
        item.Open = jsData[open];
        item.YClose = jsData[yclose];
        item.Close = jsData[close];
        item.High = jsData[high];
        item.Low = jsData[low];
        item.Vol = jsData[vol];    //股
        item.Amount = jsData[amount];
        item.Time=jsData[time];
        if (IFrameSplitOperator.IsNumber(jsData[position])) item.Position=jsData[position]; //期货持仓

        if (!IFrameSplitOperator.IsNumber(item.YClose))
        {
            if (IFrameSplitOperator.IsNumber(yClose)) item.YClose=yClose;
        }

        if (IFrameSplitOperator.IsNumber(item.Close)) yClose=item.Close;

        if (jsData[orderFlow]) item.OrderFlow=jsData[orderFlow];

        aryMinuteData.push(item);
    }

    return aryMinuteData;
}

//API 返回数据 转化为array[]
KLineChartContainer.JsonDataToMinuteHistoryData=function(data)
{
    var upperSymbol=null;
    if (data.symbol) upperSymbol=data.symbol.toUpperCase();
    var isSHSZ=false;
    if (upperSymbol) isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    var isFutures=false;    //是否是期货
    if (upperSymbol) isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);
    var list = data.data;
    var aryDayData=new Array();
    var date = 0, yclose = 1, open = 2, high = 3, low = 4, close = 5, vol = 6, amount = 7, time = 8, position=9;
    var fclose=10, yfclose=11;   //结算价, 前结算价
    var bfactor=12, afactor=13; //前, 后复权因子
    var orderFlow=JSCHART_DATA_FIELD_ID.KLINE_ORDERFLOW;
    var colorData=JSCHART_DATA_FIELD_ID.KLINE_COLOR_DATA;
    var heatMapIndex=JSCHART_DATA_FIELD_ID.KLINE_HEATMAP;
    var extendDataIndex=JSCHART_DATA_FIELD_ID.KLINE_MINUTE_EXTENDDATA; //k线扩展数据
    var yClose=null; 
    for (var i = 0; i < list.length; ++i)
    {
        var item = new HistoryData();
        var jsData=list[i];
        item.Date = jsData[date];
        item.Open = jsData[open];
        item.YClose = jsData[yclose];
        item.Close = jsData[close];
        item.High = jsData[high];
        item.Low = jsData[low];
        item.Vol = jsData[vol];    //股
        item.Amount = jsData[amount];
        item.Time=jsData[time];
        if (IFrameSplitOperator.IsNumber(jsData[position])) item.Position=jsData[position]; //期货持仓

        if (IFrameSplitOperator.IsNumber(jsData[fclose])) item.FClose=jsData[fclose];       //期货结算价
        if (IFrameSplitOperator.IsNumber(jsData[yfclose])) item.YFClose=jsData[yfclose];    //期货前结算价

        if (IFrameSplitOperator.IsNumber(jsData[bfactor])) item.BFactor=jsData[bfactor];    //前复权因子
        if (IFrameSplitOperator.IsNumber(jsData[afactor])) item.AFactor=jsData[afactor];    //后复权因子

        if (!IFrameSplitOperator.IsNumber(item.YClose))
        {
            if (IFrameSplitOperator.IsNumber(yClose)) item.YClose=yClose;
        }

        if (IFrameSplitOperator.IsNumber(item.Close)) yClose=item.Close;

        if (jsData[orderFlow]) item.OrderFlow=jsData[orderFlow];
        if (jsData[colorData]) item.ColorData=jsData[colorData];
        if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
        if (jsData[heatMapIndex]) item.HeatMap=jsData[heatMapIndex];
        

        aryDayData.push(item);
    }

    /* 内部不处理无效数据, 确保外部传过来的数据是对的.
    // 无效数据处理
    for(var i = 0; i < aryDayData.length; ++i)
    {
        var minData = aryDayData[i];
        if (minData == null) coninue;
        if (isNaN(minData.Open) || minData.Open <= 0 || isNaN(minData.High) || minData.High <= 0 || isNaN(minData.Low) || minData.Low <= 0 
            || isNaN(minData.Close) || minData.Close <= 0 )
        {
            if (i == 0)
            {
                if (minData.YClose > 0)
                {
                    minData.Open = minData.YClose;
                    minData.High = minData.YClose;
                    minData.Low = minData.YClose;
                    minData.Close = minData.YClose;
                }
            }
            else // 用前一个有效数据填充
            {
                for(var j = i-1; j >= 0; --j)
                {
                    var minData2 = aryDayData[j];
                    if (minData2 == null) coninue;
                    if (minData2.Open > 0 && minData2.High > 0 && minData2.Low > 0 && minData2.Close > 0)
                    {
                        if (minData.YClose <= 0) minData.YClose = minData2.Close;
                        minData.Open = minData2.Open;
                        minData.High = minData2.High;
                        minData.Low = minData2.Low;
                        minData.Close = minData2.Close;
                        break;
                    }
                }
            }    
        }
    }
    */
    return aryDayData;
}

KLineChartContainer.JsonDataToTickData=function(data)
{
   var aryDayData=[];
   if (!data.detail) return aryDayData;

   var date=data.date;
   var yClose=data.yclose;
   for(var i in data.detail)
   {
       var item = new HistoryData();
       var tick=data.detail[i];
       if (!tick) continue;

       item.Date = date;
       item.Time=tick[0];
       item.Low=item.High=item.Close=item.Open = tick[1];
       item.YClose = yClose;    //当前数据的前收盘
       item.Vol = tick[2];      //原始单位股
       item.Amount = tick[3];
       item.Flag=tick[4];
      
       if (!IFrameSplitOperator.IsNumber(item.Open)) continue; //停牌的数据剔除

       //yClose=item.Close;
       aryDayData.push(item);
   }

   return aryDayData;
}

KLineChartContainer.JsonDataToTickDataV2=function(data)
{
   var aryDayData=[];
   if (!IFrameSplitOperator.IsNonEmptyArray(data.data)) return aryDayData;

   for(var i=0;i<data.data.length;++i)
   {
       var item = new HistoryData();
       var tick=data.data[i];   //[ date, time, yClose, price, extendData]
       if (!tick) continue;

       item.Date = tick[0];
       item.Time=tick[1];
       item.YClose = tick[2];
       item.Low=item.High=item.Close=item.Open = tick[3];
       aryDayData.push(item);

       if (tick[4]) item.ExtendData=tick[4];
   }

   return aryDayData;
}



///////////////////////////////////////////////////////////////////////////////////////////
//  走势图
//
function MinuteChartContainer(uielement,offscreenElement,cacheElement)
{
    this.newMethod=JSChartContainer;   //派生
    this.newMethod(uielement,offscreenElement,cacheElement);
    delete this.newMethod;

    this.ClassName='MinuteChartContainer';
    this.WindowIndex=new Array();
    this.Symbol;
    this.Name;
    this.SourceData;                          //原始的历史数据
    this.IndexBindData;                       //计算指标需要绑定的分钟数据
    this.IsAutoUpdate=true;                   //是否自动更新行情数据
    this.AutoUpdateFrequency=30000;           //30秒更新一次数据
    this.AutoUpdateTimer;                     //自动更新定时器
    this.TradeDate=0;                         //行情交易日期
    this.DayCount=1;                          //显示几天的数据
    this.DayData;                             //多日分钟数据
    this.LimitPrice;                          //涨停价格 { Max:null, Min:null };  

    this.IsShowBeforeData=false;              //是否显示盘前集合竞价数据 (当日)
    this.BeforeOpenData=null;                 //盘前集合竞价数据
    this.IsBeforeData=false;                  //是否支持显示盘前集合竞价数据(当日)

    this.IsShowAfterData=false;               //收盘集合竞价
    this.AfterCloseData=null;                 //收盘集合竞价数据
    this.IsAfterData=false;                   //是否支持显示收盘集合竞价数据(当日)
    this.ShareAfterVol=0;                     //1=盘后数据成交量Y坐标和主图共享 2=盘后数据成交量Y坐标和盘前共享
    this.ExtendWidth={ Left: 120, Right:120 } ;      //单日分时图 左右扩展图形宽度
    
    this.IsShowLead=true;                     //指数是否显示领先指标

    this.IsShowMultiDayBeforeData=false;             //多日分时图 是否显示盘前集合竞价
    this.MultiDayBeforeOpenData=null;                //多日分时图 盘前集合竞价数据 
    this.IsShowMultiDayAfterData=false;             //多日分时图 是否显示收盘集合竞价
    this.MultiDayAfterCloseData=null;                //多日分时图 收盘集合竞价数据

    this.MultiDayExtendWidth={ Left:40, Right:20 };   //多日分时图 左右扩展图形宽度

    this.ChartDrawStorage=new ChartDrawStorage();
    this.ChartDrawStorageCache=null;         //首次需要创建的画图工具数据

    this.MinuteApiUrl=g_JSChartResource.Domain+"/API/Stock";
    this.HistoryMinuteApiUrl=g_JSChartResource.Domain+'/API/StockMinuteData';  //历史分钟数据

    this.ColorLineData;    //主图价格线颜色自定义配置
    this.EnableSelectRect=false;    //是否可以区间选择
    this.SelectRectDialog=null;     //区间选择对话框

    this.CorssCursorIndex={ DayIndex:-1, DataIndex:-1, Point:{X:-1, Y:-1} ,Type:-1 };
    this.EnableNewIndex=false  //是否使用新的索引版本

    this.DayOffset={ Offset:0, ShowDayCount:-1, DataOffset:0, DayCount:1,  }; //Offset 日期偏移 , DataOffset数据偏移
    this.PageInfo={ Enable:false, Offset:-8888, ShowDayCount:4 };   //分页配置
    this.DataStatus={ MultiDay:false, LatestDay:false, LatestDate:null};      //MultiDay=多日  LatestDay:当天 LatestDate:最后的日期

    this.ZoomStepPixel=50;
    this.BaselineType=0;    //基准线类型 0=最新昨收盘 1=多日前昨收盘
    this.EnableNightDayBG=false;    //是否启动夜盘背景色

    //集合竞价设置 obj={ Left:true/false, Right:true/false, MultiDay:{Left:, Right:} }
    this.SetCallCationDataBorder=function(obj)
    {
        if (!obj) return;

        var extendWidth=
        {
            Left: obj.Left?this.ExtendWidth.Left:0,
            Right: obj.Right?this.ExtendWidth.Right:0
        };

        this.Frame.SetExtendWidth(extendWidth);

        if (obj.MultiDay)
        {
            var item=obj.MultiDay;
            var DayMinuteWidth=
            {
                Left:item.Left? this.MultiDayExtendWidth.Left:0,
                Right:item.Right? this.MultiDayExtendWidth.Right:0
            };

            this.Frame.SetMultiDayMinuteWidth(DayMinuteWidth);
        }
    }

    this.ReloadChartPaint=function(resource)
    {
        for(var i=0; i<this.ChartPaint.length; ++i)
        {
            var item=this.ChartPaint[i];
            if (!item) continue;
            if (item.ReloadResource) item.ReloadResource(resource);

            if (i==0)
            {
                if (item.Name=="Minute-Line")
                {
                    item.Color=g_JSChartResource.Minute.PriceColor;
                    item.AreaColor=g_JSChartResource.Minute.AreaPriceColor;
                }
            }
            else if (i==1)
            {
                if (item.Name=="Minute-Average-Line")
                {
                    item.Color=g_JSChartResource.Minute.AvPriceColor;
                }
            }
            else if (i==2)
            {
                if (item.Name=="Minute-Vol-Bar")
                {
                    item.Color=g_JSChartResource.Minute.VolBarColor;
                }
            }
        }
    }

    this.StopAutoUpdate=function()
    {
        this.CancelAutoUpdate();
        if (!this.IsAutoUpdate) return;
        this.IsAutoUpdate=false;
    }

    this.ClickFrameButton=function(button, e)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_FRAME_TOOLBAR);
        if (event && event.Callback)
        {
            var data={ Info:button, PreventDefault:false  };    //PreventDefault 是否阻止内置的点击处理
            event.Callback(event,data,this);
            if (data.PreventDefault) return;
        }

        if (button.ID==JSCHART_BUTTON_ID.CLOSE_BEFOREOPEN_ID)
        {
            this.ShowCallAuctionData({ Left:false, Right:false, MultiDay:{ Left:false, Right:false } });
        }
        else if (button.ID==JSCHART_BUTTON_ID.CLOSE_OVERLAY_INDEX)
        {
            var id=button.IndexID;
            if (id) this.DeleteOverlayWindowsIndex(id);
        }
        else if (button.ID==JSCHART_BUTTON_ID.MODIFY_OVERLAY_INDEX_PARAM)
        {
            var id=button.IndexID;
            var frame=button.Frame;
            e.data={ Chart:this, Identify:id, IsOverlay:true };
            if (frame.ModifyIndexEvent) 
                frame.ModifyIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.CLOSE_INDEX_WINDOW)
        {
            var frame=button.Frame;
            this.RemoveIndexWindow(frame.Identify);
        }
        else if (button.ID==JSCHART_BUTTON_ID.CHANGE_INDEX)
        {
            var frame=button.Frame;
            e.data={ Chart:this, Identify:frame.Identify, IsOverlay:false };
            if (frame.ChangeIndexEvent) 
                frame.ChangeIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.MODIFY_INDEX_PARAM)
        {
            var frame=button.Frame;
            e.data={ Chart:this, Identify:frame.Identify, IsOverlay:false };
            if (frame.ModifyIndexEvent) 
                frame.ModifyIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.OVERLAY_INDEX)
        {
            var frame=button.Frame;
            e.data={ Chart:this, Identify:frame.Identify, IsOverlay:true };
            if (frame.ChangeIndexEvent) 
                frame.ChangeIndexEvent(e);
        }
        else if (button.ID==JSCHART_BUTTON_ID.MAX_MIN_WINDOW)
        {
            var id=button.IndexID;
            var frame=button.Frame;
            var frameId=button.FrameID;
            if (frameId>=this.Frame.ZoomStartWindowIndex)
            {
                if (this.ZoomIndexWindow(frameId, null))
                {
                    this.Frame.SetSizeChage(true);
                    this.Draw();
                }
            }
        }
        else if (button.ID==JSCHART_BUTTON_ID.TITLE_WINDOW) //标题模式
        {
            var id=button.IndexID;
            var frame=button.Frame;
            var frameId=button.FrameID;
            if (this.ShowIndexTitleOnly(frameId))
            {
                this.Frame.SetSizeChage(true);
                this.Draw();
            }
        }
        else if (button.ID==JSCHART_BUTTON_ID.EXPORT_DATA)  //数据导出
        {
            var data=this.ExportData({Type:"CSV"});
            if (!data) return;
    
            var date=Date.now();
            var fileName = `hqchart_${this.Symbol}_${date}.csv`;
            var alink = document.createElement("a");
            var csvDataBlob = new Blob([data], { type: "text/csv" });
            alink.href = URL.createObjectURL(csvDataBlob);
            document.body.appendChild(alink);
            alink.setAttribute("download", fileName);
            alink.click();
            document.body.removeChild(alink);
        }
            
    }

    //图形控制 { ID:, ....参数 }
    this.ChartOperator=function(obj)
    {
        var id=obj.ID;
        if (id===JSCHART_OPERATOR_ID.OP_SCROLL_LEFT || id===JSCHART_OPERATOR_ID.OP_SCROLL_RIGHT )    //左右移动 { Step:移动天数 }
        {
            if (this.DayCount==1) return false;
            if (!this.PageInfo.Enable) return false;
            if (!this.DayData) return false;    //数据还没有下载好
            var isLeft=(id===JSCHART_OPERATOR_ID.OP_SCROLL_LEFT ? true:false);
            var step=1;
            if (obj.Step>0) step=obj.Step;
            if (!this.DayOffset) return false;
            if (isLeft)
            {
                var offset=this.DayOffset.Offset;
                offset+=step;
                if (offset+this.DayOffset.ShowDayCount>this.DayOffset.DayCount) offset=this.DayOffset.DayCount-this.DayOffset.ShowDayCount;
                if (offset==this.DayOffset.Offset) return false;
                this.DayOffset.Offset=offset;
            }
            else
            {
                var offset=this.DayOffset.Offset;
                offset-=step;
                if (offset<0) offset=0;
                if (offset==this.DayOffset.Offset) return false;
                this.DayOffset.Offset=offset;
            }

            this.UpdateHistoryMinuteUI(null);

            this.SendPageChangedEvent();
            return true;
        }
        else if (id==JSCHART_OPERATOR_ID.OP_SCROLL_GOTO)
        {
            if (this.DayCount==1) return false;
            if (!this.PageInfo.Enable) return false;
            if (!this.DayData) return false;    //数据还没有下载好

            if (IFrameSplitOperator.IsNumber(obj.ShowDayCount))
            {
                this.PageInfo.ShowDayCount=obj.ShowDayCount;
                this.DayOffset.ShowDayCount=obj.ShowDayCount;
            }

            if (IFrameSplitOperator.IsNumber(obj.Offset))
            {
                var offset=obj.Offset;
                if (this.DayOffset.ShowDayCount>0 && offset+this.DayOffset.ShowDayCount>=this.DayOffset.DayCount) offset=this.DayOffset.DayCount-this.DayOffset.ShowDayCount;
                if (offset==this.DayOffset.Offset) return false;
                this.DayOffset.Offset=offset;
            }
            
            this.UpdateHistoryMinuteUI(null);

            this.SendPageChangedEvent();
            return true;
        }
        else if (id==JSCHART_OPERATOR_ID.OP_CORSSCURSOR_GOTO) //{ Type:1 如果不存在 就隐藏十字光标}
        {
            if (!this.SourceData) return false;
            if (!this.Frame || !this.Frame.SubFrame[0] || !this.Frame.SubFrame[0].Frame) return false;
            var frame=this.Frame.SubFrame[0].Frame;
            if (!IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data)) return false;
            if (IFrameSplitOperator.IsNumber(obj.Time) && IFrameSplitOperator.IsNumber(obj.Date))
            {
                var findIndex=-1, value=null, lastPrice=null;
                for(var i=0;i<this.SourceData.Data.length;++i)
                {
                    var item=this.SourceData.Data[i];
                    if (IFrameSplitOperator.IsNumber(item.Close)) lastPrice=item.Close;
                    if (item.Time==obj.Time && item.Date==obj.Date)
                    {
                        findIndex=i;
                        value=item.Close;
                        break;
                    }
                }

                if (findIndex<0 && this.DayCount==1 && !(IFrameSplitOperator.IsNumber(obj.Type) && obj.Type>0))
                {
                    var timeData = g_MinuteTimeStringData.GetTimeData(this.Symbol);
                    for(var i=0;i<timeData.length;++i)
                    {
                        if (timeData[i]==obj.Time)
                        {
                            findIndex=i;
                            value=lastPrice;
                            break;
                        }
                    }
                }

                if (findIndex<0) 
                {
                    if (obj.Type==1)    // 如果不存在 就隐藏十字光标
                    {
                        var x=-1,y=-1;
                        var MoveStatus={ X:x, Y:y, IsInClient: this.IsMouseOnClient(x,y) };
                        this.LastMouseStatus.OnMouseMove=MoveStatus;
                        this.LastMouseStatus.MoveOnPoint={X:x, Y:y};    //鼠标移动的位置
    
                        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MOUSE_MOVE);
                        var titleChart=this.TitlePaint[0];
                        if (event && titleChart) titleChart.OnMouseMoveEvent=event;
    
                        var e={clientX:x, clientY:y};
                        this.MoveOnPoint={X:x, Y:y};
                        this.OnMouseMove(x,y,e);
                        this.LastMouseStatus.MoveOnPoint=null;
                        if (titleChart) titleChart.OnMouseMoveEvent=null;
                    }

                    return;
                }
            }

            var x=frame.GetXFromIndex(findIndex);
            var y=frame.GetYFromData(value);

            //保存最后一次鼠标移动信息
            var MoveStatus={ X:x, Y:y, IsInClient: this.IsMouseOnClient(x,y) };
            this.LastMouseStatus.OnMouseMove=MoveStatus;
            this.LastMouseStatus.MoveOnPoint={X:x, Y:y};    //鼠标移动的位置

            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MOUSE_MOVE);
            var titleChart=this.TitlePaint[0];
            if (event && titleChart) titleChart.OnMouseMoveEvent=event;
            
            this.MoveOnPoint={X:x, Y:y};
            this.OnMouseMove(x,y,{});
            
            this.LastMouseStatus.MoveOnPoint=null;
            if (titleChart) titleChart.OnMouseMoveEvent=null;
            
        }
    }

    this.SendPageChangedEvent=function()
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MINUTE_PAGE_CHANGED); //选中画图工具事件
        if (!event || !event.Callback) return;
        
        var sendData={ DayOffset:this.DayOffset, DayData:this.DayData };
        event.Callback(event,sendData,this);
    }

    this.IsMouseOnClient=function(x,y)
    {
        var border=this.Frame.IsHScreen?this.Frame.ChartBorder.GetHScreenBorder():this.Frame.ChartBorder.GetBorder();
        var rect={ Left:border.Left, Top:border.Top, Right:border.Right, Bottom:border.Bottom };

        if (x>=rect.Left && x<=rect.Right && y>=rect.Top && y<=rect.Bottom) return true;

        return false;
    }

    //左右拖拽
    this.OnDragMode_One=function(moveData, e)
    {
        var drag=this.MouseDrag;
        var moveSetp=moveData.X;
        var yMoveSetp=moveData.Y;

        if (this.RectSelectDrag && this.RectSelectDrag.Index>=0)    //区间选择
        {
            if (moveSetp<5) return;
            var obj={ X:e.clientX, Y:e.clientY, PointIndex:this.RectSelectDrag.Index, Name:"MoveRectSelectLine" };
            if (this.MoveRectSelectPoint(obj))
            {
                drag.LastMove.X=e.clientX;
                this.Draw();
            }
        }
        else
        {
            if (moveSetp<5 && yMoveSetp<5) return;
            if (!this.EnableSelectRect) return;

            //this.UIElement.style.cursor="default";
            this.SetCursor({Cursor:"default"});
            var ptStart=this.PointAbsoluteToRelative(drag.Click.X, drag.Click.Y);
            var ptEnd=this.PointAbsoluteToRelative(e.clientX, e.clientY);

            this.ShowDragSelectRect(ptStart, ptEnd);
    
            drag.LastMove.X=e.clientX;
            drag.LastMove.Y=e.clientY;
        }
    }

    this.OnMinuteSelectRectMouseUp=function(e)
    {
        var drag=this.MouseDrag;
        drag.LastMove.X=e.clientX;
        drag.LastMove.Y=e.clientY;

        var selectData=new SelectRectData();
        var pixelTatio = GetDevicePixelRatio();
        //区间起始位置 结束位子
        selectData.XStart=(drag.Click.X-uielement.getBoundingClientRect().left)*pixelTatio;
        selectData.YStart=(drag.Click.Y-uielement.getBoundingClientRect().top)*pixelTatio;
        selectData.XEnd=(drag.LastMove.X-uielement.getBoundingClientRect().left)*pixelTatio;
        selectData.YEnd=(drag.LastMove.Y-uielement.getBoundingClientRect().top)*pixelTatio;
        selectData.JSChartContainer=this;
        selectData.Stock={Symbol:this.Symbol, Name:this.Name};

        if (this.EnableSelectRect && !this.BorderDrag && this.GetSelectRectData(selectData))
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_SELECT_RECT);
            var paint=this.GetRectSelectPaint();
            var isShowDialog=true;  //是否显示内置区间选择框
            if (event && event.Callback)
            {
                var data=
                { 
                    X:drag.LastMove.X-uielement.getBoundingClientRect().left,
                    Y:drag.LastMove.Y-uielement.getBoundingClientRect().top,
                    SelectData:selectData,   //区间选择的数据
                    RectSelectPaint:paint,    //区间选择背景
                    e:e
                };
                event.Callback(event,data,this);
                isShowDialog=false; //外部调用了区间选择事件，不弹框
            }

            if (isShowDialog && this.SelectRectDialog)
            {
                e.data=
                {
                    Chart:this,
                    X:drag.LastMove.X-uielement.getBoundingClientRect().left,
                    Y:drag.LastMove.Y-uielement.getBoundingClientRect().top,
                    SelectData:selectData,          //区间选择的数据
                    RectSelectPaint:paint           //区间选择背景
                };

                this.SelectRectDialog.DoModal(e);
            }
            else
            {
                this.HideSelectRect();
                this.UpdateSelectRect(selectData.Start,selectData.End);
            }
        }
        else
        {
            this.TryClickPaintEvent(JSCHART_EVENT_ID.ON_CLICKUP_CHART_PAINT,this.ClickDownPoint,e);
            this.ClickEvent(e);
        }
    }

    this.OnDragSelectRectMouseUp=function(e)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return;
        
        var selectData=paint.GetSelectRectData();
        if (!selectData) return;

        var pixelTatio = GetDevicePixelRatio();
        var corssCursor=this.ChartCorssCursor;  //十字光标
        var x=corssCursor.LastPoint.X/pixelTatio;
        var y=corssCursor.LastPoint.Y/pixelTatio;

        var isShowDialog=true;  //是否显示内置区间选择框
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAG_SELECT_RECT_MOUSEUP);
        if (event)
        {
            var data=
            { 
                X:x,
                Y:y,
                SelectData:selectData,   //区间选择的数据
                RectSelectPaint:paint,    //区间选择背景
                IsShowDialog:false
            };
            event.Callback(event,data,this);
            isShowDialog=data.IsShowDialog;
        }

        if (isShowDialog && this.SelectRectDialog)
        {
            e.data=
            {
                Chart:this,
                X:x,
                Y:y,
                SelectData:selectData,          //区间选择的数据
                RectSelectPaint:paint           //区间选择背景
            };

            this.SelectRectDialog.DoModal(e);
        }
            
    }

    this.UpdateSelectRect=function(start,end)
    {
        if (!this.SourceData || !this.SourceData.Data) return;
        var paint=this.GetRectSelectPaint();
        if (!paint) return;

        var data=this.SourceData;
        if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) return;
        var count=data.Data.length;
        var startItem=data.Data[start];
        if (end>=count) end=count-1;
        var endItem=data.Data[end];

        JSConsole.Chart.Log('[MinuteChartContainer::UpdateSelectRect]',startItem,endItem);
        paint.SetPoint(startItem, { Index:0 });
        paint.SetPoint(endItem, { Index:1 });

        this.Draw();
    }

    this.MoveRectSelectPoint=function(obj)
    {
        var paint=this.GetRectSelectPaint();
        if (!paint) return false;

        if (!this.SourceData || !this.SourceData.Data) return false;
        var kData=this.SourceData;

        if (!this.Frame.SubFrame[0]) return false;
        var subFrame=this.Frame.SubFrame[0].Frame;
        if (!subFrame) false;

        var pixelTatio = GetDevicePixelRatio();
        var x=(obj.X-uielement.getBoundingClientRect().left)*pixelTatio;
        var index=subFrame.GetXData(x);
        index=parseInt(index.toFixed(0));
        var dataIndex=index+kData.DataOffset;
        if (dataIndex>=kData.Data.length) dataIndex=kData.Data.length-1;

        var item = kData.Data[dataIndex];
        JSConsole.Chart.Log("[MinuteChartContainer::MoveRectSelectPoint] point, item", obj.PointIndex, item);

        if (!paint.SetPoint(item,{ Index: obj.PointIndex })) return false;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DRAG_SELECT_RECT);
        if (event)
        {
            var selectData=paint.GetSelectRectData();
            var data={ X:obj.X, Y:obj.Y, SelectData:selectData, RectSelectPaint:paint };
            event.Callback(event,data,this);
        }

        return true;
    }

    this.GetLastCursorIndex=function(obj)
    {
        if (obj.DataType==1)
        {
            for(var i=obj.Data.length-1;i>=0;--i)
            {
                var item=obj.Data[i];
                if (!item || !item.DayItem || !item.DayItem.Data) continue;

                obj.IndexData.DayIndex=0;
                obj.IndexData.DataIndex=item.DayItem.Data.length-1;
                obj.IndexData.Type=item.Type;
                return;
            }
        }
        else if (obj.DataType==2)
        {
            for(var i=obj.Data.length-1;i>=0;--i)
            {
                var dayItem=obj.Data[i];
                for(var j=dayItem.length-1;j>=0;--j)
                {
                    var item=dayItem[j];
                    if (!item || !item.DayItem || !item.DayItem.Data) continue;

                    obj.IndexData.DayIndex=i;
                    obj.IndexData.DataIndex=item.DayItem.Data.length-1;
                    obj.IndexData.Type=item.Type;
                    return;
                }
            }
        }
    }

    this.GetFirstCursorIndex=function(obj)
    {
        if (obj.DataType==1)
        {
            for(var i=0;i<obj.Data.length;++i)
            {
                var item=obj.Data[i];
                if (!item || !item.DayItem || !item.DayItem.Data) continue;

                obj.IndexData.DayIndex=0;
                obj.IndexData.DataIndex=0;
                obj.IndexData.Type=item.Type;
                return;
            }
        }
        else if (obj.DataType==2)
        {
            for(var i=0;i<obj.Data.length;++i)
            {
                var dayItem=obj.Data[i];
                for(var j=0;j<dayItem.length;++j)
                {
                    var item=dayItem[j];
                    if (!item || !item.DayItem || !item.DayItem.Data) continue;

                    obj.IndexData.DayIndex=i;
                    obj.IndexData.DataIndex=0;
                    obj.IndexData.Type=item.Type;
                    return;
                }
            }
        }
    }

    //获取单日 盘后集合竞价数据
    this.GetAfterCloseData=function()
    {
        var dayItem=null;
        if (this.AfterCloseData && this.IsShowAfterData) dayItem=this.AfterCloseData;
        return dayItem;
    }

    //获取单日 盘前集合竞价数据
    this.GetBeforeOpenData=function()
    {
        var dayItem=null;
        if (this.BeforeOpenData && this.IsShowBeforeData) dayItem=this.BeforeOpenData;
        return dayItem;
    }

    this.MoveCorssCursorIndex=function(option)
    {
        if (!this.EnableNewIndex) return false;

        if (!this.Frame.SubFrame[0] || !this.Frame.SubFrame[0].Frame) return false;
        var frame=this.Frame.SubFrame[0].Frame;
        if (this.CorssCursorIndex.Type==1 || this.CorssCursorIndex.Type==2 || this.CorssCursorIndex.Type==3 || this.CorssCursorIndex.Type==-1)
        {
            var aryData=[];
            var dayItem=this.GetBeforeOpenData();
            aryData.push({DayItem:dayItem, Type:2});

            var dayItem=null;
            if (this.SourceData) dayItem=this.SourceData;
            aryData.push({DayItem:dayItem, Type:1});

            var dayItem=this.GetAfterCloseData();;
            aryData.push({DayItem:dayItem, Type:3});

            var obj={ DataType:1, Data: aryData, IndexData:this.CorssCursorIndex, Point:{ X:null, Y:null }};
            var step=1;
            if (option.IsMoveLeft) 
            {
                if (this.CorssCursorIndex.DayIndex<0 && this.CorssCursorIndex.DataIndex<0) 
                {
                    this.GetLastCursorIndex(obj);
                    step=0;
                }

                if (frame.MoveXIndexLeft(step, obj))
                {
                    this.LastPoint.X=obj.Point.X;
                    this.LastPoint.Y=obj.Point.Y;
                    if (this.CorssCursorIndex.Type==1) this.CursorIndex=this.CorssCursorIndex.CursorIndex;
                    var option={ ParentFunction:'MoveCorssCursorIndex', Point:{X:obj.Point.X, Y:obj.Point.Y}, IsPhone:false, ClientPos:this.CorssCursorIndex.Type };
                    this.DrawDynamicInfo(option);
                }
            }
            else
            {
                if (this.CorssCursorIndex.DayIndex<0 && this.CorssCursorIndex.DataIndex<0) 
                {
                    this.GetFirstCursorIndex(obj);
                    step=0;
                }
                
                if (frame.MoveXIndexRight(step, obj))
                {
                    this.LastPoint.X=obj.Point.X;
                    this.LastPoint.Y=obj.Point.Y;
                    if (this.CorssCursorIndex.Type==1) this.CursorIndex=this.CorssCursorIndex.CursorIndex;
                    var option={ ParentFunction:'MoveCorssCursorIndex', Point:{X:obj.Point.X, Y:obj.Point.Y}, IsPhone:false, ClientPos:this.CorssCursorIndex.Type };
                    this.DrawDynamicInfo(option);
                }
            }
        }
        else if (this.CorssCursorIndex.Type==10 || this.CorssCursorIndex.Type==20 || this.CorssCursorIndex.Type==30 || this.CorssCursorIndex.Type==-2 )
        {
            var aryData=[];
            var offset=0, showDayCount=this.DayData.length;
            if (this.DayOffset)
            {
                if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
                if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
            }

            for(var i=offset,j=0; i<this.DayData.length && j<showDayCount; ++i,++j)
            {
                var item=[];
                var dayItem=null;
                if (this.MultiDayBeforeOpenData && this.IsShowMultiDayBeforeData) dayItem=this.MultiDayBeforeOpenData[i];
                item.push({DayItem:dayItem, Type:20});

                //倒序排的
                var dayItem=null;
                if (this.DayData) dayItem=this.DayData[this.DayData.length-1-i];
                item.push({DayItem:dayItem, Type:10});
                
                var dayItem=null;
                if (this.MultiDayAfterCloseData && this.IsShowMultiDayAfterData) dayItem=this.MultiDayAfterCloseData[i];
                item.push({DayItem:dayItem, Type:30});

                aryData.push(item);  
            }

            var obj={ DataType:2, Data: aryData, IndexData:this.CorssCursorIndex, Point:{ X:null, Y:null }};
            var step=1;
            if (option.IsMoveLeft) 
            {
                if (this.CorssCursorIndex.DayIndex<0 && this.CorssCursorIndex.DataIndex<0) 
                {
                    this.GetLastCursorIndex(obj);
                    step=0;
                }
                
                if (frame.MoveXIndexLeft(step, obj))
                {
                    this.LastPoint.X=obj.Point.X;
                    this.LastPoint.Y=obj.Point.Y;
                    if (this.CorssCursorIndex.Type==10) this.CursorIndex=this.CorssCursorIndex.CursorIndex;
                    var option={ ParentFunction:'MoveCorssCursorIndex', Point:{X:obj.Point.X, Y:obj.Point.Y}, IsPhone:false, ClientPos:null };
                    if (this.CorssCursorIndex.Type==10) option.ClientPos=1;
                    else if (this.CorssCursorIndex.Type==20) option.ClientPos=this.CorssCursorIndex.DayIndex+200;
                    else if (this.CorssCursorIndex.Type==30) option.ClientPos=this.CorssCursorIndex.DayIndex+300;
                    this.DrawDynamicInfo(option);
                }
            }
            else
            {
                if (this.CorssCursorIndex.DayIndex<0 && this.CorssCursorIndex.DataIndex<0) 
                {
                    this.GetFirstCursorIndex(obj);
                    step=0;
                }

                if (frame.MoveXIndexRight(step, obj))
                {
                    this.LastPoint.X=obj.Point.X;
                    this.LastPoint.Y=obj.Point.Y;
                    if (this.CorssCursorIndex.Type==10) this.CursorIndex=this.CorssCursorIndex.CursorIndex;
                    var option={ ParentFunction:'MoveCorssCursorIndex', Point:{X:obj.Point.X, Y:obj.Point.Y}, IsPhone:false, ClientPos:null };
                    if (this.CorssCursorIndex.Type==10) option.ClientPos=1;
                    else if (this.CorssCursorIndex.Type==20) option.ClientPos=this.CorssCursorIndex.DayIndex+200;
                    else if (this.CorssCursorIndex.Type==30) option.ClientPos=this.CorssCursorIndex.DayIndex+300;
                    this.DrawDynamicInfo(option);
                }
            }
        }
    }

    this.SetCorssCursorIndex=function(option)
    {
        if (!this.EnableNewIndex) return;

        JSConsole.Chart.Log("[MinuteChartContainer::SetCorssCursorIndex] option ", option);
        if (option.ParentFunction=="OnMouseMove")
        {
            this.CorssCursorIndex.Point.X=option.Point.X;
            this.CorssCursorIndex.Point.Y=option.Point.Y;

            var clientPos=this.PtInClient_V2(option.Point.X,option.Point.Y);
            JSConsole.Chart.Log("[MinuteChartContainer::SetCorssCursorIndex] clientPos ", clientPos);
            if (clientPos<=0)
            {
                this.CorssCursorIndex={ DayIndex:-1, DataIndex:-1, Point:{X:-1, Y:-1}, Type:clientPos };
                return;
            }

            if (!this.Frame.SubFrame[0] || !this.Frame.SubFrame[0].Frame)
            {
                this.CorssCursorIndex={ DayIndex:-1, DataIndex:-1, Point:{X:-1, Y:-1}, Type:-1 };
                return;
            }

            var frame=this.Frame.SubFrame[0].Frame;
            if (clientPos==1 || clientPos==2 || clientPos==3)
            {
                this.CorssCursorIndex.DayIndex=0;
                this.CorssCursorIndex.Type=clientPos;
                if (clientPos==2) 
                {
                    frame.GetLeftExtendXValidData(option.Point.X,{ Data: this.BeforeOpenData, IndexData: this.CorssCursorIndex });  
                }
                else if (clientPos==3) 
                {
                    frame.GetRightExtendXValidData(option.Point.X,{ Data: this.AfterCloseData, IndexData: this.CorssCursorIndex });
                }
                else if (clientPos==1) 
                {
                    var value=frame.GetXData(option.Point.X);
                    this.CorssCursorIndex.DataIndex=parseInt(value.toFixed(0));
                }
            }
            else if (clientPos>=100 && clientPos<=199)
            {
                this.CorssCursorIndex.DayIndex=clientPos-100;
                this.CorssCursorIndex.Type=10;
                var value=frame.GetXData(option.Point.X);
                var index=parseInt(value.toFixed(0));
                this.CorssCursorIndex.DataIndex=index%frame.MinuteCount;
            }
            else if (clientPos>=200 && clientPos<=299)
            {
                this.CorssCursorIndex.DayIndex=clientPos-200;
                this.CorssCursorIndex.Type=20;
                var aryData=this.MultiDayBeforeOpenData;
                if (this.DayOffset)
                {
                    var offset=0, showDayCount=this.MultiDayBeforeOpenData.length;
                    if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
                    if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
                    aryData=this.MultiDayBeforeOpenData.slice(offset,offset+showDayCount);
                }
                frame.GetLeftExtendXValidData(option.Point.X,{ Data: aryData, IndexData: this.CorssCursorIndex });               
            }
            else if (clientPos>=300 && clientPos<=399)
            {
                this.CorssCursorIndex.DayIndex=clientPos-300;
                this.CorssCursorIndex.Type=30;
                var aryData=this.MultiDayAfterCloseData;
                if (this.DayOffset && this.MultiDayAfterCloseData)
                {
                    var offset=0, showDayCount=this.MultiDayAfterCloseData.length;
                    if (IFrameSplitOperator.IsNumber(this.DayOffset.Offset)) offset=this.DayOffset.Offset;
                    if (IFrameSplitOperator.IsNumber(this.DayOffset.ShowDayCount)) showDayCount=this.DayOffset.ShowDayCount;
                    aryData=this.MultiDayAfterCloseData.slice(offset,offset+showDayCount);
                }
                frame.GetRightExtendXValidData(option.Point.X,{ Data: aryData, IndexData: this.CorssCursorIndex });
            }

            this.LastPoint.X=this.CorssCursorIndex.Point.X;
            option.Point.X=this.CorssCursorIndex.Point.X;
        }
    }

    // 100-199=多日分时主图  200-299=盘前  300-399=盘后  1=主图 2=盘前 3=盘后
    this.PtInClient_V2=function(x,y)
    {
        this.Canvas.beginPath();
        if (this.Frame.IsHScreen===true)
        {
            var border=this.Frame.ChartBorder.GetHScreenBorder();
            this.Canvas.rect(border.Left,border.TopEx,border.Right-border.Left,border.BottomEx-border.TopEx);
        }
        else
        {
            var border=this.Frame.ChartBorder.GetBorder();
            if (border.DayBorder)   //多日分时+多日集合竞价
            {
                for(var i=0;i<border.DayBorder.length;++i)
                {
                    var client=border.DayBorder[i];
                    this.Canvas.beginPath();
                    this.Canvas.rect(client.LeftEx,border.TopEx,client.RightEx-client.LeftEx,border.BottomEx-border.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) return 100+i;

                    //盘前
                    this.Canvas.beginPath();
                    this.Canvas.rect(client.Left,border.TopEx,client.LeftEx-client.Left,border.BottomEx-border.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 200+i;

                    //盘后
                    this.Canvas.beginPath();
                    this.Canvas.rect(client.RightEx,border.TopEx,client.Right-client.RightEx,border.BottomEx-border.TopEx);
                    if (this.Canvas.isPointInPath(x,y)) 
                        return 300+i;
                }

                return -2;
            }

            this.Canvas.rect(border.LeftEx,border.Top,border.RightEx-border.LeftEx,border.Bottom-border.Top);
        }

        if (this.Canvas.isPointInPath(x,y)) return 1;

        if (this.Frame.ChartBorder.LeftExtendWidth>10)
        {
            this.Canvas.beginPath();
            if (this.Frame.IsHScreen===true)
            {
                this.Canvas.rect(border.Left,border.Top,border.Right-border.Left,border.TopEx-border.Top);
            }
            else
            {
                this.Canvas.rect(border.Left,border.Top,border.LeftEx-border.Left,border.Bottom-border.Top);
            }
    
            if (this.Canvas.isPointInPath(x,y)) 
                return 2;
        }

        if (this.Frame.ChartBorder.RightExtendWidth>10)
        {
            this.Canvas.beginPath();
            if (this.Frame.IsHScreen===true)
            {
                this.Canvas.rect(border.Left,border.BottomEx,border.Right-border.Left,border.Bottom-border.BottomEx);
            }
            else
            {
                this.Canvas.rect(border.RightEx,border.Top,border.Right-border.RightEx,border.Bottom-border.Top);
            }
    
            if (this.Canvas.isPointInPath(x,y)) 
                return 3;
        }

        return -1;
    }


    //手势
    this.OnTouchStart=function(e)
    {
        if(this.DragMode==0) return;
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        this.IsPress=false;
        this.IsOnTouch=true;
        this.TouchDrawCount=0;
        this.PhonePinch=null;
        this.StopDragTimer();

        if (this.EnableScrollUpDown==false) e.preventDefault();  //上下拖动图形不能阻止事件

        if (this.IsPhoneDragging(e))
        {
            var drag= { Click:{}, LastMove:{} };//LastMove=最后移动的位置
            var touches=this.GetToucheData(e,this.IsForceLandscape);
            var pt=this.PointAbsoluteToRelative(touches[0].clientX, touches[0].clientY, true);

            if (this.TryClickLock || this.TryClickIndexTitle) //指标枷锁区域 , 指标标题点击
            {
                var x = pt.X;
                var y = pt.Y;
                if (this.TryClickLock && this.TryClickLock(x, y)) return;
                if (this.TryClickIndexTitle && this.TryClickIndexTitle(x,y)) return;
            }

            if (this.ClickFrameButton)
            {
                var button=this.Frame.PtInButtons(pt.X,pt.Y);
                if (button)
                {
                    this.ClickFrameButton(button, e);
                    return;
                }
            }

            drag.Click.X=touches[0].clientX;
            drag.Click.Y=touches[0].clientY;
            drag.LastMove.X=touches[0].clientX;
            drag.LastMove.Y=touches[0].clientY;
            var self=this;

            var T_ShowCorssCursor=function() //临时函数(Temp_) T_开头
            {
                if (self.ChartCorssCursor.IsShow === true)    //移动十字光标
                {
                    var pt=self.PointAbsoluteToRelative(drag.Click.X, drag.Click.Y, true);
                    var x = pt.X;
                    var y = pt.Y
                    self.OnMouseMove(x, y, e);
                }
            }

            if (this.ChartDrawOption.IsLockScreen)
            {
                this.MouseDrag=drag;
                if (this.SelectChartDrawPicture) this.SelectChartDrawPicture.IsSelected=false;
                this.SelectChartDrawPicture=null;

                if (this.CurrentChartDrawPicture)  //画图工具模式
                {
                    var drawPicture=this.CurrentChartDrawPicture;
                    if (drawPicture.Status==2)
                        this.SetChartDrawPictureThirdPoint(drag.Click.X,drag.Click.Y,true);
                    else
                    {
                        this.SetChartDrawPictureFirstPoint(drag.Click.X,drag.Click.Y,true);
                        //只有1个点 直接完成
                        if (this.FinishChartDrawPicturePoint()) this.DrawDynamicInfo({Corss:false, Tooltip:false});
                    }

                    if (e.cancelable) e.preventDefault();
                    return;
                }
                else
                {
                    var drawPictrueData={};
                    var pixelTatio = GetDevicePixelRatio(); //鼠标移动坐标是原始坐标 需要乘以放大倍速
                    drawPictrueData.X=(touches[0].clientX-uielement.getBoundingClientRect().left);
                    drawPictrueData.Y=(touches[0].clientY-uielement.getBoundingClientRect().top);
                    if (this.GetChartDrawPictureByPoint(drawPictrueData))
                    {
                        drawPictrueData.ChartDrawPicture.Status=20;
                        drawPictrueData.ChartDrawPicture.ValueToPoint();
                        drawPictrueData.ChartDrawPicture.MovePointIndex=drawPictrueData.PointIndex;
                        drawPictrueData.ChartDrawPicture.IsSelected=true;
                        this.CurrentChartDrawPicture=drawPictrueData.ChartDrawPicture;
                        this.SelectChartDrawPicture=drawPictrueData.ChartDrawPicture;
                        let event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_DRAWPICTURE); //选中画图工具事件
                        if (event && event.Callback)
                        {
                            let sendData={ DrawPicture: drawPictrueData.ChartDrawPicture };
                            event.Callback(event,sendData,this);
                        }

                        if (e.cancelable) e.preventDefault();
                        return;
                    }
                }
            }
            else
            {
                if (this.EnableScrollUpDown==true)
                {
                    this.DragTimer=setTimeout(function()
                    {
                        self.IsPress=true;
                        if (drag.Click.X==drag.LastMove.X && drag.Click.Y==drag.LastMove.Y)
                        {
                            var mouseDrag=self.MouseDrag;
                            self.MouseDrag=null;
                            T_ShowCorssCursor();
                            self.PreventTouchEvent(e)
                        }
                    }, 800);
                }
    
                this.MouseDrag=drag;
                this.PhoneTouchInfo={ Start:{X:touches[0].clientX, Y:touches[0].clientY }, End:{ X:touches[0].clientX, Y:touches[0].clientY } };
                this.SelectChartDrawPicture=null;
    
                if (this.EnableScrollUpDown==false)
                    T_ShowCorssCursor();    //移动十字光标
                else if (this.IsClickShowCorssCursor)
                    T_ShowCorssCursor(); 
            }

            if (this.EnableZoomIndexWindow)
            {
                this.PhoneDBClick.AddTouchStart(touches[0].clientX, touches[0].clientY, Date.now());
                JSConsole.Chart.Log("[MinuteChartContainer::OnTouchStart] PhoneDBClick ", this.PhoneDBClick);
            }

            this.TouchEvent({ EventID:JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName:"OnTouchStart"}, e);
        }
        else if (this.IsPhonePinching(e))
        {
            var phonePinch=
            {
                "Start":{},
                "Last":{}
            };

            var touches=this.GetToucheData(e,this.IsForceLandscape);

            phonePinch.Start={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};
            phonePinch.Last={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};

            this.PhonePinch=phonePinch;
            this.SelectChartDrawPicture=null;
        }
    }

    this.OnTouchMove=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        var touches=this.GetToucheData(e,this.IsForceLandscape);
        if (this.IsPhoneDragging(e))
        {
            var drag=this.MouseDrag;
            if (drag==null)
            {
                var pixelTatio = GetDevicePixelRatio();
                var x = touches[0].clientX-uielement.getBoundingClientRect().left*pixelTatio;
                var y = touches[0].clientY-uielement.getBoundingClientRect().top*pixelTatio;
                this.OnMouseMove(x,y,e);
            }
            else
            {
                var moveAngle=this.GetMoveAngle(drag.LastMove,{X:touches[0].clientX, Y:touches[0].clientY});
                var moveSetp=Math.abs(drag.LastMove.X-touches[0].clientX);
                var moveUpDown=Math.abs(drag.LastMove.Y-touches[0].clientY);
                moveSetp=parseInt(moveSetp);

                if (this.CurrentChartDrawPicture)
                {
                    var drawPicture=this.CurrentChartDrawPicture;
                    if (drawPicture.Status==1 || drawPicture.Status==2)
                    {
                        if(moveSetp<5 && moveUpDown<5) return;
                        if(this.SetChartDrawPictureSecondPoint(touches[0].clientX,touches[0].clientY,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }
                    else if (drawPicture.Status==3)
                    {
                        if(this.SetChartDrawPictureThirdPoint(touches[0].clientX,touches[0].clientY,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }
                    else if (drawPicture.Status==20)    //画图工具移动
                    {
                        if(moveSetp<5 && moveUpDown<5) return;

                        if(this.MoveChartDrawPicture(touches[0].clientX-drag.LastMove.X,touches[0].clientY-drag.LastMove.Y,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }

                    drag.LastMove.X=touches[0].clientX;
                    drag.LastMove.Y=touches[0].clientY;
                }
                else
                {
                    //上下滚动
                    if ( ((moveUpDown>0 && moveSetp<=3) || moveAngle<=this.TouchMoveMinAngle) && this.EnableScrollUpDown==true ) 
                    {
                        this.StopDragTimer();
                        return;
                    }

                    this.PreventTouchEvent(e);
                    this.MouseDrag=null;
                    var pixelTatio = GetDevicePixelRatio();
                    var x = touches[0].clientX-uielement.getBoundingClientRect().left*pixelTatio;
                    var y = touches[0].clientY-uielement.getBoundingClientRect().top*pixelTatio;
                    this.OnMouseMove(x,y,e);
                }
            }

            if (this.PhoneTouchInfo)
            {
                this.PhoneTouchInfo.End.X=touches[0].clientX;
                this.PhoneTouchInfo.End.Y=touches[0].clientY;
            }
        }
        else if (this.IsPhonePinching(e))
        {
            this.PreventTouchEvent(e);
            var phonePinch=this.PhonePinch;
            if (!phonePinch) return;

            var yHeight=Math.abs(touches[0].pageY-touches[1].pageY);
            var yLastHeight=Math.abs(phonePinch.Last.Y-phonePinch.Last.Y2);
            var yStep=yHeight-yLastHeight;

            var xHeight=Math.abs(touches[0].pageX-touches[1].pageX);
            var xLastHeight=Math.abs(phonePinch.Last.X-phonePinch.Last.X2);
            var xStep=xHeight-xLastHeight;
            var minStep=this.ZoomStepPixel;
            if (Math.abs(xStep)>minStep)
            {
                var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_MINUTE_TOUCH_ZOOM)
                if (event && event.Callback)
                {
                    var data={ XStep:xStep, YStep:yStep, PreventDefault:false };
                    event.Callback(event,data,this);
                    if (data.PreventDefault) 
                    {
                        this.PhonePinch=null;
                        this.StopDragTimer();
                        return;
                    }
                    
                }
            }

            phonePinch.Last={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};
        }

        if (this.EnableScrollUpDown==false)
        {
            e.preventDefault();
        }
        else
        {
            if (drag==null) 
            {
                this.PreventTouchEvent(e); //十字光标出来了,阻止消息
            }  
            else 
            {
                this.StopDragTimer();   //上下推动图片,停止定时器,消息传递下去
            }
        }
    }

    this.OnTouchEnd=function(e)
    {
        JSConsole.Chart.Log('[MinuteChartContainer::OnTouchEnd]',e);
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        var bClearDrawPicture=true;
        if (this.CurrentChartDrawPicture)
        {
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.Status==2 || drawPicture.Status==1 || drawPicture.Status==3)
            {
                drawPicture.PointStatus=drawPicture.Status;
                if (this.FinishChartDrawPicturePoint())
                    this.DrawDynamicInfo();
                else
                    bClearDrawPicture=false;
            }
            else if (drawPicture.Status==20)
            {
                if (this.FinishMoveChartDrawPicture())
                    this.DrawDynamicInfo();
            }
        }

        if (this.EnableZoomIndexWindow)
        {
            var time=Date.now();
            this.PhoneDBClick.AddTouchEnd(time);
            if (this.PhoneDBClick.IsVaildDBClick())
            {
                this.OnTouchDBClick(this.PhoneDBClick.Start);
                this.PhoneDBClick.Clear();
            }
        }

        this.IsOnTouch = false;
        this.StopDragTimer();
        this.TouchEvent({ EventID:JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName:"OnTouchEnd"}, e);
        this.OnTouchFinished();
        this.TouchDrawCount=0;
    }

    
    //键盘左右移动十字光标
    this.OnKeyDown=function(e)
    {
        this.StopDisplayLatest();

        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        //回调事件
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_KEYDOWN);
        if (event && event.Callback)
        {
            var sendData={ e:e, PreventDefault:false };
            event.Callback(event, sendData, this);
            if (sendData.PreventDefault) return;
        }

        var keyID = e.keyCode ? e.keyCode :e.which;
        switch(keyID)
        {
            case 37: //left
                if (this.EnableNewIndex)
                {
                    this.MoveCorssCursorIndex({IsMoveLeft:true});
                }
                else
                {
                    if (!IFrameSplitOperator.IsNumber(this.CursorIndex))
                    {
                        var xPointcount=0;
                        if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
                        else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
                        this.CursorIndex=xPointcount-1;
                    }
                    this.CursorIndex=parseInt(this.CursorIndex);
                    if (this.CursorIndex<=0.99999)
                    {
                        if (!this.DataMoveLeft()) break;
                        this.UpdataDataoffset();
                        this.UpdatePointByCursorIndex();
                        this.UpdateFrameMaxMin();
                        this.Draw();
                    }
                    else
                    {
                        --this.CursorIndex;
                        this.UpdatePointByCursorIndex();
                        this.DrawDynamicInfo();
                    }
                }
                break;
            case 39: //right
                if (this.EnableNewIndex)
                {
                    this.MoveCorssCursorIndex({IsMoveLeft:false});
                }
                else
                {
                    var xPointcount=0;
                    if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
                    else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
                    if (!IFrameSplitOperator.IsNumber(this.CursorIndex)) this.CursorIndex=0;
                    this.CursorIndex=parseInt(this.CursorIndex);
                    if (this.CursorIndex+1>=xPointcount)
                    {
                        if (!this.DataMoveRight()) break;
                        this.UpdataDataoffset();
                        this.UpdatePointByCursorIndex();
                        this.UpdateFrameMaxMin();
                        this.Draw();
                    }
                    else
                    {
                        //判断是否在最后一个数据上
                        var data=null;
                        if (this.Frame.Data) data=this.Frame.Data;
                        else data=this.Frame.SubFrame[0].Frame.Data;
                        if (!data) break;
                        if (this.CursorIndex+data.DataOffset+1>=data.Data.length) break;
    
                        ++this.CursorIndex;
                        this.UpdatePointByCursorIndex();
                        this.DrawDynamicInfo();
                    }
                }
                break;
            case 46:    //del
                if (this.SelectChartDrawPicture) 
                {
                    var drawPicture=this.SelectChartDrawPicture;
                    JSConsole.Chart.Log(drawPicture,"drawPicturedrawPicturedrawPicture")
                    this.SelectChartDrawPicture=null;
                    this.ClearChartDrawPicture(drawPicture);    //删除选中的画图工具
                }
                else if (this.SelectedChart && this.SelectedChart.Selected.Identify)
                {
                    var selectedInfo=this.GetSelectedChartInfo(this.SelectedChart.Selected);
                    if (selectedInfo)
                    {
                        if (selectedInfo.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_INDEX)
                            this.DeleteOverlayWindowsIndex(selectedInfo.IndexID);
                        else if (selectedInfo.Type==JSCHART_DRAGCHART_TYPE_ID.OVERLAY_MINUTE)
                            this.DeleteOverlaySymbol(selectedInfo.Symbol);
                    }
                }
                break;
            case 32:    //space
                this.OnMarkRectSelect(e);
                break;
            case 33:    //page up
                if (this.PageInfo.Enable)
                {
                    var option={ID:JSCHART_OPERATOR_ID.OP_SCROLL_LEFT, Step:this.PageInfo.ShowDayCount };
                    this.ChartOperator(option);
                }
                break;
            case 34:    //page down
                if (this.PageInfo.Enable)
                {
                    var option={ID:JSCHART_OPERATOR_ID.OP_SCROLL_RIGHT, Step:this.PageInfo.ShowDayCount };
                    this.ChartOperator(option);
                }
                break;
            default:
                return;
        }

        //不让滚动条滚动
        if(e.preventDefault) e.preventDefault();
        else e.returnValue = false;
    }

    this.OnMarkRectSelect=function(e)
    {
        var corssCursor=this.ChartCorssCursor;  //十字光标
        if (!corssCursor || corssCursor.Status==0) return;
        if (!IFrameSplitOperator.IsNumber(corssCursor.CursorIndex)) return;
        if (!this.SourceData || !this.SourceData.Data) return;
        var paint=this.GetRectSelectPaint();
        if (!paint) return;

        var cursorIndex=corssCursor.CursorIndex;
        JSConsole.Chart.Log("[MinuteChartContainer::OnMarkRectSelect] dataIndex", cursorIndex);

        var kData=this.SourceData;
        cursorIndex=parseInt(cursorIndex.toFixed(0));
        var index=cursorIndex+kData.DataOffset;
        if (index>=kData.Data.length) index=kData.Data.length-1;

        var item = kData.Data[index];
        JSConsole.Chart.Log("[MinuteChartContainer::OnMarkRectSelect] item", item);


        if (!this.SetRectSelectData(item)) return;

        var pointCount=paint.GetPointCount();
        var pixelTatio = GetDevicePixelRatio();
        if (pointCount==1)      //第1个位置
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_KEYDOWN_SELECT_RECT_FIRST);
            if (event && event.Callback)
            {
                var data=
                { 
                    X:corssCursor.LastPoint.X/pixelTatio,
                    Y:corssCursor.LastPoint.Y/pixelTatio,
                    Item:item,
                    Index:index,
                    RectSelectPaint:paint,    //区间选择背景
                    e:e,
                };
                event.Callback(event,data,this);
            }
        }
        else if (pointCount==2) //第2个位置
        {
            var selectData=paint.GetSelectRectData();
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_KEYDOWN_SELECT_RECT);
            if (event && event.Callback)
            {
                var data=
                { 
                    X:corssCursor.LastPoint.X/pixelTatio,
                    Y:corssCursor.LastPoint.Y/pixelTatio,
                    SelectData:selectData,   //区间选择的数据
                    RectSelectPaint:paint,    //区间选择背景
                    e:e,
                };
                event.Callback(event,data,this);
            }

            if (this.SelectRectDialog)
            {
                e.data=
                {
                    Chart:this,
                    X:corssCursor.LastPoint.X/pixelTatio,
                    Y:corssCursor.LastPoint.Y/pixelTatio,
                    SelectData:selectData,          //区间选择的数据
                    RectSelectPaint:paint           //区间选择背景
                };
                this.SelectRectDialog.DoModal(e);
            }
        }
        
        this.Draw();
    }

    //注册鼠标右键事件
    this.OnRightMenu=function(x,y,e)
    {
        var pixelTatio = GetDevicePixelRatio(); //x,y 需要乘以放大倍速
        var frameId=this.Frame.PtInFrame(x*pixelTatio,y*pixelTatio);
        this.PopupRightMenuV2({X:e.offsetX, Y:e.offsetY, FrameID:frameId}, e);
        
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CONTEXT_MENU);
        if (event)
        {
            var data={ X:x, Y:y, Event:e, FrameID:frameId };
            event.Callback(event,data,this);
        }
    }

    //右键菜单数据
    this.GetRightMenuData=function(frameID)
    {
        var windowCount=this.Frame.SubFrame.length; //窗口个数

        var aryOverlaySymbol=[];                    //叠加的股票列表
        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            if (item && item.Symbol) aryOverlaySymbol.push(item.Symbol)
        }

        var bShowCorss=false;   //十字光标十字线
        if (this.ChartCorssCursor) bShowCorss=this.ChartCorssCursor.IsShowCorss;

        var aryMenu=
        [
            { 
                Name:"叠加品种", 
                SubMenu:
                [
                    { Name:"上证指数", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["000001.sh", !aryOverlaySymbol.includes("000001.sh")]}, Checked:aryOverlaySymbol.includes("000001.sh") },
                    { Name:"深证成指", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["399001.sz", !aryOverlaySymbol.includes("399001.sz")]}, Checked:aryOverlaySymbol.includes("399001.sz") },
                    { Name:"中小板指", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["399005.sz", !aryOverlaySymbol.includes("399005.sz")]}, Checked:aryOverlaySymbol.includes("399005.sz") },
                    { Name:"创业板指", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["399006.sz", !aryOverlaySymbol.includes("399006.sz")]}, Checked:aryOverlaySymbol.includes("399006.sz") },
                    { Name:"沪深300", Data:{ ID: JSCHART_MENU_ID.CMD_OVERLAY_SYMBOL_ID, Args:["000300.sh", !aryOverlaySymbol.includes("000300.sh")]}, Checked:aryOverlaySymbol.includes("000300.sh")},
                ]
            },
            {
                Name:"多日分时图",
                SubMenu:
                [
                    { Name:"当日分时图", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_DAY_COUNT_ID, Args:[1]}, Checked:this.DayCount==1 },
                    { Name:"最近2日", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_DAY_COUNT_ID, Args:[2]}, Checked:this.DayCount==2 },
                    { Name:"最近3日", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_DAY_COUNT_ID, Args:[3]}, Checked:this.DayCount==3 },
                    { Name:"最近4日", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_DAY_COUNT_ID, Args:[4]}, Checked:this.DayCount==4 },
                    { Name:"最近5日", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_DAY_COUNT_ID, Args:[5]}, Checked:this.DayCount==5 },

                    { 
                        Name:"基准线选择",
                        SubMenu:
                        [
                            { Name:"最新昨收价", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_BASELINE_ID, Args:[0]}, Checked:this.BaselineType===0 },
                            { Name:"多日前昨收价", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_BASELINE_ID, Args:[1]}, Checked:this.BaselineType===1 }
                        ]

                    }
                ]
            },
            {
                Name:"指标窗口个数",
                SubMenu:
                [
                    { Name:"1个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[2]}, Checked:3==windowCount },
                    { Name:"2个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[3]}, Checked:4==windowCount },
                    { Name:"3个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[4]}, Checked:5==windowCount },
                    { Name:"4个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[5]}, Checked:6==windowCount },
                    { Name:"5个窗口", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_WINDOW_COUNT_ID, Args:[6]}, Checked:7==windowCount },
                ]
            },
            {
                Name:"指标切换",
                SubMenu:
                [
                    { Name:"MACD", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "MACD"]}},
                    { Name:"DMI", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "DMI"]}},
                    { Name:"DMA", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "DMA"]}},
                    { Name:"BRAR", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "BRAR"]}},
                    { Name:"KDJ", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "KDJ"]}},
                    { Name:"RSI", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "RSI"]}},
                    { Name:"WR", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "WR"]}},
                    { Name:"CCI", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "CCI"]}},
                    { Name:"TRIX", Data:{ ID: JSCHART_MENU_ID.CMD_CHANGE_INDEX_ID, Args:[frameID, "TRIX"]}},
                ]
            },
            {
                Name:"区间选择",Data:{ ID: JSCHART_MENU_ID.CMD_ENABLE_SELECT_RECT_ID, Args:[!this.EnableSelectRect]}, Checked:this.EnableSelectRect
            },
            {
                Name:"其他设置",
                SubMenu:
                [
                    { Name:"画图工具", Data:{ ID:JSCHART_MENU_ID.CMD_SHOW_DRAWTOOL_ID, Args:[]}, Checked:this.IsShowDrawToolDialog()},
                    { Name:"十字光标线", Data:{ ID:JSCHART_MENU_ID.CMD_SHOW_CORSS_LINE_ID, Args:[!bShowCorss]}, Checked:bShowCorss },
                    { Name:JSPopMenu.SEPARATOR_LINE_NAME },
                    
                    { 
                        Name:"语言设置", 
                        SubMenu:
                        [
                            { Name:"中文", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID, Args:["CN"]}, Checked:this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_CHINESE_ID  },
                            { Name:"英语", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID, Args:["EN"]}, Checked:this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_ENGLISH_ID },
                            { Name:"繁体", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_LANGUAGE_ID, Args:["TC"]}, Checked:this.LanguageID==JSCHART_LANGUAGE_ID.LANGUAGE_TRADITIONAL_CHINESE_ID },
                        ]
                    },

                    {
                        Name:"区间选择样式", 
                        SubMenu:
                        [
                            { Name:"样式1(默认)", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID, Args:[0]}, Checked:0==this.ChartDragSelectRect.ShowMode },
                            { Name:"样式2", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID, Args:[1]}, Checked:1==this.ChartDragSelectRect.ShowMode },
                            { Name:"样式3", Data:{ ID:JSCHART_MENU_ID.CMD_CHANGE_DRAG_RECT_SHOW_MODE_ID, Args:[2]}, Checked:2==this.ChartDragSelectRect.ShowMode },
                        ]
                    },

                    
                ]
            }

        ];

        if (MARKET_SUFFIX_NAME.IsSHSZStockA(this.Symbol))
        {
            var item={ Name:"集合竞价",Data:{ ID: JSCHART_MENU_ID.CMD_SHOW_BEFORE_DATA_ID, Args:[!this.IsShowBeforeData] }, Checked:this.IsShowBeforeData };
            aryMenu.splice(4,0,item);
        }

        
        //删除菜单
        for(var i=0;i<aryMenu.length;++i)
        {
            var item=aryMenu[i];
            if (item.Name=="叠加品种")
            {
                for(var j=0;j<item.SubMenu.length;++j)
                {
                    if (item.SubMenu[j].Checked)
                    {
                        item.SubMenu.push({ Name:JSPopMenu.SEPARATOR_LINE_NAME });
                        item.SubMenu.push({ Name:"取消叠加", Data:{ ID: JSCHART_MENU_ID.CMD_DELETE_ALL_OVERLAY_SYMBOL_ID} });
                        break;
                    }
                }
            }
        }

        return aryMenu;
    }

    this.OnWheel=function(e)
    {
        JSConsole.Chart.Log('[MinuteChartContainer::OnWheel]',e);
    }

    this.OnDoubleClick=function(x,y,e)
    {
        JSConsole.Chart.Log("[MinuteChartContainer::OnDoubleClick]", e);

        if (this.ClickChartTimer!=null)
        {
            clearTimeout(this.ClickChartTimer);
            this.ClickChartTimer=null;
        }

        var selectedChart;   //图形选中
        if (this.SelectedChart.EnableSelected)
        {
            selectedChart=this.PtInChart(x,y);
        }

        var dbClickInfo={SelectedChart:selectedChart};
        this.DBClickEvent(dbClickInfo, e);

        //没有图形选中,双击缩放窗口
        if (!selectedChart && this.EnableZoomIndexWindow)
        {
            var frameId=this.Frame.PtInFrame(x,y);
            JSConsole.Chart.Log("[MinuteChartContainer::OnDoubleClick] frameId",frameId);
            if (frameId>=this.Frame.ZoomStartWindowIndex)
            {
                if (this.ZoomIndexWindow(frameId, {X:x, Y:y}))
                {
                    this.Frame.SetSizeChage(true);
                    this.Draw();
                }
            }
        }
    }

    this.GetDataItem=function(pointInfo)
    {
        if (!pointInfo) return null;
        if (!IFrameSplitOperator.IsNumber(pointInfo.Index)) return null;
        if (!this.SourceData || !this.SourceData.Data) return null;
        var data=this.SourceData;

        var clientPos=pointInfo.ClientPos;
        if (clientPos==2 || clientPos==3 || (clientPos>=200&& clientPos<=299) || (clientPos>=300&& clientPos<=399)) 
        {
            if (!this.ChartCorssCursor || !this.ChartCorssCursor.CallAcutionXOperator) return null;
            var isHScreen=this.Frame.IsHScreen===true;
            var callAcutionXOper=this.ChartCorssCursor.CallAcutionXOperator;

            callAcutionXOper.Value=isHScreen?pointInfo.Point.Y:pointInfo.Point.X;
            callAcutionXOper.Point={X:pointInfo.Point.X, Y:pointInfo.Point.Y};
            callAcutionXOper.ClientPos=clientPos;

            if (clientPos==2)
            {
                if (!this.BeforeOpenData) return null;
            }
            else if (clientPos==3)
            {
                if (!this.AfterCloseData) return null;
            }
            else if (clientPos>=200 && clientPos<=299)
            {
                if (!this.MultiDayBeforeOpenData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData) ) return;
            }
            else if (clientPos>=300 && tclientPos<=399)
            {
                if (!this.MultiDayAfterCloseData || !IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData) ) return;
            }

            if (callAcutionXOper.Operator())
            {
                var item=callAcutionXOper.Item;
                return {Type:clientPos, Item:item, Index:callAcutionXOper.DataIndex };
            }

            return null;
        }

        var index=parseInt(pointInfo.Index.toFixed(0));
        var dataIndex=index+data.DataOffset;
        if (dataIndex>=data.Data.length) return null;

        var item=data.Data[dataIndex];
        
        return {Type:clientPos, Item:item, Index:dataIndex };
    }

    this.UpdatePointByCursorIndex=function()
    {
        this.LastPoint.X=this.Frame.GetXFromIndex(this.CursorIndex);

        var index=this.CursorIndex;
        index=parseInt(index.toFixed(0));
        var data=this.Frame.SourceData;
        if (data.DataOffset+index>=data.Data.length)
        {
            return;
        }
        var item=data.Data[data.DataOffset+index];
        var close=null;
        if (item.Before) close=item.Before.Close;
        else close=item.Close

        this.LastPoint.Y=this.Frame.GetYFromData(close);
    }



    //创建
    //windowCount 窗口个数
    this.Create=function(windowCount,option)
    {
        this.UIElement.JSChartContainer=this;

        //创建十字光标
        this.ChartCorssCursor=new ChartCorssCursor();
        this.ChartCorssCursor.PtInClient=(x,y)=>{ return this.PtInClient(x,y); }
        this.ChartCorssCursor.Canvas=this.Canvas;
        this.ChartCorssCursor.StringFormatX=g_DivTooltipDataForamt.Create("CorssCursor_Minute_XStringFormat");
        this.ChartCorssCursor.StringFormatX.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.StringFormatY=g_DivTooltipDataForamt.Create("CorssCursor_YStringFormat");
        this.ChartCorssCursor.StringFormatY.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.StringFormatY.LanguageID=this.LanguageID;
        this.ChartCorssCursor.StringFormatY.ShareAfterVol=this.ShareAfterVol;
        this.ChartCorssCursor.CallAcutionXOperator=new CallAcutionXOperator();
        this.ChartCorssCursor.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
       

        //创建等待提示
        this.ChartSplashPaint = new ChartSplashPaint();
        this.ChartSplashPaint.Canvas = this.Canvas;
        this.ChartSplashPaint.HQChart=this;

        //创建框架容器
        this.Frame=new HQTradeFrame();
        this.Frame.ChartBorder=new ChartBorder();
        this.Frame.ChartBorder.UIElement=this.UIElement;
        this.Frame.ChartBorder.Top=25;
        this.Frame.ChartBorder.TitleHeight=0;
        this.Frame.ChartBorder.Left=50;
        this.Frame.ChartBorder.Bottom=20;
        this.Frame.Canvas=this.Canvas;
        this.Frame.GetExtendChartRightWidth=()=> { return this.GetExtendChartRightWidth() }
        this.Frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.Frame.ZoomStartWindowIndex=2;
        this.ChartCorssCursor.Frame=this.Frame; //十字光标绑定框架
        this.ChartSplashPaint.Frame = this.Frame;

        this.CreateChildWindow(windowCount);
        this.CreateMainKLine();
        this.CreateExtendChart("RectSelectPaint", option? option.SelectRect:null);  //区间统计
        if (this.EnableIndexChartDrag) this.CreateExtendChart("DragMovePaint");
        this.CreateDragSelectRect(option? option.DragSelectRect:null);

        //子窗口动态标题
        for(var i=0;i<this.Frame.SubFrame.length; ++i)
        {
            var titlePaint=new DynamicChartTitlePainting();
            if (i==0 || i==1) titlePaint.IsShowMainIndexTitle=false;
            titlePaint.Frame=this.Frame.SubFrame[i].Frame;
            titlePaint.Canvas=this.Canvas;
            titlePaint.LanguageID=this.LanguageID;
            titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            titlePaint.SelectedChart=this.SelectedChart;
            titlePaint.MainTitlePaint=this.TitlePaint[0];
            this.TitlePaint.push(titlePaint);
        }

        this.ChartCorssCursor.StringFormatX.Frame=this.Frame.SubFrame[0].Frame;
        this.ChartCorssCursor.StringFormatY.Frame=this.Frame;
        if (this.ChartCorssCursor.CallAcutionXOperator)
            this.ChartCorssCursor.CallAcutionXOperator.Frame=this.Frame.SubFrame[0].Frame;

        var bRegisterKeydown=true;
        var bRegisterWheel=true;

        if (option && option.Listener)
        {
            var item=option.Listener;
            if (item.KeyDown===false) 
            {
                bRegisterKeydown=false;
                JSConsole.Chart.Log('[MinuteChartContainer::Create] not register keydown event.');
            }

            if (item.Wheel===false) 
            {
                bRegisterWheel=false;
                JSConsole.Chart.Log('[MinuteChartContainer::Create] not register wheel event.');
            }
        }

        if (bRegisterKeydown) this.UIElement.addEventListener("keydown", (e)=>{ this.OnKeyDown(e);} , true);              //键盘消息
        if (bRegisterWheel) this.UIElement.addEventListener("wheel", (e)=>{ this.OnWheel(e); }, true);                  //上下滚动消息
    }

    //创建子窗口
    this.CreateChildWindow=function(windowCount)
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_FRAME);
        
        for(var i=0;i<windowCount;++i)
        {
            var border=new ChartBorder();
            border.UIElement=this.UIElement;

            var frame=new MinuteFrame();
            frame.Canvas=this.Canvas;
            frame.ChartBorder=border;
            frame.Identify=i;
            frame.GlobalOption=this.GlobalOption;
            if (i<2) frame.ChartBorder.TitleHeight=0;
            frame.XPointCount=243;
            frame.HQChart=this;
            frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

            if (i>=2)
            {
                if (this.ModifyIndexDialog) frame.ModifyIndexEvent=this.ModifyIndexDialog.DoModal;        //绑定菜单事件
                if (this.ChangeIndexDialog) frame.ChangeIndexEvent=this.ChangeIndexDialog.DoModal;
            }

            var DEFAULT_HORIZONTAL=[9,8,7,6,5,4,3,2,1];
            frame.HorizontalMax=DEFAULT_HORIZONTAL[0];
            frame.HorizontalMin=DEFAULT_HORIZONTAL[DEFAULT_HORIZONTAL.length-1];

            if (i==0)
            {
                frame.YSplitOperator=new FrameSplitMinutePriceY();
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('price');
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                frame.YSplitOperator.DayOffset=this.DayOffset;
                frame.YSplitOperator.GlobalOption=this.GlobalOption;
                frame.YSplitOperator.HQChart=this;
            }
            else
            {
                frame.YSplitOperator=new FrameSplitY();
                frame.YSplitOperator.LanguageID=this.LanguageID;
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                if (i==1) frame.YSplitOperator.ShareAfterVol=this.ShareAfterVol;
            }

            frame.YSplitOperator.Frame=frame;
            frame.YSplitOperator.ChartBorder=border;
            frame.XSplitOperator=new FrameSplitMinuteX();
            frame.XSplitOperator.Frame=frame;
            frame.XSplitOperator.ChartBorder=border;
            frame.XSplitOperator.DayOffset=this.DayOffset;
            frame.XSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            if (i!=windowCount-1) frame.XSplitOperator.ShowText=false;
            frame.XSplitOperator.Operator();

            for(var j in DEFAULT_HORIZONTAL)
            {
                frame.HorizontalInfo[j]= new CoordinateInfo();
                frame.HorizontalInfo[j].Value=DEFAULT_HORIZONTAL[j];
                if (i==0 && j==frame.HorizontalMin) continue;

                frame.HorizontalInfo[j].Message[1]=DEFAULT_HORIZONTAL[j].toString();
                frame.HorizontalInfo[j].Font="14px 微软雅黑";
            }

            var subFrame=new SubFrameItem();
            frame.FrameData.SubFrameItem=subFrame;
            subFrame.Frame=frame;
            if (i==0)
                subFrame.Height=20;
            else
                subFrame.Height=10;

            this.Frame.SubFrame[i]=subFrame;

            if (event && event.Callback)
            {
                var sendData={ SubFrame:this.Frame.SubFrame[i], WindowIndex:i };
                event.Callback(event, sendData, this);
            }
        }
    }

    this.CreateSubFrameItem=function(id, mainFrame)
    {
        var border=new ChartBorder();
        border.UIElement=this.UIElement;

        if (mainFrame && mainFrame.ChartBorder && mainFrame.ChartBorder.MultiDayMinute)
        {
            var item=mainFrame.ChartBorder.MultiDayMinute;
            border.MultiDayMinute.Count=item.Count;
            border.MultiDayMinute.Left=item.Left;
            border.MultiDayMinute.Right=item.Right;
        }

        var frame=null;
        if (this.ClassName=="MinuteChartHScreenContainer") frame=new MinuteHScreenFrame();
        else frame=new MinuteFrame();

        frame.Canvas=this.Canvas;
        frame.ChartBorder=border;
        frame.Identify=id;                   //窗口序号
        frame.XPointCount=243;
        frame.GlobalOption=this.GlobalOption;
        frame.HQChart=this;
        frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        

        if (id>=2)
        {
            if (this.ModifyIndexDialog) frame.ModifyIndexEvent=this.ModifyIndexDialog.DoModal;        //绑定菜单事件
            if (this.ChangeIndexDialog) frame.ChangeIndexEvent=this.ChangeIndexDialog.DoModal;
        }

        var DEFAULT_HORIZONTAL=[9,8,7,6,5,4,3,2,1];
        frame.HorizontalMax=DEFAULT_HORIZONTAL[0];
        frame.HorizontalMin=DEFAULT_HORIZONTAL[DEFAULT_HORIZONTAL.length-1];

        frame.YSplitOperator=new FrameSplitY();
        frame.YSplitOperator.LanguageID=this.LanguageID;
        frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
        frame.YSplitOperator.Frame=frame;
        frame.YSplitOperator.ChartBorder=border;
        frame.XSplitOperator=new FrameSplitMinuteX();
        frame.XSplitOperator.Frame=frame;
        frame.XSplitOperator.ChartBorder=border;
        frame.XSplitOperator.ShowText=false;
        frame.XSplitOperator.DayOffset=this.DayOffset;
        frame.XSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        frame.XSplitOperator.Symbol=this.Symbol;

        if (this.DayCount>1)
        {
            frame.XSplitOperator.DayCount=this.DayData.length;
            frame.XSplitOperator.DayData=this.DayData;
            frame.DayCount=this.DayData.length;
        }
        

        //K线数据绑定
        var xPointCouont=this.Frame.SubFrame[0].Frame.XPointCount;
        frame.XPointCount=xPointCouont;
        frame.Data=this.ChartPaint[0].Data;

        for(var j in DEFAULT_HORIZONTAL)
        {
            frame.HorizontalInfo[j]= new CoordinateInfo();
            frame.HorizontalInfo[j].Value=DEFAULT_HORIZONTAL[j];
            frame.HorizontalInfo[j].Message[1]=DEFAULT_HORIZONTAL[j].toString();
            frame.HorizontalInfo[j].Font="14px 微软雅黑";
        }

        var subFrame=new SubFrameItem();
        frame.FrameData.SubFrameItem=subFrame;
        subFrame.Frame=frame;
        subFrame.Height=10;

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CREATE_FRAME);
        if (event && event.Callback)
        {
            var sendData={ SubFrame:subFrame, WindowIndex:id };
            event.Callback(event, sendData, this);
        }

        return subFrame;
    }

    this.AddNewSubFrame=function(option)
    {
        var mainFrame=this.Frame.SubFrame[0].Frame;
        var index=this.Frame.SubFrame.length;
        var subFrame=this.CreateSubFrameItem(index,mainFrame);
        var pixelRatio=GetDevicePixelRatio();
        subFrame.Frame.ChartBorder.TitleHeight*=pixelRatio;
        this.Frame.SubFrame[index]=subFrame;
        var titlePaint=new DynamicChartTitlePainting();
        titlePaint.Frame=this.Frame.SubFrame[index].Frame;
        titlePaint.Canvas=this.Canvas;
        titlePaint.LanguageID=this.LanguageID;
        titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        titlePaint.MainTitlePaint=this.TitlePaint[0];
        this.TitlePaint[index+1]=titlePaint;

        this.SetSubFrameOption(subFrame,option);

        //最后一个显示X轴坐标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;
        }

        this.UpdataDataoffset();        //更新数据偏移  
        this.Frame.SetSizeChage(true);
        if (this.UpdateXShowText) this.UpdateXShowText();
        this.ResetFrameXYSplit();
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();

        return index;
    }

    this.UpdateXShowText=function()
    {
        var bLastFrame=true;
        for(var i=this.Frame.SubFrame.length-1;i>=0;--i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            var subFrame=this.Frame.SubFrame[i];

            if (bLastFrame)
            {
                item.XSplitOperator.ShowText=true;
                if (subFrame.Height>0) bLastFrame=false;
            }
            else
            {
                item.XSplitOperator.ShowText=false;
            }
        }
    }

    //删除某一个窗口的指标
    this.DeleteIndexPaint=function(windowIndex,bCallDestroy)
    {
        var subFrame=this.Frame.SubFrame[windowIndex].Frame;
        if (!subFrame) return;

        var paint=[];          //踢出当前窗口的指标画法
        for(var i=0;i<this.ChartPaint.length;++i)
        {
            var item=this.ChartPaint[i];
            var bFind=(item.ChartFrame.Guid==subFrame.Guid || item.ChartFrame==subFrame);

            if (i==0 || !bFind)
            {
                paint.push(item);
            }
            else
            {
                if (bCallDestroy===true)
                {
                    if (item && item.OnDestroy) item.OnDestroy();   //图形销毁
                }
            }
        }

        //清空指定最大最小值
        
        subFrame.YSpecificMaxMin=null;
        subFrame.IsLocked=false;          //解除上锁
        subFrame.YSplitOperator.SplitType=subFrame.YSplitOperator.DefaultSplitType;  //还原Y坐标分割模式

        this.ChartPaint=paint;

         //清空东条标题
         var titleIndex=windowIndex+1;
         this.TitlePaint[titleIndex].Data=[];
         this.TitlePaint[titleIndex].Title=null;
    }

    this.CreateStockInfo=function()
    {
        this.ExtendChartPaint[0]=new StockInfoExtendChartPaint();
        this.ExtendChartPaint[0].Canvas=this.Canvas;
        this.ExtendChartPaint[0].ChartBorder=this.Frame.ChartBorder;
        this.ExtendChartPaint[0].ChartFrame=this.Frame;

        this.Frame.ChartBorder.Right=300;
    }

    //创建主图K线画法
    this.CreateMainKLine=function()
    {
        //分钟线
        var minuteLine=g_ChartPaintFactory.Create("ChartMinutePriceLine");
        minuteLine.Canvas=this.Canvas;
        minuteLine.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        minuteLine.ChartFrame=this.Frame.SubFrame[0].Frame;
        minuteLine.Name="Minute-Line";
        minuteLine.Identify="Minute-Line";
        minuteLine.Color=g_JSChartResource.Minute.PriceColor;
        minuteLine.LineWidth=g_JSChartResource.Minute.PriceLineWidth;
        minuteLine.AreaColor=g_JSChartResource.Minute.AreaPriceColor;
        minuteLine.GetEventCallback=(id)=>{ return this.GetEventCallback(id); };

        this.ChartPaint[0]=minuteLine;

        //分钟线均线
        var averageLine=new ChartMinutePriceLine();
        averageLine.Canvas=this.Canvas;
        averageLine.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        averageLine.ChartFrame=this.Frame.SubFrame[0].Frame;
        averageLine.Name="Minute-Average-Line";
        averageLine.Identify="Minute-Average-Line";
        averageLine.Color=g_JSChartResource.Minute.AvPriceColor;
        averageLine.IsDrawArea=false;
        this.ChartPaint[1]=averageLine;

        //成交量
        var volLine=g_ChartPaintFactory.Create("ChartMinuteVolumBar");
        volLine.Color=g_JSChartResource.Minute.VolBarColor;
        volLine.Canvas=this.Canvas;
        volLine.ChartBorder=this.Frame.SubFrame[1].Frame.ChartBorder;
        volLine.ChartFrame=this.Frame.SubFrame[1].Frame;
        volLine.Name="Minute-Vol-Bar";
        volLine.Identify="Minute-Vol-Bar";
        volLine.ShareAfterVol=this.ShareAfterVol;
        this.ChartPaint[2]=volLine;

        this.TitlePaint[0]=new DynamicMinuteTitlePainting();
        this.TitlePaint[0].Frame=this.Frame.SubFrame[0].Frame;
        this.TitlePaint[0].Canvas=this.Canvas;
        this.TitlePaint[0].OverlayChartPaint=this.OverlayChartPaint;    //绑定叠加
        this.TitlePaint[0].LanguageID=this.LanguageID;
        this.TitlePaint[0].CallAcutionXOperator=new CallAcutionXOperator();
        this.TitlePaint[0].CallAcutionXOperator.Frame=this.Frame.SubFrame[0].Frame;
        this.TitlePaint[0].HQChart=this;
    }

    //切换成 脚本指标
    this.ChangeScriptIndex=function(windowIndex,indexData,option)
    {
        this.DeleteIndexPaint(windowIndex, true);
        this.WindowIndex[windowIndex]=new ScriptIndex(indexData.Name,indexData.Script,indexData.Args,indexData);    //脚本执行

        var bindData=this.SourceData;
        this.BindIndexData(windowIndex,bindData);   //执行脚本

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    //切换api指标
    this.ChangeAPIIndex=function(windowIndex,indexData)
    {
        this.DeleteIndexPaint(windowIndex, true);
        //使用API挂接指标数据 API:{ Name:指标名字, Script:指标脚本可以为空, Args:参数可以为空, Url:指标执行地址 }
        var apiItem=indexData.API;
        this.WindowIndex[windowIndex]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,indexData);

        if (indexData)
        {
            if (indexData.Window) this.SetFrameToolbar(windowIndex,indexData.Window);
        }

        this.Frame.ClearUpDonwFrameYData({ Index:windowIndex });
        var bindData=this.ChartPaint[0].Data;
        this.BindIndexData(windowIndex,bindData);   //执行脚本

        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.ChangeIndex=function(windowIndex,indexName,option)
    {
        if (this.Frame.SubFrame.length<3) return;

        if (option && option.API)
            return this.ChangeAPIIndex(windowIndex,option);

        //查找系统指标
        let scriptData = new JSIndexScript();
        let indexInfo = scriptData.Get(indexName);
        if (!indexInfo) return;
        if (windowIndex<2) windowIndex=2;
        if (windowIndex>=this.Frame.SubFrame.length) windowIndex=2;

        JSIndexScript.ModifyAttribute(indexInfo, option)

        return this.ChangeScriptIndex(windowIndex, indexInfo, option);
    }

    //设置指标窗口个数
    this.ChangeIndexWindowCount=function(count)
    {
        if (count<2) return;   //1,2个窗口固定的不能动
        if (this.Frame.SubFrame.length==count) return;

        var currentLength=this.Frame.SubFrame.length;
        if (currentLength>count)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DELETE_FRAME);
            for(var i=currentLength-1;i>=count;--i)
            {
                this.DeleteIndexPaint(i);
                this.DeleteChartPaintExtend({WindowIndex:i});
                var item=this.Frame.SubFrame[i].Frame;
                if (item.ClearToolbar) item.ClearToolbar();

                if (event && event.Callback)
                {
                    var sendData={ SubFrame:this.Frame.SubFrame[i], WindowIndex:i };
                    event.Callback(event, sendData, this);
                }
            }

            this.Frame.SubFrame.splice(count,currentLength-count);
            this.WindowIndex.splice(count,currentLength-count);
            this.TitlePaint.splice(count+1,currentLength-count);
        }
        else
        {
            //创建新的指标窗口
            var mainFrame=this.Frame.SubFrame[0].Frame;
            for(var i=currentLength;i<count;++i)
            {
                var subFrame=this.CreateSubFrameItem(i, mainFrame);
                this.Frame.SubFrame[i]=subFrame;
                var titlePaint=new DynamicChartTitlePainting();
                titlePaint.Frame=this.Frame.SubFrame[i].Frame;
                titlePaint.Canvas=this.Canvas;
                titlePaint.LanguageID=this.LanguageID;
                titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                titlePaint.SelectedChart=this.SelectedChart;
                titlePaint.MainTitlePaint=this.TitlePaint[0];
                this.TitlePaint[i+1]=titlePaint;
            }

            //创建指标
            const indexName=["RSI","MACD","DMA","DMI","KDJ","WR"];
            let scriptData = new JSIndexScript();
            for(var i=currentLength;i<count;++i)
            {
                var name=indexName[i%indexName.length];
                let indexInfo = scriptData.Get(name);
                this.WindowIndex[i] = new ScriptIndex(indexInfo.Name, indexInfo.Script, indexInfo.Args,indexInfo);    //脚本执行
                var bindData=this.SourceData;
                this.BindIndexData(i,bindData);   //执行脚本
            }

            //最后一个显示X轴坐标
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                var item=this.Frame.SubFrame[i].Frame;
                if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
                else item.XSplitOperator.ShowText=false;
            }

            this.UpdataDataoffset();           //更新数据偏移
        }

        this.UpdateXShowText();
        this.Frame.SetSizeChage(true);
        this.ResetFrameXYSplit();
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.ChangeIndexTemplate=function(option)   //切换指标模板 可以设置指标窗口个数 每个窗口的指标, 只能从第3个指标窗口开始设置，前面2个指标窗口固定无法设置
    {
        if (!Array.isArray(option.Windows)) return;
        var count=option.Windows.length;
        var currentLength=this.Frame.SubFrame.length;
        var startWindowIndex=2;
        count+=startWindowIndex;

        var dayCount=null, symbol=null;
        if (IFrameSplitOperator.IsNumber(option.DayCount) && option.DayCount!=this.DayCount) dayCount= option.DayCount; //天数
        if (option.Symbol) symbol=option.Symbol;
        var bRefreshData= (dayCount!=null || symbol!=null);

        //清空所有的指标图型
        for(var i=startWindowIndex;i<currentLength;++i)
        {
            this.DeleteIndexPaint(i);
            var frame=this.Frame.SubFrame[i];
            frame.YSpecificMaxMin=null;
            frame.IsLocked=false;
            frame.YSplitScale = null;
        }
        
        if (currentLength>count)
        {
            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DELETE_FRAME);
            for(var i=currentLength-1;i>=count;--i)
            {
                this.Frame.SubFrame[i].Frame.ClearToolbar();

                if (event && event.Callback)
                {
                    var sendData={ SubFrame:this.Frame.SubFrame[i], WindowIndex:i };
                    event.Callback(event, sendData, this);
                }
            }

            this.Frame.SubFrame.splice(count,currentLength-count);
            this.WindowIndex.splice(count,currentLength-count);
            this.TitlePaint.splice(count+1,currentLength-count);
        }
        else
        {
            for(var i=currentLength;i<count;++i)  //创建新的指标窗口
            {
                var subFrame=this.CreateSubFrameItem(i);
                this.Frame.SubFrame[i]=subFrame;
                var titlePaint=new DynamicChartTitlePainting();
                titlePaint.Frame=this.Frame.SubFrame[i].Frame;
                titlePaint.Canvas=this.Canvas;
                titlePaint.LanguageID=this.LanguageID;
                titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                titlePaint.SelectedChart=this.SelectedChart;
                titlePaint.MainTitlePaint=this.TitlePaint[0];
                this.TitlePaint[i+1]=titlePaint;
            } 
        }

        for(var i=0;i<count;++i)
        {
            var windowIndex=i;
            var item=null,frameItem=null;
            if (option.Frame && option.Frame.length>i) frameItem=option.Frame[windowIndex];
            if (windowIndex>=startWindowIndex) item=option.Windows[windowIndex-startWindowIndex];

            var titleIndex=windowIndex+1;
            this.TitlePaint[titleIndex].Data=[];
            this.TitlePaint[titleIndex].Title=null;

            if (item)
            {
                if (item.Script)    //自定义指标脚本
                {
                    this.WindowIndex[windowIndex]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
                }
                else if (item.API)  //后台指标
                {
                    var apiItem=item.API;
                    this.WindowIndex[windowIndex]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,item);
                }
                else
                {
                    var indexID=item.Index;
                    var indexItem=JSIndexMap.Get(indexID);
                    if (indexItem)
                    {
                        this.WindowIndex[windowIndex]=indexItem.Create();
                        this.CreateWindowIndex(windowIndex);
                    }
                    else
                    {
                        var systemScript = new JSIndexScript();
                        var indexInfo = systemScript.Get(indexID);
                        if (indexInfo)
                        {
                            JSIndexScript.ModifyAttribute(indexInfo,item);
                            this.WindowIndex[windowIndex]=new ScriptIndex(indexInfo.Name,indexInfo.Script,indexInfo.Args,indexInfo);    //脚本执行
                        }
                    }
                }
            }
           
            this.SetSubFrameAttribute(this.Frame.SubFrame[windowIndex], item, frameItem);
        }

        //清空叠加指标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            this.DeleteWindowsOverlayIndex(i);  
        }

        //最后一个显示X轴坐标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;
        }

        //叠加指标
        var aryOverlayIndex=[];
        if (IFrameSplitOperator.IsNonEmptyArray(option.OverlayIndex))
        {
            for(var i=0;i<option.OverlayIndex.length;++i)
            {
                var item=option.OverlayIndex[i];
                if (item.Index) item.IndexName=item.Index;
                if (item.Windows>=0) item.WindowIndex=item.Windows;

                var overlay=this.CreateOverlayWindowsIndex(item);
                if (!overlay) continue;

                aryOverlayIndex.push({ WindowsIndex:item.WindowIndex, Overlay:overlay });
            }
        }

        this.Frame.SetSizeChage(true);

        if (!bRefreshData)
        {
            if (!this.SourceData)   //无数据 不需要执行指标
            {
                this.Draw();    
                return;
            }

            var bindData=this.SourceData;
            for(var i=0;i<count;++i)
            {
                this.BindIndexData(i,bindData);   //执行脚本
            }

            for(var i=0;i<aryOverlayIndex.length;++i)
            {
                var item=aryOverlayIndex[i];
                this.BindOverlayIndexData(item.Overlay,item.WindowsIndex,bindData);
            }

            this.UpdataDataoffset();           //更新数据偏移
            
            if (this.UpdateXShowText) this.UpdateXShowText();
            this.ResetFrameXYSplit();
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Draw();
        }
        else
        {
            if (!symbol) symbol=this.Symbol;
            var option={ };
            if (IFrameSplitOperator.IsNumber(dayCount)) option.DayCount=dayCount;
            this.ChangeSymbol(symbol, option);
        }
    }

    this.RemoveIndexWindow=function(id)
    {
        JSConsole.Chart.Log('[MinuteChartContainer::RemoveIndexWindow] remove id', id);
        if (id<2) return;
        if (!this.Frame.SubFrame) return;
        if (id>=this.Frame.SubFrame.length) return;

        this.Frame.RestoreIndexWindows();

        var delFrame=this.Frame.SubFrame[id].Frame;
        this.DeleteIndexPaint(id);
        this.DeleteChartPaintExtend({WindowIndex:id});
        this.Frame.SubFrame[id].Frame.ClearToolbar();

        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DELETE_FRAME);
        if (event && event.Callback)
        {
            var sendData={ SubFrame:this.Frame.SubFrame[id], WindowIndex:id };
            event.Callback(event, sendData, this);
        }

        this.Frame.SubFrame.splice(id,1);
        this.WindowIndex.splice(id,1);
        this.TitlePaint.splice(id+1,1); //删除对应的动态标题

        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i].Frame;
            if (i==this.Frame.SubFrame.length-1) item.XSplitOperator.ShowText=true;
            else item.XSplitOperator.ShowText=false;

            item.Identify=i;
        }

        /*
        if (this.ChartDrawPicture.length>0)
        {
            var aryDrawPicture=[];
            for(var i in this.ChartDrawPicture)
            {
                var item=this.ChartDrawPicture[i];
                if (item.Frame==delFrame) continue;
                aryDrawPicture.push(item);
            }
           
            this.ChartDrawPicture=aryDrawPicture;
        }
        */

        this.Frame.SetSizeChage(true);
        this.UpdateFrameMaxMin();
        this.ResetFrameXYSplit();
        this.Draw();
    }

    this.AutoUpdateEvent=function(bStart, explain)   //自定更新事件, 是给websocket使用
    {
        var eventID=bStart ? JSCHART_EVENT_ID.RECV_START_AUTOUPDATE:JSCHART_EVENT_ID.RECV_STOP_AUTOUPDATE;
        if (!this.mapEvent.has(eventID)) return;

        var self=this;
        var event=this.mapEvent.get(eventID);
        var data={ Stock:{ Symbol:this.Symbol, Name:this.Name, DayCount:this.DayCount }, Explain: explain };
        if (bStart) 
        {
            data.Callback=function(data) //数据到达更新回调
            { 
                self.RecvMinuteData(data); 
            }
        }
        event.Callback(event,data,this);
    }

    this.ClearIndexPaint=function()
    {
        //清空指标
        if (this.Frame && this.Frame.SubFrame)
        {
            for(var i=0;i<this.Frame.SubFrame.length;++i)
            {
                if (i>=2) this.DeleteIndexPaint(i, true);
                var item=this.Frame.SubFrame[i];
                if (IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex))
                {
                    for(var j=0; j<item.OverlayIndex.length; ++j ) //清空叠加指标
                    {
                        var overlayItem=item.OverlayIndex[j];
                        for(var k=0;k< overlayItem.ChartPaint.length;++k)
                        {
                            var overlayChart=overlayItem.ChartPaint[k];
                            if (overlayChart && overlayChart.OnDestroy) overlayChart.OnDestroy();
                        }
                        overlayItem.ChartPaint=[];
                    }
                }
            }
        }

        //清空叠加标题
        for(var i=1;i<this.TitlePaint.length;++i)
        {
            var item=this.TitlePaint[i];
            item.OverlayIndex=new Map();
        }
    }


    this.ResetDayOffset=function()
    {
        if (this.PageInfo.Enable)
        {
            this.DayOffset.Offset=this.PageInfo.Offset;
            this.DayOffset.ShowDayCount=this.PageInfo.ShowDayCount;
        }
        else
        {
            this.DayOffset.Offset=0;
            this.DayOffset.ShowDayCount=-1;
        }

        this.DayOffset.PageInfo=null;
    }

    this.ResetDataStatus=function()
    {
        this.DataStatus.MultiDay=false;
        this.DataStatus.LatestDay=false;
        this.DataStatus.LatestDate=null;
    }

    this.ClearOverlaySymbolData=function()
    {
        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var chart=this.OverlayChartPaint[i];
            chart.Status=OVERLAY_STATUS_ID.STATUS_NONE_ID;  //重置状态
            chart.Data.Data=[]; //清空数据
        }
    }

    //切换股票代码
    this.ChangeSymbol=function(symbol,option)
    {
        this.StopDisplayLatest();
        this.CancelAutoUpdate();
        this.AutoUpdateEvent(false, "MinuteChartContainer::ChangeSymbol");
        this.Symbol=symbol;
        this.ResetDayOffset();
        this.ResetDataStatus();
        this.ClearIndexPaint();             //清空指标
        this.ResetOverlaySymbolStatus();
        this.ReloadChartDrawPicture();
        this.ClearIndexRunCount();
        this.ClearStockCache();
        this.Frame.ClearYCoordinateMaxMin();

        if (option)
        {
            if (IFrameSplitOperator.IsNumber(option.DayCount)) this.DayCount=option.DayCount;

            if (IFrameSplitOperator.IsNonEmptyArray(option.Windows))    //切换指标
            {
                
                for(var i=0; i<option.Windows.length; ++i)
                {
                    var index=2+i;
                    if (index>=this.WindowIndex.length) break; //暂时不支持 动态增加/减少

                    var item=option.Windows[i];
                    if (!item) continue;

                    if (item.Script)
                    {
                        this.WindowIndex[index]=new ScriptIndex(item.Name,item.Script,item.Args,item);    //脚本执行
                    }
                    else if (item.API)
                    {
                        var apiItem=item.API;
                        this.WindowIndex[index]=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,item);
                    }
                    else
                    {
                        var systemScript = new JSIndexScript();
                        var indexID=item.Index;
                        var indexInfo = systemScript.Get(indexID);
                        if (indexInfo)
                        {
                            JSIndexScript.ModifyAttribute(indexInfo,item);
                            indexInfo.ID=indexID;
                            this.WindowIndex[index]=new ScriptIndex(indexInfo.Name,indexInfo.Script,indexInfo.Args,indexInfo);    //脚本执行
                        }
                    }
                }
            }

            //清空叠加股票
            if (option.ClearOverlay===true)
            {
                for(var i=0; i<this.OverlayChartPaint.length; ++i)
                {
                    var item=this.OverlayChartPaint[i];
                    item.IsDelete=true;
                }

                this.OverlayChartPaint=[];
                this.Frame.SubFrame[0].Frame.YSplitOperator.OverlayChartPaint=this.OverlayChartPaint;
                this.TitlePaint[0].OverlayChartPaint=this.OverlayChartPaint;    //绑定叠加
            }

            //叠加股票
            if (option.Overlay && IFrameSplitOperator.IsNonEmptyArray(option.Overlay))
            {
                var setSymbol=new Set();
                for(var i=0;i<this.OverlayChartPaint.length;++i)    //已有的叠加
                {
                    var item=this.OverlayChartPaint[i];
                    setSymbol.add(item.Symbol);
                }

                for(var i=0;i<option.Overlay.length;++i)
                {
                    var item=option.Overlay[i];
                    if (setSymbol.has(item.Symbol)) continue;

                    var paint=new ChartOverlayMinutePriceLine();
                    paint.Canvas=this.Canvas;
                    paint.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
                    paint.ChartFrame=this.Frame.SubFrame[0].Frame;
                    paint.Name="Overlay-Minute";
                    paint.Symbol=item.Symbol;
                    paint.Identify=`Overlay-Minute-${item.Symbol}`;
                    if (item.Color) paint.Color=item.Color; //外部设置颜色
                    else paint.Color=g_JSChartResource.OverlaySymbol.Color[g_JSChartResource.OverlaySymbol.Random%g_JSChartResource.OverlaySymbol.Color.length];
                    ++g_JSChartResource.OverlaySymbol.Random;
                    paint.MainData=this.SourceData; //绑定主图数据
            
                    if (paint.SetOption) paint.SetOption(item);
            
                    this.OverlayChartPaint.push(paint);
                }
            }
        }

        if (!symbol || this.DayCount<=0)
        {
            this.DrawEmpty();
        }
        else
        {
            this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
            this.ChartSplashPaint.EnableSplash(true);    //增加下载动画
            this.Draw();
            this.RequestData();
        }
    }

    this.SetPageInfo=function(pageInfo)
    {
        if (!pageInfo) return;

        if (IFrameSplitOperator.IsBool(pageInfo.Enable)) this.PageInfo.Enable=pageInfo.Enable;
        if (IFrameSplitOperator.IsNumber(pageInfo.Offset)) this.PageInfo.Offset=pageInfo.Offset;
        if (IFrameSplitOperator.IsNumber(pageInfo.ShowDayCount)) this.PageInfo.ShowDayCount=pageInfo.ShowDayCount;
    }

    this.ClearMinuteData=function()
    {
        this.SourceData=null;
        this.DayData=null;
        this.BeforeOpenData=null;
        this.AfterCloseData=null;
        this.MultiDayBeforeOpenData=null;
        this.MultiDayAfterCloseData=null;
    }

    this.ChangeDayCount=function(count, option)
    {
        if (count<0) return;

        this.StopDisplayLatest();
        this.CancelAutoUpdate();
        this.AutoUpdateEvent(false, "MinuteChartContainer::ChangeDayCount");
        this.DayCount=count;
        this.ClearMinuteData();

        if (option && option.PageInfo)
        {
            this.SetPageInfo(option.PageInfo);
            this.ResetDayOffset();
        }
        
        this.ReloadChartDrawPicture();
        this.ResetDataStatus();
        this.ClearIndexPaint();             //清空指标
        this.Frame.ClearYCoordinateMaxMin();
        this.ResetOverlaySymbolStatus();
        this.RequestData();
    }

    this.ChangeBaselineType=function(type)
    {
        if (this.BaselineType==type) return;

        this.BaselineType=type;
        if (this.DayCount>1) this.RequestData();
    }

    //[{ Symbol: , Color, Option: }]
    this.OverlaySymbols=function(aryData, option)
    {
        if (option && option.ClearAll===true)   //全部清空
        {
            for(var i=0; i<this.OverlayChartPaint.length; ++i)
            {
                var item=this.OverlayChartPaint[i];
                item.IsDelete=true;
            }
            this.OverlayChartPaint=[];
        }

        var aryNewOverlay=[];
        for(var i=0, j=0;i<aryData.length;++i)  //去重，已经叠加过的不用在叠加
        {
            var overlayItem=aryData[i];
            var strSymbol=overlayItem.Symbol;
            var bFind=false;
            for(j=0;j<this.OverlayChartPaint.length; ++j)
            {
                var item=this.OverlayChartPaint[j];
                if (item.Symbol==strSymbol)
                {
                    bFind=true;
                    console.warn(`[MinuteChartContainer::OverlaySymbols] overlay symbol=${strSymbol} exist.`);
                    break;
                }
            }

            if (!bFind) aryNewOverlay.push(overlayItem);
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(aryNewOverlay)) return true;

        for(var i=0;i<aryNewOverlay.length;++i)
        {
            var overlayItem=aryNewOverlay[i];
            var strSymbol=overlayItem.Symbol;
            var paint=new ChartOverlayMinutePriceLine();
            paint.Canvas=this.Canvas;
            paint.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
            paint.ChartFrame=this.Frame.SubFrame[0].Frame;
            paint.Name="Overlay-Minute";
            paint.Symbol=strSymbol;
            paint.Identify=`Overlay-Minute-${strSymbol}`;
            if (overlayItem.Option && overlayItem.Option.Color) paint.Color=overlayItem.Option.Color; //外部设置颜色
            else paint.Color=g_JSChartResource.OverlaySymbol.Color[g_JSChartResource.OverlaySymbol.Random%g_JSChartResource.OverlaySymbol.Color.length];
            ++g_JSChartResource.OverlaySymbol.Random;
            paint.MainData=this.SourceData; //绑定主图数据
    
            if (paint.SetOption) paint.SetOption(overlayItem.Option);
    
            this.OverlayChartPaint.push(paint);
        }

        if (this.DayCount<=1) this.RequestOverlayMinuteData();               //请求数据
        else this.RequestOverlayHistoryMinuteData();
        
        return true;
    }

    //叠加股票 symbol支持数据 ["600000.sh", "0000001.sz"]
    this.OverlaySymbol=function(symbol,option)
    {
        var arySymbol=null;
        if (IFrameSplitOperator.IsString(symbol)) arySymbol=[symbol];
        else if (Array.isArray(symbol)) arySymbol=symbol;
        if (!IFrameSplitOperator.IsNonEmptyArray(arySymbol)) return false;

        var aryNewSymbol=[];
        for(var i=0, j=0;i<arySymbol.length;++i)
        {
            var strSymbol=arySymbol[i];
            var bFind=false;
            for(j=0;j<this.OverlayChartPaint.length; ++j)
            {
                var item=this.OverlayChartPaint[j];
                if (item.Symbol==strSymbol)
                {
                    bFind=true;
                    console.warn(`[MinuteChartContainer::OverlaySymbol] overlay symbol=${strSymbol} exist.`);
                    break;
                }
            }

            if (!bFind) aryNewSymbol.push(strSymbol);
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(arySymbol)) return true;

        for(var i=0;i<aryNewSymbol.length;++i)
        {
            var strSymbol=aryNewSymbol[i];

            var paint=new ChartOverlayMinutePriceLine();
            paint.Canvas=this.Canvas;
            paint.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
            paint.ChartFrame=this.Frame.SubFrame[0].Frame;
            paint.Name="Overlay-Minute";
            paint.Symbol=strSymbol;
            paint.Identify=`Overlay-Minute-${strSymbol}`;
            if (option && option.Color) paint.Color=option.Color; //外部设置颜色
            else paint.Color=g_JSChartResource.OverlaySymbol.Color[g_JSChartResource.OverlaySymbol.Random%g_JSChartResource.OverlaySymbol.Color.length];
            ++g_JSChartResource.OverlaySymbol.Random;
            paint.MainData=this.SourceData; //绑定主图数据
    
            if (paint.SetOption) paint.SetOption(option);
    
            this.OverlayChartPaint.push(paint);
        }

        if (this.DayCount<=1) this.RequestOverlayMinuteData();               //请求数据
        else this.RequestOverlayHistoryMinuteData();
        
        return true;
    }

    this.ResetOverlaySymbolStatus=function()
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            item.Status=OVERLAY_STATUS_ID.STATUS_NONE_ID;
        }
    }

    //删除一个叠加股票
    this.DeleteOverlaySymbol=function(symbol)
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            if (item.Symbol===symbol)
            {
                item.IsDelete=true;
                this.OverlayChartPaint.splice(i,1);
                this.UpdateFrameMaxMin();
                this.Draw();
                return true;
            }
        }

        console.warn(`[MinuteChartContainer::DeleteOverlaySymbol] overlay symbol=${symbol} not exist.`)
        return false;
    }

    //取消叠加股票
    this.ClearOverlaySymbol=function()
    {
        for(var i in this.OverlayChartPaint)
        {
            var item=this.OverlayChartPaint[i];
            item.IsDelete=true;
        }
        this.OverlayChartPaint=[];
        this.Frame.SubFrame[0].Frame.YSplitOperator.OverlayChartPaint=this.OverlayChartPaint;
        this.TitlePaint[0].OverlayChartPaint=this.OverlayChartPaint;    //绑定叠加
        this.UpdateFrameMaxMin();
        this.Draw();
    }

    this.ShowBeforeData=function(isShow, option)
    {
        this.ShowCallAuctionData({Left:isShow}, option);
    }

    //集合竞价设置 obj={ Left:, Right: }
    this.ShowCallAuctionData=function(obj, option)
    {
        if (!obj) return;

        var optionChanged=false;    //配置修改
        if (IFrameSplitOperator.IsBool(obj.Left) && this.IsShowBeforeData!=obj.Left) 
        {
            this.IsShowBeforeData=obj.Left;
            optionChanged=true;
        }

        if (IFrameSplitOperator.IsBool(obj.Right) && this.IsShowAfterData!=obj.Right) 
        {
            this.IsShowAfterData=obj.Right;
            optionChanged=true;
        }

        if (obj.MultiDay)
        {
            var item=obj.MultiDay;
            if (IFrameSplitOperator.IsBool(item.Left) && this.IsShowMultiDayBeforeData!=item.Left)
            {
                this.IsShowMultiDayBeforeData=item.Left;
                optionChanged=true;
            }

            if (IFrameSplitOperator.IsBool(item.Right) && this.IsShowMultiDayAfterData!=item.Right) 
            {
                this.IsShowMultiDayAfterData=item.Right;
                optionChanged=true;
            }
        }

        if (option)
        {
            if (option.BeforeOpen)
            {
                var item=option.BeforeOpen;
                if (IFrameSplitOperator.IsNumber(item.Left) && this.ExtendWidth.Left!=item.Left)
                {
                    this.ExtendWidth.Left=item.Left;
                    optionChanged=true;
                }
            }

            if (option.AfterClose)
            {
                var item=option.AfterClose;
                if (IFrameSplitOperator.IsNumber(item.Right) && this.ExtendWidth.Right!=item.Right)
                {
                    this.ExtendWidth.Right=item.Right;
                    optionChanged=true;
                }
            }

            if (option.MultiDay)
            {
                var item=option.MultiDay;
                if (IFrameSplitOperator.IsNumber(item.Left) && this.MultiDayExtendWidth.Left!=item.Left)
                {
                    this.MultiDayExtendWidth.Left=item.Left;
                    optionChanged=true;
                }

                if (IFrameSplitOperator.IsNumber(item.Right)&& this.MultiDayExtendWidth.Right!=item.Right)
                {
                    this.MultiDayExtendWidth.Right=item.Right;
                    optionChanged=true;
                }
            }
        }

        if (optionChanged) 
        {
            this.Frame.ClearYCoordinateMaxMin();
            this.RequestData();
        }
    }

    this.RequestData=function()
    {
        if (this.DayCount<=1) this.RequestMinuteData();               
        else this.RequestHistoryMinuteData();
    }

    this.ChangeDrawType=function(type)
    {
        if (this.ChartPaint.length<=0) return;

        if (type==0) this.ChartPaint[0].IsDrawArea=true;
        else if (type==1) this.ChartPaint[0].IsDrawArea=false;
        else return;

        this.Draw();
    } 

    this.UpdateDataOffset=function()
    {
        this.SourceData.DataOffset=this.DayOffset.DataOffset;

        for(var i=0; i<this.ChartPaint.length; ++i)
        {
            var item =this.ChartPaint[i];
            if (!item.Data) continue;
            item.Data.DataOffset=this.DayOffset.DataOffset;

            if (item.ClassName=="ChartMinuteVolumBar" || item.ClassName=="ChartMinutePriceLine")  
                item.DayOffset=this.DayOffset;
        }

        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item =this.OverlayChartPaint[i];
            if (!item.Data) continue;
            item.Data.DataOffset=this.DayOffset.DataOffset;
        }

        //叠加指标当前显示的数据偏移
        for (var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            var subFrame=this.Frame.SubFrame[i];
            for(var j=0; j<subFrame.OverlayIndex.length; ++j)
            {
                var overlayItem=subFrame.OverlayIndex[j];
                for(var k=0; k<overlayItem.ChartPaint.length; ++k)
                {
                    var item=overlayItem.ChartPaint[k];
                    if (!item.Data) continue;
                    item.Data.DataOffset=this.DayOffset.DataOffset;
                }
            }
        }
    }

    //请求历史分钟数据
    this.RequestHistoryMinuteData=function()
    {
        var self=this;
        this.IsBeforeData=false;
        this.IsAfterData=false;
        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
        this.ChartSplashPaint.EnableSplash(true);
        this.Draw();

        if (this.NetworkFilter)
        {
            var callCation=
            { 
                Before:this.IsShowMultiDayBeforeData , 
                After:this.IsShowMultiDayAfterData
            }   //集合竞价

            var obj=
            {
                Name:'MinuteChartContainer::RequestHistoryMinuteData', //类名::函数
                Explain:'多日分时数据',
                Request:{ Url:self.HistoryMinuteApiUrl, Data:{daycount:self.DayCount, symbol:self.Symbol, callcation:callCation }, Type:'POST' }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryMinuteData(data);
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: self.HistoryMinuteApiUrl,
            data:
            {
                "symbol": self.Symbol,
                "daycount": self.DayCount
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryMinuteData(data);
            }
        });
    }

    this.RecvHistoryMinuteData=function(data)
    {
        if (this.EnableVerifyRecvData && data.symbol!=this.Symbol)
        {
            JSConsole.Chart.Warn(`[MinuteChartContainer::RecvHistoryMinuteData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        this.DayData=MinuteChartContainer.JsonDataToMinuteDataArray(data);
        this.ColorLineData=MinuteChartContainer.JsonDataToHistoryMinuteLineColorData(data);
        this.MultiDayBeforeOpenData=MinuteChartContainer.JosnDataToBeforeOpenDataArray(data);
        this.MultiDayAfterCloseData=MinuteChartContainer.JosnDataToAfterCloseDataArray(data);
        var updateTime=MinuteChartContainer.JsonDataToHistoryMinuteLastUpdateTime(data);

        this.DataStatus.MultiDay=true;

        this.CaclutateCallCationYRange();
        this.Symbol=data.symbol;
        this.Name=data.name;
        this.SetCallCationDataBorder( 
        { 
            Left:false, Right:false, 
            MultiDay:{ Left:this.IsShowMultiDayBeforeData, Right:this.IsShowMultiDayAfterData } 
        } );
        this.CaclutateLimitPrice(this.DayData[0].YClose, data.data[0].limitprice); //计算涨停价格
        this.UpdateHistoryMinuteUI(updateTime);
        this.RecvMinuteDataEvent( {FunctionName:"RecvHistoryMinuteData"} );
        this.RequestOverlayHistoryMinuteData();

        this.BindAllOverlayIndexData(this.SourceData);

        this.AutoUpdateEvent(true, "MinuteChartContainer::RequestHistoryMinuteData");
        this.AutoUpdate();
    }

    this.CaclutateCallCationYRange=function()
    {
        //多日集合竞价Y轴统一成交量
        var afterRange=null, beforeRange=null;
        if (IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData))
        {
            var range={ Max:null, Min:null };
            for(var i=0; i<this.MultiDayAfterCloseData.length; ++i)
            {
                var item=this.MultiDayAfterCloseData[i];
                if (range.Max==null) range.Max=item.VolMax;
                else if (range.Max<item.VolMax) range.Max=item.VolMax;

                if (range.Min==null) range.Min=item.VolMin;
                else if (range.Min>item.VolMin) range.Min=item.VolMin;
            }
            afterRange=range;
        }

        if (IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData))
        {
            var range={ Max:null, Min:null };
            for(var i=0; i<this.MultiDayBeforeOpenData.length; ++i)
            {
                var item=this.MultiDayBeforeOpenData[i];
                if (range.Max==null) range.Max=item.VolMax;
                else if (range.Max<item.VolMax) range.Max=item.VolMax;

                if (range.Min==null) range.Min=item.VolMin;
                else if (range.Min>item.VolMin) range.Min=item.VolMin;
            }
            beforeRange=range;
        }

        if (this.ShareAfterVol==2)  // 公用坐标
        {
            if (afterRange && beforeRange)
            {
                var max=Math.max(afterRange.Max, beforeRange.Max);
                var min=Math.min(afterRange.Min, beforeRange.Min);

                afterRange.Max=beforeRange.Max=max;
                afterRange.Min=beforeRange.Min=min;
            }
        }
        
        if (afterRange)
        {
            for(var i=0; i<this.MultiDayAfterCloseData.length; ++i)
            {
                var item=this.MultiDayAfterCloseData[i];
                item.VolMax=afterRange.Max;
                item.VolMin=afterRange.Min;
            }
        }

        if (beforeRange)
        {
            for(var i=0; i<this.MultiDayBeforeOpenData.length; ++i)
            {
                var item=this.MultiDayBeforeOpenData[i];
                item.VolMax=beforeRange.Max;
                item.VolMin=beforeRange.Min;
            }
        }
    }

    this.UpdateHistoryMinuteUI=function(updateTime)
    {
        var allMinuteData=this.HistoryMinuteDataToArray(this.DayData);

        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=allMinuteData;
        if (updateTime) sourceData.UpdateTime=updateTime;

        this.SourceData=sourceData;
        this.TradeDate=this.DayData[0].Date;

        if (this.PageInfo && this.PageInfo.Enable)
        {
            this.DayOffset.DayCount=this.DayData.length;    //一共的数据
            if (this.DayOffset.ShowDayCount==-1) this.DayOffset.ShowDayCount=this.DayData.length;   //全部显示
            if (this.DayOffset.Offset==-8888) this.DayOffset.Offset=this.DayOffset.DayCount-this.DayOffset.ShowDayCount;    //最后一页
            var showDayCount=this.DayOffset.ShowDayCount;
            this.Frame.SetDayCount(showDayCount);
        }
        else
        {
            this.DayOffset.Offset=0;
            this.DayOffset.ShowDayCount=this.DayData.length;
            var showDayCount=this.DayOffset.ShowDayCount;
            this.Frame.SetDayCount(this.DayData.length);
        }


        var upperSymbol=this.Symbol.toUpperCase();
        var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);
        var dayItem=this.DayData[0];    //最新
        if (this.BaselineType===1) dayItem=this.DayData[this.DayData.length-1]; //多日前

        var yClose=dayItem.YClose;
        if (IFrameSplitOperator.IsNumber(dayItem.YClearing) && isFutures) yClose=dayItem.YClearing; //期货使用前结算价

        this.BindMainData(sourceData,yClose);
        
         //外汇 均线暂时不用
        if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol)) this.ChartPaint[1].Data=null;  

        for(let i=0; i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            item.Frame.XSplitOperator.Symbol=this.Symbol;
            item.Frame.XSplitOperator.DayCount=showDayCount;
            item.Frame.XSplitOperator.DayData=this.DayData;
            item.Frame.XSplitOperator.Operator();   //调整X轴个数
            item.Frame.XSplitOperator.IsBeforeData=this.IsBeforeData;
            item.Frame.XSplitOperator.IsAfterData=this.IsAfterData;
            item.Frame.YSplitOperator.Symbol=this.Symbol;
            item.Frame.YSplitOperator.IsBeforeData=this.IsBeforeData;
            item.Frame.YSplitOperator.IsAfterData=this.IsAfterData;

            for(var j in item.OverlayIndex) //子坐标X轴个数同步
            {
                var overlayItem=item.OverlayIndex[j];
                overlayItem.Frame.XPointCount=item.Frame.XPointCount;
                overlayItem.Frame.MinuteCount=item.Frame.MinuteCount;
            }
        }

        this.ChartCorssCursor.StringFormatY.Symbol=this.Symbol;
        this.ChartCorssCursor.StringFormatX.Symbol=this.Symbol;
        this.ChartCorssCursor.StringFormatX.IsBeforeData=this.IsBeforeData;
        this.ChartCorssCursor.StringFormatX.IsAfterData=this.IsAfterData;
        this.TitlePaint[0].IsShowDate=true;
        this.UpdateDataOffset();
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.CreateChartDrawPictureByStorage(); //创建画图工具

        //执行脚本
        if (this.Frame.SubFrame.length>2)
        {
            var bindData=new ChartData();
            bindData.Data=allMinuteData;
            for(var i=2; i<this.Frame.SubFrame.length; ++i)
            {
                this.BindIndexData(i,bindData);
            }
        }

        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    this.HistoryMinuteDataToArray=function(data)
    {
        var result=[];
        for(var i=data.length-1; i>=0;--i)
        {
            var item=data[i];
            for(var j=0; j<item.Data.length; ++j)
            {
                result.push(item.Data[j]);
            }
        }
        return result;
    }

    //更新一天的数据
    this.UpdateLatestMinuteData=function(data,date, stock)
    {
        if (!this.DayData) return;

        for(var i=0; i<this.DayData.length; ++i)
        {
            var item=this.DayData[i];
            if (item.Date===date)  
            {
                item.Data=data; //整一天的数据都替换掉
                if (stock && IFrameSplitOperator.IsNumber(stock.yclose)) item.YClose=stock.yclose;
                if (stock && IFrameSplitOperator.IsNumber(stock.yclearing)) item.YClearing=stock.yclearing;
                return;
            }
        }

        if (this.DayData.length>0)
        {
            if (this.DayData[0].Date<date)  //新的一天 插入
            {
                var dayItem=new ChartData();
                dayItem.Date=date;
                dayItem.Data=data;
                if (stock && IFrameSplitOperator.IsNumber(stock.yclose)) dayItem.YClose=stock.yclose;
                if (stock && IFrameSplitOperator.IsNumber(stock.yclearing)) dayItem.YClearing=stock.yclearing;

                this.DayData.unshift(dayItem);
            }
        }
    }

    //更新最新的几条数据
    this.UpdateLatestMinuteDataV2=function(minuteData)
    {
        if (this.DayCount>1)
        {
            if (!this.DayData) return;

            var findItem=null;
            for(var i=0; i<this.DayData.length; ++i)
            {
                var item=this.DayData[i];
                if (item.Date===date)  
                {
                    findItem=item;
                    break;
                }
            }
    
            if (!findItem) return;
    
            var findIndex=-1;
            var firstItem=minuteData.Data[0];
            for(var i=0;i<findItem.Data.length;++i)
            {
                var item=findItem.Data[i];
                
                if (item.Date==firstItem.Date && item.Time==firstItem.Time)
                {
                    findIndex=i;
                    break;
                }
            }
    
            if (findIndex<0) findIndex=findItem.Data.length;
            for(var i=0, j=findIndex; i<minuteData.Data.length; ++i, ++j)
            {
                var item=minuteData.Data[i];
                findItem.Data[j]=item;
            }
        }
        else
        {
            if (!this.SourceData) return;
            var findIndex=-1;
            var firstItem=minuteData.Data[0];
            for(var i=0;i<this.SourceData.Data.length;++i)
            {
                var item=this.SourceData.Data[i];
                if (item.Date==firstItem.Date && item.Time==firstItem.Time)
                {
                    findIndex=i;
                    break;
                }
            }

            if (findIndex<0) findIndex=this.SourceData.Data.length;
            for(var i=0, j=findIndex; i<minuteData.Data.length; ++i, ++j)
            {
                var item=minuteData.Data[i];
                this.SourceData.Data[j]=item;
            }
        }
        
    }

    //请求分钟数据
    this.RequestMinuteData=function()
    {
        var self=this;

        var fields=
        [
            "name","symbol",
            "yclose","open","price","high","low",
            "vol","amount",
            "date","time",
            "minute","minutecount"
        ];

        var upperSymbol=this.Symbol.toUpperCase();
        if (MARKET_SUFFIX_NAME.IsFutures(upperSymbol))
        {   //期货的需要加上结算价
            fields.push("clearing");
            fields.push("yclearing");
        }

        //  盘前数据(A股)
        this.IsBeforeData=false;
        if (this.IsShowBeforeData && this.DayCount===1 && MARKET_SUFFIX_NAME.IsSHSZStockA(self.Symbol)) 
        {
            this.IsBeforeData=true;
            fields.push('before');
        }

        this.IsAfterData=false;
        if (this.IsShowAfterData && this.DayCount===1 && MARKET_SUFFIX_NAME.IsSHSZStockA(self.Symbol))
        {
            this.IsAfterData=true;
        }

        if (this.NetworkFilter)
        {
            var dateRange=null;
            if (this.DayCount>1)
            {
                if (IFrameSplitOperator.IsNonEmptyArray(this.DayData))
                {
                    var dayData=this.DayData[0];
                    dateRange=dayData.GetDateRange();
                }
            }
            else
            {
                if (this.SourceData)
                    dateRange=this.SourceData.GetDateRange();
            }

            var callCation={ Before:this.IsShowBeforeData, After:this.IsShowAfterData }   //集合竞价
            if (this.DayCount>1) callCation={ Before:this.IsShowMultiDayBeforeData, After:this.IsShowMultiDayAfterData }   //多日集合竞价
           
            var obj=
            {
                Name:'MinuteChartContainer::RequestMinuteData', //类名::函数名
                Explain:'最新分时数据',
                Request:{ Url:self.MinuteApiUrl, Data:{field:fields, symbol:[self.Symbol], callcation:callCation }, Type:'POST' }, 
                Self:this,
                PreventDefault:false
            };
            if (dateRange) obj.DateRange=dateRange; //本地数据日期范围

            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvMinuteData(data);
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }
        
        JSNetwork.HttpRequest({
            url: self.MinuteApiUrl,
            data:
            {
                "field": fields,
                "symbol": [self.Symbol],
                "start": -1
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvMinuteData(data);
            }
        });
    }

    this.RecvMinuteDataEvent=function(option)
    {
        if (!this.mapEvent.has(JSCHART_EVENT_ID.RECV_MINUTE_DATA)) return;

        var event=this.mapEvent.get(JSCHART_EVENT_ID.RECV_MINUTE_DATA);
        var data={ MinuteData:this.SourceData, Stock:{ Symbol:this.Symbol, Name:this.Name }, Option:option, DataStatus:this.DataStatus };
        event.Callback(event,data,this);
    }

    this.UpdateLineColorData=function(data, date)
    {
        if (!this.ColorLineData) 
        {
            this.ColorLineData=data;
            return;
        }


        //移除当前的
        var aryColorLineData=this.ColorLineData.filter(function(item, index, arr)
        {
            return item.Date!=date;
        });

        if (IFrameSplitOperator.IsNonEmptyArray(data))
        {
            for(var i in data)
            {
                aryColorLineData.push(data[i]);
            }
        }


        this.ColorLineData=aryColorLineData;
    }

    this.UpdateCallCationData=function(beforeOpenData,afterCloseData)
    {
        if (beforeOpenData && IFrameSplitOperator.IsNonEmptyArray(this.MultiDayBeforeOpenData))
        {
            var lastItem=this.MultiDayBeforeOpenData[this.MultiDayBeforeOpenData.length-1];
            if (lastItem.Date==beforeOpenData.Date) //存在更新
                this.MultiDayBeforeOpenData[this.MultiDayBeforeOpenData.length-1]=beforeOpenData;
            else if (lastItem.Date<beforeOpenData.Date) //新的一天插入
                this.MultiDayBeforeOpenData.push(beforeOpenData);
        }

        if (afterCloseData && IFrameSplitOperator.IsNonEmptyArray(this.MultiDayAfterCloseData))
        {
            var lastItem=this.MultiDayAfterCloseData[this.MultiDayAfterCloseData.length-1];
            if (lastItem.Date==afterCloseData.Date)
                this.MultiDayAfterCloseData[this.MultiDayAfterCloseData.length-1]=afterCloseData;
            else if (lastItem.Date<afterCloseData.Date)
                this.MultiDayAfterCloseData.push(afterCloseData);
        }

        this.CaclutateCallCationYRange();
    }

    this.RecvUpdateMinuteData=function(data)
    {
        var minuteData=MinuteChartContainer.JsonDataToUpdateMinuteData(data);
        var aryColorData=MinuteChartContainer.JsonDataToMinuteLineColorData(data);
        this.BeforeOpenData=null;
        this.AfterCloseData=null;
        var beforeOpenData=MinuteChartContainer.JsonDataToBeforeOpenData(data);
        var afterCloseData=MinuteChartContainer.JsonDataToAfterCloseData(data);
        var updateTime=MinuteChartContainer.JsonDataToMinuteLastUpdateTime(data);   //数据最后的更新时间

        if (this.DayCount>1)    //多日走势图
        {
            this.UpdateCallCationData(beforeOpenData,afterCloseData);
            this.UpdateLineColorData(aryColorData,minuteData.date);
            this.UpdateLatestMinuteDataV2(minuteData);
            this.UpdateHistoryMinuteUI(updateTime);
            this.RecvMinuteDataEvent({FunctionName:"RecvUpdateMinuteData"} );
            this.RequestOverlayMinuteData();        //请求叠加数据 (主数据下载完再下载)
            this.BindAllOverlayIndexData(this.SourceData);
            this.AutoUpdateEvent(true, "MinuteChartContainer::RecvUpdateMinuteData");
            this.AutoUpdate();
            return;
        }

        //原始数据

        this.UpdateLatestMinuteDataV2(minuteData);
        var sourceData=this.SourceData;
        var aryMinuteData=this.SourceData.Data;
        this.ColorLineData=aryColorData;
        this.TradeDate=data.stock[0].date;
        this.Frame.SetDayCount(1);  //单日数据
        this.SourceData.UpdateTime=updateTime;
        this.Symbol=minuteData.Symbol;
        this.Name=minuteData.Name;

        this.SetCallCationDataBorder( { Left:this.IsBeforeData, Right:this.IsAfterData , MultiDay:{ Left:false, Right:false }} );

        if (this.ShareAfterVol==2)  //盘前， 盘后成交量公用坐标
        {
            if (this.BeforeOpenData && this.AfterCloseData)
            {
                var max=Math.max(this.BeforeOpenData.VolMax, this.AfterCloseData.VolMax);
                var min=Math.min(this.BeforeOpenData.VolMin, this.AfterCloseData.VolMin);
                this.BeforeOpenData.VolMax=this.AfterCloseData.VolMax=max;
                this.BeforeOpenData.VolMin=this.AfterCloseData.VolMin=min;
            }
        }

        var yClose=minuteData.YClose;
        var upperSymbol=this.Symbol.toUpperCase();
        var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);
        if (minuteData.YClearing>0 && isFutures) yClose=minuteData.YClearing; //期货使用前结算价
        this.CaclutateLimitPrice(yClose, minuteData.LimitPrice); //计算涨停价格
        var extendData=null;
        if (minuteData.High>0 && minuteData.Low>0) extendData={ High:minuteData.High, Low:minuteData.Low };
        this.BindMainData(sourceData,yClose, extendData);

        if (this.Frame.SubFrame.length>2)
        {
            var bindData=new ChartData();
            bindData.Data=aryMinuteData;
            for(var i=2; i<this.Frame.SubFrame.length; ++i)
            {
                this.BindIndexData(i,bindData);
            }
        }

        for(let i=0; i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            item.Frame.XSplitOperator.Symbol=this.Symbol;
            item.Frame.XSplitOperator.DayCount=1;
            item.Frame.XSplitOperator.Operator();   //调整X轴个数
            item.Frame.YSplitOperator.Symbol=this.Symbol;

            if (IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex))
            {
                for(var j=0;j<item.OverlayIndex.length; ++j) //子坐标X轴个数同步
                {
                    var overlayItem=item.OverlayIndex[j];
                    overlayItem.Frame.XPointCount=item.Frame.XPointCount;
                    overlayItem.Frame.MinuteCount=item.Frame.MinuteCount;
                }
            }
        }

        this.ChartCorssCursor.StringFormatY.Symbol=this.Symbol;
        this.ChartCorssCursor.StringFormatX.Symbol=this.Symbol;

        if (MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) this.TitlePaint[0].IsShowDate=false;

        if (data.stock[0].IsHistoryMinute==true) this.TitlePaint[0].IsShowDate=true;

        var chartInfo=this.GetChartMinuteInfo();
        if (chartInfo) chartInfo.SourceData=this.SourceData;    //数据绑定到信息地雷上

        this.RecvMinuteDataEvent( {FunctionName:"RecvUpdateMinuteData"} );
        this.RequestMinuteInfoData();
        this.RequestOverlayMinuteData();//请求叠加数据 (主数据下载完再下载)
        this.CreateChartDrawPictureByStorage(); //创建画图工具

        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        this.BindAllOverlayIndexData(this.SourceData);
        
        this.AutoUpdateEvent(true, "MinuteChartContainer::RecvUpdateMinuteData");
        this.AutoUpdate();
    }

    this.RecvMinuteData=function(data)
    {
        if (!data) 
        {
            JSConsole.Chart.Warn("[MinuteChartContainer::RecvMinuteData] recv data is null");
            return;
        }

        if (data.dataType==1)   //增量更新数据模式
        {
            this.RecvUpdateMinuteData(data);
            return;
        }

        if (!data.stock[0]) return;
        if (data.stock[0].symbol!=this.Symbol && this.EnableVerifyRecvData) 
        {
            JSConsole.Chart.Warn(`[MinuteChartContainer::RecvMinuteData] recv data symbol not match. HQChart[${this.Symbol}] , Recv[${data.stock[0].symbol}]`);
            return;
        }

        var aryMinuteData=MinuteChartContainer.JsonDataToMinuteData(data);
        var aryColorData=MinuteChartContainer.JsonDataToMinuteLineColorData(data);
        this.BeforeOpenData=null;
        this.AfterCloseData=null;
        var beforeOpenData=MinuteChartContainer.JsonDataToBeforeOpenData(data);
        var afterCloseData=MinuteChartContainer.JsonDataToAfterCloseData(data);
        var updateTime=MinuteChartContainer.JsonDataToMinuteLastUpdateTime(data);   //数据最后的更新时间

        if (this.IsBeforeData) this.BeforeOpenData=beforeOpenData;
        if (this.IsAfterData) this.AfterCloseData=afterCloseData;

        var bFirstData=(this.DataStatus.LatestDay==false);   //首条单日数据

        this.DataStatus.LatestDate=data.stock[0].date; //保存下最后一天的日期
        this.DataStatus.LatestDay=true;
            
        if (this.DayCount>1)    //多日走势图
        {
            this.UpdateCallCationData(beforeOpenData,afterCloseData);
            this.UpdateLineColorData(aryColorData,data.stock[0].date);
            this.UpdateLatestMinuteData(aryMinuteData, data.stock[0].date, data.stock[0]);
            this.UpdateHistoryMinuteUI(updateTime);
            this.RecvMinuteDataEvent({FunctionName:"RecvMinuteData"} );
            this.RequestOverlayMinuteData();    //请求叠加数据 (主数据下载完再下载)
            this.BindAllOverlayIndexData(this.SourceData);
            this.AutoUpdateEvent(true, "MinuteChartContainer::RecvMinuteData");
            this.AutoUpdate();
            return;
        }

        if (this.IsOnTouch==true)   //正在操作中不更新数据
        {
            if (this.SourceData && IFrameSplitOperator.IsNonEmptyArray(this.SourceData.Data))
            {
                this.AutoUpdate();
                return; 
            }
        }

        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=aryMinuteData;
        sourceData.UpdateTime=updateTime;

        this.ColorLineData=aryColorData;

        this.TradeDate=data.stock[0].date;
        this.Frame.SetDayCount(1);  //单日数据

        this.SourceData=sourceData;
        this.Symbol=data.stock[0].symbol;
        this.Name=data.stock[0].name;

        this.SetCallCationDataBorder( { Left:this.IsBeforeData, Right:this.IsAfterData , MultiDay:{ Left:false, Right:false }} );

        if (this.ShareAfterVol==2)  //盘前， 盘后成交量公用坐标
        {
            if (this.BeforeOpenData && this.AfterCloseData)
            {
                var max=Math.max(this.BeforeOpenData.VolMax, this.AfterCloseData.VolMax);
                var min=Math.min(this.BeforeOpenData.VolMin, this.AfterCloseData.VolMin);
                this.BeforeOpenData.VolMax=this.AfterCloseData.VolMax=max;
                this.BeforeOpenData.VolMin=this.AfterCloseData.VolMin=min;
            }
        }

        var yClose=data.stock[0].yclose;
        var upperSymbol=this.Symbol.toUpperCase();
        var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);
        if (data.stock[0].yclearing>0 && isFutures) yClose=data.stock[0].yclearing; //期货使用前结算价
        this.CaclutateLimitPrice(yClose, data.stock[0].limitprice); //计算涨停价格
        var extendData=null;
        if (data.stock[0].high>0 && data.stock[0].low>0) extendData={ High:data.stock[0].high, Low:data.stock[0].low };
        this.BindMainData(sourceData,yClose, extendData);

        if (this.Frame.SubFrame.length>2)
        {
            var bindData=new ChartData();
            bindData.Data=aryMinuteData;
            for(var i=2; i<this.Frame.SubFrame.length; ++i)
            {
                this.BindIndexData(i,bindData);
            }
        }

        for(let i in this.Frame.SubFrame)
        {
            var item=this.Frame.SubFrame[i];
            item.Frame.XSplitOperator.Symbol=this.Symbol;
            item.Frame.XSplitOperator.DayCount=1;
            item.Frame.XSplitOperator.Operator();   //调整X轴个数
            item.Frame.YSplitOperator.Symbol=this.Symbol;

            for(var j in item.OverlayIndex) //子坐标X轴个数同步
            {
                var overlayItem=item.OverlayIndex[j];
                overlayItem.Frame.XPointCount=item.Frame.XPointCount;
                overlayItem.Frame.MinuteCount=item.Frame.MinuteCount;
            }
        }

        this.ChartCorssCursor.StringFormatY.Symbol=this.Symbol;
        this.ChartCorssCursor.StringFormatX.Symbol=this.Symbol;

        if (MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol)) this.TitlePaint[0].IsShowDate=false;

        if (data.stock[0].IsHistoryMinute==true) this.TitlePaint[0].IsShowDate=true;

        var chartInfo=this.GetChartMinuteInfo();
        if (chartInfo) chartInfo.SourceData=this.SourceData;    //数据绑定到信息地雷上

        this.RecvMinuteDataEvent( {FunctionName:"RecvMinuteData", Day:{ IsFirstData:bFirstData} } );
        this.RequestMinuteInfoData();
        this.RequestOverlayMinuteData();//请求叠加数据 (主数据下载完再下载)
        this.CreateChartDrawPictureByStorage(); //创建画图工具

        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        this.BindAllOverlayIndexData(this.SourceData);
        
        if (data.AutoUpdate===false)    //不执行自动更新
        {

        }   
        else
        {
            this.AutoUpdateEvent(true, "MinuteChartContainer::RecvMinuteData");
            this.AutoUpdate();
        }
    }

    this.CaclutateLimitPrice=function(yClose, limitData)
    {
        this.LimitPrice=null;
        //var limitData=data.stock[0].limitprice;
        if (limitData && limitData.max>0 && limitData.min>0)    //API里带涨停价格 直接使用
        {
            this.LimitPrice={ Max:limitData.max, Min:limitData.min };
            return;
        }
        
        var range=MARKET_SUFFIX_NAME.GetLimitPriceRange(this.Symbol, this.Name);   //通过规则获取涨停价格
        if (!range) 
        {
            JSConsole.Chart.Log(`[MinuteChartContainer::CaclutateLimitPrice] ${this.Symbol} no limit price.`)
            return;
        }

        //var yClose=data.stock[0].yclose;
        if (yClose<=0) return;
        this.LimitPrice={ Max:yClose*(1+range.Max), Min:yClose*(1+range.Min) };

        JSConsole.Chart.Log(`[MinuteChartContainer::CaclutateLimitPrice] ${this.Symbol} yClose:${yClose} max:${this.LimitPrice.Max} min:${this.LimitPrice.Min}`);

        this.LimitPrice.Max=parseFloat(this.LimitPrice.Max.toFixed(2));
        this.LimitPrice.Min=parseFloat(this.LimitPrice.Min.toFixed(2));
        JSConsole.Chart.Log(`[MinuteChartContainer::CaclutateLimitPrice] ${this.Symbol} tofixed(2) max:${this.LimitPrice.Max} min:${this.LimitPrice.Min}`);
    }

    this.RequestSingleOverlayMinuteData=function(symbol, date, item)
    {
        var self = this;
        item.Status=OVERLAY_STATUS_ID.STATUS_REQUESTDATA_ID;

        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'MinuteChartContainer::RequestOverlayMinuteData', //类名::函数名
                Explain:'叠加股票最新分时数据',
                Request:{ Url:this.HistoryMinuteApiUrl, Data:{days:[date], symbol:symbol}, Type:'POST' }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                self.RecvOverlayMinuteData(data,item);
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        //请求数据
        JSNetwork.HttpRequest({
            url: this.HistoryMinuteApiUrl,
            data:
            {
                "symbol":symbol,
                "days": [date],
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                //self.RecvMultiOverlayMinuteData([data]);
                self.RecvOverlayMinuteData(data,item);
            }
        });
    }

    //请求叠加数据 (主数据下载完再下载))
    this.RequestOverlayMinuteData=function()
    {
        var self = this;
        var date=this.TradeDate;    //最后一个交易日期

        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            let item=this.OverlayChartPaint[i];
            if (!item.MainData) continue;
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_NONE_ID) continue;
            var symbol=item.Symbol;
            if (!symbol) continue;

            this.RequestSingleOverlayMinuteData(symbol, date, item);

            /*
            item.Status=OVERLAY_STATUS_ID.STATUS_REQUESTDATA_ID;

            if (this.NetworkFilter)
            {
                var obj=
                {
                    Name:'MinuteChartContainer::RequestOverlayMinuteData', //类名::函数名
                    Explain:'叠加股票最新分时数据',
                    Request:{ Url:self.HistoryMinuteApiUrl, Data:{days:[date], symbol:symbol}, Type:'POST' }, 
                    Self:this,
                    PreventDefault:false
                };
                this.NetworkFilter(obj, function(data) 
                { 
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOverlayMinuteData(data,item);
                });

                if (obj.PreventDefault==true) continue;   //已被上层替换,不调用默认的网络请求
            }

            //请求数据
            JSNetwork.HttpRequest({
                url: self.HistoryMinuteApiUrl,
                data:
                {
                    "symbol":symbol,
                    "days": [date],
                },
                type:"post",
                dataType: "json",
                async:true,
                success: function (data)
                {
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    //self.RecvMultiOverlayMinuteData([data]);
                    self.RecvOverlayMinuteData(data,item);
                }
            });
            */
        }
    }

    //一次接收多个叠加品种
    this.RecvMultiOverlayMinuteData=function(aryData)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(aryData)) return;

        var bUpdate=false;
        for(var i=0;i<aryData.length; ++i)
        {
            var overlayData=aryData[i];
            if (!overlayData.symbol) continue;

            for(var j=0; j<this.OverlayChartPaint.length; ++j)
            {
                var item=this.OverlayChartPaint[j];
                if (!item.MainData) continue;
                if (overlayData.symbol==item.Symbol)
                {
                    this.RecvOverlayMinuteData(overlayData, item, { Redraw:false });
                    bUpdate=true;
                    break;
                }
            }
        }

        if (bUpdate)
        {
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Frame.SetSizeChage(true);
            this.Draw();
        }
    }

    this.RecvOverlayMinuteData=function(data,paint,option)
    {
        if (paint.IsDelete) return;

        if (this.EnableVerifyRecvData && data.symbol!=paint.Symbol)
        {
            JSConsole.Chart.Warn(`[MinuteChartContainer::RecvOverlayMinuteData] recv data symbol not match. paint[${paint.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        var aryMinuteData=MinuteChartContainer.JsonDataToMinuteDataArray(data);

        var sourceData=null;
        var yClose;
        if (this.DayCount>1)    //多日数据
        {
            if (aryMinuteData.length<=0) return;

            var minuteData=aryMinuteData[0];
            for(var i in paint.SourceData)
            {
                var item=paint.SourceData[i];
                if (item.Date==minuteData.Date)
                {
                    paint.SourceData[i]=minuteData;
                    var allMinuteData=this.HistoryMinuteDataToArray(paint.SourceData);
                    var sourceData=new ChartData();
                    sourceData.Data=allMinuteData;
                    yClose=minuteData.YClose;
                    break;
                }
            }
            if (sourceData==null) return;
        }
        else
        {
            if (aryMinuteData.length>0) sourceData=aryMinuteData[0];
            else sourceData=new ChartData();
            yClose=sourceData.YClose;
        }

        paint.Data=sourceData;
        paint.Title=data.name;
        paint.Symbol=data.symbol;
        paint.YClose=yClose;
        paint.Status=OVERLAY_STATUS_ID.STATUS_FINISHED_ID;

        var bRedraw=true;
        if (option && option.Redraw==false) bRedraw=false;
        if (bRedraw)
        {
            this.UpdateFrameMaxMin();          //调整坐标最大 最小值
            this.Frame.SetSizeChage(true);
            this.Draw();
        }
    }

    this.RequestSingleOverlayHistoryMinuteData=function(symbol, days, item)
    {
        var self = this;
        item.Status=OVERLAY_STATUS_ID.STATUS_REQUESTDATA_ID;

        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'MinuteChartContainer::RequestOverlayHistoryMinuteData', //类名::函数名
                Explain:'叠加股票多日分时数据',
                Request:{ Url:self.HistoryMinuteApiUrl, Data:{days:days, symbol:symbol}, Type:'POST' }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                self.RecvOverlayHistoryMinuteData(data,item);
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        JSNetwork.HttpRequest({
            url: self.HistoryMinuteApiUrl,
            data:{ "symbol": symbol, "days": days },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                self.RecvOverlayHistoryMinuteData(data,item);
            }
        });
    }

    this.RequestOverlayHistoryMinuteData=function()
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(this.DayData)) return;
        
        var self = this;
        var days=[];
        for(var i=0; i<this.DayData.length; ++i)
        {
            var item=this.DayData[i];
            days.push(item.Date);
        }
        if (days.length<=0) return;

        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i]
            var symbol=item.Symbol;
            if (!symbol) continue;
            if (item.Status!=OVERLAY_STATUS_ID.STATUS_NONE_ID) continue;

            this.RequestSingleOverlayHistoryMinuteData(symbol, days, item);

            /*
            item.Status=OVERLAY_STATUS_ID.STATUS_REQUESTDATA_ID;

            if (this.NetworkFilter)
            {
                var obj=
                {
                    Name:'MinuteChartContainer::RequestOverlayHistoryMinuteData', //类名::函数名
                    Explain:'叠加股票多日分时数据',
                    Request:{ Url:self.HistoryMinuteApiUrl, Data:{days:days, symbol:symbol}, Type:'POST' }, 
                    Self:this,
                    PreventDefault:false
                };
                this.NetworkFilter(obj, function(data) 
                { 
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOverlayHistoryMinuteData(data,item);
                });

                if (obj.PreventDefault==true) continue;   //已被上层替换,不调用默认的网络请求
            }

            JSNetwork.HttpRequest({
                url: self.HistoryMinuteApiUrl,
                data:{ "symbol": symbol, "days": days },
                type:"post",
                dataType: "json",
                async:true,
                success: function (data)
                {
                    item.Status=OVERLAY_STATUS_ID.STATUS_RECVDATA_ID;
                    self.RecvOverlayHistoryMinuteData(data,item);
                }
            });
            */
        }
    }

    this.RecvOverlayHistoryMinuteData=function(data,paint)    //叠加历史的分钟数据
    {
        if (this.EnableVerifyRecvData && data.symbol!=paint.Symbol)
        {
            JSConsole.Chart.Warn(`[MinuteChartContainer::RecvOverlayHistoryMinuteData] recv data symbol not match. paint[${paint.Symbol}] , Recv[${data.symbol}]`);
            return;
        }

        if (!IFrameSplitOperator.IsNonEmptyArray(this.DayData)) return;
        var dayData=MinuteChartContainer.JsonDataToMinuteDataArray(data);
        if (!IFrameSplitOperator.IsNonEmptyArray(dayData)) return;

        var overlayDayData=[];
        for(var i=0; i<this.DayData.length; ++i)
        {
            var item=this.DayData[i];
            var bFind=false;
            for(var j=0; j<dayData.length; ++j)
            {
                if (item.Date==dayData[j].Date)
                {
                    overlayDayData.push(dayData[j]);
                    bFind=true;
                    break;
                }
            }
            if (!bFind) //当天不存在叠加数据, 存空
            {
                var empytData=new ChartData();
                empytData.Date=item.Date;
                empytData.Data.length=item.Data.length;
                overlayDayData.push(empytData);
            }
        }

        paint.SourceData=overlayDayData;
        var allMinuteData=this.HistoryMinuteDataToArray(overlayDayData);
        var yClose=overlayDayData[0].YClose;    //取最近一个交易日前收盘最为中轴线
        
        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=allMinuteData;

        paint.Data=sourceData;
        paint.Title=data.name;
        paint.Symbol=data.symbol;
        paint.YClose=yClose;
        paint.Status=OVERLAY_STATUS_ID.STATUS_FINISHED_ID;

        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
    }

    this.CancelAutoUpdate=function()    //关闭停止更新
    {
        if (typeof (this.AutoUpdateTimer) == 'number') 
        {
            clearTimeout(this.AutoUpdateTimer);
            this.AutoUpdateTimer = undefined;
        }
    }

    //数据自动更新
    this.AutoUpdate=function()
    {
        this.CancelAutoUpdate();
        if (!this.IsAutoUpdate) return;
        if (!this.Symbol) return;

        var self = this;
        var marketStatus=MARKET_SUFFIX_NAME.GetMarketStatus(this.Symbol);
        if (marketStatus==0 || marketStatus==3)    //闭市,盘后
        {   //等待开盘
            this.AutoUpdateTimer=setTimeout(function() 
            { 
                self.AutoUpdate(); 
            },20000);

            return; 
        }

        var frequency=this.AutoUpdateFrequency;
        if (marketStatus==1) //盘前
        {
            this.AutoUpdateTimer=setTimeout(function() 
            { 
                self.AutoUpdate(); 
            },frequency);
        }
        else if (marketStatus==2)   //盘中
        {
            this.AutoUpdateTimer=setTimeout(function()
            {
                self.ResetOverlaySymbolStatus();
                self.RequestMinuteData();
            },frequency);
        }
    }

    this.BindIndexData=function(windowIndex, hisData, option)
    {
        if (!this.WindowIndex[windowIndex]) return;

        if (typeof(this.WindowIndex[windowIndex].RequestData)=="function")          //数据需要另外下载的.
        {
            this.WindowIndex[windowIndex].RequestData(this,windowIndex,hisData);
            return;
        }
        if (typeof(this.WindowIndex[windowIndex].ExecuteScript)=='function')
        {
            this.WindowIndex[windowIndex].ExecuteScript(this,windowIndex,hisData);
            return;
        }

        this.WindowIndex[windowIndex].BindData(this,windowIndex,hisData);
    }

    //绑定分钟数据
    this.BindMainData=function(minuteData,yClose, extendData)
    {
        var multiBeforeOpenData=this.IsShowMultiDayBeforeData?this.MultiDayBeforeOpenData:null;
        var multiAfterCloseData=this.IsShowMultiDayAfterData?this.MultiDayAfterCloseData:null;

        //分钟数据
        var bindData=new ChartData();
        bindData.Data=minuteData.GetClose();
        this.ChartPaint[0].Data=bindData;
        this.ChartPaint[0].YClose=yClose;
        this.ChartPaint[0].NotSupportMessage=null;
        this.ChartPaint[0].IsShowLead=false;
        this.ChartPaint[0].LeadData=null;
        this.ChartPaint[0].BeforeOpenData=this.BeforeOpenData;
        this.ChartPaint[0].AfterCloseData=this.AfterCloseData;
        this.ChartPaint[0].MultiDayBeforeOpenData=multiBeforeOpenData;
        this.ChartPaint[0].MultiDayAfterCloseData=multiAfterCloseData;
        this.ChartPaint[0].ColorLineData=this.ColorLineData;    //自定义分段颜色
        this.ChartPaint[0].Source=minuteData;

        if (MARKET_SUFFIX_NAME.IsSHSZIndex(this.Symbol) && this.DayCount==1 && this.IsShowLead)  //指数显示领先指标
        {
            var bindLeadData=new ChartData();
            bindLeadData.Data=minuteData.GetLead();
            this.ChartPaint[0].LeadData=bindLeadData;
            this.ChartPaint[0].IsShowLead=true;
        }

        var firstFrame=this.Frame.SubFrame[0].Frame;
       
        firstFrame.YSplitOperator.YClose=yClose;
        firstFrame.YSplitOperator.Data=bindData;
        this.Frame.Data=this.ChartPaint[0].Data;
        this.Frame.SourceData=minuteData;

        for(var i in this.Frame.SubFrame)
        {
            var item=this.Frame.SubFrame[i].Frame;
            item.Data=minuteData;  //每个子窗口都绑定下数据
        }

        //均线
        bindData=new ChartData();
        bindData.Data=minuteData.GetMinuteAvPrice();
        this.ChartPaint[1].Data=bindData;

        var upperSymbol=this.Symbol.toUpperCase();
        if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol))    //外汇没有均线
            this.ChartPaint[1].Data=null;
        else if (MARKET_SUFFIX_NAME.IsShowAvPrice && !MARKET_SUFFIX_NAME.IsShowAvPrice(upperSymbol))    //外部控制是否显示均线
            this.ChartPaint[1].Data=null;

        firstFrame.YSplitOperator.AverageData=bindData;     //均线
        firstFrame.YSplitOperator.OverlayChartPaint=this.OverlayChartPaint;
        firstFrame.YSplitOperator.LimitPrice=this.LimitPrice;
        firstFrame.YSplitOperator.MultiDayBeforeOpenData=multiBeforeOpenData;
        firstFrame.YSplitOperator.MultiDayAfterCloseData=multiAfterCloseData;
        firstFrame.YSplitOperator.DayCount=this.DayCount;
        if (extendData)
        {
            firstFrame.YSplitOperator.High=extendData.High;
            firstFrame.YSplitOperator.Low=extendData.Low;
        }
        else
        {
            firstFrame.YSplitOperator.High=null;
            firstFrame.YSplitOperator.Low=null;
        }

        //成交量
        this.ChartPaint[2].Data=minuteData;
        this.ChartPaint[2].YClose=yClose;
        this.ChartPaint[2].Symbol=this.Symbol;
        this.ChartPaint[2].BeforeOpenData=this.BeforeOpenData;
        this.ChartPaint[2].AfterCloseData=this.AfterCloseData;
        this.ChartPaint[2].MultiDayBeforeOpenData=multiBeforeOpenData;
        this.ChartPaint[2].MultiDayAfterCloseData=multiAfterCloseData;

        for(var i in this.Frame.SubFrame)
        {
            var item=this.Frame.SubFrame[i];

            item.Frame.YSplitOperator.BeforeOpenData=this.BeforeOpenData;
            item.Frame.YSplitOperator.IsBeforeData=this.IsBeforeData;
            item.Frame.YSplitOperator.AfterCloseData=this.AfterCloseData;
            item.Frame.YSplitOperator.IsAfterData=this.IsAfterData;
            item.Frame.YSplitOperator.MultiDayBeforeOpenData=multiBeforeOpenData;
            item.Frame.YSplitOperator.MultiDayAfterCloseData=multiAfterCloseData;
        }

        if(MARKET_SUFFIX_NAME.IsShowMinutePostionLine(upperSymbol))  
            this.BindOverlayPositionData(minuteData,yClose);    //期货,期权 持仓量
        else 
            this.ClearBindOverlayPositionData();

        this.TitlePaint[0].Data=this.SourceData;                    //动态标题
        this.TitlePaint[0].Symbol=this.Symbol;
        this.TitlePaint[0].Name=this.Name;
        this.TitlePaint[0].YClose=yClose;
        this.TitlePaint[0].BeforeOpenData=this.BeforeOpenData;
        this.TitlePaint[0].AfterCloseData=this.AfterCloseData;
        this.TitlePaint[0].MultiDayBeforeOpenData=this.IsShowMultiDayBeforeData?this.MultiDayBeforeOpenData:null;
        this.TitlePaint[0].MultiDayAfterCloseData=this.IsShowMultiDayAfterData?this.MultiDayAfterCloseData:null;
        if (this.TitlePaint[0].CallAcutionXOperator)
        {
            this.TitlePaint[0].CallAcutionXOperator.BeforeOpenData=this.BeforeOpenData;
            this.TitlePaint[0].CallAcutionXOperator.AfterCloseData=this.AfterCloseData;
            this.TitlePaint[0].CallAcutionXOperator.MultiDayBeforeOpenData=multiBeforeOpenData;
            this.TitlePaint[0].CallAcutionXOperator.MultiDayAfterCloseData=multiAfterCloseData;
            this.TitlePaint[0].CallAcutionXOperator.DayOffset=this.DayOffset;
        }

        if (this.ChartCorssCursor && this.ChartCorssCursor.StringFormatY)
        {
            this.ChartCorssCursor.StringFormatY.YClose=yClose;
            this.ChartCorssCursor.StringFormatY.BeforeOpenData=this.BeforeOpenData;
            this.ChartCorssCursor.StringFormatY.AfterCloseData=this.AfterCloseData;
            this.ChartCorssCursor.StringFormatY.MultiDayBeforeOpenData=multiBeforeOpenData;
            this.ChartCorssCursor.StringFormatY.MultiDayAfterCloseData=multiAfterCloseData;
            this.ChartCorssCursor.StringFormatY.DayOffset=this.DayOffset;

            this.ChartCorssCursor.StringFormatX.Data=this.ChartPaint[0].Data;       //十字光标
            this.ChartCorssCursor.StringFormatX.BeforeOpenData=this.BeforeOpenData;
            this.ChartCorssCursor.StringFormatX.AfterCloseData=this.AfterCloseData;

            this.ChartCorssCursor.StringFormatX.MultiDayBeforeOpenData=multiBeforeOpenData;
            this.ChartCorssCursor.StringFormatX.MultiDayAfterCloseData=multiAfterCloseData;
            this.ChartCorssCursor.StringFormatX.DayOffset=this.DayOffset;;

            if (this.ChartCorssCursor.CallAcutionXOperator)
            {
                this.ChartCorssCursor.CallAcutionXOperator.BeforeOpenData=this.BeforeOpenData;
                this.ChartCorssCursor.CallAcutionXOperator.AfterCloseData=this.AfterCloseData;
                this.ChartCorssCursor.CallAcutionXOperator.MultiDayBeforeOpenData=multiBeforeOpenData;
                this.ChartCorssCursor.CallAcutionXOperator.MultiDayAfterCloseData=multiAfterCloseData;
                this.ChartCorssCursor.CallAcutionXOperator.DayOffset=this.DayOffset;
            }
        }
           
        if (this.ExtendChartPaint[0])
        {
            this.ExtendChartPaint[0].Symbol=this.Symbol;
            this.ExtendChartPaint[0].Name=this.Name;
        }

        for(var i=0; i<this.OverlayChartPaint.length; ++i)
        {
            var item=this.OverlayChartPaint[i];
            item.MainData=minuteData;           //绑定主图数据
        }
    }

    //绑定分钟叠加指标数据(持仓量)
    this.BindOverlayPositionData=function(minuteData,yClose)
    {
        if (this.Frame.SubFrame.length<2) return;

        var chart=null;
        var frame=null;
        var subFrame=this.Frame.SubFrame[1];    //第2个窗口
        var overlayFrame=null;
        for(var i=0; i<subFrame.OverlayIndex.length; ++i)
        {
            var item=subFrame.OverlayIndex[i];
            if (item.Identify=='Position_Line_Frame')
            {
                overlayFrame=item;
                break;
            }
        }

        if (!overlayFrame)
        {
            overlayFrame=new OverlayIndexItem();
            overlayFrame.Identify='Position_Line_Frame';

            if (this.ClassName=="MinuteChartContainer") frame=new OverlayMinuteFrame();
            else frame=new OverlayMinuteHScreenFrame();

            frame.Canvas=this.Canvas;
            frame.MainFrame=subFrame.Frame;
            frame.ChartBorder=subFrame.Frame.ChartBorder;
            frame.GlobalOption=this.GlobalOption;
            overlayFrame.Frame=frame;

            frame.YSplitOperator=new FrameSplitY();
            frame.YSplitOperator.LanguageID=this.LanguageID;
            frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
            frame.YSplitOperator.Frame=frame;
            frame.YSplitOperator.ChartBorder=frame.ChartBorder;
            frame.YSplitOperator.SplitCount=subFrame.Frame.YSplitOperator.SplitCount;
            frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
            frame.YSplitOperator.OverlayIdentify=overlayFrame.Identify;

            var chart=new ChartMinutePositionLine();
            chart.Canvas=this.Canvas
            chart.Name='Position-Line';
            chart.ChartBorder=frame.ChartBorder;
            chart.ChartFrame=frame
            chart.Identify=overlayFrame.Identify;
            chart.Color=g_JSChartResource.Minute.PositionColor;
            overlayFrame.ChartPaint.push(chart);

            subFrame.OverlayIndex.push(overlayFrame);
            subFrame.Frame.RightFrame=frame;  //右边坐标绑定到主坐标上
        }
        else
        {
            frame=overlayFrame.Frame;

            for(var i=0;i<overlayFrame.ChartPaint.length;++i)
            {
                var item=overlayFrame.ChartPaint[i];
                if (item.Name=='Position-Line')
                {
                    chart=item;
                    break;
                }
            }

            if (!chart) //图形不存在就创建一个
            {
                chart=new ChartMinutePositionLine();
                chart.Canvas=this.Canvas
                chart.Name='Position-Line';
                chart.ChartBorder=frame.ChartBorder;
                chart.ChartFrame=frame
                chart.Identify=overlayFrame.Identify;
                chart.Color=g_JSChartResource.Minute.PositionColor;
                overlayFrame.ChartPaint.push(chart);
            }
        }

        var xPointCouont=this.Frame.SubFrame[0].Frame.XPointCount;
        frame.XPointCount=xPointCouont;
        subFrame.Frame.IsShowPositionTitle=true;

        var bindData=new ChartData();
        bindData.Data=minuteData.GetPosition();
        chart.Data=bindData;
    }

    this.ClearBindOverlayPositionData=function()
    {
        if (this.Frame.SubFrame.length<2) return;
        var subFrame=this.Frame.SubFrame[1];        //第2个窗口
        subFrame.Frame.RightFrame=null;
        subFrame.Frame.IsShowPositionTitle=false;
        for(var i in subFrame.OverlayIndex)
        {
            var item=subFrame.OverlayIndex[i];
            if (item.Identify=='Position_Line_Frame')
            {
                subFrame.OverlayIndex.splice(i,1);
                break;
            }
        }
    }

    this.GetOverlayIndexByIdentify=function(identify)
    {
        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            var item=this.Frame.SubFrame[i];
            if (!IFrameSplitOperator.IsNonEmptyArray(item.OverlayIndex)) continue;

            for(var j=0; j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                if (overlayItem.Identify===identify)
                    return { OverlayItem:overlayItem, WindowIndex:i };
            }
        }

        return null;
    }

    this.RecvOverlayIndex=function(identify, data)
    {
        var overlayIndex=this.GetOverlayIndexByIdentify(identify);
        if (overlayIndex==null) 
        {
            console.warn(`[MinuteChartContainer::RecvOverlayIndex] can't find overlay index. [identify=${identify}]`);
            return;
        }

        if (!overlayIndex.Script) return;
        if (typeof(overlayIndex.RecvSubscribeData)!="function") return;

        var bindData=this.SourceData;
        if (!bindData) return;

        overlayIndex.Script.RecvSubscribeData(data,this,overlayIndex.WindowIndex,bindData);
    }

    //更新叠加指标
    this.UpdateOverlayIndex=function(identify)
    {
        var overlayIndex=this.GetOverlayIndexByIdentify(identify)

        if (overlayIndex==null) 
        {
            console.warn(`[MinuteChartContainer::UpdateOverlayIndex] can't find overlay index. [identify=${identify}]`);
            return;
        }

        var bindData=this.SourceData;
        if (!bindData) return;

        this.BindOverlayIndexData(overlayIndex.OverlayItem, overlayIndex.WindowIndex, bindData);
    }

    //添加叠加指标
    this.AddOverlayIndex=function(obj) 
    {
        var overlay=this.CreateOverlayWindowsIndex(obj);
        if (!overlay) return;

        var bindData=this.SourceData;
        this.BindOverlayIndexData(overlay,obj.WindowIndex,bindData);
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    //创建一个叠加指标
    this.CreateOverlayWindowsIndex=function(obj) //{WindowIndex:, IndexName:, Identify:, ShowRightText:, API:}
    {
        let indexName=obj.IndexName;
        let windowIndex=obj.WindowIndex;
        var apiItem=null, indexInfo=null, indexCustom=null;
        if (obj.API)
        {
            apiItem=obj.API;
        }
        else if (obj.Script)    //动态执行脚本
        {
            indexInfo={ Script:obj.Script, ID:obj.indexName, Name:obj.indexName};
            if (obj.Name) indexInfo.Name=obj.Name;
        }
        else
        {
            let scriptData = new JSIndexScript();
            indexInfo = scriptData.Get(indexName);  //系统指标
            if (!indexInfo) 
            {
                indexCustom=JSIndexMap.Get(indexName);  //定制指标
                if (!indexCustom)
                {
                    console.warn(`[MinuteChartContainer::CreateOverlayIndex] can not find index[${indexName}]`);
                    return null;
                }
            }
        }

        var subFrame=this.Frame.SubFrame[windowIndex];
        var overlayFrame=new OverlayIndexItem();
        if (obj.Identify) overlayFrame.Identify=obj.Identify;   //由外部指定id
        var frame=null;
        if (this.ClassName=="MinuteChartContainer") frame=new OverlayMinuteFrame();
        else frame=new OverlayMinuteHScreenFrame();
        frame.Canvas=this.Canvas;
        frame.MainFrame=subFrame.Frame;
        frame.ChartBorder=subFrame.Frame.ChartBorder;
        frame.GlobalOption=this.GlobalOption;
        if (IFrameSplitOperator.IsBool(obj.ShowRightText)) frame.IsShow=obj.ShowRightText;
        if (IFrameSplitOperator.IsBool(obj.IsShareY)) frame.IsShareY=obj.IsShareY;
        if (IFrameSplitOperator.IsBool(obj.IsCalculateYMaxMin)) frame.IsCalculateYMaxMin=obj.IsCalculateYMaxMin;   //是否计算Y最大最小值
        if (IFrameSplitOperator.IsNumber(obj.IsShowMainFrame)) frame.IsShowMainFrame=obj.IsShowMainFrame;

        frame.YSplitOperator=new FrameSplitY();
        frame.YSplitOperator.LanguageID=this.LanguageID;
        frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
        frame.YSplitOperator.Frame=frame;
        frame.YSplitOperator.ChartBorder=frame.ChartBorder;
        frame.YSplitOperator.SplitCount=subFrame.Frame.YSplitOperator.SplitCount;
        frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        frame.YSplitOperator.HQChart=this;
        frame.YSplitOperator.OverlayIdentify=overlayFrame.Identify;

        if (obj.Frame)
        {
            var item=obj.Frame;
            if (item.Custom) frame.YSplitOperator.Custom=item.Custom;
        }
        
        overlayFrame.Frame=frame;

        if (apiItem)
        {
            var apiIndex=new APIScriptIndex(apiItem.Name,apiItem.Script,apiItem.Args,obj, true);
            apiIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame };    //叠加指标信息
            overlayFrame.Script=apiIndex;
        }
        else if (indexInfo)
        {
            JSIndexScript.ModifyAttribute(indexInfo, obj);
            var scriptIndex=new OverlayScriptIndex(indexInfo.Name,indexInfo.Script,indexInfo.Args,indexInfo);    //脚本执行
            scriptIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame };    //叠加指标信息
            overlayFrame.Script=scriptIndex;
        }
        else 
        {
            var scriptIndex=indexCustom.Create();
            scriptIndex.OverlayIndex={ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame };    //叠加指标信息
            scriptIndex.Create(this,windowIndex);
            overlayFrame.Script=scriptIndex;
        }

        subFrame.OverlayIndex.push(overlayFrame);
        return overlayFrame;
    }

    this.DeleteOverlayWindowsIndex=function(identify) //删除叠加指标
    {
        if (!this.DeleteOverlayIndex(identify, null)) return;

        this.Frame.ResetXYSplit(true);
        this.Draw();
    }

    //计算叠加指标
    this.BindAllOverlayIndexData=function(hisData, option)
    {
        if (!this.Frame || !this.Frame.SubFrame) return;

        //叠加指标
        for(var i=0;i<this.Frame.SubFrame.length;++i)
        {
            var item=this.Frame.SubFrame[i];
            for(var j=0;j<item.OverlayIndex.length; ++j)
            {
                var overlayItem=item.OverlayIndex[j];
                this.BindOverlayIndexData(overlayItem,i,hisData,option)
            }
        }
    }

    //叠加指标
    this.BindOverlayIndexData=function(overlayItem, windowIndex, hisData, option)
    {
        if (!overlayItem.Script) return;

        if (typeof(overlayItem.Script.RequestData)=='function')
        {
            overlayItem.Script.RequestData(this,windowIndex,hisData);
            return;
        }

        if (typeof(overlayItem.Script.ExecuteScript)=='function')
        {
            overlayItem.Script.ExecuteScript(this,windowIndex,hisData);
            return;
        }

        overlayItem.Script.BindData(this,windowIndex,hisData);
    }

    //获取子窗口的所有画法
    this.GetChartPaint=function(windowIndex)
    {
        var paint=new Array();
        for(var i in this.ChartPaint)
        {
            if (i<3) continue; //分钟 均线 成交量 3个线不能改

            var item=this.ChartPaint[i];
            if (item.ChartFrame==this.Frame.SubFrame[windowIndex].Frame)
                paint.push(item);
        }

        return paint;
    }

    //创建指定窗口指标
    this.CreateWindowIndex=function(windowIndex)
    {
        this.WindowIndex[windowIndex].Create(this,windowIndex);
    }

    this.OnTouchFinished=function()
    {
        if (this.CorssCursorTouchEnd===true)    //手势离开十字光标消失
        {
            this.DrawDynamicInfo();
            return;
        }

        /* 以后放日线的tooltip
        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName==='KLineTooltipPaint')
            {
                this.DrawDynamicInfo();
            }
        }
        */
    }

    this.CreateExtendChart=function(name, option)   //创建扩展图形
    {
        var chart;
        switch(name)
        {
            case 'MinuteTooltip':
                if (option.Create && typeof(option.Create)=='function') chart=option.Create();
                else chart=new MinuteTooltipPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                option.LanguageID=this.LanguageID;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            case "MinutePCTooltip":
                if (option.Create && typeof(option.Create)=="function") chart=option.Create();
                else chart=new MinuteLeftTooltipPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                option.LanguageID=this.LanguageID;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            case "MinuteBackgroundPaint":
                chart=new MinuteBackgroundPaint();
                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                option.LanguageID=this.LanguageID;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
            default:
                chart=g_ExtendChartPaintFactory.Create(name);
                if (!chart) return null;

                chart.Canvas=this.Canvas;
                chart.ChartBorder=this.Frame.ChartBorder;
                chart.ChartFrame=this.Frame;
                chart.HQChart=this;
                chart.SetOption(option);
                this.ExtendChartPaint.push(chart);
                return chart;
        }
    }

    this.SetMinuteInfo=function(aryInfo,bUpdate)
    {
        this.ChartInfo=[];  //先清空
        for(var i in aryInfo)
        {
            var infoItem=JSMinuteInfoMap.Get(aryInfo[i]);
            if (!infoItem) continue;
            var item=infoItem.Create();
            this.ChartInfo.push(item);
        }

        if (bUpdate==true) this.RequestMinuteInfoData();
    }

    this.GetChartMinuteInfo=function()
    {
        return this.ChartInfoPaint;
    }

    this.CreateMinuteInfo=function(option)  //在Create()以后 在调用
    {
        var chart=new ChartMinuteInfo();
        chart.Canvas=this.Canvas;
        chart.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        chart.ChartFrame=this.Frame.SubFrame[0].Frame;
        chart.HQChartBorder=this.Frame.ChartBorder;
        chart.ChartMinutePrice=this.ChartPaint[0];
        if (option && chart.SetOption) chart.SetOption(option);
        this.ChartInfoPaint=chart;
        return chart;
    }

    //信息地雷数据请求
    this.RequestMinuteInfoData=function()
    {
        if (this.ChartInfo.length<=0) return;

        var chart=this.GetChartMinuteInfo();
        if (!chart) chart=this.CreateMinuteInfo(null);  //不存在就创建 

        chart.SourceData=this.SourceData;

        //信息地雷信息
        for(var i in this.ChartInfo)
        {
            this.ChartInfo[i].RequestData(this);
        }
    }

    //更新信息地雷
    this.UpdataChartInfo=function()
    {
        var chart=this.GetChartMinuteInfo();
        if (!chart) return;

        var infoMap=new Map();
        for(var i in this.ChartInfo)
        {
            var infoData=this.ChartInfo[i].Data;
            for(var j in infoData)
            {
                var item=infoData[j];
                var dateTime=`${item.Date} ${item.Time}`;
                if (infoMap.has(dateTime))
                {
                    infoMap.get(dateTime).Data.push(item);
                }
                else
                {

                    infoMap.set(dateTime,{Data:new Array(item)});
                }
            }
        }
        
        chart.Data=infoMap;
    }

    //接收到窗口指标数据 订阅模式
    this.RecvWindowIndex=function(index, data)
    {
        var indexItem=this.WindowIndex[index];
        if (!indexItem) return;

        if (typeof(indexItem.RecvSubscribeData)=="function")
        {
            var bindData=this.SourceData;
            indexItem.RecvSubscribeData(data,this,index,bindData);
        }
    }

    this.UpdateWindowIndex=function(index)
    {
        if (index<2) return;

        var bindData=this.SourceData;
        this.BindIndexData(index,bindData)
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Draw();
    }

    this.CreateChartDrawPicture=function(name, option, callback)
    {
        var drawPicture=null;
        var item=IChartDrawPicture.GetDrawPictureByName(name);
        if (item)
        {
            drawPicture=item.Create();
            if (drawPicture.ClassName=='ChartDrawPictureText') drawPicture.HQChart=this;
        }

        if (!drawPicture)    //iconfont图标
        {
            if (IChartDrawPicture.MapIonFont.has(name))
            {
                var iconItem=IChartDrawPicture.MapIonFont.get(name);
                drawPicture=new ChartDrawPictureIconFont();
                drawPicture.FontOption.Family=iconItem.Family
                drawPicture.Text=iconItem.Text;
                if (iconItem.Color) drawPicture.LineColor=iconItem.Color;
            }
        }

        if (!drawPicture) return false;

        drawPicture.Canvas=this.Canvas;
        drawPicture.Status=0;
        drawPicture.Symbol=this.Symbol;
        drawPicture.Period=888888888;
        drawPicture.Option=this.ChartDrawOption;
        
        if (callback) drawPicture.FinishedCallback=callback;    //完成通知上层回调
        if (option) drawPicture.SetOption(option);
        var self=this;
        drawPicture.Update=function()   //更新回调函数
        {
            self.DrawDynamicInfo();
        };
        drawPicture.GetActiveDrawPicture=function() { return self.GetActiveDrawPicture(); }
        this.CurrentChartDrawPicture=drawPicture;
        JSConsole.Chart.Log("[MinuteChartContainer::CreateChartDrawPicture] ", name,this.CurrentChartDrawPicture);
        return true;
    }

    //手动添加画线
    this.AddChartDrawPicture=function(obj)
    {
        if (!obj) return null;
        if (obj.FrameID<0 || obj.FrameID>=this.Frame.SubFrame.length) return null;
        var self=this;

        var item=IChartDrawPicture.GetDrawPictureByClassName(obj.ClassName);
        if (!item) return null;
        var drawPicture=item.Create();

        drawPicture.Canvas=this.Canvas;
        drawPicture.Status=10;
        drawPicture.Frame=this.Frame.SubFrame[obj.FrameID].Frame;  //绑定框架坐标
        drawPicture.Symbol=this.Symbol;
        drawPicture.Period=888888888;
        if (obj.Value) drawPicture.Value=obj.Value;
        if (obj.Guid) drawPicture.Guid=obj.Guid;

        if (drawPicture.ImportStorageData) drawPicture.ImportStorageData(obj);
        drawPicture.SetOption(obj);

        if (obj.EnableUpdateXValue) drawPicture.UpdateXValue();
        drawPicture.ValueToPoint();

        drawPicture.GetActiveDrawPicture=function() { return self.GetActiveDrawPicture(); }

        if (drawPicture.ClassName==='ChartDrawPictureText') drawPicture.IsInitialized=true;
        this.ChartDrawPicture.push(drawPicture);

        if (obj.Draw==true) this.DrawDynamicInfo();

        return drawPicture;
    }

    this.ReloadChartDrawPicture=function()
    {
        this.ChartDrawPicture=[];
        if (this.SelectChartDrawPicture)  this.SelectChartDrawPicture.IsSelected=false; 
        this.SelectChartDrawPicture=null;
        this.CurrentChartDrawPicture=null;
        this.MoveOnChartDrawPicture=null;
        
        if (this.ChartDrawStorage)
        {
            this.ChartDrawStorageCache=this.ChartDrawStorage.GetDrawData( { Symbol:this.Symbol, Period:888888888 } );
        }
    }

    this.CreateChartDrawPictureByStorage=function() //把缓存(this.ChartDrawStorageCache) 画图工具创建出来
    {
        if (!this.ChartDrawStorageCache || this.ChartDrawStorageCache.length<=0) return;

        var self=this;
        for(var i=0; i<this.ChartDrawStorageCache.length; ++i)
        {
            var item=this.ChartDrawStorageCache[i];
            if (item.FrameID<0 || !this.Frame.SubFrame || this.Frame.SubFrame.length<item.FrameID) continue;

            var drawPicture=IChartDrawPicture.CreateChartDrawPicture(item);
            if (!drawPicture) continue;

            drawPicture.Canvas=this.Canvas;
            drawPicture.Status=10;
            drawPicture.Frame=this.Frame.SubFrame[item.FrameID].Frame;  //绑定框架坐标
            if (drawPicture.ImportStorageData) drawPicture.ImportStorageData(item);
            drawPicture.ResetXValue();
            drawPicture.UpdateXValue();
            drawPicture.ValueToPoint();
            drawPicture.GetActiveDrawPicture=()=>{ return this.GetActiveDrawPicture(); }

            if (drawPicture.ClassName==='ChartDrawPictureText') drawPicture.IsInitialized=true;

            this.ChartDrawPicture.push(drawPicture);
        }

        this.ChartDrawStorageCache=null;    //清空缓存
    }

    this.SetSizeChange=function(bChanged)
    {
        this.Frame.SetSizeChage(bChanged);
        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            item.SizeChange=bChanged;
        }
    }
    this.SetSizeChage=this.SetSizeChange;

    //根据X坐标获取数据索引
    this.GetDataIndexByPoint=function(x)
    {
        var frame=this.Frame;
        if (this.Frame.SubFrame && this.Frame.SubFrame.length>0) frame=this.Frame.SubFrame[0].Frame;
        if (!frame) return;

        var value=frame.GetXData(x);
        var index=parseInt(value.toFixed(0));

        return index;
    }

    //不支持未来时间 目前只支持主图
    this.GetDateTimeByPoint=function(x,y)
    {
        var clientPos=this.PtInClient_V2(x,y);  // 100-199=多日分时主图  200-299=盘前  300-399=盘后  1=主图 2=盘前 3=盘后
        if (clientPos<=0) return null;

        if (!this.Frame.SubFrame[0] || !this.Frame.SubFrame[0].Frame) return null;
        var frame=this.Frame.SubFrame[0].Frame;
        var data=this.Frame.SourceData;
        if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) return null;

        var index=-1;
        var result={ ClientPos:clientPos };
        if (clientPos==1)
        {
            var value=frame.GetXData(x);
            index=parseInt(value.toFixed(0));
            if (IFrameSplitOperator.IsNumber(data.DataOffset)) index+=data.DataOffset;  //加上数据偏移
        }
        else if (clientPos>=100 && clientPos<=199)
        {
            var dayIndex=clientPos-100;
            var value=frame.GetXData(x);
            index=parseInt(value.toFixed(0));
            var dataIndex=index%frame.MinuteCount;

            result.DayIndex=dayIndex;
            result.DataIndex=dataIndex;
        }
        else
        {
            return null;
        }

        if (index<0 || index>=data.Data.length) return null;

        result.Index=index;
        var item=data.Data[index];
        if (!item) return null;

        result.Date=item.Date;
        result.Time=item.Time;

        return result;
    }

    //获取主数据
    this.GetSelectRectData=function(selectData)
    {
        if (Math.abs(selectData.XStart-selectData.XEnd)<5) return false;

        var startClientPos=this.PtInClient(selectData.XStart, selectData.YStart);
        var endClientPos=this.PtInClient(selectData.XEnd, selectData.YEnd);

        selectData.StartClientPos=startClientPos;
        selectData.EndClientPos=endClientPos;
        
        var data=this.SourceData;
        if (!data) return false;
        if (!IFrameSplitOperator.IsNonEmptyArray(data.Data)) return false;

        var start=this.GetDataIndexByPoint(selectData.XStart);
        var end=this.GetDataIndexByPoint(selectData.XEnd);

        if (Math.abs(start-end)<2) return false;

        selectData.Data=data;
        var offset=data.DataOffset;
        start+=offset;
        end+=offset;
        if (start>end)
        {
            selectData.Start=end;
            selectData.End=start;
        }
        else
        {
            selectData.Start=start;
            selectData.End=end;
        }

        var count=data.Data.length;
        if (selectData.End>=count) selectData.End=count-1;

        return true;
    }

    this.Super_UpdateFrameMaxMin=this.UpdateFrameMaxMin;
    this.UpdateFrameMaxMin=function()
    {
        this.Super_UpdateFrameMaxMin();

        if (this.DayCount==1)   //集合竞价多坐标,Y轴强制都计算
        {
            var subFrame=this.Frame.SubFrame[1];
            if (subFrame.Frame) subFrame.Frame.XYSplit=true;
        }
    }

    this.ExportMainData=function(data, option)
    {
        var aryData=data.ExportMinuteData(option);   //导出K线
        return aryData;
    }

    this.DisplayLatest=function()
    {
        var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_DISPLAY_LATEST); //选中画图工具事件
        if (event)
        {
            var sendData={ PreventDefault:false  };
            event.Callback(event,sendData,this);
            if (sendData.PreventDefault) return;
        }
        
        this.CursorIndex=null;
        this.LastPoint.X=0;
        this.LastPoint.Y=0;
        this.GlobalOption.IsDisplayLatest=true;
        this.DrawDynamicInfo();
    }

    this.TryClickIndexTitle=function(x,y)
    {
        for(var i=0; i<this.TitlePaint.length; ++i)
        {
            var item=this.TitlePaint[i];
            if (!item.IsClickTitle) continue;
            if (!item.IsClickTitle(x,y)) continue;

            var data={ Point:{X:x, Y:y}, Title:item.Title, FrameID:item.Frame.Identify };
            JSConsole.Chart.Log('[MinuteChartContainer::TryClickIndexTitle] click title ', data);

            var event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_INDEXTITLE);
            if (event && event.Callback) event.Callback(event,data,this);
            
            return true;
        }

        return false;
    }

    this.ClearSelectedXBorder=function()
    {
        if (!this.GlobalOption || !this.GlobalOption.SelectedXBorder) return;
        var item=this.GlobalOption.SelectedXBorder;
        item.Date=null;
    }

    this.DrawSelectedXBorder=function()
    {
        if (this.DayCount<=1) return null;
        if (this.Frame.IsHScreen===true) return null;

        if (!this.GlobalOption || !this.GlobalOption.SelectedXBorder) return;
        var item=this.GlobalOption.SelectedXBorder;
        if (!IFrameSplitOperator.IsPlusNumber(item.Mode)) return;
        if (!IFrameSplitOperator.IsPlusNumber(item.Date)) return;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.DayData)) return;

        var rtSelected=null;
        var dayIndex=item.DayIndex;
        var border=this.Frame.ChartBorder.GetBorder();
        var rtClient={ Left:border.Left, Top:border.Top, Right:border.Right, Bottom: border.Bottom };
        rtClient.Width=rtClient.Right-rtClient.Left;
        var mainFrame=this.Frame.SubFrame[0].Frame; //主图框架
        var xPointCount=mainFrame.XPointCount;
        var minuteCount=mainFrame.MinuteCount;
        var lDayCount=xPointCount/minuteCount;
        var dayWidth=rtClient.Width/lDayCount;

        if (border.DayBorder)
        {
            var dayIndex=-1;
            for(var i=0;i<this.DayData.length;++i)
            {
                var dayItem=this.DayData[i];
                if (dayItem.Date==item.Date)
                {
                    dayIndex=this.DayData.length-1-i;
                    break;
                }
            }

            if (dayIndex<0) return;

            var item=border.DayBorder[dayIndex];
            if (!item) return;

            rtSelected={ Left:item.LeftEx, Right:item.RightEx, Top:border.Bottom, Bottom:border.ChartHeight };
            rtSelected.Width=rtSelected.Right-rtSelected.Left;
            rtSelected.Height=rtSelected.Bottom-rtSelected.Top;
        }
        else
        {
            var dayIndex=-1;
            for(var i=0;i<this.DayData.length;++i)
            {
                var dayItem=this.DayData[i];
                if (dayItem.Date==item.Date)
                {
                    dayIndex=this.DayData.length-1-i;
                    break;
                }
            }

            if (dayIndex<0) return;

            rtSelected={ Left:border.Left+dayIndex*dayWidth, Width:dayWidth, Top:border.Bottom, Bottom:border.ChartHeight };
            rtSelected.Right=rtSelected.Left+rtSelected.Width;
            rtSelected.Height=rtSelected.Bottom-rtSelected.Top;
        }


        mainFrame.Canvas.strokeStyle=g_JSChartResource.SelFrameBorderColor;
        mainFrame.Canvas.strokeRect(ToFixedPoint(rtSelected.Left),ToFixedPoint(rtSelected.Top),ToFixedRect(rtSelected.Width),ToFixedRect(rtSelected.Height)-1);
    }

    this.PtInMulitDayMinute=function(x,y)
    {
        if (this.DayCount<=1) return null;
        if (this.Frame.IsHScreen===true) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(this.DayData)) return null;

        var border=this.Frame.ChartBorder.GetBorder();
        var rtClient={ Left:border.Left, Top:border.Top, Right:border.Right, Bottom: border.Bottom };
        rtClient.Width=rtClient.Right-rtClient.Left;
        if (!(x>rtClient.Left && x<rtClient.Right && y>rtClient.Top && y<rtClient.Bottom)) return null; //不在窗口里面

        if (border.DayBorder)
        {
            for(var i=0;i<border.DayBorder.length;++i)
            {
                var item=border.DayBorder[i];
                var rtDay={ Left:item.LeftEx, Right:item.RightEx };
                if (x>=rtDay.Left && x<=rtDay.Right)
                {
                    var dayItem=this.DayData[this.DayData.length-1-i];
                    if (!dayItem) return null;

                    return dayItem.Date;
                }
            }
        }
        else
        {
            var mainFrame=this.Frame.SubFrame[0].Frame; //主图框架
            var xPointCount=mainFrame.XPointCount;
            var minuteCount=mainFrame.MinuteCount;
            var lDayCount=xPointCount/minuteCount;
            var dayWidth=rtClient.Width/lDayCount;
            var rtDay={ Left:rtClient.Left, Right:dayWidth+rtClient.Left };
            for(var i=0;i<lDayCount;++i)
            {
                if (x>=rtDay.Left && x<=rtDay.Right)
                {
                    var dayItem=this.DayData[this.DayData.length-1-i];
                    if (!dayItem) return null;

                    return dayItem.Date;
                }

                rtDay.Left+=dayWidth;
                rtDay.Right+=dayWidth;
            }
        }

        return null;
    }
}

//盘前数据
MinuteChartContainer.JsonDataToBeforeOpenData=function(data)
{
    var symbol=data.stock[0].symbol;
    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);

    var yClose=data.stock[0].yclose;
    var preClose=data.stock[0].yclose;      //前一个数据价格
    var stockData=data.stock[0];
    var date=stockData.date;                //日期
    var beforeOpenData={ Data:[], TotalCount:15, Ver:1.0, Date:date };
    var extendDataIndex=JSCHART_DATA_FIELD_ID.MINUTE_BEFOREOPEN_EXTENDDATA;  //扩展数据序号
    if (stockData.beforeinfo)
    {
        if (IFrameSplitOperator.IsNumber(stockData.beforeinfo.totalcount)) beforeOpenData.TotalCount=stockData.beforeinfo.totalcount;
        if (IFrameSplitOperator.IsNumber(stockData.beforeinfo.ver)) beforeOpenData.Ver=stockData.beforeinfo.ver;
    }

    if (beforeOpenData.Ver==1.0)
    {
        if (IFrameSplitOperator.IsNonEmptyArray(stockData.before))
        {
            for(var i=0; i<stockData.before.length; ++i)
            {
                var item=new BeforeOpenData();
                var jsData=stockData.before[i];
                item.YClose=yClose;
                item.Time=jsData[0];
                item.Date=date;
                item.Price=jsData[1];
                if (!item.Price) item.Price=preClose;
                else preClose=item.Price;
                if (isSHSZ) item.Vol[0]=jsData[2]/100;  //沪深股票原始单位股
                else  item.Vol[0]=jsData[2];  
                item.Amount=jsData[3];
    
                if (IFrameSplitOperator.IsNumber(jsData[4]) && jsData[4]>19000101)    //日期
                    item.Date=jsData[4];
               
                item.DateTime=`${item.Date} ${item.Time}`;
                beforeOpenData.Data.push(item);
            }
        }
    }
    else if (beforeOpenData.Ver==2.0)
    {
        var max=0;
        for(var i in stockData.before)
        {
            var item=new BeforeOpenData();
            var jsData=stockData.before[i];
            item.YClose=yClose;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.Vol[0]=jsData[2];  //匹配量
            item.Vol[1]=jsData[3];  //未匹配量
            item.ColorID=jsData[4]; //柱子颜色ID
            if (IFrameSplitOperator.IsNumber(jsData[6])) item.Date=jsData[6]    //日期
            item.DateTime=`${item.Date} ${item.Time})`;

            var totalVol=item.Vol[0]+item.Vol[1];
            if (IFrameSplitOperator.IsNumber(jsData[5])) totalVol=jsData[5];
            if (totalVol>max) max=totalVol;
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];

            beforeOpenData.Data.push(item);
        }

        beforeOpenData.VolMax=max;
        beforeOpenData.VolMin=0;
    }
    else if (beforeOpenData.Ver==3.0)
    {
        var max=0;
        
        for(var i in stockData.before)
        {
            var item=new BeforeOpenData();
            var jsData=stockData.before[i];
            item.YClose=yClose;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.AvPrice=jsData[2]; //均价
            item.Vol[0]=jsData[3];  //匹配量
            item.ColorID=jsData[4]; //柱子颜色ID
            item.DateTime=date.toString()+" "+item.Time.toString();

            var totalVol=item.Vol[0];
            if (IFrameSplitOperator.IsNumber(jsData[5])) totalVol=jsData[5];
            if (totalVol>max) max=totalVol;
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
    
            beforeOpenData.Data.push(item);
        }

        beforeOpenData.VolMax=max;
        beforeOpenData.VolMin=0;
    }
    
    return beforeOpenData;
}

//收盘集合竞价
MinuteChartContainer.JsonDataToAfterCloseData=function(data)
{
    var yClose=data.stock[0].yclose;
    var preClose=data.stock[0].yclose;      //前一个数据价格
    var stockData=data.stock[0];
    var date=stockData.date;                //日期
    if (!stockData.afterinfo) return null;

    var afterCloseData={ Data:[], TotalCount:3*60, Ver:2.0, Date:date };
    var item=stockData.afterinfo;
    if (IFrameSplitOperator.IsNumber(item.totalcount)) afterCloseData.TotalCount=item.totalcount;
    if (IFrameSplitOperator.IsNumber(item.ver)) afterCloseData.Ver=item.ver;
    var extendDataIndex=JSCHART_DATA_FIELD_ID.MINUTE_AFTERCLOSE_EXTENDDATA;  //扩展数据序号
    
    if (afterCloseData.Ver==1.0)
    {
        for(var i=0; i<stockData.after.length; ++i)
        {
            var item=new AfterCloseData();
            var jsData=stockData.after[i];
            item.YClose=yClose;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.Vol[0]=jsData[2];  
            item.Amount=jsData[3];

            if (IFrameSplitOperator.IsNumber(jsData[4]))    //日期
                item.Date=jsData[4];
           
            item.DateTime=`${item.Date} ${item.Time}`;
            afterCloseData.Data.push(item);
        }
    }
    else if (afterCloseData.Ver==2.0)
    {
        var max=0;
        for(var i in stockData.after)
        {
            var item=new AfterCloseData();
            var jsData=stockData.after[i];
            item.YClose=yClose;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.Vol[0]=jsData[2];  //匹配量
            item.Vol[1]=jsData[3];  //未匹配量
            item.ColorID=jsData[4]; //柱子颜色ID
            item.DateTime=date.toString()+" "+item.Time.toString();

            var totalVol=item.Vol[0]+item.Vol[1];
            if (IFrameSplitOperator.IsNumber(jsData[5])) totalVol=jsData[5];
            if (totalVol>max) max=totalVol;
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
    
            afterCloseData.Data.push(item);
        }

        afterCloseData.VolMax=max;
        afterCloseData.VolMin=0;
    }
    else if (afterCloseData.Ver==3.0)
    {
        var max=0;
        for(var i in stockData.after)
        {
            var item=new AfterCloseData();
            var jsData=stockData.after[i];
            item.YClose=yClose;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.AvPrice=jsData[2]; //均价
            item.Vol[0]=jsData[3];  //匹配量
            item.ColorID=jsData[4]; //柱子颜色ID
            item.DateTime=date.toString()+" "+item.Time.toString();

            var totalVol=item.Vol[0];
            if (IFrameSplitOperator.IsNumber(jsData[5])) totalVol=jsData[5];
            if (totalVol>max) max=totalVol;
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];

            afterCloseData.Data.push(item);
        }

        afterCloseData.VolMax=max;
        afterCloseData.VolMin=0;
    }
    
    return afterCloseData;
}

//API 返回数据 转化为array[]
MinuteChartContainer.JsonDataToMinuteData=function(data,isBeforeData)
{
    var symbol=data.stock[0].symbol;
    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //国内期货, 纽约期货交易所
    var isSHO=MARKET_SUFFIX_NAME.IsSHO(upperSymbol);            //上海股票期权
    var isSZO=MARKET_SUFFIX_NAME.IsSZO(upperSymbol);            //深证股票期权
    var aryMinuteData=[];
    var preClose=data.stock[0].yclose;      //前一个数据价格
    var preAvPrice=data.stock[0].yclose;    //前一个均价
    var yClose=data.stock[0].yclose;
    var yClearing=data.stock[0].yclearing;

    if (isFutures && yClearing) preClose=preAvPrice=yClearing;  //期货使用昨结算价

    if (!IFrameSplitOperator.IsNonEmptyArray(data.stock[0].minute)) return aryMinuteData;

    var date=data.stock[0].date;    //默认使用外部日期, 但跨天的 走势图使用内部的日期
    for(var i=0; i<data.stock[0].minute.length; ++i)
    {
        var jsData=data.stock[0].minute[i];
        var item=new MinuteData();
        item.YClearing=yClearing;
        item.YClose=yClose;
        item.Close=jsData.price;
        item.Open=jsData.open;
        item.High=jsData.high;
        item.Low=jsData.low;
        if (isSHSZ) item.Vol=jsData.vol/100; //沪深股票原始单位股
        else item.Vol=jsData.vol;
        item.Amount=jsData.amount;
        if (jsData.date>0) date=jsData.date;    //分钟数据中有日期 优先使用
        item.DateTime=date.toString()+" "+jsData.time.toString();
        item.Date=date;
        item.Time=jsData.time;
        if (isFutures || isSHO || isSZO) item.Position=jsData.position;  //期货 期权有持仓
        else if (IFrameSplitOperator.IsNumber(jsData.position)) item.Position=jsData.position;
 
        item.Increase=jsData.increase;
        item.Risefall=jsData.risefall;
        item.AvPrice=jsData.avprice;
        
        if (IFrameSplitOperator.IsNumber(jsData.lead)) 
            item.Lead=jsData.lead;  //领先指标 指数才有

        if (!IFrameSplitOperator.IsNumber(item.Close)) //当前没有价格 使用上一个价格填充
        {
            item.Close=preClose;
            item.Open=item.High=item.Low=item.Close;
        }

        if (!item.AvPrice) item.AvPrice=preAvPrice;

        if (yClose && item.Close) 
            item.Increase=(item.Close-yClose)/yClose*100; //涨幅 (最新价格-昨收)/昨收*100;

        if (isFutures && yClearing && item.Close) 
            item.Increase=(item.Close-yClearing)/yClearing*100; //涨幅 (最新价格-昨结算价)/昨结算价*100;

        //上次价格
        if (IFrameSplitOperator.IsNumber(jsData.price)) preClose=jsData.price;
        if (IFrameSplitOperator.IsNumber(jsData.avprice) && item.AvPrice===jsData.avprice) preAvPrice=jsData.avprice;

        if (jsData.ExtendData) item.ExtendData=jsData.ExtendData;   //扩展数据

        aryMinuteData[i]=item;
    }

    return aryMinuteData;
}

//分钟增量数据  stock: [ { date:, yclose:， yclearing: , minute:[ [],]}  0=日期 1=时间 2=开 3=高 4=低 5=收 6=均价 7=量 8=金额 9=涨幅 10=涨跌 11=领先指标 ]
MinuteChartContainer.JsonDataToUpdateMinuteData=function(data)
{
    if (!data || !data.stock) return null;
    var stock=data.stock[0];
    if (!IFrameSplitOperator.IsNumber(stock.date)) return null;
    var symbol=data.stock[0].symbol;
    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //国内期货, 纽约期货交易所
    var minuteData={ Date:stock.date,  Data:[] , Symbol:symbol, Name:stock.name };
    var extendDataIndex=JSCHART_DATA_FIELD_ID.MINUTE_DAY_EXTENDDATA;  //扩展数据序号
    if (IFrameSplitOperator.IsNumber(stock.high)) minuteData.High=stock.high;
    if (IFrameSplitOperator.IsNumber(stock.low)) minuteData.Low=stock.low;
    if (IFrameSplitOperator.IsNumber(stock.yclose)) minuteData.YClose=stock.yclose;
    if (IFrameSplitOperator.IsNumber(stock.YClearing)) minuteData.YClearing=stock.yclearing;

    if (IFrameSplitOperator.IsNonEmptyArray(stock.minute))
    {
        for(var i=0;i<stock.minute.length;++i)
        {
            var jsData=stock.minute[i];
            var item=new MinuteData();
    
            item.YClearing=minuteData.YClearing;
            item.YClose=minuteData.YClose;
            item.Date=jsData[0];
            item.Time=jsData[1];
            item.Open=jsData[2];
            item.High=jsData[3];
            item.Low=jsData[4];
            item.Close=jsData[5];
            item.AvPrice=jsData[6];
            item.Vol=jsData[7];
            item.Amount=jsData[8];
            if (IFrameSplitOperator.IsNumber(jsData[9])) item.Increase=jsData[9];
            if (IFrameSplitOperator.IsNumber(jsData[10])) item.Risefall=jsData[10];
            if (IFrameSplitOperator.IsNumber(jsData[11])) item.Lead=jsData[11];


            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
            item.DateTime=item.Date.toString()+" "+item.Time.toString();
            if (isSHSZ) item.Vol=item.Vol/100; //沪深股票原始单位股

            if (IFrameSplitOperator.IsNumber(minuteData.YClose) && item.Close) 
                item.Increase=(item.Close-minuteData.YClose)/minuteData.YClose*100; //涨幅 (最新价格-昨收)/昨收*100;
    
            if (isFutures && minuteData.YClearing && item.Close) 
            item.Increase=(item.Close-minuteData.YClearing)/minuteData.YClearing*100; //涨幅 (最新价格-昨结算价)/昨结算价*100;

                
            minuteData.Data.push(item);
        }
    }

    return minuteData;
}

MinuteChartContainer.JsonDataToMinuteLineColorData=function(data)
{
    if (!data || !data.stock[0]) return null;
    var stockItem=data.stock[0];
    if (!stockItem.linecolor || !IFrameSplitOperator.IsNonEmptyArray(stockItem.linecolor.data)) return null;

    var aryLineColor=[];
    for(var i in stockItem.linecolor.data)
    {
        var item=stockItem.linecolor.data[i];
        if (!IFrameSplitOperator.IsNumber(item.type) || !IFrameSplitOperator.IsNumber(item.date) || !IFrameSplitOperator.IsNumber(item.start) ||
            !IFrameSplitOperator.IsNumber(item.end) || !item.color) continue;
        
        if (item.start>=item.end) continue;

        var newItem={ Type:item.type, Date:item.date, Start:item.start, End:item.end, Color:item.color };
        if (IFrameSplitOperator.IsPlusNumber(item.linewidth)) newItem.LineWidth=item.linewidth;

        aryLineColor.push(newItem);
    }

    return aryLineColor;
}

//获取最后的数据更新时间
MinuteChartContainer.JsonDataToMinuteLastUpdateTime=function(data)
{
    if (!data || !data.stock[0]) return null;
    var stock=data.stock[0];
    if (!IFrameSplitOperator.IsNumber(stock.date) || !IFrameSplitOperator.IsNumber(stock.time)) return null;
    return { Date:stock.date, Time:stock.time };
}

MinuteChartContainer.JsonDataToHistoryMinuteLastUpdateTime=function(data)
{
    if (!data || !data.updatetime) return null;
    var item=data.updatetime;

    if (!IFrameSplitOperator.IsNumber(item.date) || !IFrameSplitOperator.IsNumber(item.time)) return null;

    return { Date:item.date, Time:item.time };
}

//多日日线数据API 转化成array[];
MinuteChartContainer.JsonDataToMinuteDataArray=function(data)
{
    var symbol=data.symbol;
    var upperSymbol=symbol.toUpperCase();
    var isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    var isSHO=MARKET_SUFFIX_NAME.IsSHO(upperSymbol);            //上海股票期权
    var isSZO=MARKET_SUFFIX_NAME.IsSZO(upperSymbol);            //深证股票期权
    var isFutures=MARKET_SUFFIX_NAME.IsFutures(upperSymbol);    //国内期货, 纽约期货交易所
    var result=[];
    var extendDataIndex=JSCHART_DATA_FIELD_ID.MINUTE_MULTI_DAY_EXTENDDATA;  //扩展数据序号
    for(var i in data.data)
    {
        var minuteData=[];
        var dayData=data.data[i];
        var date=dayData.date;
        var yClearing=dayData.yclearing;    //昨结算价
        var yClose=dayData.yclose;          //前收盘 计算涨幅
        var preClose=yClose;                //前一个数据价格
        var preAvPrice=null;                //上一个均价

        if (isFutures && yClearing) preClose=preAvPrice=yClearing;  //期货使用昨结算价

        for(var j in dayData.minute)
        {
            var jsData=dayData.minute[j];
            if (jsData[2]) preClose=jsData[2];  //保存上一个收盘数据
            var item=new MinuteData();
            item.YClearing=yClearing;
            item.YClose=yClose;
            item.Close=jsData[2];
            item.Open=jsData[1];
            item.High=jsData[3];
            item.Low=jsData[4];
            item.Increase=null;
            if (isSHSZ) item.Vol=jsData[5]/100; //原始单位股
            else item.Vol=jsData[5];
            item.Amount=jsData[6];
            if (7<jsData.length && jsData[7]>0) item.AvPrice=jsData[7];    //均价
            item.DateTime=date.toString()+" "+jsData[0].toString();
            item.Date=date;
            item.Time=jsData[0];
            if (8<jsData.length && jsData[8]>0) 
            {
                item.Date=jsData[8];    //日期
                item.DateTime=item.Date.toString()+" "+jsData[0].toString();
            }
            if ((isFutures || isSHO || isSZO) && 9<jsData.length) item.Position=jsData[9];  //持仓
            
            if (!IFrameSplitOperator.IsNumber(item.Close))    //当前没有价格 使用上一个价格填充
            {
                item.Close=preClose;   
                item.Open=item.High=item.Low=item.Close;
            }

            if (!item.AvPrice && preAvPrice) item.AvPrice=preAvPrice;

            if (item.Close && yClose) 
                item.Increase = (item.Close - yClose)/yClose*100;

            if (item.Close && yClearing && isFutures)
                item.Increase = (item.Close - yClearing)/yClearing*100;
           

            if (jsData.length>7 && jsData[7]>0 && item.AvPrice===jsData[7]) preAvPrice=jsData[7];
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];

            minuteData[j]=item;
        }

        var newData=new ChartData();
        newData.Data=minuteData;
        newData.YClose=yClose;
        if (IFrameSplitOperator.IsNumber(yClearing)) newData.YClearing=yClearing;
        newData.Close=dayData.close;
        newData.Date=date;

        result.push(newData);
    }

    return result;
}

MinuteChartContainer.JsonDataToHistoryMinuteLineColorData=function(data)
{
    if (!data) return null;

    var aryLineColor=[];
    for(var i in data.data)
    {
        var dayData=data.data[i];
        if (!dayData.linecolor) continue;

        for(var j in dayData.linecolor.data)
        {
            var item=dayData.linecolor.data[j];

            if (!IFrameSplitOperator.IsNumber(item.type) || !IFrameSplitOperator.IsNumber(item.date) || !IFrameSplitOperator.IsNumber(item.start) ||
            !IFrameSplitOperator.IsNumber(item.end) || !item.color) continue;
        
            if (item.start>=item.end) continue;

            var newItem={ Type:item.type, Date:item.date, Start:item.start, End:item.end, Color:item.color };
            if (IFrameSplitOperator.IsPlusNumber(item.linewidth)) newItem.LineWidth=item.linewidth;

            aryLineColor.push(newItem);
        }
    }

    return aryLineColor.length>0? aryLineColor : null;
}


MinuteChartContainer.JsonDataToCallAuctionItem=function(data, callAuctionData, isBeforeOpen, symbol)
{
    var isSHSZ=false;
    if (symbol)
    {
        var upperSymbol=symbol.toUpperCase();
        isSHSZ=MARKET_SUFFIX_NAME.IsSHSZ(upperSymbol);
    }
    
    var date=callAuctionData.Date;
    var yClose=callAuctionData.YClose;
    var yClearing=callAuctionData.YClearing;
    var extendDataIndex=isBeforeOpen? JSCHART_DATA_FIELD_ID.MINUTE_BEFOREOPEN_EXTENDDATA:JSCHART_DATA_FIELD_ID.MINUTE_AFTERCLOSE_EXTENDDATA;  //扩展数据序号
    if (callAuctionData.Ver==1.0)
    {
        var preClose=null;
        for(var i in data)
        {
            var item=isBeforeOpen? new BeforeOpenData() : new AfterCloseData();
            var jsData=data[i];
            item.YClose=yClose;
            item.YClearing=yClearing;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            if (!item.Price) item.Price=preClose;
            else preClose=item.Price;
            item.Vol[0]=isSHSZ ? jsData[2]/100 : jsData[2];  //沪深股票原始单位股
            item.Amount=jsData[3];
            if (IFrameSplitOperator.IsNumber(jsData[4]))    //日期
                item.Date=jsData[4];
                
            item.DateTime=`${item.Date} ${item.Time}`;
    
            callAuctionData.Data.push(item);
        }
    }
    else if (callAuctionData.Ver==2.0)
    {
        var max=0;
        for(var i in data)
        {
            var item=isBeforeOpen? new BeforeOpenData() : new AfterCloseData();
            var jsData=data[i];
            item.YClose=yClose;
            item.YClearing=yClearing;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.Vol[0]=jsData[2];  //匹配量
            item.Vol[1]=jsData[3];  //未匹配量
            item.ColorID=jsData[4]; //柱子颜色ID
            item.DateTime=date.toString()+" "+item.Time.toString();

            var totalVol=item.Vol[0]+item.Vol[1];
            if (IFrameSplitOperator.IsNumber(jsData[5])) totalVol=jsData[5];
            if (totalVol>max) max=totalVol;
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
    
            callAuctionData.Data.push(item);
        }

        callAuctionData.VolMax=max;
        callAuctionData.VolMin=0;
    }
    else if (beforeOpenData.Ver==3.0)
    {
        var max=0;
        for(var i in data)
        {
            var item=isBeforeOpen? new BeforeOpenData() : new AfterCloseData();
            var jsData=data[i];
            item.YClose=yClose;
            item.YClearing=yClearing;
            item.Time=jsData[0];
            item.Date=date;
            item.Price=jsData[1];
            item.AvPrice=jsData[2]; //均价
            item.Vol[0]=jsData[3];  //匹配量
            item.ColorID=jsData[4]; //柱子颜色ID
            item.DateTime=date.toString()+" "+item.Time.toString();

            var totalVol=item.Vol[0];
            if (IFrameSplitOperator.IsNumber(jsData[5])) totalVol=jsData[5];
            if (totalVol>max) max=totalVol;
            if (jsData[extendDataIndex]) item.ExtendData=jsData[extendDataIndex];
    
            callAuctionData.Data.push(item);
        }

        callAuctionData.VolMax=max;
        callAuctionData.VolMin=0;
    }
}

MinuteChartContainer.JosnDataToBeforeOpenDataArray=function(data)
{
    if (!data || !data.data) return null;

    var aryDay=[];
    for(var i in data.data)
    {
        var dayItem=data.data[i];
        var beforeOpenData={ Data:[], TotalCount:15, Ver:1.0, Date:dayItem.date, YClose:dayItem.yclose, YClearing:dayItem.YClearing };
        if (dayItem.beforeinfo)
        {
            if (IFrameSplitOperator.IsNumber(dayItem.beforeinfo.totalcount)) beforeOpenData.TotalCount=dayItem.beforeinfo.totalcount;
            if (IFrameSplitOperator.IsNumber(dayItem.beforeinfo.ver)) beforeOpenData.Ver=dayItem.beforeinfo.ver;
        }

        MinuteChartContainer.JsonDataToCallAuctionItem(dayItem.before, beforeOpenData, true, data.symbol);

        aryDay.push(beforeOpenData);
    }

    aryDay.sort((left, right)=>{return left.Date - right.Date}); 

    return aryDay;
}

MinuteChartContainer.JosnDataToAfterCloseDataArray=function(data)
{
    if (!data || !data.data) return null;

    var aryDay=[];
    for(var i in data.data)
    {
        var dayItem=data.data[i];
        var afterCloseData={ Data:[], TotalCount:15, Ver:1.0, Date:dayItem.date, YClose:dayItem.yclose, YClearing:dayItem.YClearing };

        if (dayItem.afterinfo)
        {
            if (IFrameSplitOperator.IsNumber(dayItem.afterinfo.totalcount)) afterCloseData.TotalCount=dayItem.afterinfo.totalcount;
            if (IFrameSplitOperator.IsNumber(dayItem.afterinfo.ver)) afterCloseData.Ver=dayItem.afterinfo.ver;
        }

        MinuteChartContainer.JsonDataToCallAuctionItem(dayItem.after, afterCloseData, false, data.symbol);

        aryDay.push(afterCloseData);
    }

    aryDay.sort((left, right)=>{return left.Date - right.Date}); 

    return aryDay;
}

/*
    历史分钟走势图
*/
/*  废弃 统一使用 MinuteChartContainer
function HistoryMinuteChartContainer(uielement)
{
    this.newMethod=MinuteChartContainer;   //派生
    this.newMethod(uielement);
    delete this.newMethod;

    this.HistoryMinuteApiUrl="http://127.0.0.1:8080/cache/minuteday/day/";
    this.ClassName='HistoryMinuteChartContainer';

    //创建主图K线画法
    this.CreateMainKLine=function()
    {
        //分钟线
        var minuteLine=new ChartMinutePriceLine();
        minuteLine.Canvas=this.Canvas;
        minuteLine.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        minuteLine.ChartFrame=this.Frame.SubFrame[0].Frame;
        minuteLine.Name="Minute-Line";
        minuteLine.Color=g_JSChartResource.Minute.PriceColor;

        this.ChartPaint[0]=minuteLine;

        //分钟线均线
        var averageLine=new ChartLine();
        averageLine.Canvas=this.Canvas;
        averageLine.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        averageLine.ChartFrame=this.Frame.SubFrame[0].Frame;
        averageLine.Name="Minute-Average-Line";
        averageLine.Color=g_JSChartResource.Minute.AvPriceColor;
        this.ChartPaint[1]=averageLine;

        var averageLine=new ChartMinuteVolumBar();
        averageLine.Color=g_JSChartResource.Minute.VolBarColor;
        averageLine.Canvas=this.Canvas;
        averageLine.ChartBorder=this.Frame.SubFrame[1].Frame.ChartBorder;
        averageLine.ChartFrame=this.Frame.SubFrame[1].Frame;
        averageLine.Name="Minute-Vol-Bar";
        this.ChartPaint[2]=averageLine;


        this.TitlePaint[0]=new DynamicMinuteTitlePainting();
        this.TitlePaint[0].Frame=this.Frame.SubFrame[0].Frame;
        this.TitlePaint[0].Canvas=this.Canvas;
        this.TitlePaint[0].IsShowDate=true;
    }

    //设置交易日期
    this.ChangeTradeDate=function(trdateDate)
    {
        if (!trdateDate) return;

        this.TradeDate=trdateDate;
        this.RequestData(); //更新数据
    }

    this.RequestData=function()
    {
        var date=new Date();
        var nowDate=date.getFullYear()*10000+(date.getMonth()+1)*100+date.getDate();
        if (nowDate==this.TradeDate) this.RequestMinuteData();
        else this.RequestHistoryMinuteData();
    }

    //请求分钟数据
    this.RequestHistoryMinuteData=function()
    {
        var self=this;
        var url=this.HistoryMinuteApiUrl+this.TradeDate.toString()+"/"+this.Symbol+".json";

        JSNetwork.HttpRequest({
            url: url,
            type:"get",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryMinuteData(data);
            },
            error:function(reqeust)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryMinuteError(reqeust);
            }
        });
    }

    this.RecvHistoryMinuteError=function(reqeust)
    {
        if (reqeust.status!=404) return;

        var sourceData=new ChartData();
        this.SourceData=sourceData;

        for(var i in this.ChartPaint)
        {
            this.ChartPaint[i].Data=sourceData;
            if (i==0) this.ChartPaint[i].NotSupportMessage='没有权限访问!';
        }

        this.TitlePaint[0].Data=this.SourceData;                    //动态标题
        this.TitlePaint[0].Symbol=this.Symbol;
        this.TitlePaint[0].Name=null;

        this.Draw();
    }

    this.RecvHistoryMinuteData=function(data)
    {
        var aryMinuteData=HistoryMinuteChartContainer.JsonDataToMinuteData(data);

        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=aryMinuteData;

        this.TradeDate=data.date;

        this.SourceData=sourceData;
        this.Symbol=data.symbol;
        this.Name=data.name;

        this.BindMainData(sourceData,data.day.yclose);

        if (this.Frame.SubFrame.length>2)
        {
            var bindData=new ChartData();
            bindData.Data=aryMinuteData;
            for(var i=2; i<this.Frame.SubFrame.length; ++i)
            {
                this.BindIndexData(i,bindData);
            }
        }

        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();

        //this.AutoUpdata();
    }

}

//API 返回数据 转化为array[]
HistoryMinuteChartContainer.JsonDataToMinuteData=function(data)
{
    var aryMinuteData=[];
    for(var i in data.minute.time)
    {
        var item=new MinuteData();

        if (data.minute.price[i]<=0 && i>0) //当前这一分钟价格为空,使用上一分钟的数据
        {
            item.Close=aryMinuteData[i-1].Close;
            item.Open=aryMinuteData[i-1].Close;
            item.High=item.Close;
            item.Low=item.Close;
            item.Vol=data.minute.vol[i]; //原始单位股
            item.Amount=data.minute.amount[i];
            item.DateTime=data.date.toString()+" "+data.minute.time[i].toString();
            //item.Increate=jsData.increate;
            //item.Risefall=jsData.risefall;
            item.AvPrice=aryMinuteData[i-1].AvPrice;
        }
        else
        {
            item.Close=data.minute.price[i];
            item.Open=data.minute.open[i];
            item.High=data.minute.high[i];
            item.Low=data.minute.low[i];
            item.Vol=data.minute.vol[i]; //原始单位股
            item.Amount=data.minute.amount[i];
            item.DateTime=data.date.toString()+" "+data.minute.time[i].toString();
            //item.Increate=jsData.increate;
            //item.Risefall=jsData.risefall;
            item.AvPrice=data.minute.avprice[i];
        }

        //价格是0的 都用空
        if (item.Open<=0) item.Open=null;
        if (item.Close<=0) item.Close=null;
        if (item.AvPrice<=0) item.AvPrice=null;
        if (item.High<=0) item.High=null;
        if (item.Low<=0) item.Low=null;

        aryMinuteData[i]=item;
    }

    return aryMinuteData;
}
*/

/////////////////////////////////////////////////////////////////////////////
//  自定义指数
//
function CustomKLineChartContainer(uielement)
{
    this.newMethod=KLineChartContainer;   //派生
    this.newMethod(uielement);
    delete this.newMethod;

    this.ClassName='CustomKLineChartContainer';
    this.CustomKLineApiUrl=g_JSChartResource.Domain+"/API/IndexCalculate";                        //自定义指数计算地址
    this.CustomStock;   //成分
    this.QueryDate={Start:20180101,End:20180627} ;     //计算时间区间

    this.RequestHistoryData=function()
    {
        var self=this;
        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
        this.ChartSplashPaint.EnableSplash(true);
        this.Draw();
        JSNetwork.HttpRequest({
            url: this.CustomKLineApiUrl,
            data:
            {
                "stock": self.CustomStock,
                "Name": self.Symbol,
                "date": { "startdate":self.QueryDate.Start,"enddate":self.QueryDate.End }
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (data)
            {
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvHistoryData(data);
            }
        });
    }

    this.RecvHistoryData=function(data)
    {
        var aryDayData=KLineChartContainer.JsonDataToHistoryData(data);

        //原始数据
        var sourceData=new ChartData();
        sourceData.Data=aryDayData;
        sourceData.DataType=0;      //0=日线数据 1=分钟数据

        //显示的数据
        var bindData=new ChartData();
        bindData.Data=aryDayData;
        bindData.Right=this.Right;
        bindData.Period=this.Period;
        bindData.DataType=0;

        if (bindData.Right>0)    //复权
        {
            var rightData=bindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
            bindData.Data=rightData;
        }

        if (ChartData.IsDayPeriod(this.Period,false))   //周期数据
        {
            var periodData=sourceData.GetPeriodData(bindData.Period);
            bindData.Data=periodData;
        }

        //绑定数据
        this.SourceData=sourceData;
        this.Name=data.name;
        this.BindMainData(bindData,this.PageSize);

        for(var i=0; i<this.Frame.SubFrame.length; ++i)
        {
            this.BindIndexData(i,bindData);
        }

        //刷新画图
        this.UpdataDataoffset();           //更新数据偏移
        this.UpdatePointByCursorIndex();   //更新十字光标位子
        this.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.Frame.SetSizeChage(true);
        this.Draw();
        
    }

}

////////////////////////////////////////////////////////////////////////////////
//  K线训练 新版本
//
function KLineTrainChartContainer(uielement, bHScreen)
{
    if (bHScreen===true)
    {
        this.newMethod=KLineChartHScreenContainer;   //派生
        this.newMethod(uielement);
        delete this.newMethod;
    }
    else
    {
        this.newMethod=KLineChartContainer;   //派生
        this.newMethod(uielement);
        delete this.newMethod;
    }

    this.BuySellPaint;          //买卖点画法
    this.TrainDataCount=300;    //训练数据个数
    this.TrainStartDate;        //训练开始日期时间 { Date:, Time: }
    this.AutoRunTimer=null;     //K线自动前进定时器
    this.BuySellData=[];        //模拟买卖数据 {Buy:{Price:价格,Date:日期, Time:时间} , Sell:{Price:价格,Date:日期, Time:时间} 
    this.TrainCallback;         //训练回调 (K线每前进一次就调用一次)
    this.DragMode=1;
    this.IsAutoUpdate=false;

    this.KLineSourceData;       //原始K线数据 对应 SourceData
    this.TrainInfo={ Start:{ }, End:{ } }; // Index:数据索引, Date:日期  Time:时间
    this.Super_RecvFlowCapitalData=this.RecvFlowCapitalData;

    this.CreateBuySellPaint=function()  //在主窗口建立以后 创建买卖点
    {
        var chart=new ChartBuySell();
        chart.Canvas=this.Canvas;
        chart.ChartBorder=this.Frame.SubFrame[0].Frame.ChartBorder;
        chart.ChartFrame=this.Frame.SubFrame[0].Frame;
        chart.Name="KLine-Train-BuySell";
        this.ChartPaintEx[0]=chart;
    }

    this.GetKDataIndexByDateTime=function(kData, dateTime)
    {
        if (!dateTime || !kData) return -1;

        for(var i=0;i<kData.length; ++i)
        {
            var item=kData[i];
            if (ChartData.IsMinutePeriod(this.Period, true))
            {
                if (IFrameSplitOperator.IsNumber(this.TrainStartDate.Time))
                {
                    if (item.Date>=this.TrainStartDate.Date && item.Time>=this.TrainStartDate.Time)
                        return i;
                }
                else
                {
                    if (item.Date>=this.TrainStartDate.Date)
                        return i;
                }
            }
            else if (ChartData.IsDayPeriod(this.Period, true) || ChartData.IsTickPeriod(this.Period))
            {
                if (item.Date>=this.TrainStartDate.Date)
                    return i;
            }
        }

        return -1;
    }

    this.AfterBindMainData=function(funcName)
    {
        if (!this.ChartPaintEx[0]) this.CreateBuySellPaint();

        var hisData=this.ChartPaint[0].Data;
        this.ChartPaintEx[0].Data=hisData;

        var showItem=hisData.Data[hisData.Data.length-1];

        //最后一个显示数据
        this.TrainInfo.LastShowData=showItem;
        this.TrainInfo.LastData = this.SourceData.Data[this.SourceData.Data.length - 1];

        if (funcName!='Update')
            this.UpdateTrainUICallback("开始");
    }

    this.BeforeBindMainData=function(funcName)
    {
        if (funcName=="Update") return;

        //全量数据 需要过滤
        this.KLineSourceData=new ChartData();
        this.KLineSourceData.Data=this.SourceData.Data.slice(0);
        var count=this.SourceData.Data.length;
        var lEnd=count-this.TrainDataCount-20;
        var findIndex=this.GetKDataIndexByDateTime(this.SourceData.Data, this.TrainStartDate);
        if (findIndex>=0)
        {
            lEnd=findIndex+1;
            if (count-lEnd<this.TrainDataCount) this.TrainDataCount=count-lEnd;
        }
        
        //训练起始日期
        var index=lEnd-1;
        var kItem=this.SourceData.Data[index];
        this.TrainInfo.Start.Index=index;
        this.TrainInfo.Start.Date=kItem.Date;
        this.TrainInfo.Start.Time=kItem.Time;

        //训练结束日期
        this.TrainInfo.End.Index=index;
        this.TrainInfo.End.Date=kItem.Date;
        this.TrainInfo.End.Time=kItem.Time;
        
        //最后一个数据
        this.TrainInfo.LastData=kItem;

        //修改数据个数
        this.SourceData.Data.length=lEnd;
    }

    this.Run=function(option)
    {
        if (this.AutoRunTimer) return;
        if (this.TrainDataCount<=0) return;

        var self=this;
        this.AutoRunTimer=setInterval(function()
        {
            if (!self.MoveNextKLineData(option)) clearInterval(self.AutoRunTimer);
        }, 1000);
    }

    this.MoveNextKLineData=function(option) //{PageSize:, Step:}
    {
        if (this.TrainDataCount<=0) return false;

        var step=1;
        if (option && option.Step>1) step=option.Step;

        var moveStep=0;
        for(var i=0; i<step; ++i)
        {
            var index=this.TrainInfo.End.Index+1;
            if (index>=this.KLineSourceData.Data.length) break;
    
            var kItem=this.KLineSourceData.Data[index];
            this.SourceData.Data.push(kItem);
    
            this.TrainInfo.End.Index=index;
            this.TrainInfo.End.Date=kItem.Date;
            this.TrainInfo.End.Time=kItem.Time;
            --this.TrainDataCount;
            ++moveStep;

            if (this.TrainDataCount<=0) break;
        }

        if (moveStep==0) return false;

        //使用当前页数据个数移动K线
        var pageSize=this.Frame.GetCurrentPageSize();
        if (IFrameSplitOperator.IsNumber(pageSize))
            this.PageSize=pageSize-this.RightSpaceCount;

        if (option && option.PageSize>0) this.PageSize=option.PageSize;

        this.Update();

        if (this.TrainDataCount<=0) 
        {
            this.FinishTrainData();
            this.UpdateTrainUICallback("结束");
            return false;
        }

        this.UpdateTrainUICallback("训练中");
        return true;
    }

    this.UpdateTrainUICallback=function(description)
    {
        //新的监听事件
        if (!this.mapEvent.has(JSCHART_EVENT_ID.RECV_TRAIN_MOVE_STEP)) return;
        var item=this.mapEvent.get(JSCHART_EVENT_ID.RECV_TRAIN_MOVE_STEP);
        if (!item.Callback) return;

        var data=
        { 
            TrainDataCount:this.TrainDataCount,
            BuySellData:this.BuySellData, 
            KLine:
            { 
                Start: { Index: this.TrainInfo.Start.Index, Date:this.TrainInfo.Start.Date },
                End:{ Index: this.TrainInfo.End.Index, Date:this.TrainInfo.End.Date }
            },
            LastData:this.TrainInfo.LastData,
            LastShowData:this.TrainInfo.LastShowData
        };  
        if (IFrameSplitOperator.IsNumber(this.TrainInfo.Start.Time)) data.KLine.Start.Time=this.TrainInfo.Start.Time;
        if (IFrameSplitOperator.IsNumber(this.TrainInfo.End.Time)) data.KLine.End.Time=this.TrainInfo.End.Time;
        if (description) data.Description=description

        if (this.TrainDataCount<=0)
        {
            data.Symbol=this.Symbol;
            data.Name=this.Name;
        }

        item.Callback(item,data,this);
    }

    this.FinishTrainData=function()
    {
        JSConsole.Chart.Log('[KLineTrainChartContainer::FinishTrainData] trian end ');
    }

    this.Stop=function()
    {
        if (this.AutoRunTimer!=null) clearInterval(this.AutoRunTimer);
        this.AutoRunTimer=null;
    }

    this.BuyOrSell=function(obj, bDraw)  //{ Price:价格, Vol:数量, Op: 买/卖 0=buy 1=sell, ID:单号 } bDraw是否立即绘制图标
    {
        var kItem=this.TrainInfo.LastShowData;
        if (!kItem) return false;
        
        var buySellPaint=this.ChartPaintEx[0];
        if (!buySellPaint) return false;

        var hisData=this.ChartPaint[0].Data;
        if (!hisData || hisData.Data.length<=0) return false;

        var index=hisData.Data.length-1;  //数据索引
        var buyItem={ Date:this.TrainInfo.End.Date, Time:this.TrainInfo.End.Time, Price:obj.Price, Vol:obj.Vol, Op:0, ID:obj.ID };
        if (obj.Op==1) buyItem.Op=1;
        var key=index;
        buyItem.Key=key;

        this.BuySellData.push(buyItem);
        buySellPaint.AddTradeItem(buyItem);

        if (bDraw==true) this.Draw();
    }

    this.RestartTrain=function(option)  // { Symbol:, Period:周期, Right:复权, Train:{ DataCount:, DateTime: } }
    {
        JSConsole.Chart.Log('[KLineTrainChartContainer::RestartTrain] option ', option);

        this.TrainInfo={ Start:{ }, End:{ } };
        this.BuySellData=[];
        this.KLineSourceData=null;

        var buySellPaint=this.ChartPaintEx[0];
        if (buySellPaint)
        {
            buySellPaint.Data=null;
            buySellPaint.ClearTradeData();
        }

        if (option.Symbol) this.Symbol=option.Symbol;
        if (IFrameSplitOperator.IsNumber(option.Period)) this.Period=option.Period;
        if (IFrameSplitOperator.IsNumber(option.Right)) this.Right=option.Right;
        if (option.Train)
        {
            if (option.Train.DataCount>1) this.TrainDataCount=option.Train.DataCount;
            if (option.Train.DateTime) this.TrainStartDate=option.Train.DateTime;
        }

        var symbol=this.Symbol;
        this.ChangeSymbol(symbol);
    }

    this.RecvFlowCapitalData=function(data)
    {
        if (!data.stock || data.stock.length!=1) return;

        let stock=data.stock[0];
        var aryData=new Array();
        for(let i in stock.stockday)
        {
            var item=stock.stockday[i];
            let indexData=new SingleData();
            indexData.Date=item.date;
            var financeData=item.capital;
            if (!financeData) continue;
            if (financeData.a>0)
            {
                indexData.Value=financeData.a;    //流通股本（股）
                aryData.push(indexData);
            }
        }

        if (ChartData.IsMinutePeriod(this.Period,true)) //分钟数据
        {
            var aryFixedData=this.SourceData.GetMinuteFittingFinanceData(aryData);
            for(let i in this.SourceData.Data)
            {
                var item=this.SourceData.Data[i];
                if (!aryFixedData[i]) continue;
                item.FlowCapital=aryFixedData[i].Value;
            }

            var bindData=this.ChartPaint[0].Data;
            var newBindData=new ChartData();
            newBindData.Data=this.SourceData.Data;

            if (ChartData.IsMinutePeriod(bindData.Period,false)) //周期数据
            {
                var periodData=newBindData.GetPeriodData(bindData.Period);  
                newBindData.Data=periodData;
            }
            bindData.Data=newBindData.Data;

            var aryFixedData=this.KLineSourceData.GetMinuteFittingFinanceData(aryData); //数据添加到备份数据中
            for(let i in this.KLineSourceData.Data)
            {
                var item=this.KLineSourceData.Data[i];
                if (!aryFixedData[i]) continue;
                item.FlowCapital=aryFixedData[i].Value;
            }
        }
        else
        {
            var aryFixedData=this.SourceData.GetFittingFinanceData(aryData);
            for(let i in this.SourceData.Data)
            {
                var item=this.SourceData.Data[i];
                if (!aryFixedData[i]) continue;
                item.FlowCapital=aryFixedData[i].Value;
            }

            var bindData=this.ChartPaint[0].Data;
            var newBindData=new ChartData();
            newBindData.Data=this.SourceData.Data;

            if (bindData.Right>0)    //复权
            {
                var rightData=newBindData.GetRightData(bindData.Right, { AlgorithmType: this.RightFormula });
                newBindData.Data=rightData;
            }

            if (ChartData.IsDayPeriod(bindData.Period,false)) //周期数据
            {
                var periodData=newBindData.GetPeriodData(bindData.Period);  
                newBindData.Data=periodData;
            }

            bindData.Data=newBindData.Data;

            var aryFixedData=this.KLineSourceData.GetFittingFinanceData(aryData);   //数据添加到备份数据中
            for(let i in this.KLineSourceData.Data)
            {
                var item=this.KLineSourceData.Data[i];
                if (!aryFixedData[i]) continue;
                item.FlowCapital=aryFixedData[i].Value;
            }
        }

        this.FlowCapitalReady=true;
        var bDraw=false;
        for(var i in this.ExtendChartPaint)
        {
            var item=this.ExtendChartPaint[i];
            if (item.ClassName=='StockChip')
            {
                bDraw=true;
                break;
            }
        }

        if (bDraw) this.Draw();
    }

    this.AutoUpdate()
    {

    }
}


function KLineTrainSimpleChartContainer(uielement, bHScreen)
{
    this.newMethod=KLineTrainChartContainer;   //派生
    this.newMethod(uielement, bHScreen);
    delete this.newMethod;

    this.IsHScreen=bHScreen;
    this.IsZoomLockRight=true;
    this.RightSpaceCount=0;
    

    this.RecvFlowCapitalData=function(data)
    {
        this.Super_RecvFlowCapitalData(data);
    }

    this.BeforeBindMainData=function(funcName)
    {
        
    }

    this.UpdateLastDataIcon=function()
    {
        if (!this.ChartPaintEx[0]) return;

        var chart=this.ChartPaintEx[0];
        chart.LastDataIndex=this.TrainInfo.End.Index;
    }

    this.AfterBindMainData=function(funcName)
    {
        if (!this.ChartPaintEx[0]) 
        {
            this.CreateBuySellPaint();
            this.ChartPaintEx[0].LastDataDrawType=1;
        }

        if (funcName!="Update")
        {
            var hisData=this.ChartOperator_Temp_GetHistroyData();
            if (!hisData) return false;

            var count=hisData.Data.length;
            var lEnd=count-this.TrainDataCount-20;
            var xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
            var findIndex=this.GetKDataIndexByDateTime(hisData.Data, this.TrainStartDate);
            if (findIndex>=0)
            {
                lEnd=findIndex+1;
                if (count-lEnd<this.TrainDataCount) this.TrainDataCount=count-lEnd;
            }
            var xOffset=lEnd-xPointcount;
            hisData.DataOffset=xOffset;

            var index=lEnd-1;
            var kItem=hisData.Data[index];

            //最后一个显示数据
            this.TrainInfo.LastShowData=kItem;
            this.TrainInfo.LastData = kItem;

            //训练起始日期
            this.TrainInfo.Start.Index=index;
            this.TrainInfo.Start.Date=kItem.Date;
            this.TrainInfo.Start.Time=kItem.Time;

            //训练结束日期
            this.TrainInfo.End.Index=index;
            this.TrainInfo.End.Date=kItem.Date;
            this.TrainInfo.End.Time=kItem.Time;

            this.UpdateLastDataIcon();

            this.UpdateTrainUICallback("开始");
        }
    }

    this.Super_UpdataDataoffset=this.UpdataDataoffset;
    this.UpdataDataoffset=function()
    {
        this.Super_UpdataDataoffset();

        var hisData=this.ChartPaint[0].Data;
        this.ChartPaintEx[0].Data=hisData;
    }


    this.MoveNextKLineData=function(option) //{PageSize:, Step:}
    {
        if (this.TrainDataCount<=0) return false;
        var hisData=this.ChartOperator_Temp_GetHistroyData();
        if (!hisData) return false;

        var step=1;
        if (option && option.Step>1) step=option.Step;
        var count=hisData.Data.length;

        var moveStep=0;
        for(var i=0; i<step; ++i)
        {
            var index=this.TrainInfo.End.Index+1;
            if (index>=count) break;
    
            var kItem=hisData.Data[index];
            this.TrainInfo.End.Index=index;
            this.TrainInfo.End.Date=kItem.Date;
            this.TrainInfo.End.Time=kItem.Time;
            --this.TrainDataCount;
            ++moveStep;

            if (this.TrainDataCount<=0) break;
        }

        if (moveStep==0) return false;

        //最后一个显示数据
        this.TrainInfo.LastShowData=kItem;
        this.TrainInfo.LastData = kItem;

        //调整x轴索引位置
        var lEnd=this.TrainInfo.End.Index;
        var xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
        var xOffset=lEnd-xPointcount+1;
        hisData.DataOffset=xOffset;

        this.UpdateLastDataIcon();
        this.UpdataDataoffset();
        this.UpdateFrameMaxMin();
        this.Draw();

        if (this.TrainDataCount<=0) 
        {
            this.FinishTrainData();
            this.UpdateTrainUICallback("结束");
            return false;
        }

        this.UpdateTrainUICallback("训练中");
        return true;
    }

    this.BuyOrSell=function(obj, bDraw)  //{ Price:价格, Vol:数量, Op: 买/卖 0=buy 1=sell, ID:单号 } bDraw是否立即绘制图标
    {
        var kItem=this.TrainInfo.LastShowData;
        if (!kItem) return false;
        
        var buySellPaint=this.ChartPaintEx[0];
        if (!buySellPaint) return false;

        var hisData=this.ChartPaint[0].Data;
        if (!hisData || hisData.Data.length<=0) return false;

        var index=this.TrainInfo.End.Index;  //数据索引
        var buyItem={ Date:this.TrainInfo.End.Date, Time:this.TrainInfo.End.Time, Price:obj.Price, Vol:obj.Vol, Op:0, ID:obj.ID };
        if (obj.Op==1) buyItem.Op=1;
        var key=index;
        buyItem.Key=key;

        this.BuySellData.push(buyItem);
        buySellPaint.AddTradeItem(buyItem);

        if (bDraw==true) this.Draw();
    }

    this.DataMove=function(step,isLeft)
    {
        var oneStepWidth=this.GetMoveOneStepWidth();
        var moveStep=step;
        step=parseInt(step/oneStepWidth);  //除以4个像素
        if (step<=0) return false;

        var data=this.ChartOperator_Temp_GetHistroyData();
        if (!data) return false;

        var xPointcount=0;
        if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
        else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
        if (!xPointcount) return false;

        if (this.Frame.SubFrame && this.Frame.SubFrame.length>0 && this.Frame.SubFrame[0].Frame)
        {
            var fristFrame=this.Frame.SubFrame[0].Frame;
            if (fristFrame.DataWidth<=1 || fristFrame.DistanceWidth<=1) //K线在缩放很小的时候 移动加速
            {
                if (IFrameSplitOperator.IsPlusNumber(this.StepPixel))
                    step=moveStep*this.StepPixel;
            }
               
        }

        if (isLeft) //-->
        {
            if (this.RightSpaceCount>0)
            {
                //TODO: not support 
                if (xPointcount+data.DataOffset>=data.Data.length+this.RightSpaceCount-1) return false;
                data.DataOffset+=step;

                if (data.DataOffset+xPointcount>=data.Data.length+this.RightSpaceCount)
                    data.DataOffset=data.Data.length-(xPointcount-this.RightSpaceCount);
            }
            else
            {
                var end=this.TrainInfo.End.Index+1;
                if (xPointcount+data.DataOffset>=end) return false;

                data.DataOffset+=step;
                if (data.DataOffset+xPointcount>=end)
                    data.DataOffset=end-xPointcount;
            }
            return true;
        }
        else        //<--
        {
            if (data.DataOffset<=0) return false;

            data.DataOffset-=step;
            if (data.DataOffset<0) data.DataOffset=0;

            return true;
        }
    }

    this.DataMoveRight=function()
    {
        var data=this.ChartOperator_Temp_GetHistroyData();
        if (!data) return false;

        var xPointcount=0;
        if (this.Frame.XPointCount) xPointcount=this.Frame.XPointCount;
        else xPointcount=this.Frame.SubFrame[0].Frame.XPointCount;
        if (!xPointcount) return false;

        var end=this.TrainInfo.End.Index+1;
        if (xPointcount+data.DataOffset>=end) return false;

        ++data.DataOffset;
        return true;
    }
}

////////////////////////////////////////////////////////////////////////////////
//  K线横屏显示
//
function KLineChartHScreenContainer(uielement)
{
    this.newMethod=KLineChartContainer;   //派生
    this.newMethod(uielement);
    delete this.newMethod;

    this.ClassName='KLineChartHScreenContainer';

    this.OnMouseMove=function(x,y,e,isPhone)
    {
        this.LastPoint.X=x;
        this.LastPoint.Y=y;
        this.CursorIndex=this.Frame.GetXData(y);

        var option={ ParentFunction:'OnMouseMove', Point:{X:x, Y:y}, IsPhone:isPhone===true };

        this.DrawDynamicInfo(option);
    }

    uielement.onmousedown=function(e)   //鼠标拖拽
    {
        if(!this.JSChartContainer) return;
        if(this.JSChartContainer.DragMode==0) return;

        var pixelTatio = GetDevicePixelRatio();
        if (this.JSChartContainer.TryClickLock)
        {
            var x = (e.clientX-this.getBoundingClientRect().left)*pixelTatio;
            var y = (e.clientY-this.getBoundingClientRect().top)*pixelTatio;
            if (this.JSChartContainer.TryClickLock(x,y)) return;
        }


        var drag=
        {
            "Click":{},
            "LastMove":{}  //最后移动的位置
        };

        drag.Click.X=e.clientX;
        drag.Click.Y=e.clientY;
        drag.LastMove.X=e.clientX;
        drag.LastMove.Y=e.clientY;

        this.JSChartContainer.MouseDrag=drag;
        document.JSChartContainer=this.JSChartContainer;
        this.JSChartContainer.SelectChartDrawPicture=null;

        uielement.ondblclick=function(e)
        {
            var x = e.clientX-this.getBoundingClientRect().left;
            var y = e.clientY-this.getBoundingClientRect().top;

            if(this.JSChartContainer)
                this.JSChartContainer.OnDoubleClick(x,y,e);
        }

        document.onmousemove=function(e)
        {
            if(!this.JSChartContainer) return;
            //加载数据中,禁用鼠标事件
            if (this.JSChartContainer.ChartSplashPaint && this.JSChartContainer.ChartSplashPaint.IsEnableSplash == true) return;

            var drag=this.JSChartContainer.MouseDrag;
            if (!drag) return;

            var moveSetp=Math.abs(drag.LastMove.Y-e.clientY);

            if (this.JSChartContainer.DragMode==1)  //数据左右拖拽
            {
                if (moveSetp<5) return;

                var oneStepWidth=this.JSChartContainer.GetMoveOneStepWidth();
                if (moveSetp<oneStepWidth) return;

                var isLeft=true;
                if (drag.LastMove.Y<e.clientY) isLeft=false;//右移数据

                if(this.JSChartContainer.DataMove(moveSetp,isLeft))
                {
                    this.JSChartContainer.UpdataDataoffset();
                    this.JSChartContainer.UpdatePointByCursorIndex();
                    this.JSChartContainer.UpdateFrameMaxMin();
                    this.JSChartContainer.ResetFrameXYSplit();
                    this.JSChartContainer.Draw();
                }

                drag.LastMove.X=e.clientX;
                drag.LastMove.Y=e.clientY;
            }
        };

        document.onmouseup=function(e)
        {
            //清空事件
            document.onmousemove=null;
            document.onmouseup=null;

            //清空数据
            this.JSChartContainer.MouseDrag=null;
            this.JSChartContainer.CurrentChartDrawPicture=null;
            this.JSChartContainer=null;
        }
    }

    //手机拖拽
    this.OnTouchStart=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        this.IsPress=false;
        this.PhonePinch=null;
        this.IsOnTouch=true;
        this.TouchDrawCount=0;
        this.StopDragTimer();
        var isSingleTouch=this.IsSingleTouch(e);
        if (e.cancelable) e.preventDefault();

        if (this.IsPhoneDragging(e))
        {
            var touches = this.GetToucheData(e, false);
            var pt=this.PointAbsoluteToRelative(touches[0].clientX, touches[0].clientY, true);

            if (this.TryClickLock || this.TryClickIndexTitle) //指标枷锁区域, 指标标题点击
            {
                var x = pt.X;
                var y = pt.Y;
                if (this.TryClickLock && this.TryClickLock(x, y)) return;
                if (this.TryClickIndexTitle && this.TryClickIndexTitle(x,y)) return;
            }

            if (this.ClickFrameButton)
            {
                var button=this.Frame.PtInButtons(pt.X,pt.Y);
                if (button)
                {
                    this.ClickFrameButton(button, e);
                    return;
                }
            }

            if (this.EnableVerticalDrag )
            {
                this.VerticalDrag={ IsDrag:false };
                if (this.Frame.PtInFrameVertical(pt.X, pt.Y))
                    this.VerticalDrag.IsDrag=true;
            }

            var bStartTimer=true;
            if (this.ChartDrawOption.IsLockScreen)
            {
                bStartTimer=false;
            }
            else if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
            {
                if (this.TouchStatus.CorssCursorShow==true) bStartTimer=false;
            }
            else if (this.DragMode==JSCHART_DRAG_ID.DISABLE_DRAG_ID)
            {
                bStartTimer=false;
            }
            else
            {
                if (!isSingleTouch) bStartTimer=false;
            }

            if (this.VerticalDrag) bStartTimer=false;

            var drag= {  Click:{}, LastMove:{}  }; //LastMove=最后移动的位置
           

            //var touches=this.GetToucheData(e,false);

            drag.Click.X=touches[0].clientX;
            drag.Click.Y=touches[0].clientY;
            drag.LastMove.X=touches[0].clientX;
            drag.LastMove.Y=touches[0].clientY;

            this.MouseDrag=drag;
            this.PhoneTouchInfo={ Start:{X:touches[0].clientX, Y:touches[0].clientY }, End:{ X:touches[0].clientX, Y:touches[0].clientY } };
            if (this.SelectChartDrawPicture) this.SelectChartDrawPicture.IsSelected=false;
            this.SelectChartDrawPicture=null;

            if (this.CurrentChartDrawPicture)  //画图工具模式
            {
                var drawPicture=this.CurrentChartDrawPicture;
                if (drawPicture.Status==2)
                    this.SetChartDrawPictureThirdPoint(drag.Click.X,drag.Click.Y,true);
                else
                {
                    this.SetChartDrawPictureFirstPoint(drag.Click.X,drag.Click.Y,true);
                    //只有1个点 直接完成
                    if (this.FinishChartDrawPicturePoint()) this.DrawDynamicInfo({Corss:false, Tooltip:false});
                    
                }

                if (e.cancelable) e.preventDefault();
                return;
            }
            else
            {
                var drawPictrueData={};
                var pixelTatio = GetDevicePixelRatio(); //鼠标移动坐标是原始坐标 需要乘以放大倍速
                drawPictrueData.X=(touches[0].clientX-uielement.getBoundingClientRect().left);
                drawPictrueData.Y=(touches[0].clientY-uielement.getBoundingClientRect().top);
                if (this.GetChartDrawPictureByPoint(drawPictrueData))
                {
                    drawPictrueData.ChartDrawPicture.Status=20;
                    drawPictrueData.ChartDrawPicture.ValueToPoint();
                    drawPictrueData.ChartDrawPicture.MovePointIndex=drawPictrueData.PointIndex;
                    drawPictrueData.ChartDrawPicture.IsSelected=true;
                    this.CurrentChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    this.SelectChartDrawPicture=drawPictrueData.ChartDrawPicture;
                    let event=this.GetEventCallback(JSCHART_EVENT_ID.ON_CLICK_DRAWPICTURE); //选中画图工具事件
                    if (event && event.Callback)
                    {
                        let sendData={ DrawPicture: drawPictrueData.ChartDrawPicture };
                        event.Callback(event,sendData,this);
                    }

                    if (e.cancelable) e.preventDefault();
                    return;
                }
            }

            if (bStartTimer)    //长按2秒,十字光标
            {
                var self=this;
                this.DragTimer=setTimeout(function()
                {
                    self.IsPress=false;
                    if (drag.Click.X==drag.LastMove.X && drag.Click.Y==drag.LastMove.Y) //手指没有移动，出现十字光标
                    {
                        var mouseDrag=self.MouseDrag;
                        self.MouseDrag=null;
                        self.MoveCorssCursor(drag.Click,e);//移动十字光标
                    }
                }, self.PressTime);
            }

            if (this.ChartDrawOption.IsLockScreen)
            {
                this.MouseDrag=null;
            }
            else if (this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID)
            {

            }
            else if (this.DragMode==JSCHART_DRAG_ID.DISABLE_DRAG_ID)
            {
                this.MouseDrag=null;
                this.MoveCorssCursor(drag.Click,e);
            }
            else if (this.VerticalDrag)
            {
                if (!this.VerticalDrag.IsDrag) this.MoveCorssCursor(drag.Click,e);  //没有点击X轴, 就显示十字光标
            }
            else if (this.IsClickShowCorssCursor)
            {
                this.MoveCorssCursor(drag.Click,e);
            }    

        }
        else if (this.IsPhonePinching(e))
        {
            var phonePinch=
            {
                "Start":{},
                "Last":{}
            };

            var touches=this.GetToucheData(e,false);

            phonePinch.Start={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};
            phonePinch.Last={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};

            this.PhonePinch=phonePinch;
            this.SelectChartDrawPicture=null;

            //if (this.ChartDrawOption.IsLockScreen) this.PhonePinch=null;    //锁屏禁止缩放
        }

        this.TouchEvent({ EventID:JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName:"OnTouchStart"}, e);
    }

    this.OnTouchMove=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        if (e.cancelable) e.preventDefault();

        var touches=this.GetToucheData(e,false);

        if (this.IsPhoneDragging(e))
        {
            var drag=this.MouseDrag;
            if (drag==null)
            {
                if (!this.ChartDrawOption.IsLockScreen) this.MoveCorssCursor({X:touches[0].clientX, Y:touches[0].clientY},e);
            }
            else
            {
                var moveSetp=Math.abs(drag.LastMove.Y-touches[0].clientY);
                var moveUpDown=Math.abs(drag.LastMove.X-touches[0].clientX);
                var isMoveCorssCursor=(this.DragMode==JSCHART_DRAG_ID.CLICK_TOUCH_MODE_ID && this.TouchStatus.CorssCursorShow==true); //是否移动十字光标

                if (this.VerticalDrag) 
                {
                    if (this.VerticalDrag.IsDrag===true) isMoveCorssCursor=false;
                    else isMoveCorssCursor=true;
                }

                if (this.CurrentChartDrawPicture)
                {
                    var drawPicture=this.CurrentChartDrawPicture;
                    if (drawPicture.Status==1 || drawPicture.Status==2)
                    {
                        if(moveSetp<5 && moveUpDown<5) return;
                        if(this.SetChartDrawPictureSecondPoint(touches[0].clientX,touches[0].clientY,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }
                    else if (drawPicture.Status==3)
                    {
                        if(this.SetChartDrawPictureThirdPoint(touches[0].clientX,touches[0].clientY,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }
                    else if (drawPicture.Status==20)    //画图工具移动
                    {
                        if(moveSetp<5 && moveUpDown<5) return;

                        if(this.MoveChartDrawPicture(touches[0].clientX-drag.LastMove.X,touches[0].clientY-drag.LastMove.Y,true))
                        {
                            this.DrawDynamicInfo();
                        }
                    }

                    drag.LastMove.X=touches[0].clientX;
                    drag.LastMove.Y=touches[0].clientY;
                }
                else if (isMoveCorssCursor)  //点击模式下 十字光标显示 左右移动十字光标
                {
                    var mouseDrag=this.MouseDrag;
                    this.MouseDrag=null;
                    this.MoveCorssCursor(drag.Click,e); //移动十字光标
                }
                else if (this.DragMode==1 || isMoveCorssCursor==false)  //数据左右拖拽
                {
                    if (moveSetp<5) return;

                    var oneStepWidth=this.GetMoveOneStepWidth();
                    if (moveSetp<oneStepWidth) return;

                    if (this.EnableVerticalDrag)
                    {
                        if (!this.VerticalDrag) return;
                        if (!this.VerticalDrag.IsDrag) return;
                    }

                    var isLeft=true;
                    if (drag.LastMove.Y<touches[0].clientY) isLeft=false;//右移数据

                    if(this.DataMove(moveSetp,isLeft))
                    {
                        this.UpdataDataoffset();
                        this.UpdatePointByCursorIndex();
                        this.UpdateFrameMaxMin();
                        this.ResetFrameXYSplit();
                        this.Draw();
                        this.OnKLinePageChange("OnTouchMove");
                    }
                    else
                    {
                        if (this.DragDownloadData) this.DragDownloadData();
                    }

                    drag.LastMove.X=touches[0].clientX;
                    drag.LastMove.Y=touches[0].clientY;
                }
            }

            if (this.PhoneTouchInfo)
            {
                this.PhoneTouchInfo.End.X=touches[0].clientX;
                this.PhoneTouchInfo.End.Y=touches[0].clientY;
            }
        }
        else if (this.IsPhonePinching(e))
        {
            if (this.DragMode==JSCHART_DRAG_ID.DISABLE_DRAG_ID) return;

            var phonePinch=this.PhonePinch;
            if (!phonePinch) return;

            var yHeight=Math.abs(touches[0].pageX-touches[1].pageX);
            var yLastHeight=Math.abs(phonePinch.Last.X-phonePinch.Last.X2);
            var yStep=yHeight-yLastHeight;
            if (Math.abs(yStep)<5) return;

            if (yStep>0)    //放大
            {
                var cursorIndex={};
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (!this.Frame.ZoomUp(cursorIndex)) return;
                this.CursorIndex=cursorIndex.Index;
                this.UpdatePointByCursorIndex();
                this.UpdataDataoffset();
                this.UpdateFrameMaxMin();
                this.Draw();
                this.ShowTooltipByKeyDown();
                this.OnKLinePageChange("OnTouchMove");
            }
            else        //缩小
            {
                var cursorIndex={};
                cursorIndex.Index=parseInt(Math.abs(this.CursorIndex-0.5).toFixed(0));
                if (!this.Frame.ZoomDown(cursorIndex)) return;
                this.CursorIndex=cursorIndex.Index;
                this.UpdataDataoffset();
                this.UpdatePointByCursorIndex();
                this.UpdateFrameMaxMin();
                this.Draw();
                this.ShowTooltipByKeyDown();
                this.OnKLinePageChange("OnTouchMove");
            }

            phonePinch.Last={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};
        }
    }

    this.OnTouchEnd=function(e)
    {
        JSConsole.Chart.Log('[KLineChartHScreenContainer:OnTouchEnd]',e);
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        var bClearDrawPicture=true;
        if (this.CurrentChartDrawPicture)
        {
            var drawPicture=this.CurrentChartDrawPicture;
            if (drawPicture.Status==2 || drawPicture.Status==1 || drawPicture.Status==3)
            {
                drawPicture.PointStatus=drawPicture.Status;
                if (this.FinishChartDrawPicturePoint())
                    this.DrawDynamicInfo();
                else
                    bClearDrawPicture=false;
            }
            else if (drawPicture.Status==20)
            {
                if (this.FinishMoveChartDrawPicture())
                    this.DrawDynamicInfo();
            }
        }

        this.IsOnTouch = false;
        this.VerticalDrag=null;
        this.StopDragTimer();
        this.TouchEvent({ EventID:JSCHART_EVENT_ID.ON_PHONE_TOUCH, FunctionName:"OnTouchEnd"}, e);
        this.OnTouchFinished();
        this.TouchDrawCount=0;
    }

    //创建
    //windowCount 窗口个数
    this.Create=function(windowCount)
    {
        this.UIElement.JSChartContainer=this;

        //创建十字光标
        this.ChartCorssCursor=new ChartCorssCursor();
        this.ChartCorssCursor.Canvas=this.Canvas;
        this.ChartCorssCursor.StringFormatX=g_DivTooltipDataForamt.Create("CorssCursor_XStringFormat");
        this.ChartCorssCursor.StringFormatX.LanguageID=this.LanguageID;
        this.ChartCorssCursor.StringFormatY=g_DivTooltipDataForamt.Create("CorssCursor_YStringFormat");
        this.ChartCorssCursor.StringFormatY.LanguageID=this.LanguageID;
        this.ChartCorssCursor.StringFormatY.ExtendChartPaint=this.ExtendChartPaint;
        this.ChartCorssCursor.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

        //创建等待提示
        this.ChartSplashPaint = new ChartSplashPaint();
        this.ChartSplashPaint.Canvas = this.Canvas;
        this.ChartSplashPaint.HQChart=this;

        //创建框架容器
        this.Frame=new HQTradeHScreenFrame();
        this.Frame.ChartBorder=new ChartBorder();
        this.Frame.ChartBorder.UIElement=this.UIElement;
        this.Frame.ChartBorder.Top=30;
        this.Frame.ChartBorder.Left=5;
        this.Frame.ChartBorder.Bottom=20;
        this.Frame.Canvas=this.Canvas;
        this.ChartCorssCursor.Frame=this.Frame; //十字光标绑定框架
        this.ChartSplashPaint.Frame = this.Frame;

        this.CreateChildWindow(windowCount);
        this.CreateMainKLine();

        //子窗口动态标题
        for(var i in this.Frame.SubFrame)
        {
            var titlePaint=new DynamicChartTitlePainting();
            titlePaint.Frame=this.Frame.SubFrame[i].Frame;
            titlePaint.Canvas=this.Canvas;
            titlePaint.LanguageID=this.LanguageID;
            titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            titlePaint.SelectedChart=this.SelectedChart;
            this.TitlePaint.push(titlePaint);
        }

        this.UIElement.addEventListener("keydown", OnKeyDown, true);    //键盘消息
    }

    //创建子窗口
    this.CreateChildWindow=function(windowCount)
    {
        for(var i=0;i<windowCount;++i)
        {
            var border=new ChartBorder();
            border.UIElement=this.UIElement;

            var frame=g_ChartFrameFactory.Create("KLineHScreenFrame", { ID:i });
            frame.Canvas=this.Canvas;
            frame.GetExtraCanvas=(name)=>{ return this.GetExtraCanvas(name); };
            frame.ChartBorder=border;
            frame.Identify=i;                   //窗口序号
            frame.RightSpaceCount=this.RightSpaceCount; //右边

            if (this.ModifyIndexDialog) frame.ModifyIndexEvent=this.ModifyIndexDialog.DoModal;        //绑定菜单事件
            if (this.ChangeIndexDialog) frame.ChangeIndexEvent=this.ChangeIndexDialog.DoModal;

            frame.HorizontalMax=20;
            frame.HorizontalMin=10;

            if (i==0)
            {
                frame.YSplitOperator=new FrameSplitKLinePriceY();
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('price');
                frame.YSplitOperator.FrameSplitData2=this.FrameSplitData.get('double');
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                //主图上下间距
                var pixelTatio = GetDevicePixelRatio(); //获取设备的分辨率
                border.TopSpace=12*pixelTatio;
                border.BottomSpace=12*pixelTatio;
            }
            else
            {
                frame.YSplitOperator=new FrameSplitY();
                frame.YSplitOperator.LanguageID=this.LanguageID;
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
                //frame.IsLocked = true;
            }

            frame.YSplitOperator.Frame=frame;
            frame.YSplitOperator.ChartBorder=border;
            frame.XSplitOperator=new FrameSplitKLineX();
            frame.XSplitOperator.Frame=frame;
            frame.XSplitOperator.ChartBorder=border;
            frame.XSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

            if (i!=windowCount-1) frame.XSplitOperator.ShowText=false;

            for(var j=frame.HorizontalMin;j<=frame.HorizontalMax;j+=1)
            {
                frame.HorizontalInfo[j]= new CoordinateInfo();
                frame.HorizontalInfo[j].Value=j;
                if (i==0 && j==frame.HorizontalMin) continue;

                frame.HorizontalInfo[j].Message[1]=j.toString();
                frame.HorizontalInfo[j].Font="14px 微软雅黑";
            }

            var subFrame=new SubFrameItem();
            frame.FrameData.SubFrameItem=subFrame;
            subFrame.Frame=frame;
            if (i==0)
                subFrame.Height=20;
            else
                subFrame.Height=10;

            this.Frame.SubFrame[i]=subFrame;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
//  走势图横屏显示
//
function MinuteChartHScreenContainer(uielement)
{
    this.newMethod=MinuteChartContainer;   //派生
    this.newMethod(uielement);
    delete this.newMethod;

    this.ClassName='MinuteChartHScreenContainer';

    this.OnMouseMove=function(x,y,e,isPhone)
    {
        this.LastPoint.X=x;
        this.LastPoint.Y=y;
        this.CursorIndex=this.Frame.GetXData(y);

        var clientPos=this.PtInClient(x,y);
        var option={ ParentFunction:'OnMouseMove', Point:{X:x, Y:y}, IsPhone:isPhone===true,ClientPos:clientPos };
        this.DrawDynamicInfo(option);
    }

     //创建
    //windowCount 窗口个数
    this.Create=function(windowCount)
    {
        this.UIElement.JSChartContainer=this;

        //创建十字光标
        this.ChartCorssCursor=new ChartCorssCursor();
        this.ChartCorssCursor.PtInClient=(x,y)=>{ return this.PtInClient(x,y); }
        this.ChartCorssCursor.Canvas=this.Canvas;
        this.ChartCorssCursor.StringFormatX=g_DivTooltipDataForamt.Create("CorssCursor_Minute_XStringFormat");
        this.ChartCorssCursor.StringFormatX.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.StringFormatY=g_DivTooltipDataForamt.Create("CorssCursor_YStringFormat");
        this.ChartCorssCursor.StringFormatY.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.ChartCorssCursor.CallAcutionXOperator=new CallAcutionXOperator();
        this.ChartCorssCursor.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

         //创建等待提示
         this.ChartSplashPaint = new ChartSplashPaint();
         this.ChartSplashPaint.Canvas = this.Canvas;
         this.ChartSplashPaint.HQChart=this;

        //创建框架容器
        this.Frame=new HQTradeHScreenFrame();
        this.Frame.ChartBorder=new ChartBorder();
        this.Frame.ChartBorder.UIElement=this.UIElement;
        this.Frame.ChartBorder.Top=25;
        this.Frame.ChartBorder.Left=50;
        this.Frame.ChartBorder.Bottom=20;
        this.Frame.Canvas=this.Canvas;
        this.ChartCorssCursor.Frame=this.Frame; //十字光标绑定框架
        this.ChartSplashPaint.Frame = this.Frame;

        this.CreateChildWindow(windowCount);
        this.CreateMainKLine();

        //子窗口动态标题
        for(var i in this.Frame.SubFrame)
        {
            var titlePaint=new DynamicChartTitlePainting();
            titlePaint.Frame=this.Frame.SubFrame[i].Frame;
            titlePaint.Canvas=this.Canvas;
            titlePaint.LanguageID=this.LanguageID;
            titlePaint.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            titlePaint.SelectedChart=this.SelectedChart;
            this.TitlePaint.push(titlePaint);
        }
        
        this.ChartCorssCursor.StringFormatX.Frame=this.Frame.SubFrame[0].Frame;
        this.ChartCorssCursor.StringFormatY.Frame=this.Frame;
        this.ChartCorssCursor.CallAcutionXOperator.Frame=this.Frame.SubFrame[0].Frame;

        this.UIElement.addEventListener("keydown", OnKeyDown, true);    //键盘消息
    }

    //创建子窗口
    this.CreateChildWindow=function(windowCount)
    {
        for(var i=0;i<windowCount;++i)
        {
            var border=new ChartBorder();
            border.UIElement=this.UIElement;

            var frame=new MinuteHScreenFrame();
            frame.Canvas=this.Canvas;
            frame.ChartBorder=border;
            frame.Identify=i;
            if (i<2) frame.ChartBorder.TitleHeight=0;
            frame.XPointCount=243;
            frame.HQChart=this;
            frame.GetEventCallback=(id)=> { return this.GetEventCallback(id); }

            var DEFAULT_HORIZONTAL=[9,8,7,6,5,4,3,2,1];
            frame.HorizontalMax=DEFAULT_HORIZONTAL[0];
            frame.HorizontalMin=DEFAULT_HORIZONTAL[DEFAULT_HORIZONTAL.length-1];

            if (i==0)
            {
                frame.YSplitOperator=new FrameSplitMinutePriceY();
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('price');
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
                frame.YSplitOperator.DayOffset=this.DayOffset;
                frame.YSplitOperator.HQChart=this;
            }
            else
            {
                frame.YSplitOperator=new FrameSplitY();
                frame.YSplitOperator.LanguageID=this.LanguageID;
                frame.YSplitOperator.FrameSplitData=this.FrameSplitData.get('double');
                frame.YSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            }

            frame.YSplitOperator.Frame=frame;
            frame.YSplitOperator.ChartBorder=border;
            frame.XSplitOperator=new FrameSplitMinuteX();
            frame.XSplitOperator.Frame=frame;
            frame.XSplitOperator.ChartBorder=border;
            frame.XSplitOperator.DayOffset=this.DayOffset;
            frame.XSplitOperator.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
            if (i!=windowCount-1) frame.XSplitOperator.ShowText=false;
            frame.XSplitOperator.Operator();

            for(var j in DEFAULT_HORIZONTAL)
            {
                frame.HorizontalInfo[j]= new CoordinateInfo();
                frame.HorizontalInfo[j].Value=DEFAULT_HORIZONTAL[j];
                if (i==0 && j==frame.HorizontalMin) continue;

                frame.HorizontalInfo[j].Message[1]=DEFAULT_HORIZONTAL[j].toString();
                frame.HorizontalInfo[j].Font="14px 微软雅黑";
            }

            var subFrame=new SubFrameItem();
            frame.FrameData.SubFrameItem=subFrame;
            subFrame.Frame=frame;
            if (i==0)
                subFrame.Height=20;
            else
                subFrame.Height=10;

            this.Frame.SubFrame[i]=subFrame;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////////
//  深度图
//
function DepthChartContainer(uielement)
{
    this.newMethod=JSChartContainer;   //派生
    this.newMethod(uielement);
    delete this.newMethod;

    this.ClassName="DepthChartContainer";
    this.Symbol;
    
    //数据
    this.MapAsk=new Map();
    this.MapBid=new Map();

    this.IsAutoUpdate=false;                    //是否自动更新行情数据
    this.AutoUpdateFrequency=30000;             //30秒更新一次数据
    this.AutoUpdateTimer;

    this.DefaultZoom=0.8;       //默认显示80%的盘口 (0 - 1)
    this.MaxVolRate=1.1;

    this.Create=function(option)
    {
        this.UIElement.JSChartContainer=this;

        //创建十字光标
        this.ChartCorssCursor=new DepthChartCorssCursor();
        this.ChartCorssCursor.Canvas=this.Canvas;
        this.ChartCorssCursor.HQChart=this;
        //this.ChartCorssCursor.StringFormatX=g_DivTooltipDataForamt.Create("CorssCursor_XStringFormat");
        //this.ChartCorssCursor.StringFormatX.LanguageID=this.LanguageID;
        //this.ChartCorssCursor.StringFormatY=g_DivTooltipDataForamt.Create("CorssCursor_YStringFormat");
        //this.ChartCorssCursor.StringFormatY.LanguageID=this.LanguageID;


        //创建等待提示
        this.ChartSplashPaint = new ChartSplashPaint();
        this.ChartSplashPaint.Canvas = this.Canvas;
        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);

        //创建框架
        this.Frame=new DepthChartFrame();
        this.Frame.ChartBorder=new ChartBorder();
        this.Frame.ChartBorder.UIElement=this.UIElement;
        this.Frame.ChartBorder.Top=30;
        this.Frame.ChartBorder.Left=5;
        this.Frame.ChartBorder.Bottom=20;
        this.Frame.ChartBorder.TitleHeight=0;
        this.Frame.Canvas=this.Canvas;
        this.Frame.Identify=0;

        var ySplitOper=new FrameSplitY();
        ySplitOper.FrameSplitData=this.FrameSplitData.get('double');
        ySplitOper.LanguageID=this.LanguageID;
        ySplitOper.Frame=this.Frame;
        ySplitOper.SplitCount=5;
        ySplitOper.LineType=3;
        ySplitOper.IgnoreYValue=[0];
        //ySplitOper.SplitType=2;
        ySplitOper.ChartBorder=this.Frame.ChartBorder;
        ySplitOper.GetEventCallback=(id)=> { return this.GetEventCallback(id); }
        this.Frame.YSplitOperator=ySplitOper;

        var xSplitOper=new FrameSplitXDepth();
        xSplitOper.Frame=this.Frame;;
        xSplitOper.ChartBorder=this.Frame.ChartBorder;;
        xSplitOper.LanguageID=this.LanguageID;
        xSplitOper.LineType=3;
        xSplitOper.GetEventCallback=(id)=> { return this.GetEventCallback(id); };
        this.Frame.XSplitOperator=xSplitOper

        if (this.ChartCorssCursor) this.ChartCorssCursor.Frame=this.Frame; //十字光标绑定框架
        this.ChartSplashPaint.Frame = this.Frame;

        var chartItem=new ChartOrderbookDepth();
        chartItem.Canvas=this.Canvas;
        chartItem.ChartBorder=this.Frame.ChartBorder;
        chartItem.ChartFrame=this.Frame;
        chartItem.Name="深度图"
        this.ChartPaint.push(chartItem);

        var bRegisterKeydown=true;
        var bRegisterWheel=true;
        if (option)
        {
            if (option.Wheel===false) 
            {
                bRegisterWheel=false;
                JSConsole.Chart.Log('[DepthChartContainer::Create] not register wheel event.');
            }
        }

        if (bRegisterKeydown) this.UIElement.addEventListener("keydown", (e)=>{ this.OnKeyDown(e); }, true);            //键盘消息
        if (bRegisterWheel) this.UIElement.addEventListener("wheel", (e)=>{ this.OnWheel(e); }, true);                //上下滚动消息
    }

    this.OnWheel=function(e)
    {
        JSConsole.Chart.Log('[KLineChartContainer::OnWheel]',e);
        var x = e.clientX-this.UIElement.getBoundingClientRect().left;
        var y = e.clientY-this.UIElement.getBoundingClientRect().top;

        var isInClient=false;
        this.Canvas.beginPath();
        this.Canvas.rect(this.Frame.ChartBorder.GetLeft(),this.Frame.ChartBorder.GetTop(),this.Frame.ChartBorder.GetWidth(),this.Frame.ChartBorder.GetHeight());
        isInClient=this.Canvas.isPointInPath(x,y);

        var wheelValue=e.wheelDelta;
        if (!IFrameSplitOperator.IsObjectExist(e.wheelDelta))
            wheelValue=e.deltaY* -0.01;
        
        var enableZoomUpDown=true;  //是否允许缩放
        if (this.EnableZoomUpDown && this.EnableZoomUpDown.Wheel===false) enableZoomUpDown=false;
        
        if (isInClient && wheelValue<0 && enableZoomUpDown)       //缩小
        {
            if (this.Frame.ZoomDown())
            {
                this.UpdateFrameMaxMin();
                this.Draw();
            }
        }
        else if (isInClient && wheelValue>0 && enableZoomUpDown)  //放大
        {
            if (this.Frame.ZoomUp())
            {
                this.UpdateFrameMaxMin();
                this.Draw();
            }
        }

        if(e.preventDefault) e.preventDefault();
        else e.returnValue = false;
    }

    this.UIOnMouseDown=function(e)
    {
    }

    this.OnTouchStart=function(e)
    {
        if (this.ChartSplashPaint && this.ChartSplashPaint.IsEnableSplash == true) return;

        this.IsOnTouch=true;
        this.TouchDrawCount=0;
        this.PhonePinch=null;

        var isSingleTouch=this.IsSingleTouch(e);
        if (this.EnableScrollUpDown==false || !isSingleTouch) //多点触屏 
        {
            if (e.cancelable) e.preventDefault();
        }

        if (this.IsPhoneDragging(e))
        {
            var drag=
            {
                "Click":{},
                "LastMove":{}  //最后移动的位置
            };

            var touches=this.GetToucheData(e,this.IsForceLandscape);

            drag.Click.X=touches[0].clientX;
            drag.Click.Y=touches[0].clientY;
            drag.LastMove.X=touches[0].clientX;
            drag.LastMove.Y=touches[0].clientY;

            this.MouseDrag=drag;

            this.MoveCorssCursor(drag.Click,e);
        }
        else if (this.IsPhonePinching(e))
        {
            var phonePinch=
            {
                "Start":{},
                "Last":{}
            };

            var touches=this.GetToucheData(e,this.IsForceLandscape);

            phonePinch.Start={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};
            phonePinch.Last={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};

            this.PhonePinch=phonePinch;
        }
    }

    this.OnTouchMove=function(e)
    {
        var touches=this.GetToucheData(e,false);
        if (this.IsPhoneDragging(e))
        {
            var drag=this.MouseDrag;
            if (drag==null)
            {
                var pixelTatio = GetDevicePixelRatio();
                var x = touches[0].clientX-uielement.getBoundingClientRect().left*pixelTatio;
                var y = touches[0].clientY-uielement.getBoundingClientRect().top*pixelTatio;
                this.OnMouseMove(x,y,e);
            }
            else
            {
                var moveAngle=this.GetMoveAngle(drag.LastMove,{X:touches[0].clientX, Y:touches[0].clientY});
                var moveSetp=Math.abs(drag.LastMove.X-touches[0].clientX);
                var moveUpDown=Math.abs(drag.LastMove.Y-touches[0].clientY);
                moveSetp=parseInt(moveSetp);

                //上下滚动
                if ( ((moveUpDown>0 && moveSetp<=3) || moveAngle<=this.TouchMoveMinAngle) && this.EnableScrollUpDown==true ) 
                {
                    return;
                }

                this.PreventTouchEvent(e);
                this.MouseDrag=null;
                var pixelTatio = GetDevicePixelRatio();
                var x = touches[0].clientX-uielement.getBoundingClientRect().left*pixelTatio;
                var y = touches[0].clientY-uielement.getBoundingClientRect().top*pixelTatio;
                this.OnMouseMove(x,y,e);
            }
        }
        else if (this.IsPhonePinching(e))
        {
            this.PreventTouchEvent(e);
            var phonePinch=this.PhonePinch;
            if (!phonePinch) return;

            if (this.EnableZoomUpDown && this.EnableZoomUpDown.Touch===false) return;

            var yHeight=Math.abs(touches[0].pageY-touches[1].pageY);
            var yLastHeight=Math.abs(phonePinch.Last.Y-phonePinch.Last.Y2);
            var yStep=yHeight-yLastHeight;

            var xHeight=Math.abs(touches[0].pageX-touches[1].pageX);
            var xLastHeight=Math.abs(phonePinch.Last.X-phonePinch.Last.X2);
            var xStep=xHeight-xLastHeight;
            var minStep=this.ZoomStepPixel;
            if (Math.abs(yStep)<minStep && Math.abs(xStep)<minStep) return;
            var step=yStep;
            if (Math.abs(yStep)<minStep) step=xStep;

            if (step>0)    //放大
            {
                if (!this.Frame.ZoomUp()) return;
                this.UpdateFrameMaxMin();
                this.Draw();
            }
            else        //缩小
            {
                if (!this.Frame.ZoomDown()) return;
                this.UpdateFrameMaxMin();
                this.Draw();
            }

            phonePinch.Last={"X":touches[0].pageX,"Y":touches[0].pageY,"X2":touches[1].pageX,"Y2":touches[1].pageY};
        }

        this.PreventTouchEvent(e);
    }

    this.OnTouchEnd=function(e)
    {
        JSConsole.Chart.Log('[DepthChartContainer::OnTouchEnd]',e);
        this.IsOnTouch = false;
        this.OnTouchFinished();
        this.TouchDrawCount=0;
    }

    this.OnTouchFinished=function()
    {
        if (this.CorssCursorTouchEnd===true)    //手势离开十字光标消失
        {
            this.DrawDynamicInfo();
            return;
        }
    }

    this.ChangeSymbol=function(symbol)
    {
        this.CancelAutoUpdate();    //先停止定时器
        this.Symbol=symbol;
        this.MapBid=new Map();
        this.MapAsk=new Map();
        this.Frame.VerticalRange.Differ=null;

        this.ChartSplashPaint.SetTitle(this.LoadDataSplashTitle);
        this.ChartSplashPaint.EnableSplash(true);
        this.Draw();

        this.RequestDepthData();
    }

    this.RequestDepthData=function()  //全量历史数据
    {
        var self=this;
        if (this.NetworkFilter)
        {
            var obj=
            {
                Name:'DepthChartContainer::RequestDepthData', //类名::
                Explain:'深度图数据',
                Request:{ Data: { symbol:self.Symbol } }, 
                Self:this,
                PreventDefault:false
            };
            this.NetworkFilter(obj, function(data) 
            { 
                self.ChartSplashPaint.EnableSplash(false);
                self.RecvDepthData(data);
                self.AutoUpdate();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }
    }

    this.RecvDepthData=function(data)
    {
        this.UpdateAskAndBid(data);

        var aryAsk=Array.from(this.MapAsk.values());    //卖    右边
        aryAsk.sort((a,b)=> { return a.Price-b.Price; });
        var sumVol=0;
        for(var i in aryAsk)
        {
            var item=aryAsk[i];
            sumVol+=item.Vol;

            aryAsk[i]={Price:item.Price, Vol:sumVol };
        }

        var aryBid=Array.from(this.MapBid.values());    //买    左边
        aryBid.sort((a,b)=> { return b.Price-a.Price; });
        var sumVol=0;
        for(var i in aryBid)
        {
            var item=aryBid[i];
            sumVol+=item.Vol;

            aryBid[i]={Price:item.Price, Vol:sumVol };
        }

        var drawData={ Asks:aryAsk, Bids:aryBid };
        var chart=this.ChartPaint[0];
        chart.Data=drawData;

        this.Frame.XSplitOperator.Symbol=this.Symbol;
        this.ChartCorssCursor.Data=drawData;
        this.ChartCorssCursor.Symbol=this.Symbol;

        this.UpdateFramePriceList();
        this.UpdateFrameMaxMin();

        this.Draw();
    }

    this.UpdateAskAndBid=function(data) //更新数据
    {
        if(data.datatype=="snapshot") //全量数据
        {
            this.MapBid=new Map();
            this.MapAsk=new Map();
        }

        for(var i in data.asks)
        {
            var item=data.asks[i];
            var price=parseFloat(item[0]);
            var vol=parseFloat(item[1]);

            if (this.MapAsk.has(price))
            {
                var value=this.MapAsk.get(price);
                if (vol<=0) this.MapAsk.delete(price);
                else value.Vol=vol;
            }
            else
            {
                if (vol>0) this.MapAsk.set(price, { Price:price, Vol:vol});
            }
        }

        for(var i in data.bids)
        {
            var item=data.bids[i];
            var price=parseFloat(item[0]);
            var vol=parseFloat(item[1]);

            if (this.MapBid.has(price))
            {
                var value=this.MapBid.get(price);
                if (vol<=0) this.MapBid.delete(price);
                else value.Vol=vol;
            }
            else
            {
                if (vol>0) this.MapBid.set(price, { Price:price, Vol:vol});
            }
        }
    }

    this.UpdateFramePriceList=function()
    {
        var aryAskPrice=Array.from(this.MapAsk.keys());
        var aryBidPrice=Array.from(this.MapBid.keys());

        aryAskPrice.sort((a,b)=> { return a-b; });
        aryBidPrice.sort((a,b)=> { return a-b; });

        var range={ Max:88, Min:8 };
        if (aryAskPrice.length>1 && aryBidPrice.length>1)
        {
            var askMin=aryAskPrice[0], askMax=aryAskPrice[aryAskPrice.length-1];
            var bidMin=aryBidPrice[0], bidMax=aryBidPrice[aryBidPrice.length-1];
            var askDifference=askMax-askMin;    //卖差值
            var bidDifference=bidMax-bidMin;    //买差值
            var difference=Math.max(askDifference, bidDifference);   //取最大的差值,2边调整

            var ask={Min:askMin, Max:askMin+difference};
            var bid={Max:bidMax, Min:bidMax-difference};
            range={ Max:ask.Max, Min:bid.Min };
        }

        this.Frame.SetPriceList(aryAskPrice,aryBidPrice);
        var xRange=this.Frame.VerticalRange;
        xRange.Max=range.Max;
        xRange.Center=range.Min+(range.Max-range.Min)/2;
        xRange.Min=range.Min;
        xRange.MaxDiffer=difference;        //差值
        xRange.Ask=ask;
        xRange.Bid=bid;
        if (!IFrameSplitOperator.IsNumber(xRange.Differ)) 
            xRange.Differ=difference*this.DefaultZoom;
        
        xRange.Min=xRange.Center-xRange.Differ;
        xRange.Max=xRange.Center+xRange.Differ;
    }

    this.UpdateFrameMaxMin=function()
    {
        var range=this.ChartPaint[0].GetMaxMin();

        this.Frame.HorizontalMax=range.Max*this.MaxVolRate;
        this.Frame.HorizontalMin=0;
        this.Frame.XYSplit=true;
    }

    this.CancelAutoUpdate=function()    //关闭停止更新
    {
        if (typeof (this.AutoUpdateTimer) == 'number') 
        {
            clearTimeout(this.AutoUpdateTimer);
            this.AutoUpdateTimer = undefined;
        }
    }

    this.StopAutoUpdate=function()
    {
        this.CancelAutoUpdate();
        if (!this.IsAutoUpdate) return;
        this.IsAutoUpdate=false;
    }

    this.AutoUpdate=function()  //数据自动更新
    {
        this.CancelAutoUpdate();
        if (!this.IsAutoUpdate) return;
        if (!this.Symbol) return;

        var self = this;
        var marketStatus=MARKET_SUFFIX_NAME.GetMarketStatus(this.Symbol);
        if (marketStatus==0 || marketStatus==3) return; //闭市,盘后

        var frequency=this.AutoUpdateFrequency;
        if (marketStatus==1) //盘前
        {
            this.AutoUpdateTimer=setTimeout(function() 
            { 
                self.AutoUpdate(); 
            },frequency);
        }
        else if (marketStatus==2)   //盘中
        {
            this.AutoUpdateTimer=setTimeout(function()
            {
                self.RequestDepthData();
            },frequency);
        }
    }
}

//////////////////////////////////////////////////////////
//
//  指标信息
//
function IndexInfo(name,param)
{
    this.Name=name;                 //名字
    this.Param=param;               //参数
    this.LineColor;                 //线段颜色
    this.ReqeustData=null;          //数据请求
}

function BaseIndex(name)
{
    this.Index;         //指标阐述
    this.Name=name;     //指标名字
    this.Script=null;   //通达信脚本
    this.ClassName="BaseIndex";
    
    this.OverlayIndex=null; //叠加指标{ IsOverlay:true, Identify:overlayFrame.Identify, WindowIndex:windowIndex, Frame:overlayFrame }
    this.GetEventCallback;  //事件回调函数
    this.Status=0;          //0=空闲 1=计算
    this.Guid=Guid();       //指标唯一标准

    //默认创建都是线段
    this.Create=function(hqChart,windowIndex)
    {
        
    }

    //指标不支持 周期/复权/股票等
    this.NotSupport=function(hqChart,windowIndex,message)
    {
        var isOverlay=this.IsOverlay();
        if (isOverlay) return;

        hqChart.DeleteIndexPaint(windowIndex);  //清空
        var frame=hqChart.Frame.SubFrame[windowIndex].Frame;

        var paint=new ChartErrorMessage();
        paint.Canvas=hqChart.Canvas;
        paint.ChartBorder=frame.ChartBorder;
        paint.ChartFrame=frame;
        paint.NotSupportMessage=message;

        hqChart.ChartPaint.push(paint);
    }

    //格式化指标名字+参数
    //格式:指标名(参数1,参数2,参数3,...)
    this.FormatIndexTitle=function()
    {
        var title=this.Name;
        var param=null;

        for(var i in this.Index)
        {
            var item = this.Index[i];
            if (item.Param==null) continue;

            if (param)
                param+=','+item.Param.toString();
            else
                param=item.Param.toString();
        }

        if (param)
        {
            title+='('+param+')';
        }

        return title;
    }

    this.IsOverlay=function()   //是否是叠加指标
    {
        if (!this.OverlayIndex || this.OverlayIndex.IsOverlay!=true) return false;

        return true;
    }

    this.CreateChart=function(id)   //创建图形
    {
        return new ChartLine();
    }

    this.CreatePaints=function(hqChart,windowIndex)
    {
        var frame=null;
        var isOverlay=this.IsOverlay();
        if (isOverlay) 
        {
            frame=this.OverlayIndex.Frame.Frame;
            this.OverlayIndex.Frame.ChartPaint=[];    //清空
        }
        else 
        {
            frame=hqChart.Frame.SubFrame[windowIndex].Frame;
            hqChart.DeleteIndexPaint(windowIndex);  //清空
        }
        
        var aryPaint=[];
        for(var i in this.Index)
        {
            var paint=this.CreateChart(i);
            paint.Color=this.Index[i].LineColor;
            paint.Canvas=hqChart.Canvas;
            paint.Name=this.Name+"-"+i.toString();
            paint.ChartBorder=frame.ChartBorder;
            paint.ChartFrame=frame

            if (isOverlay) this.OverlayIndex.Frame.ChartPaint.push(paint);
            else hqChart.ChartPaint.push(paint);

            aryPaint.push(paint);
        }

        return aryPaint;
    }

    this.SendEvent=function(hqChart,windowIndex,hisData, error)
    {
        if (!hqChart.GetIndexEvent) return;
        var event=hqChart.GetIndexEvent();  //指标计算完成回调
        if (!event) return;

        var data={ Data:this.GetOutData(), WindowIndex: windowIndex, Name: this.Name, HistoryData: hisData, 
            Stock: {Symbol:hqChart.Symbol,Name:hqChart.Name} };
        if (error) data.Error=error;
        event.Callback(event,data,self);
    }

    this.GetOutData=function()
    {
        return null;
    }
}

function JSIndex_OX()
{
    this.newMethod=BaseIndex;   //派生
    this.newMethod('OX');
    delete this.newMethod;

    this.ClassName="JSIndex_OX";
    this.IsUsePageData=true;
    this.BlockSize=0.5;

    this.Arguments=
    [
        { Name:"Reversal", Value:3 }
    ];

    this.SetArgs=function(args)
    {
        if (!args || !IFrameSplitOperator.IsNonEmptyArray(args)) return;

        for(var i=0;i<args.length;++i)
        {
            var item=args[i];
            if (item.Name=="Reversal") this.SetParamValue(item.Name,item.Value);
        }
    }

    this.SetParamValue=function(name, value)
    {
        for(var i=0;i<this.Arguments.length;++i)
        {
            var item=this.Arguments[i];
            if (item.Name==name) item.Value=value;
        }
    }

    this.GetParamValue=function(name)
    {
        for(var i=0;i<this.Arguments.length;++i)
        {
            var item=this.Arguments[i];
            if (item.Name==name) return item.Value;
        }
    }

    this.RequestData=function(hqChart,windowIndex,hisData)
    {
        this.BindData(hqChart,windowIndex,hisData);

        hqChart.UpdataDataoffset();           //更新数据偏移
        hqChart.UpdateFrameMaxMin();          //调整坐标最大 最小值
        hqChart.Draw();

        return true;
    }

    this.CreatePaints=function(hqChart,windowIndex)
    {
        var frame=null;
        var isOverlay=this.IsOverlay();
        if (isOverlay) 
        {
            frame=this.OverlayIndex.Frame.Frame;
            this.OverlayIndex.Frame.ChartPaint=[];    //清空
        }
        else 
        {
            frame=hqChart.Frame.SubFrame[windowIndex].Frame;
            hqChart.DeleteIndexPaint(windowIndex);  //清空
        }
        
        var aryPaint=[];
        var paint=new ChartOX();
        paint.Canvas=hqChart.Canvas;
        paint.Name=this.Name+"-0";
        paint.ChartBorder=frame.ChartBorder;
        paint.ChartFrame=frame

        if (isOverlay) this.OverlayIndex.Frame.ChartPaint.push(paint);
        else hqChart.ChartPaint.push(paint);

        aryPaint.push(paint);
    
        return aryPaint;
    }

    //根据最大最小值 调整格子价位
    this.CalculateBlockSize=function(max, min)
    {
        var value=max-min;
        if (value<=5) return 0.25;   //[1,5]=>0.25
        else if (value<=20) return 0.5;  //[5,20)=>0.5
        else if (value<=100) return 1;   //[10,100]=>1
        else if (value<=200) return 2;   //[100,200]=>2
        else if (value<=500) return 5;   //[200,500]=>5
        else if (value<=1000) return 10;   //[500,1000]=>10
        else return 50;
    }

    this.Calculate=function(hqChart, hisData)
    {
        if (!hqChart.ChartPaint[0]) return null;
        var range=hqChart.ChartPaint[0].ShowRange;
        if (!range) return null;
        if (!IFrameSplitOperator.IsNonEmptyArray(hisData.Data)) return null;

        var max=null, min=null;
        var startPrice=null;
        for(var i=range.Start; i<=range.End && i<hisData.Data.length;++i)
        {
            var item=hisData.Data[i];
            if (max==null)
            {
                if (IFrameSplitOperator.IsNumber(item.High)) max=item.High;
            } 
            else
            {
                if (IFrameSplitOperator.IsNumber(item.High) && max<item.High) max=item.High;
            }


            if (min==null)
            {
                if (IFrameSplitOperator.IsNumber(item.Low)) min=item.Low;
            }
            else
            {
                if (IFrameSplitOperator.IsNumber(item.Low) && min>item.Low) min=item.Low;
            }

            if (startPrice==null)
            {
                if (IFrameSplitOperator.IsNumber(item.High)) startPrice=item.High;
            }
        }

        var reversal=this.GetParamValue("Reversal");
       
        var blockSize=this.CalculateBlockSize(max, min);
        this.BlockSize=blockSize;
        var oxData={ Max:max+blockSize, Min:min-blockSize, StartPrice:startPrice, Data:[], BlockSize:blockSize };

        var currentTrend=1;
        var currentPrice=startPrice;
       
        var itemData={ Type:0, Data:[], Start:null, End:null };
        for(var i=range.Start, j=0; i<=range.End && i<hisData.Data.length;++i)
        {
            var item=hisData.Data[i];
            if (currentTrend==1)
            {
                if (item.High >= currentPrice + blockSize)
                {
                    var count=parseInt((item.High-currentPrice)/blockSize);
                    for(j=0;j<count;++j)
                    {
                        currentPrice+=blockSize;
                        itemData.Data.push(currentPrice);
                    }
                }
                else
                {
                    if (item.Low <= currentPrice - (blockSize * reversal))
                    {
                        currentTrend=0;
                        if (itemData && IFrameSplitOperator.IsNonEmptyArray(itemData.Data))
                            oxData.Data.push(itemData);

                        itemData={ Type:1, Data:[], Start:null, End:null };
                        var count=parseInt((currentPrice-item.Low)/blockSize);
                        for(j=0;j<count;++j)
                        {
                            currentPrice-=blockSize;
                            itemData.Data.push(currentPrice);
                        }
                    }
                }
            }
            else
            {
                if (item.Low <= currentPrice - blockSize)
                {
                    var count=parseInt((currentPrice-item.Low)/blockSize);
                    for(j=0;j<count;++j)
                    {
                        currentPrice-=blockSize;
                        itemData.Data.push(currentPrice);
                    }
                }
                else
                {
                    if (item.High >= currentPrice + (blockSize*reversal))
                    {
                        currentTrend=1;
                        if (itemData && IFrameSplitOperator.IsNonEmptyArray(itemData.Data))
                            oxData.Data.push(itemData);

                        itemData={ Type:0, Data:[], Start:null, End:null };
                        var count=parseInt((item.High-currentPrice)/blockSize);
                        for(j=0;j<count;++j)
                        {
                            currentPrice+=blockSize;
                            itemData.Data.push(currentPrice);
                        }
                    }
                }
            }

            if (itemData.Start==null) itemData.Start=item;
            itemData.End=item;
        }

        if (itemData && IFrameSplitOperator.IsNonEmptyArray(itemData.Data))
            oxData.Data.push(itemData);

        return oxData;
    }

    this.BindData=function(hqChart,windowIndex,hisData)
    {
        var aryPaint=this.CreatePaints(hqChart,windowIndex);
        var isOverlay=this.IsOverlay();

        var event=hqChart.GetEventCallback(JSCHART_EVENT_ID.ON_CALCULATE_INDEX_OX)
        if (event && event.Callback)
        {
            var eventData={ HQChart:hqChart, WidnowIndex:windowIndex, HisData:hisData, OXData:null };
            event.Callback(event,eventData,this);
            aryPaint[0].OXData=eventData.OXData;
        }
        else
        {
            aryPaint[0].OXData=this.Calculate(hqChart, hisData);
        }
        
        var blockSize=this.BlockSize, reversal=this.GetParamValue("Reversal");
        var title=`${this.Name} BlockSize=${blockSize} Reversal=${reversal}`;
        var titleIndex=windowIndex+1;
        if (isOverlay) 
        {
            var titlePaint=hqChart.TitlePaint[titleIndex];
            var titleInfo={ Data:[], Title:'' };
            titlePaint.OverlayIndex.set(this.OverlayIndex.Identify,titleInfo);
        }
        else  
        {
            hqChart.TitlePaint[titleIndex].Title =title;
        }

        return true;
    }
}

//成交量分布图-可视范围
function VolProfileVisibleRangeIndex(option)
{
    this.newMethod=BaseIndex;   //派生
    this.newMethod('VRVR');
    delete this.newMethod;

    this.ClassName="VolProfileVisibleRangeIndex";
    this.IsUsePageData=true;
    this.ChartVolProfile;
    this.HQChart;
    this.WindowIndex;
    this.RequestTimer=null;
    this.DelayRequestFrequency=500;  //延迟请求数据

    this.VolType=0;         //0=up|down bar  1=total bar
    this.BarPosition=1;     //柱子方向 0=左边  1=右边
    this.BarWidthRate=0.3;

    this.Arguments=
    [
        { Name:"VAVol", Value:70 },
        { Name:"BarPosition", Value:0 }
    ];

    this.SetArgs=function(args)
    {
        if (!args || !IFrameSplitOperator.IsNonEmptyArray(args)) return;

        for(var i=0;i<args.length;++i)
        {
            var item=args[i];
            if (item.Name=="VAVol") this.SetParamValue(item.Name,item.Value);
            else if (item.Name=="BarPosition") this.SetParamValue(item.Name,item.Value);
        }
    }

    this.SetParamValue=function(name, value)
    {
        for(var i=0;i<this.Arguments.length;++i)
        {
            var item=this.Arguments[i];
            if (item.Name==name) item.Value=value;
        }
    }

    if (option)
    {
        if (IFrameSplitOperator.IsNumber(option.VolType)) this.VolType=option.VolType;
        if (IFrameSplitOperator.IsNumber(option.BarWidthRate)) this.BarWidthRate=option.BarWidthRate;
        if (IFrameSplitOperator.IsNumber(option.DelayRequestFrequency)) this.DelayRequestFrequency=option.DelayRequestFrequency;
        if (option.Args) this.SetArgs(option.Args);

        if (IFrameSplitOperator.IsNumber(option.BarPosition)) 
        {
            this.BarPosition=option.BarPosition;
            this.SetParamValue("BarPosition",this.BarPosition);
        }
    }


    this.GetParamValue=function(name)
    {
        for(var i=0;i<this.Arguments.length;++i)
        {
            var item=this.Arguments[i];
            if (item.Name==name) return item.Value;
        }
    }

    this.Create=function(hqChart,windowIndex)
    {
        this.HQChart=hqChart;
        this.WindowIndex=windowIndex;
    }

    this.CreateChart=function(hqChart,windowIndex)
    {
        var frame=null;
        var isOverlay=this.IsOverlay();
        if (isOverlay) 
        {
            frame=this.OverlayIndex.Frame.Frame;
            this.OverlayIndex.Frame.ChartPaint=[];    //清空
        }
        else 
        {
            frame=hqChart.Frame.SubFrame[windowIndex].Frame;
            hqChart.DeleteIndexPaint(windowIndex);  //清空
        }
        
        var aryPaint=[];
        var paint=new ChartVolProfileVisibleRange();
        paint.Canvas=hqChart.Canvas;
        paint.Name=this.Name+"-0";
        paint.ChartBorder=frame.ChartBorder;
        paint.ChartFrame=frame;
        paint.HQChart=this.HQChart;
        paint.Identify=this.Guid;
        paint.SetOption(this);

        if (isOverlay) this.OverlayIndex.Frame.ChartPaint.push(paint);
        else hqChart.ChartPaint.push(paint);

        aryPaint.push(paint);

        this.ChartVolProfile=paint;
    
        return aryPaint;
    }

    this.CancelRequestTimer=function()
    {
        if (this.RequestTimer) 
        {
            clearTimeout(this.RequestTimer);
            this.RequestTimer = null;
        }
    }

    //请求数据
    this.RequestData=function(hqChart,windowIndex,hisData, option)
    {
        this.CancelRequestTimer();

        var T_RequestData=()=>
        {
            //请求数据
            var klineChart=hqChart.ChartPaint[0];   //获取当前K线图实例
            var kData=klineChart.Data;              //K线数据
            if (!kData || IFrameSplitOperator.IsNonEmptyArray(!kData.Data)) return;

            var pageKRange=klineChart.DrawKRange;   //当前显示的K线索引
            if (!pageKRange || !IFrameSplitOperator.IsNumber(pageKRange.Start) || !IFrameSplitOperator.IsNumber(pageKRange.End)) return;

            var startKItem=kData.Data[pageKRange.Start];
            var endKItem=kData.Data[pageKRange.End];

            var option={ Start:{ Date:startKItem.Date, DataIndex:pageKRange.Start }, End:{ Date:endKItem.Date, DataIndex:pageKRange.End }, Chart:this };
            if (IFrameSplitOperator.IsNumber(startKItem.Time)) option.Start.Time=startKItem.Time;
            if (IFrameSplitOperator.IsNumber(endKItem.Time)) option.End.Time=endKItem.Time;
            option.ValueAreaVol=this.Arguments[0].Value;

            if (this.Arguments[1].Value>0)  this.BarPosition=1;
            else  this.BarPosition=0;

            if (this.ChartVolProfile)
            {
                this.ChartVolProfile.SetOption( { BarPosition:this.BarPosition} );
            }

            this.DataStatus=0
            if (hqChart && hqChart.RequestVolumeProfileData)
            {
                hqChart.RequestVolumeProfileData(option);
            }
        }

        if (option && option.Type==1)    //页面缩放或移动延迟更新
        {
            this.RequestTimer=setTimeout(function()
            {
                T_RequestData();
            }, this.DelayRequestFrequency);
        }
        else
        {
            T_RequestData();
        }

        return true;
    }

    this.OnRecvVolumeProfileData=function(data)
    {
        this.BindData(data);

        this.HQChart.UpdataDataoffset();           //更新数据偏移
        this.HQChart.UpdateFrameMaxMin();          //调整坐标最大 最小值
        this.HQChart.Draw();

        return true;
    }


    this.BindData=function(data)
    {
        if (!this.ChartVolProfile || this.ChartVolProfile.IsDestroy==true) this.CreateChart(this.HQChart, this.WindowIndex);

        var chart=this.ChartVolProfile;
        chart.Data=null;
        if (!data || !IFrameSplitOperator.IsNonEmptyArray(data.Data)) return;
        if (!IFrameSplitOperator.IsNumber(data.MaxPrice) || !IFrameSplitOperator.IsNumber(data.MinPrice)) return;

        var maxVol=0,vol=0;
        var maxVolPrice=null;
        for(var i=0, j=0;i<data.Data.length;++i)
        {
            var item=data.Data[i];
            vol=0;
            for(j=0; j<item.Vol.length;++j)
            {
                var volItem=item.Vol[j];
                if (IFrameSplitOperator.IsNumber(volItem.Value)) vol+=volItem.Value;
            }

            if (maxVol<vol) 
            {
                maxVol=vol;
                maxVolPrice=item.Price;
            }
        }

        if (this.maxVolPrice<=0 || this.maxVol<=0) return;

        chart.MaxVolPrice=maxVolPrice;
        chart.MaxVol=maxVol;
        chart.MaxPrice=data.MaxPrice;
        chart.MinPrice=data.MinPrice;
        chart.Data=data;

        var titleIndex=this.WindowIndex+1;
        this.HQChart.TitlePaint[titleIndex].Title ="VPVR";
        this.HQChart.TitlePaint[titleIndex].Identify=this.Guid;    //指标ID
        var titleData=new DynamicTitleData(chart.Data, "VPVR", chart.Data);
        titleData.ChartClassName="ChartVolProfileVisibleRange";
        titleData.Chart=chart;
        this.HQChart.TitlePaint[titleIndex].Data[0]=titleData;
    }
}


function JSIndex_CJL()
{
    this.newMethod=BaseIndex;   //派生
    this.newMethod('CJL');
    delete this.newMethod;

    this.Index=new Array(
        new IndexInfo("VOL",null),
        new IndexInfo("OPID",null),
    );

    this.Index[0].LineColor=g_JSChartResource.Index.LineColor[0];
    this.Index[1].LineColor=g_JSChartResource.Index.LineColor[1];

    this.CreateChart=function(id) 
    {
        if (id==0)
        {
            var chart=new ChartVolStick();
            return chart;
        }
        else if (id==1)
        {
            var chart = new ChartSubLine();
            chart.LineWidth = 1*GetDevicePixelRatio();
            return chart;
        }
    }

    //请求数据
    this.RequestData=function(hqChart,windowIndex,hisData)
    {
        this.BindData(hqChart,windowIndex,hisData);

        hqChart.UpdataDataoffset();           //更新数据偏移
        hqChart.UpdateFrameMaxMin();          //调整坐标最大 最小值
        hqChart.Draw();

        return true;
    }

    
    this.BindData=function(hqChart,windowIndex,hisData)
    {
        var paint=this.CreatePaints(hqChart,windowIndex);
        var isOverlay=this.IsOverlay();
        if (paint.length!=this.Index.length) return false;

        var vol=hisData.GetVol();
        var position=hisData.GetPosition();

        paint[0].HistoryData=hisData;
        paint[0].Data.Data=vol;
        paint[1].Data.Data=position;

        var titleIndex=windowIndex+1;

        if (isOverlay) 
        {
            var titlePaint=hqChart.TitlePaint[titleIndex];
            var titleInfo={ Data:[], Title:'' };
            titlePaint.OverlayIndex.set(this.OverlayIndex.Identify,titleInfo);
            for(var i in paint)
            {
                var titleData=new DynamicTitleData(paint[i].Data,this.Index[i].Name,this.Index[i].LineColor);
                titlePaint.OverlayIndex.get(this.OverlayIndex.Identify).Data[i]=titleData;
            }
        }
        else  
        {
            hqChart.TitlePaint[titleIndex].Data[0]=new DynamicTitleData(paint[0].Data,this.Index[0].Name,this.Index[0].LineColor);
            hqChart.TitlePaint[titleIndex].Data[1]=new DynamicTitleData(paint[1].Data,this.Index[1].Name,this.Index[1].LineColor);
            hqChart.TitlePaint[titleIndex].Title = this.Name;
        }

        return true;
    }
}

/*
    py指标 服务器端执行
*/
function PyScriptIndex(name,script,args,option)
{
    this.newMethod=BaseIndex;   //派生
    this.newMethod(name);
    delete this.newMethod;

    this.Script=script; //脚本
    this.Arguments=[];  //参数
    this.OutVar=[];     //输出数据
    this.ApiUrl=g_JSChartResource.PyIndexDomain+'/hq/code';
    if (args) this.Arguments=args;

    this.RequestData=function(hqChart,windowIndex,hisData)
    {
        this.OutVar=[];
        var self = this;
        var param=
        {
            HQChart:hqChart,
            WindowIndex:windowIndex,
            HistoryData:hisData
        };

        //参数
        var strParam='';
        for(let i in this.Arguments)
        {
            if (strParam.length>0) strParam+=',';
            var item=this.Arguments[i];
            strParam+='"'+item.Name+'"'+':'+item.Value;
        }
        strParam='{'+strParam+'}';
        var indexParam=JSON.parse(strParam);

        var data=JSON.stringify(
            {
                code:this.Script,   //脚本
                symbol:param.HQChart.Symbol,    //股票代码
                period:param.HQChart.Period,    //周期 0=日线 1=周线 2=月线 3=年线 4=1分钟 5=5分钟 6=15分钟 7=30分钟 8=60分钟
                right:param.HQChart.Right,      //复权 0 不复权 1 前复权 2 后复权
                params:indexParam,               //指标参数
                numcount:hqChart.MaxRequestDataCount,
            });

        //请求数据
        JSNetwork.HttpRequest({
            url: this.ApiUrl,
            data:data,
            type:"post",
            dataType: "json",
            contentType:' application/json; charset=utf-8',
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            },
            complete:function(h)
            {
                //JSConsole.Chart.Log(h);
            },
            error: function(http,e)
            {
                self.RecvError(http,e,param);;
                
            }
        });

        return true;
    }

    this.RecvError=function(http,e,param)
    {
        JSConsole.Chart.Log("[PyScriptIndex::RecvError] error",e);
        if (param.HQChart.ScriptErrorCallback) param.HQChart.ScriptErrorCallback(e);
    }

    this.RecvData=function(recvData,param)
    {
        if (recvData.code!=0) 
        {
            JSConsole.Chart.Log("[PyScriptIndex::RecvData] failed.", recvData);
            if (param.HQChart.ScriptErrorCallback) param.HQChart.ScriptErrorCallback(recvData.msg);
            return;   //失败了
        }

        JSConsole.Chart.Log('[PyScriptIndex::RecvData] recv data.',recvData);
        var aryDate=recvData.date;
        for(var i in recvData.data)
        {
            var item=recvData.data[i];
            var indexData=[];
            for(var j=0;j<aryDate.length && j<aryDate.length;++j)
            {
                if (j>=item.data.length) continue;
                var indexItem=new SingleData(); //单列指标数据
                indexItem.Date=aryDate[j];
                indexItem.Value=item.data[j];
                indexData.push(indexItem);
            }

            var aryFittingData=param.HistoryData.GetFittingData(indexData); //数据和主图K线拟合
            var bindData=new ChartData();
            bindData.Data=aryFittingData;
            bindData.Period=param.HQChart.Period;   //周期
            bindData.Right=param.HQChart.Right;     //复权

            var indexInfo={Name:item.name,Type:item.graph,LineWidth:item.width,Data:bindData.GetValue(),Color:item.color};
            this.OutVar.push(indexInfo);
        }

        this.BindData(param.HQChart,param.WindowIndex,param.HistoryData);   //把数据绑定到图形上

        param.HQChart.UpdataDataoffset();           //更新数据偏移
        param.HQChart.UpdateFrameMaxMin();          //调整坐标最大 最小值
        param.HQChart.Draw();
    }

    this.BindData=function(hqChart,windowIndex,hisData)
    {
        hqChart.DeleteIndexPaint(windowIndex); //清空指标图形

        for(let i in this.OutVar)
        {
            let item=this.OutVar[i];
            switch(item.Type)
            {
                case 'line':
                this.CreateLine(hqChart,windowIndex,item,i);
                break;
                case 'colorstick':  //上下柱子
                this.CreateColorStock(hqChart,windowIndex,item,i);
                break;
            }
        }

        var titleIndex=windowIndex+1;
        hqChart.TitlePaint[titleIndex].Title=this.Name; //这是指标名称

        let indexParam='';  //指标参数
        for(let i in this.Arguments)
        {
            let item=this.Arguments[i];
            if (indexParam.length>0) indexParam+=',';
            indexParam+=item.Value.toString();
        }
        if (indexParam.length>0) hqChart.TitlePaint[titleIndex].Title=this.Name+'('+indexParam+')';

        return true;
    }

    this.CreateLine=function(hqChart,windowIndex,varItem,id)
    {
        let line=new ChartLine();
        line.Canvas=hqChart.Canvas;
        line.DrawType=1;
        line.Name=varItem.Name;
        line.ChartBorder=hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
        line.ChartFrame=hqChart.Frame.SubFrame[windowIndex].Frame;
        if (varItem.Color) line.Color=varItem.Color;
        else line.Color=this.GetDefaultColor(id);

        if (varItem.LineWidth>0) line.LineWidth=varItem.LineWidth;
        if (varItem.IsShow==false) line.IsShow=false;
        
        let titleIndex=windowIndex+1;
        line.Data.Data=varItem.Data;
        hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(line.Data,varItem.Name,line.Color);

        hqChart.ChartPaint.push(line);
    }

    this.CreateColorStock=function(hqChart,windowIndex,varItem,id)
    {
        let chart=new ChartMACD();
        chart.Canvas=hqChart.Canvas;

        chart.Name=varItem.Name;
        chart.ChartBorder=hqChart.Frame.SubFrame[windowIndex].Frame.ChartBorder;
        chart.ChartFrame=hqChart.Frame.SubFrame[windowIndex].Frame;

        let titleIndex=windowIndex+1;
        chart.Data.Data=varItem.Data;
        hqChart.TitlePaint[titleIndex].Data[id]=new DynamicTitleData(chart.Data,varItem.Name,this.GetDefaultColor(id));

        hqChart.ChartPaint.push(chart);
    }

    //给一个默认的颜色
    this.GetDefaultColor=function(id)
    {
        let COLOR_ARRAY=
        [
            "rgb(255,174,0)",
            "rgb(25,199,255)",
            "rgb(175,95,162)",
            "rgb(236,105,65)",
            "rgb(68,114,196)",
            "rgb(229,0,79)",
            "rgb(0,128,255)",
            "rgb(252,96,154)",
            "rgb(42,230,215)",
            "rgb(24,71,178)",
        ];

        let number=parseInt(id);
        return COLOR_ARRAY[number%(COLOR_ARRAY.length-1)];
    }

}



/*
    json格式数据指标 用来显示本地数据
*/
function JsonDataIndex(name,script,args,option)
{
    this.newMethod=PyScriptIndex;   //派生
    this.newMethod(name);
    delete this.newMethod;

    this.JsonData;  //json格式数据
    if (option.JsonData) this.JsonData=option.JsonData;

    this.RequestData=function(hqChart,windowIndex,hisData)
    {
        if (!this.JsonData)
        {
            console.warn("[PyScriptIndex::RequestData] JsonData is null");
            if (param.HQChart.ScriptErrorCallback) param.HQChart.ScriptErrorCallback('json 数据不能为空');
        }
        else
        {
            var param=
            {
                HQChart:hqChart,
                WindowIndex:windowIndex,
                HistoryData:hisData
            };

            this.JsonData.code=0;
            var recvData=this.JsonData;
            this.RecvData(recvData,param);
        }
    }

}

//给一个默认的颜色
PyScriptIndex.prototype.GetDefaultColor=function(id)
{
    let COLOR_ARRAY=
    [
        "rgb(255,174,0)",
        "rgb(25,199,255)",
        "rgb(175,95,162)",
        "rgb(236,105,65)",
        "rgb(68,114,196)",
        "rgb(229,0,79)",
        "rgb(0,128,255)",
        "rgb(252,96,154)",
        "rgb(42,230,215)",
        "rgb(24,71,178)",
    ];

    let number=parseInt(id);
    return COLOR_ARRAY[number%(COLOR_ARRAY.length-1)];
}


/*
    信息地雷
*/

/*
    信息地雷列表
*/
function JSKLineInfoMap()
{
}

JSKLineInfoMap.Get=function(id)
{
    var infoMap=new Map(
        [
            ["互动易",      {Create:function(){ return new InvestorInfo()}  }],
            ["公告",        {Create:function(){ return new AnnouncementInfo()}  }],
            ["业绩预告",    {Create:function(){ return new PforecastInfo()}  }],
            ["调研",        {Create:function(){ return new ResearchInfo()}  }],
            ["大宗交易",    {Create:function(){ return new BlockTrading()}  }],
            ["龙虎榜",      {Create:function(){ return new TradeDetail()}  }]
        ]
        );

    return infoMap.get(id);
}

JSKLineInfoMap.GetClassInfo=function(id)
{
    var infoMap=new Map(
        [
            ["互动易",      { ClassName:"InvestorInfo" }],
            ["公告",        { ClassName:"AnnouncementInfo" }],
            ["业绩预告",    { ClassName:"PforecastInfo" } ],
            ["调研",        { ClassName:"ResearchInfo"  }],
            ["大宗交易",    { ClassName:"BlockTrading"  }],
            ["龙虎榜",      { ClassName:"TradeDetail"}  ]
        ]
        );

    return infoMap.get(id);
}

JSKLineInfoMap.GetIconUrl=function(type)
{     
    switch(type)
    {
        case KLINE_INFO_TYPE.INVESTOR:
            return g_JSChartResource.KLine.Info.Investor.Icon;
            break;
        case KLINE_INFO_TYPE.PFORECAST:
            return g_JSChartResource.KLine.Info.Pforecast.Icon;
        case KLINE_INFO_TYPE.ANNOUNCEMENT:
            return g_JSChartResource.KLine.Info.Announcement.Icon;
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_1:
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_2:
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_3:
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_4:
            return g_JSChartResource.KLine.Info.Announcement.IconQuarter;
        case KLINE_INFO_TYPE.RESEARCH:
            return g_JSChartResource.KLine.Info.Research.Icon;
        case KLINE_INFO_TYPE.BLOCKTRADING:
            return g_JSChartResource.KLine.Info.BlockTrading.Icon;
        case KLINE_INFO_TYPE.TRADEDETAIL:
            return g_JSChartResource.KLine.Info.TradeDetail.Icon;
        default:
            return g_JSChartResource.KLine.Info.Announcement.Icon;
    }
}

JSKLineInfoMap.GetIconLibrary=function(index)
{
    var iconLib=g_JSChartResource.KLine.Info.IconLibrary;
    if (!iconLib || !iconLib.Icon) return g_JSChartResource.KLine.Info.Announcement.IconFont;

    if (index>=0 && index<iconLib.Icon.length)
    {
        var item=iconLib.Icon[index];
        var obj={ Text:item.Text, HScreenText:item.HScreenText, Color:item.Color, Family:iconLib.Family };
        return obj;
    }

    return g_JSChartResource.KLine.Info.Announcement.IconFont;
}

JSKLineInfoMap.GetIconFont=function(type)
{
    //公告扩展数据
    if (type>=KLINE_INFO_TYPE.ANNOUNCEMENT_EX_START && type<=KLINE_INFO_TYPE.ANNOUNCEMENT_EX_END)
    {
        var index=type-KLINE_INFO_TYPE.ANNOUNCEMENT_EX_START;
        return JSKLineInfoMap.GetIconLibrary(index);
    }

    switch(type)
    {
        case KLINE_INFO_TYPE.INVESTOR:
            return g_JSChartResource.KLine.Info.Investor.IconFont;
            break;
        case KLINE_INFO_TYPE.PFORECAST:
            return g_JSChartResource.KLine.Info.Pforecast.IconFont;
        case KLINE_INFO_TYPE.ANNOUNCEMENT:
            return g_JSChartResource.KLine.Info.Announcement.IconFont;
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_1:
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_2:
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_3:
        case KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_4:
            return g_JSChartResource.KLine.Info.Announcement.IconFont2;
        case KLINE_INFO_TYPE.RESEARCH:
            return g_JSChartResource.KLine.Info.Research.IconFont;
        case KLINE_INFO_TYPE.BLOCKTRADING:
            return g_JSChartResource.KLine.Info.BlockTrading.IconFont;
        case KLINE_INFO_TYPE.TRADEDETAIL:
            return g_JSChartResource.KLine.Info.TradeDetail.IconFont;
        default:
            return g_JSChartResource.KLine.Info.Announcement.IconFont;
    }
}


function IKLineInfo()
{
    this.MaxRequestDataCount=1000;
    this.StartDate=20160101;
    this.Data;
    this.ClassName='IKLineInfo';
    this.Explain="IKLineInfo";

    this.GetToday=function()
    {
        var date=new Date();
        var today=date.getFullYear()*10000+(date.getMonth()+1)*100+date.getDate();
        return today;
    }

    this.GetRequestData=function(hqChart)
    {
        var obj=
        { 
            Symbol:hqChart.Symbol ,
            MaxRequestDataCount: hqChart.MaxRequestDataCount,            //日线数据个数
            MaxRequestMinuteDayCount:hqChart.MaxRequestMinuteDayCount,    //分钟数据请求的天数
            Period:hqChart.Period       //周期
        };

        //K线数据范围
        var hisData=null;
        if (hqChart.ChartOperator_Temp_GetHistroyData)  hisData=hqChart.ChartOperator_Temp_GetHistroyData();
        if (hisData)
            obj.DateRange=hisData.GetDateRange();
        
        return obj;
    }

    this.NetworkFilter=function(hqChart,callInfo)
    {
        if (!hqChart.NetworkFilter) return false;

        var self=this;

        var param=
        {
            HQChart:hqChart,
        };

        var obj=
        {
            Name:`${this.ClassName}::RequestData`, //类名::函数
            Explain:this.Explain,
            Request:this.GetRequestData(hqChart), 
            Self:this,
            HQChart:hqChart,
            PreventDefault:false
        };

        if (callInfo) 
        {
            if (callInfo.Update==true) 
            {
                obj.Update={ Start:{ Date: callInfo.StartDate } };
                param.Update={ Start:{ Date: callInfo.StartDate } };
            }

            obj.CallFunctionName=callInfo.FunctionName; //内部调用函数名
        }

        hqChart.NetworkFilter(obj, function(data) 
        { 
            self.RecvData(data,param);
        });

        if (obj.PreventDefault==true) return true;   //已被上层替换,不调用默认的网络请求
        
        return false;
    }
}



//互动易
function InvestorInfo()
{
    this.newMethod=IKLineInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='InvestorInfo';
    this.Explain='互动易'
    this.RequestData=function(hqChart, obj)
    {
        var self = this;
        var param=
        {
            HQChart:hqChart,
        };

        this.Data=[];
        if (this.NetworkFilter(hqChart,obj)) return; //已被上层替换,不调用默认的网络请求

        var postData=
        {
            filed: ["question","answerdate","symbol","id"],
            symbol: [param.HQChart.Symbol],
            querydate:{"StartDate":this.StartDate,"EndDate":this.GetToday()},
            start:0,
            end:this.MaxRequestDataCount,
        };

        //请求数据
        var url=g_JSChartResource.Domain+g_JSChartResource.KLine.Info.Investor.ApiUrl;
        JSNetwork.HttpRequest({
            url: url,
            data:postData,
            type:"post",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            }
        });

        return true;
    }

    this.RecvData=function(recvData,param)
    {
        if (recvData.list.length<=0) return;

        for(var i in recvData.list)
        {
            var item=recvData.list[i];
            var infoData=new KLineInfoData();
            infoData.Date=item.answerdate;
            infoData.Title=item.question;
            infoData.InfoType=KLINE_INFO_TYPE.INVESTOR;
            this.Data.push(infoData);
        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }
}


//公告 支持增量更新
function AnnouncementInfo()
{
    this.newMethod=IKLineInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='AnnouncementInfo';
    this.Explain='公告';
    this.ApiType=1; //0=读API 1=读OSS缓存文件

    this.RequestData=function(hqChart,obj)
    {
        var self = this;
        var param=
        {
            HQChart:hqChart,
        };

        if (obj && obj.Update===true)   //更新模式 不清内存数据
        {

        }
        else
        {
            this.Data=[];
        }

        if (this.NetworkFilter(hqChart, obj)) return; //已被上层替换,不调用默认的网络请求

        if (this.ApiType==1)    //取缓存文件
        {
            var url=`${g_JSChartResource.CacheDomain}/cache/analyze/shszreportlist/${param.HQChart.Symbol}.json`;
            JSNetwork.HttpRequest({
                url: url,
                type:"get",
                dataType: "json",
                async:true,
                success: function (recvData)
                {
                    self.RecvData(recvData,param);
                },
                error: function(http,e)
                {
                    self.RecvError(http,e,param);;
                }
            });
        }
        else    //取api
        {
            //请求数据
            var url=g_JSChartResource.Domain+g_JSChartResource.KLine.Info.Announcement.ApiUrl;
            JSNetwork.HttpRequest({
                url: url,
                data:
                {
                    "filed": ["title","releasedate","symbol","id"],
                    "symbol": [param.HQChart.Symbol],
                    "querydate":{"StartDate":this.StartDate,"EndDate":this.GetToday()},
                    "start":0,
                    "end":this.MaxRequestDataCount,
                },
                type:"post",
                dataType: "json",
                async:true,
                success: function (recvData)
                {
                    self.RecvData(recvData,param);
                },
                error: function(http,e)
                {
                    self.RecvError(http,e,param);;
                }
            });

        }
    }

    this.RecvData=function(recvData,param)
    {
        if (!IFrameSplitOperator.IsNonEmptyArray(recvData.report)) return;

        var aryReport=[];
        for(var i=0;i<recvData.report.length; ++i)
        {
            var item=recvData.report[i];
            var infoData=new KLineInfoData();
            infoData.Date=item.releasedate;
            infoData.Title=item.title;
            infoData.InfoType=KLINE_INFO_TYPE.ANNOUNCEMENT;
            if (IFrameSplitOperator.IsNumber(item.time)) infoData.Time=item.time;
            for(var j in item.type)
            {
                var typeItem=item.type[j];
                switch(typeItem)
                {
                    case "一季度报告":
                        infoData.InfoType=KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_1;
                        break;
                    case "半年度报告":
                        infoData.InfoType=KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_2;
                        break;
                    case "三季度报告":
                        infoData.InfoType=KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_3;
                        break;
                    case "年度报告":
                        infoData.InfoType=KLINE_INFO_TYPE.ANNOUNCEMENT_QUARTER_4;
                        break;
                }
            }

            //目前只支持1个类型
            for(var j in item.typeex)
            {
                var id=item.typeex[j];
                infoData.InfoType=KLINE_INFO_TYPE.ANNOUNCEMENT_EX_START+id;
                break;
            }

            aryReport.push(infoData);
        }

        if (recvData.Update===true && this.Data.length>0)
        {
            this.UpdateData(aryReport);
        }
        else
        {
            this.Data=aryReport;
        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }

    //增量更新
    this.UpdateData=function(aryData)
    {
        if (!aryData || aryData.length<=0) return;

        var setKeys=new Set();  //通过 日期+类型+标题去重
        for(var i in this.Data)
        {
            var item=this.Data[i];
            var strKey=`${item.Date}-${item.Time}-${item.InfoType}-${item.Title}`;
            setKeys.add(strKey);
        }

        var count=0;
        for(var i in aryData)
        {
            var item=aryData[i];
            var strKey=`${item.Date}-${item.Time}-${item.InfoType}-${item.Title}`;
            if (setKeys.has(strKey)) continue;

            this.Data.push(item);
            ++count;
        }

        JSConsole.Chart.Log(`[AnnouncementInfo::UpdateData] add new count=${count}`);
    }

    this.RecvError=function(http,e,param)
    {
        console.warn("[AnnouncementInfo::RecvError] error, http ",e, http);
        //if (param.HQChart.ScriptErrorCallback) param.HQChart.ScriptErrorCallback(e);
    }
}



 //业绩预告
function PforecastInfo()
{
    this.newMethod=IKLineInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='PforecastInfo';
    this.Explain='业绩预告';

    this.RequestData=function(hqChart,obj)
    {
        var self = this;
        var param=
        {
            HQChart:hqChart,
        };

        this.Data=[];

        var url=g_JSChartResource.Domain+g_JSChartResource.KLine.Info.Pforecast.ApiUrl;

        if (this.NetworkFilter(hqChart, obj)) return; //已被上层替换,不调用默认的网络请求

        //请求数据
        JSNetwork.HttpRequest({
            url: url,
            data:
            {
                "field": ["pforecast.type","pforecast.reportdate","fweek"],
                "condition":
                [
                    {"item":["pforecast.reportdate","int32","gte",this.StartDate]}
                ],
                "symbol": [param.HQChart.Symbol],
                "start":0,
                "end":this.MaxRequestDataCount,
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            }
        });

        return true;
    }

    this.RecvData=function(recvData,param)
    {
        if (recvData.stock.length!=1) return;
        if (recvData.stock[0].stockday.length<=0) return;

        for(var i in recvData.stock[0].stockday)
        {
            var item=recvData.stock[0].stockday[i];
            if (item.pforecast.length>0)
            {
                var dataItem=item.pforecast[0];
                var infoData=new KLineInfoData();
                infoData.Date= item.date;
                infoData.Title=dataItem.type;
                infoData.InfoType=KLINE_INFO_TYPE.PFORECAST;
                infoData.ExtendData={ Type:dataItem.type, ReportDate:dataItem.reportdate}
                if(item.fweek)  //未来周涨幅
                {
                    infoData.ExtendData.FWeek={};
                    if (item.fweek.week1!=null) infoData.ExtendData.FWeek.Week1=item.fweek.week1;
                    if (item.fweek.week4!=null) infoData.ExtendData.FWeek.Week4=item.fweek.week4;
                }
                this.Data.push(infoData);
            }
        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }
}


//投资者关系 (调研)
function ResearchInfo()
{
    this.newMethod=IKLineInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='ResearchInfo';
    this.Explain='调研';

    this.RequestData=function(hqChart,obj)
    {
        var self = this;
        var param=
        {
            HQChart:hqChart
        };

        this.Data=[];
        var url=g_JSChartResource.Domain+g_JSChartResource.KLine.Info.Research.ApiUrl;

        if (this.NetworkFilter(hqChart, obj)) return; //已被上层替换,不调用默认的网络请求

        //请求数据
        JSNetwork.HttpRequest({
            url: url,
            data:
            {
                "filed": ["releasedate","researchdate","level","symbol","id",'type'],
                "querydate":{"StartDate":this.StartDate,"EndDate":this.GetToday()},
                "symbol": [param.HQChart.Symbol],
                "start":0,
                "end":this.MaxRequestDataCount,
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            }
        });

        return true;
    }

    this.RecvData=function(recvData,param)
    {
        if (recvData.list.length<=0) return;

        for(var i in recvData.list)
        {
            var item=recvData.list[i];
            var infoData=new KLineInfoData();
            infoData.ID=item.id;
            infoData.Date= item.researchdate;
            infoData.InfoType=KLINE_INFO_TYPE.RESEARCH;
            infoData.ExtendData={ Level:item.level , Type:item.type};
            this.Data.push(infoData);

        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }
}


//大宗交易
function BlockTrading()
{
    this.newMethod=IKLineInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='BlockTrading';
    this.Explain='大宗交易';

    this.RequestData=function(hqChart,obj)
    {
        var self = this;
        var param=
        {
            HQChart:hqChart
        };

        this.Data=[];
        var url=g_JSChartResource.Domain+g_JSChartResource.KLine.Info.BlockTrading.ApiUrl;

        if (this.NetworkFilter(hqChart, obj)) return; //已被上层替换,不调用默认的网络请求

        //请求数据
        JSNetwork.HttpRequest({
            url: url,
            data:
            {
                "field": ["blocktrading.price","blocktrading.vol","blocktrading.premium","fweek","price"],
                "condition":
                [
                    {"item":["date","int32","gte",this.StartDate]},
                    {"item":["blocktrading.vol","int32","gte","0"]}
                ],
                "symbol": [param.HQChart.Symbol],
                "start":0,
                "end":this.MaxRequestDataCount,
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            }
        });

        return true;
    }

    this.RecvData=function(recvData,param)
    {
        if (recvData.stock.length!=1) return;
        if (recvData.stock[0].stockday.length<=0) return;

        for(var i in recvData.stock[0].stockday)
        {
            var item=recvData.stock[0].stockday[i];
            var infoData=new KLineInfoData();
            infoData.Date= item.date;
            infoData.InfoType=KLINE_INFO_TYPE.BLOCKTRADING;
            infoData.ExtendData=
            {
                Price:item.blocktrading.price,          //交易价格
                Premium:item.blocktrading.premium,      //溢价 （百分比%)
                Vol:item.blocktrading.vol,              //交易金额单位（万元)
                ClosePrice:item.price,                  //收盘价
            };

            if(item.fweek)  //未来周涨幅
            {
                infoData.ExtendData.FWeek={};
                if (item.fweek.week1!=null) infoData.ExtendData.FWeek.Week1=item.fweek.week1;
                if (item.fweek.week4!=null) infoData.ExtendData.FWeek.Week4=item.fweek.week4;
            }

            this.Data.push(infoData);
        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }
}



//龙虎榜
function TradeDetail()
{
    this.newMethod=IKLineInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='TradeDetail';
    this.Explain='大宗交易';
    
    this.RequestData=function(hqChart, obj)
    {
        var self = this;
        var param=
        {
            HQChart:hqChart
        };

        this.Data=[];
        var url=g_JSChartResource.Domain+g_JSChartResource.KLine.Info.TradeDetail.ApiUrl;

        if (this.NetworkFilter(hqChart, obj)) return; //已被上层替换,不调用默认的网络请求

        //请求数据
        JSNetwork.HttpRequest({
            url: url,
            data:
            {
                "field": ["tradedetail.typeexplain","tradedetail.type","fweek"],
                "condition":
                [
                    {"item":["date","int32","gte",this.StartDate]},
                    {"item":["tradedetail.type","int32","gte","0"]}
                ],
                "symbol": [param.HQChart.Symbol],
                "start":0,
                "end":this.MaxRequestDataCount,
            },
            type:"post",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            }
        });

        return true;
    }

    this.RecvData=function(recvData,param)
    {
        if (recvData.stock.length!=1) return;
        if (recvData.stock[0].stockday.length<=0) return;

        for(var i in recvData.stock[0].stockday)
        {
            var item=recvData.stock[0].stockday[i];

            var infoData=new KLineInfoData();
            infoData.Date= item.date;
            infoData.InfoType=KLINE_INFO_TYPE.TRADEDETAIL;
            infoData.ExtendData={Detail:new Array()};

            for(var j in item.tradedetail)
            {
                var tradeItem=item.tradedetail[j]; 
                infoData.ExtendData.Detail.push({"Type":tradeItem.type,"TypeExplain":tradeItem.typeexplain});
            }

            if(item.fweek)  //未来周涨幅
            {
                infoData.ExtendData.FWeek={};
                if (item.fweek.week1!=null) infoData.ExtendData.FWeek.Week1=item.fweek.week1;
                if (item.fweek.week4!=null) infoData.ExtendData.FWeek.Week4=item.fweek.week4;
            }

            this.Data.push(infoData);
        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }
}

function JSMinuteInfoMap()
{
    
}

JSMinuteInfoMap.InfoMap=new Map(
[
    ["大盘异动",      {Create:function(){ return new MarketEventInfo()}  }],
]);

JSMinuteInfoMap.Get=function(id)
{
    return JSMinuteInfoMap.InfoMap.get(id);
}

function IMinuteInfo()
{
    this.Data;
    this.ClassName='IMinuteInfo';
}

//////////////////////////////////////////////////////////////////////
//  大盘异动
// 结构 {Date:日期 Time:时间, Title:标题, Type:0 }
////////////////////////////////////////////////////////////////////
function MarketEventInfo()
{
    this.newMethod=IMinuteInfo;   //派生
    this.newMethod();
    delete this.newMethod;

    this.ClassName='MarketEventInfo';

    this.RequestData=function(hqChart)
    {
        var self = this;
        this.Data=[];
        var param=
        {
            HQChart:hqChart
        };

        var url=g_JSChartResource.CacheDomain+'/cache/analyze/shszevent/marketevent/concept/'+hqChart.TradeDate+'.json';

        if (hqChart.NetworkFilter)
        {
            var obj=
            {
                Name:'MarketEventInfo::RequestData', //类名::
                Explain:'大盘异动',
                Request:{ Url:url, Type:'Get', Data: { Date:hqChart.TradeDate, Symbol:hqChart.Symbol } }, 
                Self:this,
                PreventDefault:false
            };
            hqChart.NetworkFilter(obj, function(data) 
            { 
                self.RecvData(data,param);
                param.HQChart.UpdataChartInfo();
                param.HQChart.Draw();
            });

            if (obj.PreventDefault==true) return;   //已被上层替换,不调用默认的网络请求
        }

        //请求数据
        JSNetwork.HttpRequest({
            url: url,
            type:"get",
            dataType: "json",
            async:true,
            success: function (recvData)
            {
                self.RecvData(recvData,param);
            },
            error: function(http,e)
            {
                console.warn("[MarketEventInfo::RequestData] error, http ",e, http);
            }
        });

        return true;
    }

    this.RecvData=function(recvData,param)
    {
        for(var i in recvData.event)
        {
            var event=recvData.event[i];
            for(var j in event.data)
            {
                var item=event.data[j];
                if (Array.isArray(item))
                {
                    if (item.length<2) continue; 
                    var info={Date:event.date, Time:item[0], Title:item[1], Type:0};
                    if (item.length>=3 && item[2] && typeof(item[2])=='string') info.Color=item[2];  //[3]=字体颜色
                    if (item.length>=4 && item[3] && typeof(item[3])=='string') info.BGColor=item[3];  //[3]=背景颜色
                    this.Data.push(info);
                }
                else    //新格式
                {
                    if (!IFrameSplitOperator.IsNumber(item.Date) || !IFrameSplitOperator.IsNumber(item.Time) || !item.Title) continue;
                    var info={ Date:item.Date, Time:item.Time, Title:item.Title, Type:0 };
                    if (item.Color) info.Color=item.Color;
                    if (item.BGColor) info.BGColor=item.BGColor;
                    if (IFrameSplitOperator.IsNumber(item.Price)) info.Price=item.Price;
                    if (item.Content) info.Content=item.Content;
                    if (item.Link) info.Link=item.Link;
                    this.Data.push(info);
                }
            }
        }

        param.HQChart.UpdataChartInfo();
        param.HQChart.Draw();
    }
}


//注意！！！ 这个函数已经不用了
//是否是指数代码
function IsIndexSymbol(symbol)
{
    var upperSymbol=symbol.toUpperCase();
    if (upperSymbol.indexOf('.SH')>0)
    {
        upperSymbol=upperSymbol.replace('.SH','');
        if (upperSymbol.charAt(0)=='0' && parseInt(upperSymbol)<=3000) return true;

    }
    else if (upperSymbol.indexOf('.SZ')>0)
    {
        upperSymbol=upperSymbol.replace('.SZ','');
        if (upperSymbol.charAt(0)=='3' && upperSymbol.charAt(1)=='9') return true;
    }
    else if (upperSymbol.indexOf('.CI')>0)  //自定义指数
    {
        return true;
    }

    return false;
}

//注意！！！ 这个函数已经不用了
//是否是基金代码
function IsFundSymbol(symbol)
{
    if (!symbol) return false;

    var upperSymbol=symbol.toUpperCase();
    if (upperSymbol.indexOf('.SH')>0)
    {
        upperSymbol=upperSymbol.replace('.SH','');  //51XXXX.sh
        if (upperSymbol.charAt(0)=='5' && upperSymbol.charAt(1)=='1') return true;
    }
    else if (upperSymbol.indexOf('.SZ')>0)
    {
        upperSymbol=upperSymbol.replace('.SZ','');  //15XXXX.sz, 16XXXX.sz, 17XXXX.sz, 18XXXX.sz
        if (upperSymbol.charAt(0)=='1' && 
            (upperSymbol.charAt(1)=='5' || upperSymbol.charAt(1)=='6' || upperSymbol.charAt(1)=='7' || upperSymbol.charAt(1)=='8') ) return true;
    }

    return false;
}

//设置对话框工厂类
function DialogFactory()
{
    //[key:name, { Create:function(divElement) { return new class(divElement); }} ]
    this.DataMap=new Map(
    [
        ["ChartPictureSettingMenu", { Create:function(divElement) { return new ChartPictureSettingMenu(divElement); } }],
        ["ChartPictureTextSettingMenu", { Create:function(divElement) { return new ChartPictureTextSettingMenu(divElement); } }]
    ]); 

    this.Create=function(name, option)
    {
        if (!this.DataMap.has(name)) 
        {
            JSConsole.Warn(`[DialogFactory::Create] can't find class=${name}.`);
            return null;
        }

        var item=this.DataMap.get(name);
        return item.Create(option);
    }

    this.Add=function(name, option)
    {
        this.DataMap.set(name, { Create:option.Create } );
    }
}

var g_DialogFactory=new DialogFactory();

//设置窗口基类
function IDivDialog(divElement)
{
    this.DivElement=divElement;     //父节点
    this.ID=null;                   //div id
    this.TimeOut=null;              //定时器

    //隐藏窗口
    this.Hide=function()
    {
        $("#"+this.ID).hide();
    }

    //显示窗口
    this.Show=function(left,top,width,height)
    {
        var cssData={display:'block'};
        if (IFrameSplitOperator.IsNumber(left)) cssData.left=left+'px';
        if (IFrameSplitOperator.IsNumber(top)) cssData.top=top+'px';
        if (IFrameSplitOperator.IsNumber(width)) cssData.width=width+'px';
        if (IFrameSplitOperator.IsNumber(height)) cssData.height=height+'px';

        $("#"+this.ID).css(cssData);
    }
}


//修改指标
function ModifyIndexDialog(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.Title={ ID:Guid() };      //标题
    this.ParamList={ID:Guid() };   //参数列表  class='parameter-content'
    this.ParamData=[];              //{ ID:参数ID, Value:参数值}
    this.Identify;
    this.HQChart;
    this.IsOverlay=false;           //是否是叠加指标

    this.IndexScript;

    //创建
    this.Create=function()
    {
        this.ID=Guid();

        var div=document.createElement('div');
        div.className='jchart-modifyindex-box';
        div.id=this.ID;
        div.innerHTML=
        "<div class='parameter'>\
            <div class='parameter-header'>\
                <span></span>\
                <strong id='close' class='icon iconfont icon-close'></strong>\
            </div>\
            <div class='parameter-content'><input/>MA</div>\
            <div class='parameter-footer'>\
                <button class='submit' >确定</button>\
                <button class='cancel' >取消</button>\
            </div>\
        </div>";

        this.DivElement.appendChild(div);

        //确定按钮
        $("#"+this.ID+" .submit").click(
            {
                divBox:this,
            },
            function(event)
            {
                event.data.divBox.Hide();
            });

        //给一个id 后面查找方便
        var titleElement=div.getElementsByTagName('span')[0];
        titleElement.id=this.Title.ID;

        var paramListElement=div.getElementsByClassName('parameter-content')[0];
        paramListElement.id=this.ParamList.ID;
    }

    //设置标题
    this.SetTitle=function(title)
    {
        $("#"+this.Title.ID).html(title);
    }

    //清空参数
    this.ClearParamList=function()
    {
        $("#"+this.ParamList.ID).empty();
        this.ParamData=[];
    }

    this.BindParam=function()
    {
        for(var i=0; i<this.IndexScript.Arguments.length; ++i)
        {
            var item=this.IndexScript.Arguments[i];
            if (item.Name==null || isNaN(item.Value)) break;

            var guid=Guid();
            var param = '<input class="row-line" id="'+guid+'" value="'+item.Value+'" type="number" step="1"/>'+ item.Name +'<br>';
            $("#"+this.ParamList.ID).append(param);

            this.ParamData.push({ID:guid,Value:item.Value});
        }

        //绑定参数修改事件
        var self=this;
        for(var i=0; i<this.ParamData.length; ++i)
        {
            var item=this.ParamData[i];
            $("#"+item.ID).mouseup(
                {
                    ParamIndex:i   //参数序号
                },
                function(event)
                {
                    var value = parseInt($(this).val());                            //获取当前操作的input属性值，转化为整型
                    if (!IFrameSplitOperator.IsNumber(value)) 
                    {
                        alert("参数不能为空");
                        return;
                    }
                    var chart=self.HQChart;
                    var identify=self.Identify;
                    var paramIndex=event.data.ParamIndex;
                    var script=self.IndexScript;
                    var isOverlay=self.IsOverlay;

                    script.Arguments[paramIndex].Value = value;         //为参数属性重新赋值
                    if (isOverlay) chart.UpdateOverlayIndex(identify);
                    else chart.UpdateWindowIndex(identify);              //调用更新窗口指标函数，参数用来定位窗口
                }
            )

            $("#"+item.ID).keyup(
                {
                    ParamIndex:i   //参数序号
                },
                function(event)
                {
                    var value = parseInt($(this).val());                            //获取当前操作的input属性值，转化为整型
                    if (!IFrameSplitOperator.IsNumber(value)) 
                    {
                        alert("参数不能为空");
                        return;
                    }
                    var chart=self.HQChart;
                    var identify=self.Identify;
                    var paramIndex=event.data.ParamIndex;
                    var script=self.IndexScript;
                    var isOverlay=self.IsOverlay;

                    script.Arguments[paramIndex].Value = value;    //为参数属性重新赋值
                    if (isOverlay) chart.UpdateOverlayIndex(identify);
                    else chart.UpdateWindowIndex(identify);                              //调用更新窗口指标函数，参数用来定位窗口
                }
            )
        }
    }

    //绑定取消事件
    this.BindCancel=function()
    {
        //取消按钮事件
        var self=this;
        var test=$("#"+this.ID+" .cancel");
        $("#"+this.ID+" .cancel").unbind("click").click(
            function(event)
            {
                var chart=self.HQChart;
                var identify=self.Identify;
                self.RestoreParam();
                var isOverlay=self.IsOverlay;
                if (isOverlay) chart.UpdateOverlayIndex(identify);
                else chart.UpdateWindowIndex(identify);
                self.IndexScript=null;
                self.Hide();
            }
        );

        //关闭和取消是一样的
        $("#"+this.ID+" #close").unbind("click").click(
            function(event)
            {
                var chart=self.HQChart;
                var identify=self.Identify;
                var isOverlay=self.IsOverlay;
                self.RestoreParam();
                if (isOverlay) chart.UpdateOverlayIndex(identify);
                else chart.UpdateWindowIndex(identify);
                self.IndexScript=null;
                self.Hide();
            }
        );
    }

    //还原参数
    this.RestoreParam=function()
    {
        if (!this.IndexScript) return;

        for(var i=0; i<this.ParamData.length; ++i)
        {
            var item=this.ParamData[i];
            this.IndexScript.Arguments[i].Value=item.Value;
        }
    }

    //显示
    this.DoModal=function(event)
    {
        var chart=event.data.Chart;
        var identify=event.data.Identify;
        var dialog=chart.ModifyIndexDialog;
        var isOverlay=event.data.IsOverlay===true;

        if(!dialog) return;

        if (dialog.ID==null) dialog.Create();   //第1次 需要创建div
        dialog.Identify=identify;
        dialog.HQChart=chart;
        dialog.IsOverlay=isOverlay

        if (isOverlay)
        {
            var overlayIndex=chart.GetOverlayIndexByIdentify(identify);
            if (!overlayIndex || !overlayIndex.OverlayItem.Script) return;
            dialog.IndexScript=overlayIndex.OverlayItem.Script;
            dialog.SetTitle(dialog.IndexScript.Name+" 叠加指标参数设置");   //设置标题
        }
        else
        {
            dialog.IndexScript=chart.WindowIndex[identify];
            dialog.SetTitle(dialog.IndexScript.Name+" 指标参数设置");      //设置标题
        }

        dialog.ClearParamList();            //清空参数
        dialog.BindParam(chart,identify);   //绑定参数
        dialog.BindCancel();  //绑定取消和关闭事件

        dialog.Show();//显示, 在css里调整居中
    }
}

//换指标
function ChangeIndexDialog(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.DivElement=divElement;   //父节点
    //this.IndexTreeApiUrl="../commonindextree.json";               //数据下载地址
    //this.OverlayIndexTreeApiUrl="../commonindextree.json";        //叠加指标列表数据下载地址
    this.IsOverlayIndex=false;

    this.Create=function()
    {
        var div=document.createElement('div');
        div.className='jchart-changeindex-box';
        div.id=this.ID=Guid();
        div.innerHTML=
        '<div class="target-panel">\n' +
            '            <div class="target-header">\n' +
            '                <span>换指标</span>\n' +
            '                <strong class="close-tar icon iconfont icon-close"></strong>\n' +
            '            </div>\n' +
            '            <div class="target-content">\n' +
            '                <div class="target-left">\n' +
            '                    <input type="text">\n' +
            '                    <ul></ul>\n' +
            '                </div>\n' +
            '                <div class="target-right">\n' +
            '                    <ul></ul>\n' +
            '                </div>\n' +
            '            </div>\n' +
            '        </div>';

        this.DivElement.appendChild(div);
    }

    //指标菜单内容
    this.GetMenuData=function()
    {
        var data={
            "name":"页面通用版指标树",
            "list":
            [
                { 
                    "node":"超买超卖型",
                    "list":
                    [
                        {"name":"ADTM 动态买卖气指标",      "id":"ADTM"},
                        {"name":"BIAS 乖离率",              "id":"BIAS"},
                        {"name":"BIAS36 三六乖离",          "id":"BIAS36"},
                        {"name":"BIAS_QL 乖离率-传统版",    "id":"BIAS_QL"},
                        {"name":"CCI 商品路径指标",         "id":"CCI"},
                        {"name":"FSL 分水岭",               "id":"FSL"},
                        {"name":"KDJ 随机指标",             "id":"KDJ"},
                        {"name":"MTM 动量线",               "id":"MTM"},
                        {"name":"OSC 变动速率线",            "id":"OSC"},
                        {"name":"RSI 相对强弱指标",           "id":"RSI"},
                        {"name":"ROC 变动率指标",             "id":"ROC"},
                        {"name":"WR 威廉指标",                  "id":"WR"}
                    ]
                },
                {
                    "node":"趋势型",
                    "list":
                    [
                        {"name":"CHO 济坚指数",         "id":"CHO"},
                        {"name":"DMA 平均差",           "id":"DMA"},
                        {"name":"DMI 趋向指标",         "id":"DMI"},
                        {"name":"EMV 简易波动指标",     "id":"EMV"},
                        {"name":"MACD 平滑异同平均",    "id":"MACD"},
                        {"name":"TRIX 三重指数平均线",  "id":"TRIX"},
                        {"name":"UOS 终极指标",         "id":"UOS"},
                        {"name":"TRIX 三重指数平均线",  "id":"TRIX"}
                    ]
                },
                { 
                    "node":"成交量型",
                    "list":
                    [
                        {"name":"HSL 换手率",           "id":"HSL"},
                        {"name":"OBV 累积能量线",       "id":"OBV"},
                        {"name":"NVI 负成交量",         "id":"NVI"},
                        {"name":"PVI 正成交量",         "id":"PVI"},
                        {"name":"VOL 成交量",           "id":"VOL"}
                    ]
                },
                {
                    "node":"均线型",
                    "list":
                    [
                        {"name":"MA 均线", "id":"均线"},
                        {"name":"BBI 多空线", "id":"BBI"}
                    ]
                },
                {
                    "node":"路径型",
                    "list":
                    [
                        {"name":"BOLL 布林线",          "id":"BOLL"},
                        {"name":"BOLL副图 布林线",      "id":"BOLL副图"},
                        {"name":"MIKE 麦克支撑压力",    "id":"MIKE"},
                        {"name":"ENE 轨道线",           "id":"ENE"}
                    ]
                },
                {
                    "node":"能量型",
                    "list":
                    [
                        {"name":"BRAR 情绪指标",            "id":"BRAR"},
                        {"name":"CYR 市场强弱",             "id":"CYR"},
                        {"name":"MASS 梅斯线",              "id":"MASS"},
                        {"name":"PSY 心理线",               "id":"PSY"},
                        {"name":"CR 带状能量线",            "id":"CR"},
                        {"name":"VR 成交量变异率",          "id":"VR"},
                        {"name":"WAD 威廉多空力度线",        "id":"WAD"}
                    ]
                }
        
            ]
        };

        return data;
    }

    //下载数据 如果上次下载过可以 可以不用下载
    this.ReqeustData=function()
    {
        if($("#" + this.ID + " .target-left ul li").length>0){
            return false;
        }

        var res=this.GetMenuData();
        var item = res.list;
        changeIndexLeftList(item);   //处理左侧list列表
        changeIndexRightList(item);  //处理右侧内容列表

        /*
        var url = this.IndexTreeApiUrl;
        if (this.IsOverlayIndex==true) url=this.OverlayIndexTreeApiUrl;
        JSNetwork.HttpRequest({
            url: url,
            type: 'get',
            success: function (res) {
                var item = res.list;
                changeIndexLeftList(item);   //处理左侧list列表
                changeIndexRightList(item);  //处理右侧内容列表
            }
        });
        */

        //处理左侧list列表
        function changeIndexLeftList(item) {
            $(".target-left ul").html('');
            $.each(item,function(i,result){
                var htmlList;
                htmlList = '<li>' + result.node + '</li>';
                $(".target-left ul").append(htmlList);
            });
            //默认选中第一项
            $(".target-left ul li:first-child").addClass("active-list");
        }
        //处理右侧内容列表
        function changeIndexRightList(listNum) {
            var contentHtml;
            var conData = [];
            $.each(listNum,function(index,result){
                conData.push(result.list);
            })
            //页面初始化时显示第一个列表分类下的内容
            $.each(conData[0],function (i, res) {
                contentHtml = '<li id='+res.id+'>'+ res.name +'</li>';
                $(".target-right ul").append(contentHtml);
            })
            //切换list
            $(".target-left ul").delegate("li","click",function () {
                $(this).addClass("active-list").siblings().removeClass("active-list");
                var item = $(this).index();
                $(".target-right ul").html("");
                $.each(conData[item],function (i, res) {
                    contentHtml = '<li id='+res.id+'>'+ res.name +'</li>';
                    $(".target-right ul").append(contentHtml);
                })
            })
        }
    }

    this.BindClose=function(chart)
    {
        //关闭按钮
        $("#"+this.ID+" .close-tar").click(
            {
                Chart:chart,
            },
            function(event)
            {
                var chart=event.data.Chart;
                chart.ChangeIndexDialog.Hide();
            }
        );
    }

    //搜索事件
    this.BindSearch=function(chart)
    {
        $(".target-left input").on('input',
            {
                Chart:chart
            },
            function(event)
            {
                let scriptData = new JSIndexScript();
                let result=scriptData.Search(event.target.value);

                $(".target-right ul").html("");
                for(var i in result)
                {
                    var name=result[i];
                    var contentHtml = '<li id='+name+'>'+ name +'</li>';
                    $(".target-right ul").append(contentHtml);
                }
                
            }
        );
    }

    this.DoModal=function(event)
    {
        var chart=event.data.Chart;
        var identify=event.data.Identify;
        var dialog=chart.ChangeIndexDialog;
        var isOverlay=event.data.IsOverlay; //是否叠加

        if(!dialog) return;

        if (dialog.ID==null) dialog.Create();   //第1次 需要创建div
        dialog.IsOverlayIndex=isOverlay;
        dialog.ReqeustData();   //下载数据

        //切换窗口指标类型  每次委托事件执行之前，先用undelegate()解除之前的所有绑定
        changeIndeWindow();
        function changeIndeWindow() 
        {
            $(".target-right ul").undelegate().delegate("li","click",function () {
                var idv = $(this).attr("id");
                if (isOverlay)
                    chart.AddOverlayIndex({WindowIndex:identify,IndexName:idv});
                else
                    chart.ChangeIndex(identify,idv);
                $(this).addClass("active-list").siblings().removeClass("active-list");
            });
        }

        dialog.BindSearch(chart);
        //关闭弹窗
        dialog.BindClose(chart);
        dialog.Show();
    }
}

//信息地理tooltip
function KLineInfoTooltip(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.UpColor=g_JSChartResource.UpTextColor;
    this.DownColor=g_JSChartResource.DownTextColor;
    this.UnchagneColor=g_JSChartResource.UnchagneTextColor;

    this.Create=function()
    {
        this.ID=Guid();

        var div=document.createElement('div');
        div.className='jchart-klineinfo-tooltip';
        div.id=this.ID;
        div.innerHTML="<div class='title-length'></div>";
        this.DivElement.appendChild(div);
    }


    this.BindInfoList=function(infoType,infoList)
    {
        var strBox="<div class='total-list'>共"+infoList.length+"条</div>";
        var strText=[];
        for(var i in infoList)
        {
            var item=infoList[i];
            var strOld=item.Date;
            if(infoType==KLINE_INFO_TYPE.PFORECAST)
            {
                var reportDate=item.ExtendData.ReportDate;
                var year=parseInt(reportDate/10000);  //年份
                var day=reportDate%10000;   //比较 这个去掉年份的日期
                var reportType;
                if(day == 1231){
                    reportType = "年报"
                }else if(day == 331){
                    reportType = "一季度报"
                }else if(day == 630){
                    reportType = "半年度报"
                }else if(day == 930){
                    reportType = "三季度报"
                }

                var weekData="";
                if (item.ExtendData.FWeek)
                {
                    if (item.ExtendData.FWeek.Week1!=null) weekData+="一周后涨幅:<i class='increase' style='color:"+this.GetColor(item.ExtendData.FWeek.Week1.toFixed(2))+"'>"+ item.ExtendData.FWeek.Week1.toFixed(2)+"%</i>";
                    if (item.ExtendData.FWeek.Week4!=null) weekData+="&nbsp;四周后涨幅:<i class='increase' style='color:"+this.GetColor(item.ExtendData.FWeek.Week4.toFixed(2))+"'>"+ item.ExtendData.FWeek.Week4.toFixed(2)+"%</i>";
                    if (weekData.length>0) weekData="<br/>&nbsp;&nbsp;<i class='prorecast-week'>"+weekData+"</i>";
                }
                var strDate=item.Date.toString();
                var strNew=strDate.substring(0,4)+"-"+strDate.substring(4,6)+"-"+strDate.substring(6,8);  //转换时间格式
                strText+="<span>"+strNew+"&nbsp;&nbsp;"+year+reportType+item.Title+"&nbsp;"+weekData+"</span>";

            }
            else if (infoType==KLINE_INFO_TYPE.RESEARCH)    //调研单独处理
            {
                var levels=item.ExtendData.Level;
                var recPerson=[];
                if(levels.length==0){
                    recPerson = "<i>无</i>"
                }else{
                    for(var j in levels)
                    {
                        if(levels[j]==0){
                            recPerson+="<i style='color:#00a0e9'>证券代表&nbsp;&nbsp;&nbsp;</i>";
                        }else if(levels[j]==1){
                            recPerson+="<i>董秘&nbsp;&nbsp;&nbsp;</i>";
                        }else if(levels[j]==2){
                            recPerson+="<i style='color:#00a0e9'>总经理&nbsp;&nbsp;&nbsp;</i>";
                        }else if(levels[j]==3){
                            recPerson+="<i style='color:#00a0e9'>董事长&nbsp;&nbsp;&nbsp;</i>";
                        }
                    }
                }
                var strDate=item.Date.toString();
                var strNew=strDate.substring(0,4)+"-"+strDate.substring(4,6)+"-"+strDate.substring(6,8);  //转换时间格式
                strText+="<span>"+strNew+"&nbsp;&nbsp;&nbsp;接待:&nbsp;&nbsp;&nbsp;"+recPerson+"</span>";
            }else if(infoType==KLINE_INFO_TYPE.BLOCKTRADING)
            {
                var showPriceInfo = item.ExtendData;
                var strDate=item.Date.toString();
                var strNew=strDate.substring(0,4)+"-"+strDate.substring(4,6)+"-"+strDate.substring(6,8);  //转换时间格式
                strText+="<span><i class='date-tipbox'>"+strNew+"</i>&nbsp;&nbsp;<i class='tipBoxTitle'>成交价:&nbsp;"+showPriceInfo.Price.toFixed(2)+"</i><i class='tipBoxTitle'>收盘价:&nbsp;"+showPriceInfo.ClosePrice.toFixed(2)+
                    "</i><br/><i class='rate-discount tipBoxTitle'>溢折价率:&nbsp;<strong style='color:"+ this.GetColor(showPriceInfo.Premium.toFixed(2))+"'>"+
                    showPriceInfo.Premium.toFixed(2)+"%</strong></i><i class='tipBoxTitle'>成交量(万股):&nbsp;"+showPriceInfo.Vol.toFixed(2)+"</i></span>";
            }
            else if (infoType==KLINE_INFO_TYPE.TRADEDETAIL) //龙虎榜
            {
                /*var detail=[
                    "日价格涨幅偏离值达到9.89%",
                    "日价格涨幅偏离值达格涨幅偏离值达格涨幅偏离值达到9.89%"
                ]*/
                var detail=item.ExtendData.Detail;
                //格式：日期 上榜原因: detail[0].TypeExplain
                //                    detail[1].TypeExplain
                //      一周后涨幅: xx 四周后涨幅: xx
                var str=strOld.toString();
                var strNew=str.substring(0,4)+"-"+str.substring(4,6)+"-"+str.substring(6,8);  //转换时间格式
                var reasons = [];
                for(var i in detail){
                    reasons += "<i>"+detail[i].TypeExplain+"</i><br/>"
                    // reasons += detail[i] + "<br/>"
                }

                strText = "<span><i class='trade-time'>"+strNew+"&nbsp;&nbsp;&nbsp;上榜原因:&nbsp;&nbsp;</i><i class='reason-list'>"+reasons+"</i><br/><i class='trade-detall'>一周后涨幅:&nbsp;<strong style='color:"+
                    this.GetColor(item.ExtendData.FWeek.Week1.toFixed(2))+"'>"+ item.ExtendData.FWeek.Week1.toFixed(2)+
                    "%</strong>&nbsp;&nbsp;&nbsp;四周后涨幅:&nbsp;<strong style='color:"+this.GetColor(item.ExtendData.FWeek.Week4.toFixed(2))+";'>"+
                    item.ExtendData.FWeek.Week4.toFixed(2)+"%</strong></i></span>";
            }
            else
            {
                var str=strOld.toString();
                var strNew=str.substring(0,4)+"-"+str.substring(4,6)+"-"+str.substring(6,8);  //转换时间格式
                strText+="<span>"+strNew+"&nbsp;&nbsp;&nbsp;"+item.Title+"</span>";
            }
        }
        var titleInnerBox = $(".title-length").html(strText);

        $("#"+this.ID).html(titleInnerBox);

        //当信息超过8条时，添加“共XX条”统计总数
        if(infoList.length > 8){
            $("#"+this.ID).append(strBox);
        }
    }


    this.GetColor=function(price)
    {
        if(price>0) return this.UpColor;
        else if (price<0) return this.DownColor;
        else return this.UnchagneColor;
    }

    //显示窗口，改函数仅为KLineInfoTooltip使用
    this.Show=function(left,top,width,height,tooltip,times)
    {
        //显示位置
        $("#"+this.ID).css({'display':'block','top':top+'px', "left":left+'px', "width":width+'px', "height":height+'px' });

        function toolHide() {
            tooltip.Hide();
        }

        if (this.TimeOut!=null)
            clearTimeout(this.TimeOut); //清空上一次的定时器,防止定时器不停的被调用

        //设置窗口定时隐藏
        this.TimeOut=setTimeout(toolHide,times);

    }


    this.DoModal=function(event)
    {
        var chart=event.data.Chart;
        var infoType=event.data.InfoType;   //信息地雷类型
        var infoList=event.data.InfoList;    //信息数据列表
        var tooltip=chart.KLineInfoTooltip;

        if(!tooltip) return;
        if (tooltip.ID==null) tooltip.Create();   //第1次 需要创建div

        tooltip.BindInfoList(infoType,infoList);

        var left=event.pageX;
        var top=event.pageY+10;
        var widthTool=380;
        var heightTool=$("#"+tooltip.ID).height();

        if((left + widthTool) > chart.UIElement.getBoundingClientRect().width){
            left = left - widthTool;
        }
        /*if(top+heightTool>chart.UIElement.getBoundingClientRect().height){
            top=top-heightTool-45;
        }*/

        tooltip.Show(left,top,widthTool,"auto",tooltip,8000);
    }

    //鼠标离开
    this.Leave=function(event)
    {
        var chart=event.data.Chart;
        var tooltip=chart.KLineInfoTooltip;

        if(!tooltip || tooltip.ID==null) return;

        tooltip.Hide();
    }
}

function MinuteSelectRectDialog(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.SelectData;
    this.Dialog;
    this.HQChart;
    this.RectSelectPaint;

    //隐藏窗口
    this.Close=function()
    {
        if (this.Dialog) 
        {
            this.DivElement.removeChild(this.Dialog);
            this.Dialog=null;
            this.ID=null;
        }

        if (this.RectSelectPaint) this.RectSelectPaint.PreventClose=false;
    }

    //创建
    this.Create=function()
    {
        this.ID=Guid();
        var div=document.createElement('div');
        div.className='jchart-select-statistics-box';
        div.id=this.ID;
        div.innerHTML=
        "<div class='parameter jchart-select-section'>\
            <div class='parameter-header'>\
                <span>分时图区间统计</span>\
                <strong id='close' class='icon iconfont icon-close'></strong>\
            </div>\
            <div class='parameter-content'>统计数据</div>\
        <div class='parameter-footer'>\
            <button id='close' class='submit' >确定</button>\
        </div>\
        </div>";

        this.DivElement.appendChild(div);
        this.Dialog=div;

        //关闭按钮
        $("#"+this.ID+" #close").click(
            {
                divBox:this,
            },
            function(event)
            {
                event.data.divBox.Close();
            });
    }

    this.BindData=function()
    {
        var hqData=this.SelectData.Data;
        var start=this.SelectData.Start;
        var end=this.SelectData.End;
        this.HQChart.UpdateSelectRect(start,end);
        if (this.RectSelectPaint) this.RectSelectPaint.PreventClose=true;

        var showData=
        { 
            Open:0,Close:0,High:0,Low:0,  //起始价格, 结束价格, 最高, 最低
            Vol:0, Amount:0, 
            Date:
            { 
                Start:{Time:null, Date:null },
                End:{ Time:null, Date:null }
            }, 
            Count:0,
        }

        for(var i=start; i<=end && i<hqData.Data.length; ++i)
        {
            var item=hqData.Data[i];
            if (i==start) 
            {
                showData.Date.Start.Date=item.Date;
                showData.Date.Start.Time=item.Time;
                showData.Open=item.Close;
                showData.High=item.High;
                showData.Low=item.Low;
            }

            showData.Date.End.Date=item.Date;
            showData.Date.End.Time=item.Time;
            showData.Close=item.Close;
            showData.Vol+=item.Vol;
            showData.Amount+=item.Amount;
            ++showData.Count;
            if (showData.High<item.High) showData.High=item.High;
            if(showData.Low>item.Low) showData.Low=item.Low;
        }

        if (showData.Vol>0) showData.AvPrice=showData.Amount/showData.Vol;  //均价
        if (item.Open>0)
        {
            showData.Increase = (showData.Close - showData.Open) / showData.Open *100;   //区间涨幅
            showData.Amplitude = (showData.High - showData.Low) / showData.Open * 100;   //区间振幅
        }

        // JSConsole.Chart.Log('[KLineSelectRectDialog::BindData]', showData);
        var defaultfloatPrecision=GetfloatPrecision(this.SelectData.Symbol);
        var startDate=IFrameSplitOperator.FormatDateString(showData.Date.Start.Date);
        var endDate=IFrameSplitOperator.FormatDateString(showData.Date.End.Date);
        startDate+=' '+IFrameSplitOperator.FormatTimeString(showData.Date.Start.Time,"HH:MM");
        endDate+=" "+IFrameSplitOperator.FormatTimeString(showData.Date.End.Time,"HH:MM");
       
        var startLeftClass="",startRightClass="",endLeftClass="",endRightClass="";
        if(start<=0) startLeftClass = "BtnBackground";
        if(start >= end) {
            startRightClass = "BtnBackground";
            endLeftClass = "BtnBackground";
        }
        if(end >= hqData.Data.length - 1) endRightClass = "BtnBackground";

        var div=document.createElement('div');
        div.className='jchart-select-table-right';
        div.innerHTML=
            '<div class="jchart-select-date">\n' +
            '            <span>开始: '+ startDate +'<i class="start-date-left '+ startLeftClass +'"><</i><i class="start-date-right '+ startRightClass +'">></i></span>\n' +
            '            <span>结束: '+ endDate +'<i class="end-date-left '+ endLeftClass +'"><</i><i class="end-date-right '+ endRightClass +'">></i></span>\n' +
            '            <span>总个数: '+ showData.Count +'</span>\n' +
            '        </div>\n' +
            '        <table>\n' +
            '            <tr><td><strong>起始价: </strong><span>'+ showData.Open.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>终止价: </strong><span>'+ showData.Close.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>均价: </strong><span>'+ (IFrameSplitOperator.IsNumber(showData.AvPrice) ? showData.AvPrice.toFixed(defaultfloatPrecision):"--.--") +'</span></td></tr>\n' +
            '            <tr><td><strong>最低价: </strong><span>'+ showData.Low.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>最高价: </strong><span>'+ showData.High.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>涨跌幅: </strong><span class="'+ IFrameSplitOperator.FormatValueColor(showData.Increase) +'">'+ showData.Increase.toFixed(2) +'%</span></td></tr>\n' +
            '            <tr><td><strong>振幅: </strong><span>'+ showData.Amplitude.toFixed(2) +'%</span></td>' +
            '               <td><strong>成交量: </strong><span>'+ IFrameSplitOperator.FormatValueString(showData.Vol,2) +'股</span></td>' +
            '               <td><strong>金额: </strong><span>'+ IFrameSplitOperator.FormatValueString(showData.Amount,2) +'元</span></td></tr>\n' +
            '        </table>';

        $(".parameter-content").html(div);
        this.BindEvent();
    }

    this.BindEvent = function () 
    {
        var _self = this;
        if(_self.SelectData.Start > 0){
            $(".jchart-select-date .start-date-left").click(function () {
                _self.SelectData.Start--;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
        }
        if(_self.SelectData.Start < _self.SelectData.End){
            $(".jchart-select-date .start-date-right").click(function () {
                _self.SelectData.Start++;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
            $(".jchart-select-date .end-date-left").click(function () {
                _self.SelectData.End--;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
        }
        if(_self.SelectData.End < _self.SelectData.Data.Data.length - 1){
            $(".jchart-select-date .end-date-right").click(function () {
                _self.SelectData.End++;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
        }
    }


    //显示
    this.DoModal=function(event)
    {
        var chart=event.data.Chart;
        if (this.ID==null) this.Create();   //第1次 需要创建div
        this.SelectData=event.data.SelectData;
        this.RectSelectPaint=event.data.RectSelectPaint;
        this.HQChart=chart;
        this.HQChart.HideSelectRect();
        this.BindData();

        this.Show();      //通过CSS居中显示
    }


}

//区间统计
function KLineSelectRectDialog(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.SelectData;
    this.Dialog;
    this.HQChart;
    this.RectSelectPaint;

    //隐藏窗口
    this.Close=function()
    {
        if (this.Dialog) 
        {
            this.DivElement.removeChild(this.Dialog);
            this.Dialog=null;
        }

        if (this.RectSelectPaint) this.RectSelectPaint.PreventClose=false;
    }

    //创建
    this.Create=function()
    {
        this.ID=Guid();
        var div=document.createElement('div');
        div.className='jchart-select-statistics-box';
        div.id=this.ID;
        div.innerHTML=
        "<div class='parameter jchart-select-section'>\
            <div class='parameter-header'>\
                <span>区间统计</span>\
                <strong id='close' class='icon iconfont icon-close'></strong>\
            </div>\
            <div class='parameter-content'>统计数据</div>\
        <div class='parameter-footer'>\
            <button id='close' class='submit' >确定</button>\
            <button id='match' class='submit' >形态匹配</button>\
        </div>\
        </div>";

        this.DivElement.appendChild(div);
        this.Dialog=div;

        //关闭按钮
        $("#"+this.ID+" #close").click(
            {
                divBox:this,
            },
            function(event)
            {
                event.data.divBox.Close();
            });
        
        //形态匹配
        $("#"+this.ID+" #match").click(
            {
                divBox:this,
            },
            function(event)
            {
                event.data.divBox.KLineMatch();
            });   
    }

    this.BindData=function()
    {
        var hqData=this.SelectData.Data;
        var start=this.SelectData.Start;
        var end=this.SelectData.End;
        this.HQChart.UpdateSelectRect(start,end);
        if (this.RectSelectPaint) this.RectSelectPaint.PreventClose=true;

        var showData=
        { 
            Open:0,Close:0,High:0,Low:0, YClose:0,
            Vol:0, Amount:0, 
            Date:
            { 
                Start:{Time:null, Date:null },
                End:{ Time:null, Date:null }
            }, 
            Count:0,
            KLine:{ Up:0,Down:0,Unchanged:0 }    //阳线|阴线|平线
        }

        for(var i=start; i<=end && i<hqData.Data.length; ++i)
        {
            var item=hqData.Data[i];
            if (i==start) 
            {
                showData.Date.Start.Date=item.Date;
                showData.Date.Start.Time=item.Time;
                showData.Open=item.Open;
                showData.High=item.High;
                showData.Low=item.Low;
                showData.YClose=item.YClose;
            }

            showData.Date.End.Date=item.Date;
            showData.Date.End.Time=item.Time;
            showData.Close=item.Close;
            showData.Vol+=item.Vol;
            showData.Amount+=item.Amount;
            ++showData.Count;
            if (showData.High<item.High) showData.High=item.High;
            if(showData.Low>item.Low) showData.Low=item.Low;
            if (item.Close>item.Open) ++showData.KLine.Up;
            else if (item.Close<item.Open) ++showData.KLine.Down;
            else ++showData.KLine.Unchanged;
        }

        if (showData.Vol>0) showData.AvPrice=showData.Amount/showData.Vol;  //均价
        if (item.YClose>0)
        {
            showData.Increase = (showData.Close - showData.YClose) / showData.YClose *100;   //涨幅
            showData.Amplitude = (showData.High - showData.Low) / showData.YClose * 100;     //振幅
        }

        // JSConsole.Chart.Log('[KLineSelectRectDialog::BindData]', showData);
        var defaultfloatPrecision=GetfloatPrecision(this.SelectData.Symbol);
        var startDate=IFrameSplitOperator.FormatDateString(showData.Date.Start.Date);
        var endDate=IFrameSplitOperator.FormatDateString(showData.Date.End.Date);
        if (ChartData.IsMinutePeriod(this.HQChart.Period))
        {
            startDate+=' '+IFrameSplitOperator.FormatTimeString(showData.Date.Start.Time,"HH:MM");
            endDate+=" "+IFrameSplitOperator.FormatTimeString(showData.Date.End.Time,"HH:MM");
        }
        else if (ChartData.IsSecondPeriod(this.HQChart.Period) || ChartData.IsTickPeriod(this.HQChart.Period))
        {
            startDate+=' '+IFrameSplitOperator.FormatTimeString(showData.Date.Start.Time,"HH:MM:SS");
            endDate+=" "+IFrameSplitOperator.FormatTimeString(showData.Date.End.Time,"HH:MM:SS");
        }
       
        var startLeftClass="",startRightClass="",endLeftClass="",endRightClass="";
        if(start<=0) startLeftClass = "BtnBackground";
        if(start >= end) {
            startRightClass = "BtnBackground";
            endLeftClass = "BtnBackground";
        }
        if(end >= hqData.Data.length - 1) endRightClass = "BtnBackground";

        var div=document.createElement('div');
        div.className='jchart-select-table-right';
        div.innerHTML=
            '<div class="jchart-select-date">\n' +
            '            <span>开始: '+ startDate +'<i class="start-date-left '+ startLeftClass +'"><</i><i class="start-date-right '+ startRightClass +'">></i></span>\n' +
            '            <span>结束: '+ endDate +'<i class="end-date-left '+ endLeftClass +'"><</i><i class="end-date-right '+ endRightClass +'">></i></span>\n' +
            '            <span>总个数: '+ showData.Count +'</span>\n' +
            '        </div>\n' +
            '        <table>\n' +
            '            <tr><td><strong>起始价: </strong><span>'+ showData.YClose.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>最终价: </strong><span>'+ showData.Close.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>均价: </strong><span>'+ (IFrameSplitOperator.IsNumber(showData.AvPrice) ? showData.AvPrice.toFixed(defaultfloatPrecision):"--.--") +'</span></td></tr>\n' +
            '            <tr><td><strong>最低价: </strong><span>'+ showData.Low.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>最高价: </strong><span>'+ showData.High.toFixed(defaultfloatPrecision) +'</span></td>' +
            '               <td><strong>涨跌幅: </strong><span class="'+ IFrameSplitOperator.FormatValueColor(showData.Increase) +'">'+ showData.Increase.toFixed(2) +'%</span></td></tr>\n' +
            '            <tr><td><strong>振幅: </strong><span>'+ showData.Amplitude.toFixed(2) +'%</span></td>' +
            '               <td><strong>成交量: </strong><span>'+ IFrameSplitOperator.FormatValueString(showData.Vol,2) +'股</span></td>' +
            '               <td><strong>金额: </strong><span>'+ IFrameSplitOperator.FormatValueString(showData.Amount,2) +'元</span></td></tr>\n' +
            '            <tr><td><strong>阴线: </strong><span>'+ showData.KLine.Up +'</span></td>' +
            '               <td><strong>阳线: </strong><span>'+ showData.KLine.Down +'</span></td>' +
            '               <td><strong>平线: </strong><span>'+ showData.KLine.Unchanged +'</span></td></tr>\n' +
            '        </table>';

        $(".parameter-content").html(div);
        this.BindEvent();
    }

    this.BindEvent = function () {
        var _self = this;
        if(_self.SelectData.Start > 0){
            $(".jchart-select-date .start-date-left").click(function () {
                _self.SelectData.Start--;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
        }
        if(_self.SelectData.Start < _self.SelectData.End){
            $(".jchart-select-date .start-date-right").click(function () {
                _self.SelectData.Start++;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
            $(".jchart-select-date .end-date-left").click(function () {
                _self.SelectData.End--;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
        }
        if(_self.SelectData.End < _self.SelectData.Data.Data.length - 1){
            $(".jchart-select-date .end-date-right").click(function () {
                _self.SelectData.End++;
                _self.BindData();
                _self.HQChart.UpdateSelectRect(_self.SelectData.Start,_self.SelectData.End);
            })
        }
    }

    //显示
    this.DoModal=function(event)
    {
        var chart=event.data.Chart;
        if (this.ID==null) this.Create();   //第1次 需要创建div
        this.SelectData=event.data.SelectData;
        this.RectSelectPaint=event.data.RectSelectPaint;
        this.HQChart=chart;
        this.HQChart.HideSelectRect();
        this.BindData();

        this.Show();      //通过CSS居中显示
    }

    //形态匹配
    this.KLineMatch=function(data)
    {
        var waitDialog=new WaitDialog(this.DivElement);
        waitDialog.DoModal(
            {
                data:
                { 
                    Title:'计算中......', 
                    Chart:this.HQChart
                } 
            });

        this.Close();   //关闭窗口

        var hqChart=this.HQChart;
        var param= { Scope: { Plate:["CNA.ci"],Minsimilar:0.90 }, WaitDialog:waitDialog }  //沪深A股, 相似度>=90%
        hqChart.RequestKLineMatch(this.SelectData, param);
    }
}

//形态选股
function KLineMatchDialog(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.MatchData;     //匹配的股票数据
    this.Sample;        //样本数据
    this.Dialog;
    this.HQChart;

    this.PageData; //分页数据

    //隐藏窗口
    this.Close=function()
    {
        this.DivElement.removeChild(this.Dialog);
    }

    //创建
    this.Create=function()
    {
        this.ID=Guid();
        var div=document.createElement('div');
        div.className='jchart-kline-match-box';
        div.id=this.ID;
        div.innerHTML=
        `<div class='parameter jchart-kline-match-box'>
            <div class='parameter-header'>
                <span>形态匹配</span>
                <strong id='close' class='icon iconfont icon-close'></strong>
            </div>
            <div class='parameter-content'>
                <p class='dataCount'></p>
                <table class='matchTable'>
                    <thead>
                        <tr>
                            <td>股票名称</td>
                            <td>匹配度</td>
                            <td>时间段</td>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
                <div class='pagination' data-current='1'></div>
            </div>
            <div class='parameter-footer'>
                <button id='close' class='submit' >确定</button>
            </div>
        </div>`.trim();

        this.DivElement.appendChild(div);
        this.Dialog=div;

        //关闭按钮
        $("#"+this.ID+" #close").click(
            {
                divBox:this,
            },
            function(event)
            {
                event.data.divBox.Close();
            });
    }

    this.BindData=function()
    {
        JSConsole.Chart.Log(`[KLineMatchDialog::BindData] 形态源: ${this.Sample.Stock.Name} 区间:${this.Sample.Date.Start} - ${this.Sample.Date.End}`);
        var count = this.MatchData.length + 1;
        var pageData = {NewData:{},MetaData:[],PageCount:0,Count:count};
        var pageCount = 0;
        var paginationHtml = '';

        $('#'+this.ID+' .dataCount').html('个数：'+count);
        
        for(let i = 0; i < count ; i++){
            var dataObj = {};
            if(i == 0){
                dataObj = {
                    Symbol:this.Sample.Stock.Symbol,
                    Name:this.Sample.Stock.Name,
                    Rate:'形态源',
                    Color:'red',
                    Date:`${this.Sample.Date.Start}-${this.Sample.Date.End}`
                };
            }else{
                let dataItem = this.MatchData[i - 1];
                dataObj = {
                    Symbol:dataItem.Symbol,
                    Name:dataItem.Name,
                    Rate:Number(dataItem.Similar * 100).toFixed(2),
                    Color:'',
                    Date:`${dataItem.Start}-${dataItem.End}`
                };
            }
            pageData.MetaData.push(dataObj);
        }

        if(pageData.Count % 10 == 0){
            pageCount = pageData.Count / 10;
        }else{
            pageCount = Math.floor(pageData.Count / 10) + 1;
        }
        pageData.PageCount = pageCount;

        this.PaginationMetaData(pageData);
        this.PageData = pageData;
        JSConsole.Chart.Log('[KLineMatchDialog::DoModal pageData]',pageData);

        this.RenderDom(1);

        this.PaginationInit('#'+this.ID,pageData.PageCount,this.paginationCallback);
        // $('#' + this.ID + ' .pagination').html(paginationHtml);

        
    }
    this.RenderDom = function(page){
        let currentPageData = this.PageData.NewData[page];
        JSConsole.Chart.Log('[KLineMatchDialog::RenderDom currentPageData]',currentPageData);
        let bodyHtml = '';
        for(let i = 0; i < currentPageData.length; i++){
            bodyHtml += `<tr>
                        <td class=${currentPageData[i].Color}>${currentPageData[i].Name}</td>
                        <td class=${currentPageData[i].Color}>${currentPageData[i].Rate}</td>
                        <td class=${currentPageData[i].Color}>${currentPageData[i].Date}</td>
                    </tr>`.trim();
        }
        
        $('#'+this.ID + ' .matchTable tbody').html(bodyHtml)
    }
    var _this = this;
    this.paginationCallback = function(page) {
        _this.RenderDom(page);
        _this.PaginationInit('#'+_this.ID,_this.PageData.PageCount,_this.paginationCallback); //更新UI
    }
    this.PaginationInit = function(id, maxPageNum, callback) {  //初始化分页
        var spanStr = "";
        var currentPageNum = $(id + " .pagination").data("current");
        var lastPageNum = 0;
        var showCountPage = 5; //只显示5个数字项
    
        if (currentPageNum < showCountPage) {  //当前页小于预显示页数
            if (maxPageNum >= showCountPage) {
                for (var j = 0; j < showCountPage; j++) {  //上 1 2 3 4 5 下
                    spanStr += (j + 1) != currentPageNum ? "<span>" + (j + 1) + "</span>" : "<span class='active'>" + (j + 1) + "</span>";
                }
            } else {
                for (var j = 0; j < maxPageNum; j++) {  //上 1 2 3 4 5 下
                    spanStr += (j + 1) != currentPageNum ? "<span>" + (j + 1) + "</span>" : "<span class='active'>" + (j + 1) + "</span>";
                }
            }
        } else { //大于5时，最终页数是当前页数加1
            lastPageNum = (currentPageNum + 1) > maxPageNum ? currentPageNum : (currentPageNum + 1);

            for (var i = currentPageNum - 3; i <= lastPageNum; i++) { //含最终项之前的五项
                spanStr += i != currentPageNum ? "<span>" + i + "</span>" : "<span class='active'>" + i + "</span>";
            }
        }
    
        spanStr = "<span class='beforePage'>上一页</span>" + spanStr + "<span class='nextPage'>下一页</span>";
        $(id + " .pagination").html(spanStr);
        $(id + " .pagination span").bind('click', { "maxpage": maxPageNum, "Callback": callback }, this.PaginationCurrentIndex);
        // return spanStr;
    }
    
    this.PaginationCurrentIndex = function(event) {  //分页切换
        var text = $(this).text();
        JSConsole.Chart.Log('[::PaginationCurrentIndex text]',text);
        var currentPageNum = Number($(this).parent().data("current"));
        var maxPageNum = event.data.maxpage;
        var callback = event.data.Callback;
        var flag = 1;
        if (text === "上一页") {
            flag = currentPageNum === 1 ? currentPageNum : currentPageNum - 1;
        } else if (text === "下一页") {
            flag = currentPageNum === maxPageNum ? currentPageNum : currentPageNum + 1;
        } else {
            flag = Number(text);
        }
        $(this).parent().data("current", flag);  //将当前页存到dom上
        callback(flag);
    }
    
    this.PaginationMetaData = function(data){ //假分页数据,每页10条数据
        // data = {NewData:{},MetaData:[],PageCount:0,Callback:null};
        var newData = {};
        var metaData = data.MetaData;
        var pageCount = data.PageCount;
        
        for(let i = 0; i < pageCount; i++){
            var itemArr = [];
            for(let j = 0; j < 10; j++){
                var itemIndex = 10*i + j;
                if(itemIndex <= metaData.length - 1){
                    var item = metaData[itemIndex];
                    itemArr.push(item);
                }else {
                    break;
                }
            }
            newData[i+1] = itemArr;
        }
        data.NewData = newData;
    }

    //显示
    this.DoModal=function(event)
    {
        var chart=event.data.Chart;
        if (this.ID==null) this.Create();   //第1次 需要创建div
        this.MatchData=event.data.MatchData;
        this.Sample=event.data.Sample;
        this.HQChart=chart;

        this.BindData();
        

        //居中显示
        var border=chart.Frame.ChartBorder;
        var scrollPos=GetScrollPosition();
        var left=border.GetWidth()/2;
        var top=border.GetHeight()/2;

        this.Show(left,top,200,200);      //显示
    }
}

//等待动画窗口
function WaitDialog(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.Title='加载中......';
    this.Dialog;

    //隐藏窗口
    this.Close=function()
    {
        if (this.Dialog) 
        {
            this.DivElement.removeChild(this.Dialog);
            this.Dialog=null;
        }
    }

    this.SetTitle=function(title)
    {
        this.Title=title;
        if (!this.Dialog) return;
        //TODO: 更新标题数据
    }

    this.Create=function()
    {
        this.ID=Guid();
        var div=document.createElement('div');
        div.className='jchart-wait-box';
        div.id=this.ID;
        div.innerHTML=
        `<div class='parameter jchart-kline-match-box'>
            <div class='parameter-header'>
                <span>${this.Title}</span>
            </div>
        </div>`.trim();

        this.DivElement.appendChild(div);
        this.Dialog=div;
    }

    //显示
    this.DoModal=function(event)
    {
        this.Title=event.data.Title;
        var chart=event.data.Chart;
        if (this.ID==null) this.Create();   //第1次 需要创建div
        
        //居中显示
        var border=chart.Frame.ChartBorder;
        var scrollPos=GetScrollPosition();
        var left=border.GetWidth()/2;
        var top=border.GetHeight()/2;

        this.Show(left,top,200,40);      //显示
    }
}

//画图工具 单个图形设置
function ChartPictureSettingMenu(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.HQChart;
    this.ChartPicture;
    this.SubToolsDiv;
    this.SettingMenu;
    this.SettingPV;

    this.DoModal=function(event)
    {
        var $body;
        if (!this.SubToolsDiv)
        {
            this.ID=Guid();
            var div=document.createElement("div");
            div.className='subTolls';
            div.id=this.ID;
            this.DivElement.appendChild(div);
            //$body = $("."+event.data.HQChart.ClassName).context.body;
            //$body.append(div);
            this.SubToolsDiv=div;
        }
        this.HQChart=event.data.HQChart;
        this.ChartPicture=event.data.ChartPicture;

        var pixelTatio = GetDevicePixelRatio();
        var frame=this.HQChart.Frame.SubFrame[0].Frame;
        // var top=frame.ChartBorder.GetTopTitle();
        var top=frame.ChartBorder.Top + 40;
        // var right=frame.ChartBorder.GetRight();
        var right=frame.ChartBorder.Right;
        var left=frame.ChartBorder.GetLeft();
        var className = this.ChartPicture.ClassName; //='ChartDrawPictureText'时加“设置”
        var lineColor=this.ChartPicture.LineColor;
        if (lineColor.indexOf("rgb(")==0 || lineColor.indexOf("RGB(")==0)
            lineColor=IChartDrawPicture.RGBToHex(lineColor.toLowerCase());
        var toolsDiv = "";
        if(className === 'ChartDrawPictureText')
        {
            toolsDiv = '<span class="changes-color" title="改变图形颜色">'+
                           '<i class="iconfont icon-bianji"></i>'+
                           '<input type="color" name="color" id="color" class="change-color" value="'+ lineColor +'">'+
                        '</span>\n' +
                        '<span class="subtool-set" title="设置"><i class="iconfont icon-shezhi"></i></span>'+
                        '<span class="subtool-del"><i class="iconfont icon-recycle_bin"></i></span>';
        }
        else if (className=="ChartDrawVolProfile")
        {
            toolsDiv='<span class="vp-set" title="设置"><i class="iconfont icon-shezhi"></i></span>'+
            '<span class="subtool-del"><i class="iconfont icon-recycle_bin"></i></span>';
        }
        else
        {
            toolsDiv =
            '<p class="changes-color" title="改变图形颜色"><i class="iconfont icon-bianji"></i>' +
            '<input type="color" name="color" id="color" class="change-color" value="'+ lineColor +'"></p>\n' +
            '        <p class="subtool-del"><i class="iconfont icon-recycle_bin"></i></p>';
        }

        
        this.SubToolsDiv.style.right = right/pixelTatio + "px";
        this.SubToolsDiv.style.top = top/pixelTatio + "px";
        this.SubToolsDiv.innerHTML = toolsDiv;
        this.SubToolsDiv.style.position = "absolute";
        this.SubToolsDiv.style.display = "block";

        var hqChart = this.HQChart;
        var picture = this.ChartPicture;
        var subToolDiv = this.SubToolsDiv;
        $(".subtool-del").click(function(){
            hqChart.SelectChartDrawPicture=null;
            hqChart.ClearChartDrawPicture(picture);
            // subToolDiv.innerHTML = "";
            $(".subTolls").css("display","none");
        });
        var self = this;
        $(".subtool-set").click(function(){
            $(self.SubToolsDiv).hide();
            //创建div设置窗口
            if (!self.SettingMenu) self.SettingMenu=new ChartPictureTextSettingMenu(frame.ChartBorder.UIElement.parentNode);

            self.SettingMenu.ChartPicture=picture;
            self.SettingMenu.HQChart=hqChart;
            self.SettingMenu.Position={Left:right + 80,Top:top + 20};
            self.SettingMenu.DoModal();
        });
        $(".changes-color").click(function () {
            document.getElementById('color').click();
            $(".change-color").change(function () {
                var color = $(".change-color").val();
                picture.LineColor = color;
                picture.PointColor = color;
                if (hqChart.ChartDrawStorage) hqChart.ChartDrawStorage.SaveDrawData(picture);   //保存下
            });
        });

        //成交量分布图设置
        $(".vp-set").click(function()
        {
            if (!self.SettingPV) self.SettingPV=new ChartPictureVolProfileSettingMenu(frame.ChartBorder.UIElement.parentNode);
            self.SettingPV.ChartPicture=picture;
            self.SettingPV.HQChart=hqChart;
            self.SettingPV.Position={Left:right + 80,Top:top + 20};
            self.SettingPV.DoModal();
        });


        JSConsole.Chart.Log("[ChartPictureSettingMenu::DoModal]", {Top:top,Left:left, Right:right});
    }
}

//画图工具 文本设置窗口
function ChartPictureTextSettingMenu(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.ChartPicture;
    this.SettingDiv;
    this.Position;

    this.BackupData;    //画图工具备份数据

    this.Close=function()   
    {
        if (this.SettingDiv) this.DivElement.removeChild(this.SettingDiv);  //直接删除
    }

    this.DoModal=function()
    {
        var text=this.ChartPicture.Text;    //显示的文本
        var fontOption=this.ChartPicture.FontOption;    //字体设置
        var lineColor=this.ChartPicture.LineColor;
        //数据备份, 点取消的时候把备份数据设置回去
        this.BackupData=
        {
            Text:text, 
            LineColor:lineColor,
            FontOption:{Family: fontOption.Family, Size: fontOption.Size, Weight: fontOption.Weight, Style: fontOption.Style }
        };
        JSConsole.Chart.Log('[ChartPictureTextSettingMenu::DoModal] picture info',this.BackupData);

        var self=this;
        var div=this.DivElement.getElementsByClassName('chartpicture-text-setting')[0];
        if (!div)
        {
            div=document.createElement("div");
            div.className='chartpicture-text-setting';
            this.DivElement.appendChild(div);
            this.SettingDiv=div;
        }
        else 
        {
            this.SettingDiv=div;
        }
        
        var titleContainerStr = '<div class="titleWrap">'+
                                    '<span class="titleName">样式设置</span>'+
                                    '<i class="closeBtn iconfont icon-close"></i>'+
                                '</div>';
                            
        var fontSizeArray = [10,11,12,14,16,20,24,28,32,40];
        var fontArray = ['微软雅黑','宋体','Arial','仿宋'];
        var sizeListStr = "";
        var fontListStr = "";
        fontArray.forEach(function(item,index){
            fontListStr += index !== 0 ? '<p>'+item+'</P>' : '<p class="active">'+item+'</P>';
        });
        fontSizeArray.forEach(function(item,index){
            sizeListStr += index !== 5 ? '<p>'+item+'</P>' : '<p class="active">'+item+'</P>';
        });
        var contentContainerStr = '<div class="contentWrap">'+
                                    '<div class="styleOptions">'+
                                        '<span class="colorPicker"><input type="color" id="fontColor" value="#1e90ff"></span>'+
                                        '<div class="likeSelect fontSelect"><span class="choicedText">微软雅黑</span><div class="selectList">'+fontListStr+'</div><i class="iconfont icon-xia"></i></div>'+
                                        '<div class="likeSelect fontSizeSelect"><span class="choicedText">20</span><div class="selectList">'+sizeListStr+'</div><i class="iconfont icon-xia"></i></div>'+
                                        '<span class="strongFont likeBtn"><i class="iconfont icon-jiacu"></i></span>'+
                                        '<span class="italicsFont likeBtn"><i class="iconfont icon-qingxieL"></i></span>'+
                                    '</div>'+
                                    '<textarea class="tArea" id="tArea" placeholder="Text"></textarea>'+
                                  '</div>';
        var btnContainer = '<div class="btnsContainer">'+
                                '<span class="okBtn btn">确认</span>'+
                                '<span class="cancelBtn btn">取消</span>'+
                            '</div>';

        var pixelTatio = GetDevicePixelRatio();
        var DoModalStr = titleContainerStr+contentContainerStr+btnContainer;
        this.SettingDiv.style.left = this.Position.Left/pixelTatio + "px";
        this.SettingDiv.style.top = this.Position.Top/pixelTatio + "px";
        this.SettingDiv.innerHTML=DoModalStr;
        this.SettingDiv.style.position = "absolute";
        this.SettingDiv.style.display = "block";
        $(".chartpicture-text-setting .colorPicker").css({ //初始设置
            "borderColor":self.ChartPicture.LineColor,
            "background-color":self.ChartPicture.LineColor
        });

        var family = this.ChartPicture.FontOption.Family;
        $('.chartpicture-text-setting .fontSelect .choicedText').html(family);
        fontArray.forEach(function(item,index){
            if(item == family){
                $('.chartpicture-text-setting .fontSelect p').removeClass('active');
                $('.chartpicture-text-setting .fontSelect p').eq(index).addClass('active');
            }
        });

        var size = this.ChartPicture.FontOption.Size;
        $('.chartpicture-text-setting .fontSizeSelect .choicedText').html(size);
        fontSizeArray.forEach(function(item,index){
            if(item == size){
                $('.chartpicture-text-setting .fontSizeSelect p').removeClass('active');
                $('.chartpicture-text-setting .fontSizeSelect p').eq(index).addClass('active');
            }
        });

        var weight = this.ChartPicture.FontOption.Weight;
        if( weight != null && weight == 'bold'){
            $('.chartpicture-text-setting .strongFont').addClass('hot');
        }

        var style = this.ChartPicture.FontOption.Style;
        if( style != null && style == 'italic'){
            $('.chartpicture-text-setting .italicsFont').addClass('hot');
        }

        var text = this.ChartPicture.Text;
        $('.chartpicture-text-setting .tArea').val(text);  //结束初始设置

        var defaultTextOption = { Family:'微软雅黑', Size:20, Weight:null, Style:null };
        $(".chartpicture-text-setting #fontColor").change(
            {
                Picture:this.ChartPicture
            },
            function(event)
            {  //颜色选择
                var value = $(this).val();
                $(this).parent().css({
                    "borderColor":value,
                    "background-color":value
                });
                var chart=event.data.Picture;
                chart.LineColor = value;
                if (chart.Update) chart.Update();   //更新界面
            }
        );
        $(".chartpicture-text-setting .fontSelect,.chartpicture-text-setting .fontSizeSelect").click(function(){
            $(this).find('.selectList').toggle();
            $(this).toggleClass('hot');
        });
        $(".chartpicture-text-setting .fontSelect p").click(
            {
                Picture:this.ChartPicture
            },
            function(event){ //字体选择
                var choicedText = $(this).closest(".fontSelect").find('.choicedText').html();
                var currentSelect = event.currentTarget.innerHTML;
                if(choicedText !== currentSelect){
                    $(this).closest(".fontSelect").find('.choicedText').html(currentSelect);
                    $(this).siblings().removeClass('active');
                    $(this).addClass('active');
                    var chart = event.data.Picture;
                    chart.FontOption.Family = currentSelect;
                    if (chart.Update) chart.Update();   //更新界面
                }
        });
        $(".chartpicture-text-setting .fontSizeSelect p").click(
            {
                Picture:this.ChartPicture
            },
            function(event){  //字号选择
            var choicedText = $(this).closest(".fontSizeSelect").find('.choicedText').html();
            var currentSelect = event.currentTarget.innerHTML;
            if(choicedText !== currentSelect){
                $(this).closest(".fontSizeSelect").find('.choicedText').html(currentSelect);
                $(this).siblings().removeClass('active');
                $(this).addClass('active');
                var chart = event.data.Picture;
                chart.FontOption.Size = Number(currentSelect);
                if (chart.Update) chart.Update();   //更新界面
            }
        });
        $(".chartpicture-text-setting .strongFont").click(
            {
                Picture:this.ChartPicture
            },
            function(event){
            $(this).toggleClass('hot');
            var classnames = $(this).attr('class');
            if(classnames.indexOf('hot') > 0){
                var chart = event.data.Picture;
                chart.FontOption.Weight = 'bold';
                if (chart.Update) chart.Update();   //更新界面
            }
        });
        $(".chartpicture-text-setting .italicsFont").click(
            {
                Picture:this.ChartPicture
            },
            function(event){
            $(this).toggleClass('hot')
            var classnames = $(this).attr('class');
            if(classnames.indexOf('hot') > 0){
                var chart = event.data.Picture;
                chart.FontOption.Style = 'italic';
                if (chart.Update) chart.Update();   //更新界面
            }
        });
        $(".chartpicture-text-setting .titleWrap .closeBtn,.chartpicture-text-setting .btnsContainer .cancelBtn").click(  //取消
            {
                Picture:this.ChartPicture
            },
            function(event){
                var picture = event.data.Picture;
                picture.Text = self.BackupData.Text;
                picture.LineColor = self.BackupData.LineColor;
                picture.FontOption = self.BackupData.FontOption;
                if (picture.Update) picture.Update();
                self.Close();
        });
        $(".chartpicture-text-setting .tArea").keyup( //文本内容
            {
                Picture:this.ChartPicture
            },
            function(event){
                JSConsole.Chart.Log('[ChartPictureTextSettingMenu::DoModal] $(".chartpicture-text-setting .tArea").keyup()');
                var content = $(this).val();
                var chart = event.data.Picture;
                chart.Text = content;
                if (chart.Update) chart.Update();   //更新界面
        });

        //确定按钮
        $(".chartpicture-text-setting .btnsContainer .okBtn").click(
            function()
            {  
                self.Close(); 
                if (self.HQChart && self.HQChart.ChartDrawStorage) self.HQChart.ChartDrawStorage.SaveDrawData(self.ChartPicture);   //保存下
            }
        );
    }
}


function ChartPictureVolProfileSettingMenu(divElement)
{
    this.newMethod=IDivDialog;   //派生
    this.newMethod(divElement);
    delete this.newMethod;

    this.ChartPicture;
    this.SettingDiv;
    this.Position;
    this.ID=Guid();

    this.Close=function()   
    {
        if (this.SettingDiv) this.DivElement.removeChild(this.SettingDiv);  //直接删除
    }

    this.DoModal=function()
    {
        var valueAreaVol=this.ChartPicture.VAVol;    //Value area volume
        var barPosition=this.ChartPicture.BarPosition;

        var self=this;
        var div=document.getElementById(this.ID);
        if (!div)
        {
            div=document.createElement("div");
            div.className='jchart-modifyindex-box';
            div.id=this.ID;
            this.DivElement.appendChild(div);
            this.SettingDiv=div;
        }
        else 
        {
            this.SettingDiv=div;
        }

        div.innerHTML=
        `<div class='parameter'>\
            <div class='parameter-header'>\
                <span>固定范围成交量分布设置</span>\
                <strong id='close' class='icon iconfont icon-close'></strong>\
            </div>\
            <div class='parameter-content'>
                <input class='row-line' value=${valueAreaVol} />VAVol <br>
                <input class='row-line' value=${barPosition} />BarPosition
            </div>\
            <div class='parameter-footer'>\
                <button class='submit' >确定</button>\
                <button class='cancel' >取消</button>\
            </div>\
        </div>`;

        var pixelTatio = GetDevicePixelRatio();
        var frame=this.HQChart.Frame.SubFrame[0].Frame;
        var top=frame.ChartBorder.Top + 40;
        var right=frame.ChartBorder.Right;
        var left=frame.ChartBorder.GetLeft();

        this.SettingDiv.style.right = right/pixelTatio + "px";
        this.SettingDiv.style.top = top/pixelTatio + "px";
        this.SettingDiv.style.position = "absolute";
        this.SettingDiv.style.display = "block";

        var btnCancel=div.getElementsByClassName("cancel")[0];
        btnCancel.onclick=function()
        {
            self.Close();
        }

        var btnClose=div.getElementsByClassName("icon iconfont icon-close")[0];
        btnClose.onclick=function()
        {
            self.Close();
        }
        
        var btnSubmit=div.getElementsByClassName("submit")[0];
        btnSubmit.onclick=function()
        {
            var value=div.getElementsByClassName("row-line")[0].value;
            self.ChartPicture.VAVol=parseFloat(value);
            var value=parseInt(div.getElementsByClassName("row-line")[1].value);
            self.ChartPicture.BarPosition=value>0?1:0;

            self.ChartPicture.RequestVolumeProfileData();
            self.Close();
        }
    }
}



///////////////////////////////////////////////////////////////////////////////////////
//
//  各个品种分钟走势图坐标信息
//
//////////////////////////////////////////////////////////////////////////////////////
var MARKET_SUFFIX_NAME=
{
    SH:'.SH',
    SZ:'.SZ',
    SHSZ_C_Index:'.CI',     //自定义指数
    BJ:".BJ",               //北交所 BeiJing stock exchange

    SHO:'.SHO',          //上海交易所 股票期权
    SZO:".SZO",          //深证交易所 股票期权
    HK:'.HK',            //港股
    FHK:'.FHK',          //港股期货            
    SHFE: '.SHF',        //上期所 (Shanghai Futures Exchange) | 上期所-能源
    SHFE2:'.SHFE',       //上期所 (Shanghai Futures Exchange) | 上期所-能源
    CFFEX: '.CFE',       //中期所 (China Financial Futures Exchange)
    CFFEX2:'.CFFEX',     //中期所 (China Financial Futures Exchange)
    DCE: '.DCE',         //大连商品交易所(Dalian Commodity Exchange)
    CZCE: '.CZC',        //郑州期货交易所
    GZFE:".GZFE",        //广州期货交易所

    USA:'.USA',          //美股
    FTSE:'.FTSE',        //富时中国

    BIT:'.BIT',          //数字货币 如比特币
    BIZ:'.BIZ',          //数字货币

    FOREX:'.FOREX',      //外汇 (Foreign Exchange)

    NYMEX:'.NYMEX',      //纽约商品期货交易所(New York Mercantile Exchange)
    COMEX:".COMEX",      //纽约商品期货交易所(New York Mercantile Exchange)
    NYBOT:".NYBOT",      //美國紐約商品交易所
    CBOT:".CBOT",        //芝商所

    LME:".LME",          //伦敦金属交易所
    TOCOM:".TOCOM",      //东京商品交易所（TOCOM）
    IPE:".IPE",          //美国洲际交易所 （ICE EUROPE）

    TW:".TW",            //台湾股票 9：00-13：30
    JP:".JP",            //日本股票 9:00-11:30, 12:30-15:00

    //越南股市
    HSX:".HSX",         //HSX胡志明交易所
    HNX:".HNX",         //HNX河內交易所
    UPCOM:".UPCOM",     //UPCOM未上市公司交易所

    ET:'.ET',            //其他未知的品种

    IsET:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.ET) > 0;
    },

    IsETShowAvPrice:function(upperSymbol)   //是否显示均价
    {
        return false;
    },

    IsHSX:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.HSX)>0;
    },

    IsHNX:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.HNX)>0;
    },

    IsUPCOM:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.UPCOM)>0;
    },

    IsNYMEX:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.NYMEX)>0;
    },

    IsCOMEX:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.COMEX)>0;
    },

    IsNYBOT:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.NYBOT)>0;
    },

    IsCBOT:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.CBOT)>0;
    },

    IsLME:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.LME)>0;
    },

    IsTOCOM:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.TOCOM)>0;
    },

    IsIPE:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.IPE)>0;
    },

    IsForeignExchange(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.FOREX) > 0;
    },

    IsFTSE:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.FTSE) > 0;
    },

    IsFHK:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.FHK) > 0;
    },

    IsBIT:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        if (upperSymbol.indexOf(this.BIT) > 0) return true;
        if (upperSymbol.indexOf(this.BIZ) > 0) return true;
        return false;
    },

    IsUSA:function(upperSymbol) //是否是美股
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.USA) > 0;
    },

    IsSH: function (upperSymbol)
    {
        //需要精确匹配最后3位
        var pos = upperSymbol.length-this.SH.length;
        var find = upperSymbol.indexOf(this.SH);
        return find == pos;
    },

    IsSZ: function (upperSymbol)
    {
        var pos = upperSymbol.length - this.SZ.length;
        var find = upperSymbol.indexOf(this.SZ);
        return find == pos;
    },

    IsBJ:function(upperSymbol)
    {
        var pos = upperSymbol.length - this.BJ.length;
        var find = upperSymbol.indexOf(this.BJ);
        return find == pos;
    },

    //自定义指数
    IsSHSZCustomIndex:function(upperSymbol)
    {
        var pos = upperSymbol.length - this.SHSZ_C_Index.length;
        var find = upperSymbol.indexOf(this.SHSZ_C_Index);
        return find == pos;
    },

    IsSHO: function(upperSymbol)
    {
        var pos = upperSymbol.length - this.SHO.length;
        var find = upperSymbol.indexOf(this.SHO);
        return find == pos;
    },

    IsSZO: function(upperSymbol)
    {
        var pos = upperSymbol.length - this.SZO.length;
        var find = upperSymbol.indexOf(this.SZO);
        return find == pos;
    },

    IsHK: function (upperSymbol)
    {
        var pos = upperSymbol.length - this.HK.length;
        var find = upperSymbol.indexOf(this.HK);
        return find == pos;
    },

    IsTW:function(upperSymbol)
    {
        var pos = upperSymbol.length - this.TW.length;
        var find = upperSymbol.indexOf(this.TW);
        return find == pos;
    },

    IsJP:function(upperSymbol)
    {
        var pos = upperSymbol.length - this.JP.length;
        var find = upperSymbol.indexOf(this.JP);
        return find == pos;
    },

    IsSHFE: function (upperSymbol)
    {
        if (!upperSymbol) return false;
        if (upperSymbol.indexOf(this.SHFE) > 0) return true;
        if (upperSymbol.indexOf(this.SHFE2) > 0) return true;
        return false;
    },
        
    IsCFFEX: function (upperSymbol) 
    {
        if (!upperSymbol) return false;
        if (upperSymbol.indexOf(this.CFFEX) > 0) return true;
        if (upperSymbol.indexOf(this.CFFEX2) > 0) return true;
        
        return false;
    },

    IsDCE: function (upperSymbol) 
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.DCE) > 0;
    },

    IsCZCE: function (upperSymbol) 
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.CZCE) > 0;
    },

    IsGZFE:function(upperSymbol)
    {
        if (!upperSymbol) return false;
        return upperSymbol.indexOf(this.GZFE) > 0;
    },

    IsChinaFutures:function(upperSymbol)   //是否是国内期货 /期权
    {
        return this.IsSHO(upperSymbol) || this.IsSZO(upperSymbol) || 
            this.IsGZFE(upperSymbol) ||
            this.IsCFFEX(upperSymbol) || this.IsCZCE(upperSymbol) || this.IsDCE(upperSymbol) || this.IsSHFE(upperSymbol);
    },

    IsFutures:function(upperSymbol) //是否是期货 包含国外的
    {
        if (!upperSymbol) return false;

        return this.IsChinaFutures(upperSymbol) || 
            this.IsNYMEX(upperSymbol) || this.IsCOMEX(upperSymbol) || this.IsNYBOT(upperSymbol) || this.IsCBOT(upperSymbol) ||
            this.IsLME(upperSymbol) || this.IsTOCOM(upperSymbol);
    },

    IsSHSZ:function(upperSymbol)            //是否是沪深的股票
    {
        return this.IsSZ(upperSymbol)|| this.IsSH(upperSymbol) || this.IsSHSZCustomIndex(upperSymbol);
    },

    IsSHSZFund:function(upperSymbol)        //是否是交易所基金
    {
        if (!upperSymbol) return false;

        if (this.IsSH(upperSymbol)) //51XXXX.SH
        {
            if (upperSymbol.charAt(0)=='5' && upperSymbol.charAt(1)=='1') return true;
        }
        else if (this.IsSZ(upperSymbol)) //15XXXX.sz, 16XXXX.sz, 17XXXX.sz, 18XXXX.sz
        {
            if (upperSymbol.charAt(0)=='1' && 
                (upperSymbol.charAt(1)=='5' || upperSymbol.charAt(1)=='6' || upperSymbol.charAt(1)=='7' || upperSymbol.charAt(1)=='8') ) return true;
        }

        return false;
    },

    IsSHSZIndex:function(symbol)     //是否是沪深指数代码
    {
        if (!symbol) return false;
        var upperSymbol=symbol.toUpperCase();
        if (this.IsSH(upperSymbol))
        {
            var temp=upperSymbol.replace('.SH','');
            if (upperSymbol.charAt(0)=='0' && parseInt(temp)<=3000) return true;

        }
        else if (this.IsSZ(upperSymbol))
        {
            if (upperSymbol.charAt(0)=='3' && upperSymbol.charAt(1)=='9') return true;
        }
        else if (this.IsSHSZCustomIndex(upperSymbol))  //自定义指数
        {
            return true;
        }

        return false;
    },

    IsSHSZStockA:function(symbol) //是否是沪深A股
    {
        if (!symbol) return false;
        var upperSymbol=symbol.toUpperCase();
        if (this.IsSH(upperSymbol))
        {
            var temp=upperSymbol.replace('.SH','');
            if (upperSymbol.charAt(0)=='6') return true;

        }
        else if (this.IsSZ(upperSymbol))
        {
            if (upperSymbol.charAt(0)=='0')
            {
                if (upperSymbol.charAt(1)=='0' && upperSymbol.charAt(2)=='2') return true;  //002 中小板
                if (upperSymbol.charAt(1)!='7' && upperSymbol.charAt(1)!='8') return true;
            } 
            else if (upperSymbol.charAt(0)=='3')
            {
                if (upperSymbol.charAt(1)=='0')
                {
                    if (upperSymbol.charAt(2)=='0') return true;    //创业板 300XXX.sz
                    if (upperSymbol.charAt(2)=='1') return true;    //创业板 301XXX.sz
                }
            }
        }

        return false;
    },

    IsBJStock:function(symbol)  //北交所股票
    {
        if (!symbol) return false;
        var upperSymbol=symbol.toUpperCase();
        if (!this.IsBJ(upperSymbol)) return false;

        var value=upperSymbol.charAt(0);

        if (value=='4' || value=='8') return true;

        return false;
    },

    IsSHStockSTAR:function(symbol)   // 是否是科创板 Sci-Tech innovAtion boaRd (STAR Market)
    {
        if (!symbol) return false;
        var upperSymbol=symbol.toUpperCase();
        if (!this.IsSH(upperSymbol)) return false;
        if (upperSymbol.charAt(0)=='6' && upperSymbol.charAt(1)=='8' && upperSymbol.charAt(2)=='8')
            return true;
        
        return false;
    },

    IsSHGEM:function(symbol)    //创业板(growth enterprise market) 30开头
    {
        if (!symbol) return false;
        var upperSymbol=symbol.toUpperCase();
        if (!this.IsSH(upperSymbol)) return false;
        if (upperSymbol.charAt(0)=='3' && upperSymbol.charAt(1)=='0')
            return true;
        
        return false;
    },

    GetMarketStatus:function(symbol)    //获取市场状态 0=闭市 1=盘前 2=盘中 3=盘后
    {
        if (!symbol) return 0;
        var upperSymbol=symbol.toUpperCase();
        var nowDate= new Date();
        var day = nowDate.getDay();
        var time = nowDate.getHours() * 100 + nowDate.getMinutes();
        if (this.IsUSA(upperSymbol))
        {
            var usaDate=GetLocalTime(-4);
            var day = usaDate.getDay();
            var time = usaDate.getHours() * 100 + usaDate.getMinutes();
            if(day == 6 || day== 0) return 0;   //周末

            //9:30 - 16:00 考虑夏令时间时间增加1小时 9:30 - 17:00
            if (time>1730) return 3;
            if (time<930) return 1;

            return 2;
        }
        else if (this.IsBIT(upperSymbol))   //数字货币24小时
        {
            return 2;
        }
        else if (this.IsForeignExchange(upperSymbol))   //外汇24小时
        {
            return 2;
        }
        else if (this.IsFTSE(upperSymbol))  //富时中国 9:00-16:30 17:00-04:45
        {
            if(day == 6 || day== 0) return 0;   //周末
            if (time>=830 && time<=2359) return 2;
            if (time>=0 && time<=500) return 2;
            return 0;
        }
        else if (this.IsFHK(upperSymbol))   //港股指数期货 9:15-12:00 13:00-16:30 17:15-01:00
        {
            if(day == 6 || day== 0) return 0;   //周末
            if (time>=900 && time<=2359) return 2;
            if (time>=0 && time<=320) return 2;
            return 0;
        }
        else if (this.IsET(upperSymbol))
        {
            return this.GetETMarketStatus(symbol);
        }
        else if (this.IsHK(upperSymbol))    //港股
        {
            if(day == 6 || day== 0) return 0;   //周末
            if(time>1630) return 3;
            if(time<925) return 1;
            return 2;   
        }
        else if (this.IsTW(upperSymbol))    //台湾股票 上午9：00——下午1：30
        {
            if(day == 6 || day== 0) return 0;   //周末
            if(time>1410) return 3;
            if(time<820) return 1;
            return 2;   
        }
        else if (this.IsJP(upperSymbol))    //日本股票 9:00-11:30 12:30-15:00
        {
            if(day == 6 || day== 0) return 0;   //周末
            if(time>1520) return 3;
            if(time<830) return 1;
            return 2;
        }
        else if (this.IsNYMEX(upperSymbol))
        {
            return this.GetNYMEXMarketStatus(upperSymbol);
        }
        else if (this.IsCOMEX(upperSymbol))
        {
            return this.GetCOMEXMarketStatus(upperSymbol);
        }
        else if (this.IsNYBOT(upperSymbol))
        {
            return this.GetNYBOTMarketStatus(upperSymbol);
        }
        else if (this.IsCBOT(upperSymbol))
        {
            return this.GetCBOTMarketStatus(upperSymbol);
        }
        else if (this.IsLME(upperSymbol))
        {
            return this.GetLMEMarketStatus(upperSymbol);
        }
        else if (this.IsTOCOM(upperSymbol))
        {
            return this.GetTOCOMMarketStatus(upperSymbol);
        }
        else if (this.IsChinaFutures(upperSymbol))  //国内期货
        {
            if(day == 6 || day== 0) return 0;   //周末

            if (this.IsCFFEX(upperSymbol))  //中金所期货 9:10-15:40
            {
                if(time>1540) return 3;
                if(time<910) return 1;
                return 2;
            }

            //21:00-2:30
            if(time>=2100) return 2;
            if (time<=240) return 2;

            //8:55-11:30, 13:00-15:00
            if(time>=830 && time<=1510) return 2;

            return 1;
        }
        else    //9:30 - 15:40  (默认9:10-15:40)
        {
            if(day == 6 || day== 0) return 0;   //周末
            if(time>1540) return 3;
            if(time<910) return 1;
            return 2;   
        }

    },

    GetLimitPriceRange:function(symbol, name) //涨停范围
    {
        if (!this.IsSHSZStockA(symbol)) return null;
        if (this.IsSHStockSTAR(symbol)) return {Max:0.2 , Min:-0.2};    //科创板 [20% - -20%]
        if (this.IsSHGEM(symbol)) return { Max:0.2 , Min:-0.2};         //创业板 [20% - -20%]
        
        if (!name) return null;
        if (name.indexOf('ST')>=0) return { Max:0.05, Min:-0.05 }; //ST 股票 [5% - -5%]
        
        return {Max:0.1 , Min:-0.1}; //[10% - -10%]
    },

    GetDefaultDecimal:function(symbol)  //默认小数位数
    {
        return 2;
    },

    GetSHDecimal:function(symbol)
    {
        return 2;
    },

    GetSZDecimal:function(symbol)
    {
        return 2;
    },

    GetFHKDecimal:function(symbol)  //港股指数期货 小数位数
    {
        return 0;
    },

    GetFTSEDecimal:function(symbol) //富时中国A50期货 小数位数
    {
        return 0;
    },

    GetBITDecimal:function(symbol)
    {
        return 2;
    },

    GetSHODecimal:function(symbol)
    {
        return 4;
    },

    GetETDecimal:function(symbol)
    {
        return 2;
    },

    GetHKDecimal:function(symbol)
    {
        return 2;
    },

    GetTWDecimal:function(symbol)
    {
        return 2;
    },

    GetJPDecimal:function(symbol)
    {
        return 2;
    },

    GetHSXDecimal:function(symbol)
    {
        return 2;
    },

    GetHNXDecimal:function(symbol)
    {
        return 2;
    },

    GetUPCOMDecimal:function(symbol)
    {
        return 2;
    },

    GetForeignExchangeDecimal:function(symbol)
    {
        return 4;
    },

    GetNYMEXDecimal:function(symbol)    //纽约期货交易所
    {
        return g_NYMEXTimeData.GetDecimal(symbol);
    },

    GetCOMEXDecimal:function(symbol)
    {
        return g_COMEXTimeData.GetDecimal(symbol);
    },

    GetNYBOTDecimal:function(symbol)
    {
        return g_NYBOTTimeData.GetDecimal(symbol);
    },

    GetCBOTDecimal:function(symbol)
    {
        return g_CBOTTimeData.GetDecimal(symbol);
    },

    GetLMEDecimal:function(symbol)
    {
        return g_LMETimeData.GetDecimal(symbol);
    },

    GetTOCOMDecimal:function(symbol)
    {
        return g_TOCOMTimeData.GetDecimal(symbol);
    },

    GetIPEDecimal:function(symbol)
    {
        return g_IPETimeData.GetDecimal(symbol);
    },

    GetETMarketStatus:function(symbol)  
    {
        // 0=闭市 1=盘前 2=盘中 3=盘后
        return 2;
    },

    GetNYMEXMarketStatus:function(symbol)
    {
        return g_NYMEXTimeData.GetMarketStatus(symbol);
    },

    GetCOMEXMarketStatus:function(symbol)
    {
        return g_COMEXTimeData.GetMarketStatus(symbol);
    },

    GetNYBOTMarketStatus:function(symbol)
    {
        return g_NYBOTTimeData.GetMarketStatus(symbol);
    },

    GetCBOTMarketStatus:function(symbol)
    {
        return g_CBOTTimeData.GetMarketStatus(symbol);
    },

    GetLMEMarketStatus:function(symbol)
    {
        return g_LMETimeData.GetMarketStatus(symbol);
    },

    GetTOCOMMarketStatus:function(symbol)
    {
        return g_TOCOMTimeData.GetMarketStatus(symbol);
    },

    GetIPEMarketStatus:function(symbol)
    {
        return g_IPETimeData.GetMarketStatus(symbol);
    },

    IsShowMinuteVolTitle:function(symbol)   //是否画走势图成交量标题
    {
        if (!symbol) return false;
        var upperSymbol=symbol.toUpperCase();
        //if (this.IsChinaFutures(upperSymbol)) return true;

        return false;
    },

    IsShowMinutePostionLine:function(upperSymbol)    //分时图 成交量图中是否显示持仓线
    {
        if(MARKET_SUFFIX_NAME.IsFutures(upperSymbol) || MARKET_SUFFIX_NAME.IsSHO(upperSymbol) || MARKET_SUFFIX_NAME.IsSZO(upperSymbol))  return true;

        return false;
    },

    IsShowMinuteColorVolBar:function(symobl)        //是否分时图成绩量柱子使用彩色柱
    {
        if (g_JSChartResource.Minute.VolBarColor) return true;

        return false;
    },

    IsEnableRight:function(period, symbol, rightFormula)    //是否支持复权
    {
        if (!MARKET_SUFFIX_NAME.IsSHSZStockA(symbol) && !MARKET_SUFFIX_NAME.IsBJStock(symbol)) return false;
        if (ChartData.IsTickPeriod(period)) return false;   //分笔没有复权
        if (IFrameSplitOperator.IsPlusNumber(rightFormula)) return true;        //复权因子复权
        if (ChartData.IsMinutePeriod(period,true)) return false;                //内置分钟K线不支持复权

        return true;
    }
}


//走势图分钟数据对应的时间
function MinuteTimeStringData() 
{
    this.SHSZ = null;       //上海深证交易所时间
    this.BJ=null;
    this.SHO=null;          //上海股票期权交易时间
    this.HK = null;         //香港交易所时间
    this.Futures=new Map(); //期货交易时间 key=时间名称 Value=数据
    this.USA = null;        //美股交易时间
    this.FTSE=null;         //富时中国
    this.FHK=null;          //港股指数期货
    this.ForeEx=null;       //外汇
    this.BIT=null;          //数字货币
    this.TW=null;           //台湾股票
    this.JP=null;           //日本股票
    this.HSX=null;          //HSX胡志明交易所
    this.HNX=null;          //HNX河內交易所
    this.UPCOM=null;        //UPCOM未上市公司交易所

    this.Initialize = function ()  //初始化 默认只初始化沪深的 其他市场动态生成
    {
        //this.SHSZ = this.CreateSHSZData();
        //this.HK = this.CreateHKData();
    }

    this.GetET=function(upperSymbol)   //当天所有的分钟
    {
        throw {Name:'MinuteTimeStringData::GetET', Error:'not implement'};
    }

    this.GetSHSZ=function(upperSymbol) //动态创建
    {
        if (!this.SHSZ) this.SHSZ=this.CreateSHSZData();
        return this.SHSZ;
    }

    this.GetBJ=function(upperSymbol)
    {
        if (!this.BJ) this.BJ=this.CreateBJData();
        return this.BJ;
    }

    this.GetSHO=function()
    {
        if (!this.SHO) this.SHO=this.CreateSHOData();
        return this.SHO;
    }

    this.GetHK=function(upperSymbol)
    {
        if (!this.HK) this.HK = this.CreateHKData();
        return this.HK;
    }

    this.GetTW=function(upperSymbol)
    {
        if (this.TW) this.TW=this.CreateTWData();
        return this.TW;
    }

    this.GetJP=function(upperSymbol)
    {
        if (this.JP) this.JP=this.CreateJPData();
        return this.JP;
    }

    this.GetHSX=function(upperSymbol)
    {
        if (this.HSX) this.HSX=this.CreateHSXData();
        return this.HSX;
    }

    this.GetHNX=function(upperSymbol)
    {
        if (this.HNX) this.HSX=this.CreateHNXData();
        return this.HNX;
    }

    this.GetUPCOM=function(upperSymbol)
    {
        if (this.UPCOM) this.UPCOM=this.CreateUPCOMData();
        return this.UPCOM;
    }

    this.GetFutures=function(splitData)
    {
        if (!this.Futures.has(splitData.Name)) 
        {
            var data = this.CreateTimeData(splitData.Data);
            this.Futures.set(splitData.Name,data);
        }
        
        return this.Futures.get(splitData.Name);
    }

    // type=时间类型 
    this.GetUSA=function(upperSymbol)
    {
        if (!this.USA) this.USA=this.CreateUSAData(0);
        return this.USA;
    }

    this.GetFTSE=function()
    {
        if (!this.FTSE) this.FTSE=this.CreateFTSEData();
        return this.FTSE;
    }

    this.GetFHK=function()
    {
        if (!this.FHK) this.FHK=this.CreateFHKData();
        return this.FHK;
    }

    this.GetForeignExchange=function(upperSymbol)
    {
        if (!this.ForeEx) this.ForeEx=this.CreateForeignExchangeData();
        return this.ForeEx;
    }

    this.GetBIT=function(upperSymbol)
    {
        if (!this.BIT) this.BIT=this.CreateBITData();
        return this.BIT;
    }

    this.CreateSHSZData = function () 
    {
        const TIME_SPLIT =
            [
                { Start: 925, End: 925 },
                { Start: 930, End: 1130 },
                { Start: 1300, End: 1500 }
            ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateBJData=function()
    {
        const TIME_SPLIT =
            [
                { Start: 925, End: 925 },
                { Start: 930, End: 1130 },
                { Start: 1300, End: 1500 }
            ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateSHOData=function()
    {
        const TIME_SPLIT =
        [
            { Start: 930, End: 1129 },
            { Start: 1300, End: 1500 }
        ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateHKData = function () 
    {
        const TIME_SPLIT =
            [
                { Start: 930, End: 1200 },
                { Start: 1300, End: 1600 }
            ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateTWData=function()
    {
        const TIME_SPLIT =
            [
                { Start: 900, End: 1330 }
            ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateJPData=function()
    {
        const TIME_SPLIT =
        [
            { Start: 900, End: 1130 },
            { Start: 1230, End: 1500 }
        ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateFTSEData=function()
    {
        const TIME_SPLIT=
        [
            { Start:1700, End:2359 },
            { Start:0,  End:445 },
            { Start:900, End:1630 }
        ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateFHKData=function()
    {
         //港股指数期货 9:15-12:00 13:00-16:30 17:15-03:00
         const TIME_SPLIT=           
         [
             { Start:1715, End:2359 },
             { Start:0,  End:300 },
             { Start:915, End:1200 },
             { Start:1300, End:1630 },
         ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateHSXData=function()
    {
        throw {Name:'MinuteTimeStringData::CreateHSXData', Error:'not implement'};
    }

    this.CreateHNXData=function()
    {
        throw {Name:'MinuteTimeStringData::CreateHNXData', Error:'not implement'};
    }

    this.CreateUPCOMData=function()
    {
        throw {Name:'MinuteTimeStringData::CreateUPCOMData', Error:'not implement'};
    }

    this.CreateUSAData=function(type)
    {
        if (type==1)    //美国夏令时
        {
            const TIME_SPLIT =
            [
                { Start: 2130, End: 2359 },
                { Start: 0, End: 400 }
            ];

            return this.CreateTimeData(TIME_SPLIT); 
        }
        else if (type==2)    //非夏令时
        {
            const TIME_SPLIT =
            [
                { Start: 2230, End: 2359 },
                { Start: 0, End: 500 }
            ];
            
            return this.CreateTimeData(TIME_SPLIT); 
        }
        else    //使用美国本地时间
        {
            const TIME_SPLIT =
            [
                { Start: 930, End: 1600 }   //美国东部时间9:30到16:00
            ];
            
            return this.CreateTimeData(TIME_SPLIT); 
        }
    }

    this.CreateForeignExchangeData=function()
    {
         //外汇 7:00 - 6:59
         const TIME_SPLIT=           
         [
             { Start:600, End:2359 },
             { Start:0,  End:559 },
         ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateBITData=function()
    {
         //数字货币 7:00 - 6:59
         const TIME_SPLIT=           
         [
             { Start:600, End:2359 },
             { Start:0,  End:559 },
         ];

        return this.CreateTimeData(TIME_SPLIT);
    }

    this.CreateTimeData = function (timeSplit) 
    {
        var data = [];
        for (var i in timeSplit) 
        {
            var item = timeSplit[i];
            for (var j = item.Start; j <= item.End; ++j) 
            {
                if (j % 100 >= 60) continue;    //大于60分钟的数据去掉
                data.push(j);
            }
        }
        return data;
    }

    this.GetTimeData = function (symbol) 
    {
        if (!symbol) return this.SHSZ;

        var upperSymbol = symbol.toLocaleUpperCase(); //转成大写
        if (MARKET_SUFFIX_NAME.IsSH(upperSymbol) || MARKET_SUFFIX_NAME.IsSZ(upperSymbol)) return this.GetSHSZ(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsBJ(upperSymbol)) return this.GetBJ(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsSHO(upperSymbol) || MARKET_SUFFIX_NAME.IsSZO(upperSymbol)) return this.GetSHO();
        if (MARKET_SUFFIX_NAME.IsHK(upperSymbol)) return this.GetHK(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsTW(upperSymbol)) return this.GetTW(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsJP(upperSymbol)) return this.GetJP(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsUSA(upperSymbol)) return this.GetUSA(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsCFFEX(upperSymbol) || MARKET_SUFFIX_NAME.IsCZCE(upperSymbol) || MARKET_SUFFIX_NAME.IsDCE(upperSymbol) || MARKET_SUFFIX_NAME.IsSHFE(upperSymbol) || MARKET_SUFFIX_NAME.IsGZFE(upperSymbol))
        {
            var splitData = g_FuturesTimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }
        if (MARKET_SUFFIX_NAME.IsFTSE(upperSymbol)) return this.GetFTSE();
        if (MARKET_SUFFIX_NAME.IsFHK(upperSymbol)) return this.GetFHK();
        if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol)) return this.GetForeignExchange(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsET(upperSymbol)) return this.GetET(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol)) return this.GetBIT(upperSymbol);

        //越南股市
        if (MARKET_SUFFIX_NAME.IsHSX(upperSymbol)) return this.GetHSX(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsHNX(upperSymbol)) return this.GetHNX(upperSymbol);
        if (MARKET_SUFFIX_NAME.IsUPCOM(upperSymbol)) return this.GetUPCOM(upperSymbol);

        if (MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol))    //纽约期货交易所
        {
            var splitData = g_NYMEXTimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }

        if (MARKET_SUFFIX_NAME.IsCOMEX(upperSymbol))    //纽约期货交易所
        {
            var splitData = g_COMEXTimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }

        if (MARKET_SUFFIX_NAME.IsNYBOT(upperSymbol))    //纽约期货交易所
        {
            var splitData = g_NYBOTTimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }

        if (MARKET_SUFFIX_NAME.IsCBOT(upperSymbol))    //芝商所
        {
            var splitData = g_CBOTTimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }

        if (MARKET_SUFFIX_NAME.IsLME(upperSymbol))    //伦敦LME
        {
            var splitData = g_LMETimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }

        if (MARKET_SUFFIX_NAME.IsTOCOM(upperSymbol))    //东京商品交易所（TOCOM）
        {
            var splitData = g_TOCOMTimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }

        if (MARKET_SUFFIX_NAME.IsIPE(upperSymbol))    //东京商品交易所（TOCOM）
        {
            var splitData = g_IPETimeData.GetSplitData(upperSymbol);
            if (!splitData) return null;
            return this.GetFutures(splitData);
        }
    }
}

//走势图刻度分钟线
function MinuteCoordinateData() 
{
    //沪深走势图时间刻度
    const SHZE_MINUTE_X_COORDINATE =
        {
            Full:   //完整模式
            [
                [0, 0, "rgb(200,200,200)", "09:30"],    //[0]=索引 [1]=线段类型(预留) [2]=文字颜色(弃用) [3]=刻度文字 [4]=线段颜色 [5]=背景色
                [31, 0, "RGB(200,200,200)", "10:00"],
                [61, 0, "RGB(200,200,200)", "10:30"],
                [91, 0, "RGB(200,200,200)", "11:00"],
                [122, 1, "RGB(200,200,200)", "13:00"],
                [152, 0, "RGB(200,200,200)", "13:30"],
                [182, 0, "RGB(200,200,200)", "14:00"],
                [212, 0, "RGB(200,200,200)", "14:30"],
                [242, 1, "RGB(200,200,200)", "15:00"], // 15:00
            ],
            Simple: //简洁模式
            [
                [0, 0, "rgb(200,200,200)", "09:30"],
                [61, 0, "RGB(200,200,200)", "10:30"],
                [122, 1, "RGB(200,200,200)", "13:00"],
                [182, 0, "RGB(200,200,200)", "14:00"],
                [242, 1, "RGB(200,200,200)", "15:00"]
            ],
            Min:   //最小模式     
            [
                [0, 0, "rgb(200,200,200)", "09:30"],
                [122, 1, "RGB(200,200,200)", "13:00"],
                [242, 1, "RGB(200,200,200)", "15:00"]
            ],

            Count: 243,
            MiddleCount: 122,

            GetData: function (width) 
            {
                if (width < 200) return this.Min;
                else if (width < 400) return this.Simple;

                return this.Full;
            }
        };

    //上海股票期权时间刻度
    const SHO_MINUTE_X_COORDINATE =
        {
            Full:   //完整模式
            [
                [0, 0, "rgb(200,200,200)", "09:30"],
                [30, 0, "RGB(200,200,200)", "10:00"],
                [60, 0, "RGB(200,200,200)", "10:30"],
                [90, 0, "RGB(200,200,200)", "11:00"],
                [120, 1, "RGB(200,200,200)", "13:00"],
                [150, 0, "RGB(200,200,200)", "13:30"],
                [180, 0, "RGB(200,200,200)", "14:00"],
                [210, 0, "RGB(200,200,200)", "14:30"],
                [240, 1, "RGB(200,200,200)", "15:00"], // 15:00
            ],
            Simple: //简洁模式
            [
                [0, 0, "rgb(200,200,200)", "09:30"],
                [60, 0, "RGB(200,200,200)", "10:30"],
                [120, 1, "RGB(200,200,200)", "13:00"],
                [180, 0, "RGB(200,200,200)", "14:00"],
                [240, 1, "RGB(200,200,200)", "15:00"]
            ],
            Min:   //最小模式     
            [
                [0, 0, "rgb(200,200,200)", "09:30"],
                [120, 1, "RGB(200,200,200)", "13:00"],
                [240, 1, "RGB(200,200,200)", "15:00"]
            ],

            Count: 241,
            MiddleCount: 120,

            GetData: function (width) 
            {
                if (width < 200) return this.Min;
                else if (width < 400) return this.Simple;

                return this.Full;
            }
        };

    //港股走势图时间刻度
    const HK_MINUTE_X_COORDINATE =
        {
            Full:   //完整模式
            [
                [0, 1, "RGB(200,200,200)", "09:30"],
                [30, 0, "RGB(200,200,200)", "10:00"],
                [60, 1, "RGB(200,200,200)", "10:30"],
                [90, 0, "RGB(200,200,200)", "11:00"],
                [120, 1, "RGB(200,200,200)", "11:30"],
                [151, 0, "RGB(200,200,200)", "13:00"],
                [181, 1, "RGB(200,200,200)", "13:30"],
                [211, 0, "RGB(200,200,200)", "14:00"],
                [241, 1, "RGB(200,200,200)", "14:30"],
                [271, 0, "RGB(200,200,200)", "15:00"],
                [301, 1, "RGB(200,200,200)", "15:30"],
                [331, 1, "RGB(200,200,200)", "16:00"]
            ],
            Simple: //简洁模式
            [
                [0, 1, "RGB(200,200,200)", "09:30"],
                [60, 1, "RGB(200,200,200)", "10:30"],
                [120, 1, "RGB(200,200,200)", "11:30"],
                [211, 0, "RGB(200,200,200)", "14:00"],
                [271, 0, "RGB(200,200,200)", "15:00"],
                [331, 1, "RGB(200,200,200)", "16:00"]
            ],
            Min:   //最小模式     
            [
                [0, 1, "RGB(200,200,200)", "09:30"],
                [151, 0, "RGB(200,200,200)", "13:00"],
                [331, 1, "RGB(200,200,200)", "16:00"]
            ],

            Count: 332,
            MiddleCount: 151,

            GetData: function (width) 
            {
                if (width < 200) return this.Min;
                else if (width < 450) return this.Simple;

                return this.Full;
            }
        };

    //美股走势图时间刻度
    const USA_MINUTE_X_COORDINATE =
    {
        /*
        Full:   //完整模式
        [
            [0, 0, "rgb(200,200,200)", "21:30"],
            [60, 0, "RGB(200,200,200)", "22:30"],
            [120, 1, "RGB(200,200,200)", "23:30"],
            [210, 0, "RGB(200,200,200)", "01:00"],
            [270, 0, "RGB(200,200,200)", "02:00"],
            [330, 0, "RGB(200,200,200)", "03:00"],
            [390, 0, "RGB(200,200,200)", "04:00"],
        ],
        Simple: //简洁模式
        [
            [0, 0, "rgb(200,200,200)", "21:30"],
            [160, 1, "RGB(200,200,200)", "00:00"],
            [270, 0, "RGB(200,200,200)", "02:00"],
            [390, 0, "RGB(200,200,200)", "04:00"],
        ],
        Min:   //最小模式     
        [
            [0, 0, "rgb(200,200,200)", "21:30"],
            [160, 1, "RGB(200,200,200)", "00:00"],
            [390, 0, "RGB(200,200,200)", "04:00"],
        ],
        */

        //美国本地时间
        Full:   //完整模式
        [
            [0, 0, "rgb(200,200,200)", "9:30"],
            [30, 0, "RGB(200,200,200)", "10:00"],
            [90, 1, "RGB(200,200,200)", "11:00"],
            [150, 0, "RGB(200,200,200)", "12:00"],
            [210, 0, "RGB(200,200,200)", "13:00"],
            [270, 0, "RGB(200,200,200)", "14:00"],
            [330, 0, "RGB(200,200,200)", "15:00"],
            [390, 0, "RGB(200,200,200)", "16:00"],
        ],
        Simple: //简洁模式
        [
            [30, 0, "rgb(200,200,200)", "10:00"],
            [150, 1, "RGB(200,200,200)", "12:00"],
            [270, 0, "RGB(200,200,200)", "14:00"],
            [390, 0, "RGB(200,200,200)", "16:00"],
        ],
        Min:   //最小模式     
        [
            [30, 0, "rgb(200,200,200)", "10:00"],
            [210, 1, "RGB(200,200,200)", "13:00"],
            [390, 0, "RGB(200,200,200)", "16:00"],
        ],

        Count: 391,
        MiddleCount: 211,

        GetData: function (width) 
        {
            if (width < 200) return this.Min;
            else if (width < 400) return this.Simple;

            return this.Full;
        }
    };

    //富时中国
    const FTSE_MINUTE_X_COORDINATE=
    {
        Full:   //完整模式
        [
            [0, 1, "RGB(200,200,200)", "17:00"],
            //[60, 0, "RGB(200,200,200)", "18:00"],
            [120, 1, "RGB(200,200,200)", "19:00"],
            //[180, 0, "RGB(200,200,200)", "20:00"],
            [240, 1, "RGB(200,200,200)", "21:00"],
            //[300, 0, "RGB(200,200,200)", "22:00"],
            [360, 1, "RGB(200,200,200)", "23:00"],
            //[420, 0, "RGB(200,200,200)", "00:00"],
            [480, 1, "RGB(200,200,200)", "01:00"],
            //[540, 0, "RGB(200,200,200)", "02:00"],
            [600, 1, "RGB(200,200,200)", "03:00"],
            //[660, 1, "RGB(200,200,200)", "04:00"],
            [706, 1, "RGB(200,200,200)", "09:00"],
            //[766, 1, "RGB(200,200,200)", "10:00"],
            [826, 1, "RGB(200,200,200)", "11:00"],
            //[886, 1, "RGB(200,200,200)", "12:00"],
            [946, 1, "RGB(200,200,200)", "13:00"],
            //[1006, 1, "RGB(200,200,200)", "14:00"],
            [1066, 1, "RGB(200,200,200)", "15:00"],
            [1156, 1, "RGB(200,200,200)", "16:30"],
        ],
        Simple: //简洁模式
        [
            [0, 1, "RGB(200,200,200)", "17:00"],
            //[60, 0, "RGB(200,200,200)", "18:00"],
            //[120, 1, "RGB(200,200,200)", "19:00"],
            //[180, 0, "RGB(200,200,200)", "20:00"],
            [240, 1, "RGB(200,200,200)", "21:00"],
            //[300, 0, "RGB(200,200,200)", "22:00"],
            //[360, 1, "RGB(200,200,200)", "23:30"],
            //[420, 0, "RGB(200,200,200)", "00:00"],
            [480, 1, "RGB(200,200,200)", "01:00"],
            //[540, 0, "RGB(200,200,200)", "02:00"],
            //[600, 1, "RGB(200,200,200)", "03:00"],
            //[660, 1, "RGB(200,200,200)", "04:00"],
            [706, 1, "RGB(200,200,200)", "09:00"],
            //[766, 1, "RGB(200,200,200)", "10:00"],
            //[826, 1, "RGB(200,200,200)", "11:00"],
            //[886, 1, "RGB(200,200,200)", "12:00"],
            [946, 1, "RGB(200,200,200)", "13:00"],
            //[1006, 1, "RGB(200,200,200)", "14:00"],
            //[1066, 1, "RGB(200,200,200)", "15:00"],
            [1156, 1, "RGB(200,200,200)", "16:30"],
        ],
        Min:   //最小模式     
        [
            [0, 1, "RGB(200,200,200)", "17:00"],
            [706, 1, "RGB(200,200,200)", "09:00"],
            [1156, 1, "RGB(200,200,200)", "16:30"],
        ],

        Count: 1157,
        MiddleCount: 707,

        GetData: function (width) 
        {
            if (width < 200) return this.Min;
            else if (width < 450) return this.Simple;

            return this.Full;
        }
    }

    //港股指数期货
    const FHK_MINUTE_X_COORDINATE=
    {
        Full:   //完整模式
        [
            [0, 1, "RGB(200,200,200)", "17:15"],
            [105, 1, "RGB(200,200,200)", "19:00"],
            [225, 1, "RGB(200,200,200)", "21:00"],
            [345, 1, "RGB(200,200,200)", "23:00"],
            [586, 0, "RGB(200,200,200)", "09:15"],
            [691, 1, "RGB(200,200,200)", "11:00"],
            [812, 1, "RGB(200,200,200)", "14:00"],
            [963, 1, "RGB(200,200,200)", "16:30"],
        ],
        Simple: //简洁模式
        [
            [0, 1, "RGB(200,200,200)", "17:15"],
            [225, 1, "RGB(200,200,200)", "21:00"],
            [586, 0, "RGB(200,200,200)", "09:15"],
            [752, 1, "RGB(200,200,200)", "13:00"],
            [963, 1, "RGB(200,200,200)", "16:30"],
        ],
        Min:   //最小模式     
        [
            [0, 1, "RGB(200,200,200)", "17:15"],
            [586, 0, "RGB(200,200,200)", "09:15"],
            [963, 1, "RGB(200,200,200)", "16:30"],
        ],

        Count: 963,
        MiddleCount: 526,

        GetData: function (width) 
        {
            if (width < 200) return this.Min;
            else if (width < 450) return this.Simple;

            return this.Full;
        }
    }

    //外汇
    const FOREX_MINUTE_X_COORDINATE=
    {
        Full:   //完整模式
        [
            [0, 1, "RGB(200,200,200)", "06:00"],
            [120, 1, "RGB(200,200,200)", "08:00"],
            [240, 1, "RGB(200,200,200)", "10:00"],
            [360, 1, "RGB(200,200,200)", "12:00"],
            [480, 0, "RGB(200,200,200)", "14:00"],
            [600, 1, "RGB(200,200,200)", "16:00"],
            [720, 1, "RGB(200,200,200)", "18:00"],
            [840, 1, "RGB(200,200,200)", "20:00"],
            [960, 1, "RGB(200,200,200)", "22:00"],
            [1080, 1, "RGB(200,200,200)", "0:00"],
            [1200, 1, "RGB(200,200,200)", "02:00"],
            [1320, 1, "RGB(200,200,200)", "04:00"],
        ],
        Simple: //简洁模式
        [
            [0, 1, "RGB(200,200,200)", "06:00"],
            [240, 1, "RGB(200,200,200)", "10:00"],
            [480, 0, "RGB(200,200,200)", "14:00"],
            [720, 1, "RGB(200,200,200)", "18:00"],
            [960, 1, "RGB(200,200,200)", "22:00"],
            [1200, 1, "RGB(200,200,200)", "02:00"],
        ],
        Min:   //最小模式     
        [
            [0, 1, "RGB(200,200,200)", "06:00"],
            [480, 0, "RGB(200,200,200)", "14:00"],
            [960, 1, "RGB(200,200,200)", "22:00"],
        ],

        Count: 1440,
        MiddleCount: 600,

        GetData: function (width) 
        {
            if (width < 200) return this.Min;
            else if (width < 450) return this.Simple;

            return this.Full;
        }
    }

    //台湾股票
    const TW_MINUTE_X_COORDINATE=
    {
        Full:   //完整模式
        [
            [0, 1, "RGB(200,200,200)", "09:00"],
            [30, 0, "RGB(200,200,200)", "09:30"],
            [60, 1, "RGB(200,200,200)", "10:00"],
            [90, 0, "RGB(200,200,200)", "10:30"],
            [120, 1, "RGB(200,200,200)", "11:00"],
            [150, 0, "RGB(200,200,200)", "11:30"],
            [180, 1, "RGB(200,200,200)", "12:00"],
            [210, 0, "RGB(200,200,200)", "12:30"],
            [240, 1, "RGB(200,200,200)", "13:00"],
            [270, 0, "RGB(200,200,200)", "13:30"],
        ],
        Simple: //简洁模式
        [
            [0, 1, "RGB(200,200,200)", "09:00"],
            [60, 1, "RGB(200,200,200)", "10:00"],
            [120, 1, "RGB(200,200,200)", "11:00"],
            [180, 1, "RGB(200,200,200)", "12:00"],
            [270, 0, "RGB(200,200,200)", "13:30"],
        ],
        Min:   //最小模式     
        [
            [0, 1, "RGB(200,200,200)", "09:00"],
            [60, 1, "RGB(200,200,200)", "11:00"],
            [270, 0, "RGB(200,200,200)", "13:30"],
        ],

        Count: 271,
        MiddleCount: 151,

        GetData: function (width) 
        {
            if (width < 200) return this.Min;
            else if (width < 450) return this.Simple;

            return this.Full;
        }
    }

    

    this.GetCoordinateData = function (symbol, width) 
    {
        var data = null;
        if (!symbol) 
        {
            data = SHZE_MINUTE_X_COORDINATE;    //默认沪深股票
        }
        else 
        {
            var upperSymbol = symbol.toLocaleUpperCase(); //转成大写
            if (MARKET_SUFFIX_NAME.IsSH(upperSymbol) || MARKET_SUFFIX_NAME.IsSZ(upperSymbol) || MARKET_SUFFIX_NAME.IsSHSZIndex(upperSymbol))
                data = this.GetSHSZData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsBJ(upperSymbol))
                data=this.GetBJData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsSHO(upperSymbol) || MARKET_SUFFIX_NAME.IsSZO(upperSymbol))
                data=this.GetSHOData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsHK(upperSymbol))
                data=this.GetHKData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsTW(upperSymbol))
                data=this.GetTWData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsJP(upperSymbol))
                data=this.GetJPData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsCFFEX(upperSymbol) || MARKET_SUFFIX_NAME.IsCZCE(upperSymbol) || MARKET_SUFFIX_NAME.IsDCE(upperSymbol) || MARKET_SUFFIX_NAME.IsSHFE(upperSymbol) || MARKET_SUFFIX_NAME.IsGZFE(upperSymbol))
                return this.GetChinatFuturesData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsUSA(upperSymbol))
                data = this.GetUSAData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsFTSE(upperSymbol))
                data=this.GetFTSEData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsFHK(upperSymbol))
                data=this.GetFHKData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol))
                data=this.GetForeignExchangeData(upperSymbol);
            else if ((MARKET_SUFFIX_NAME.IsBIT(upperSymbol,width)))
                data=this.GetBITData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsET(upperSymbol))
                data=this.GetETData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol))
               return  data=this.GetNYMEXData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsCOMEX(upperSymbol))
               return  data=this.GetCOMEXData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsNYBOT(upperSymbol))
               return  data=this.GetNYBOTData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsCBOT(upperSymbol))
               return  data=this.GetCBOTData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsLME(upperSymbol))
               return  data=this.GetLMEData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsTOCOM(upperSymbol))
                return  data=this.GetTOCOMData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsIPE(upperSymbol))
                return  data=this.GetIPEData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsHSX(upperSymbol))
                return  data=this.GetHSXData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsHNX(upperSymbol))
                return  data=this.GetHNXData(upperSymbol,width);
            else if (MARKET_SUFFIX_NAME.IsUPCOM(upperSymbol))
                return  data=this.GetUPCOMData(upperSymbol,width);
            
        }

        //JSConsole.Chart.Log('[MiuteCoordinateData]', width);
        var result = { Count: data.Count, MiddleCount: data.MiddleCount, Data: data.GetData(width) };
        return result;
    }

    this.GetSHSZData=function(upperSymbol,width)
    {
        var result=SHZE_MINUTE_X_COORDINATE;
        return result;
    }

    this.GetBJData=function(upperSymbol,width)
    {
        var result=SHZE_MINUTE_X_COORDINATE;
        return result;
    }

    this.GetUSAData=function(upperSymbol,width)
    {
        var result=USA_MINUTE_X_COORDINATE;
        return result;
    }

    this.GetHKData=function(upperSymbol,width)
    {
        var result=HK_MINUTE_X_COORDINATE;
        return result;
    }

    this.GetTWData=function(upperSymbol,width)
    {
        return TW_MINUTE_X_COORDINATE;
    }

    this.GetSHOData=function(upperSymbol,width)
    {
        var result=SHO_MINUTE_X_COORDINATE;
        return result;
    }

    this.GetFuturesData = function (upperSymbol,width,timeData)
    {
        var splitData = timeData.GetSplitData(upperSymbol);
        if (!splitData) return null;
        var stringData = g_MinuteTimeStringData.GetFutures(splitData);
        if (!stringData) return null;
        var result = { Count: stringData.length };
        var coordinate=null;
        var minWidth=200, simpleWidth=480;
        /*
        if (splitData.Name =='21:00-1:00,9:00-10:15,10:30-11:30,13:30-15:00')
        {
            minWidth=250;
            simpleWidth=500;
        }
        */
        
        if (width < minWidth) coordinate = splitData.Coordinate.Min;
        else if (width < simpleWidth) coordinate = splitData.Coordinate.Simple;
        else coordinate = splitData.Coordinate.Full;
        
        var data=[];
        for(var i=0;i<stringData.length;++i)
        {
            var value = stringData[i];
            for(var j=0;j<coordinate.length;++j)
            {
                var coordinateItem = coordinate[j];
                if (value == coordinateItem.Value)
                {
                    var item = [i, 0, 'RGB(200,200,200)', coordinateItem.Text];
                    data.push(item);
                    break;
                }
            }
        }

        result.Data = data;
        return result;
    }

    this.GetChinatFuturesData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_FuturesTimeData);
    }

    this.GetNYMEXData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_NYMEXTimeData);
    }

    this.GetCOMEXData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_COMEXTimeData);
    }

    this.GetNYBOTData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_NYBOTTimeData);
    }

    this.GetCBOTData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_CBOTTimeData);
    }

    this.GetLMEData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_LMETimeData);
    }

    this.GetTOCOMData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_TOCOMTimeData);
    }

    this.GetIPEData=function(upperSymbol,width)
    {
        return this.GetFuturesData(upperSymbol,width, g_IPETimeData);
    }

    this.GetFTSEData=function(upperSymbol,width)
    {
        var result=FTSE_MINUTE_X_COORDINATE;
        return result;
    }

    this.GetFHKData=function(upperSymbol,width)
    {
        var result=FHK_MINUTE_X_COORDINATE;
        return result
    }

    this.GetForeignExchangeData=function(upperSymbol,width)
    {
        var result=FOREX_MINUTE_X_COORDINATE;  
        return result;
    }

    this.GetBITData=function(upperSymbol,width)
    {
        var result=FOREX_MINUTE_X_COORDINATE;   //先用外汇的吧
        return result;
    }

    this.GetETData=function(upperSymbol,width)
    {
        throw {Name:'MinuteCoordinateData::GetETData', Error:'not implement'};
    }

    this.GetJPData=function(upperSymbol,width)
    {
        throw {Name:'MinuteCoordinateData::GetJPData', Error:'not implement'};
    }

    this.GetHSXData=function(upperSymbol,width)
    {
        throw {Name:'MinuteCoordinateData::GetHSXData', Error:'not implement'};
    }

    this.GetHNXData=function(upperSymbol,width)
    {
        throw {Name:'MinuteCoordinateData::GetHNXData', Error:'not implement'};
    }

    this.GetUPCOMData=function(upperSymbol,width)
    {
        throw {Name:'MinuteCoordinateData::GetUPCOMData', Error:'not implement'};
    }

}

//国内期货不同品种 交易时间数据 
function FuturesTimeData()
{
    this.TIME_SPLIT=
    [
        //ID=0 9:00-10:15,10:31-11:30,13:31-15:00
        {
            Name:'9:00-10:15,10:31-11:30,13:31-15:00',
            Data:
            [
                //9:00-10:15,10:30-11:30,13:30-15:00
                { Start: 900, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 930, Text: '9:30' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },
        //ID=1 9:30-11:30,13:01-15:15
        {

            Name:'9:30-11:30,13:01-15:15',
            Data:
            [
                { Start: 930, End: 1130 },
                { Start: 1301, End: 1515 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 930, Text: '9:30' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1515, Text: '15:15' },
                ],
                Simple: //简洁模式
                [
                    { Value: 930, Text: '9:30' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1515, Text: '15:15' },
                ],
                Min:   //最小模式  
                [
                    { Value: 930, Text: '9:30' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1515, Text: '15:15' },
                ]
            }
        },
        //ID=2 '9:30-11:30,13:01-15:00'
        {
            Name:'9:30-11:30,13:00-15:00',
            Data:
            [
                { Start: 930, End: 1130 },
                { Start: 1301, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 930, Text: '9:30' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 930, Text: '9:30' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 930, Text: '9:30' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },
        {
            Name:'21:00-23:30,9:00-10:15,10:30-11:30,13:30-15:00',
            Data:
            [
                { Start: 2100, End: 2330 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID=4 21:00-1:00,9:01-10:15,10:31-11:30,13:31-15:00
        {
            Name:'21:00-1:00,9:01-10:15,10:31-11:30,13:31-15:00',
            Data:
            [   
                { Start: 2100, End: 2359 },
                { Start: 0, End: 100 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID=5 21:00-2:30,9:01-10:15,10:31-11:30,13:31-15:00
        {
            Name:'21:00-2:30,9:01-10:15,10:31-11:30,13:31-15:00',
            Data:
            [
                { Start: 2100, End: 2359 },
                { Start: 0, End: 230 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID:6 21:00-23:00,9:01-10:15,10:30-11:30,13:31-15:00
        {
            Name:'21:00-23:00,9:01-10:15,10:30-11:30,13:31-15:00',
            Data:
            [
                { Start: 2100, End: 2300 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },
        {

            Name:'9:00-11:30,13:00-15:00',
            Data:
            [
                { Start: 900, End: 1130 },
                { Start: 1300, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },
        {
            Name:'21:00-23:00,9:00-10:15,10:30-11:30,13:30-15:00',
            Data:
            [
                { Start: 2100, End: 2300 },
                { Start: 900, End: 1015 },
                { Start: 1030, End: 1130 },
                { Start: 1330, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID=9 9:01-10:15,10:31-11:30,13:31-15:00
        {
            Name:'9:01-10:15,10:31-11:30,13:31-15:00',
            Data:
            [
                //9:01-10:15,10:31-11:30,13:31-15:00
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 901, Text: '9:00' },
                    { Value: 930, Text: '9:30' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 901, Text: '9:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 901, Text: '9:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID=10 21:00-1:00,9:01-10:15,10:31-11:30,13:31-15:00
        {
            Name:'21:01-1:00,9:01-10:15,10:31-11:30,13:31-15:00',
            Data:
            [   
                { Start: 2101, End: 2359 },
                { Start: 0, End: 100 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID:11 21:01-23:00,9:01-10:15,10:30-11:30,13:31-15:00
        {
            Name:'21:01-23:00,9:01-10:15,10:30-11:30,13:31-15:00',
            Data:
            [
                { Start: 2101, End: 2300 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID=12 21:01-2:30,9:01-10:15,10:31-11:30,13:31-15:00
        {
            Name:'21:01-2:30,9:01-10:15,10:31-11:30,13:31-15:00',
            Data:
            [
                { Start: 2101, End: 2359 },
                { Start: 0, End: 230 },
                { Start: 901, End: 1015 },
                { Start: 1031, End: 1130 },
                { Start: 1331, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1031, Text: '10:30' },
                    { Value: 1331, Text: '13:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 2101, Text: '21:00' },
                    { Value: 901, Text: '9:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },

        //ID=13 9:31-11:30,13:01-15:15
        {

            Name:'9:30-11:30,13:01-15:15',
            Data:
            [
                { Start: 931, End: 1130 },
                { Start: 1301, End: 1515 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 931, Text: '9:30' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1301, Text: '13:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1515, Text: '15:15' },
                ],
                Simple: //简洁模式
                [
                    { Value: 931, Text: '9:30' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1301, Text: '13:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1515, Text: '15:15' },
                ],
                Min:   //最小模式  
                [
                    { Value: 931, Text: '9:30' },
                    { Value: 1301, Text: '13:00' },
                    { Value: 1515, Text: '15:15' },
                ]
            }
        },

         //ID=14 '9:31-11:30,13:01-15:00'
        {
            Name:'9:31-11:30,13:01-15:00',
            Data:
            [
                { Start: 931, End: 1130 },
                { Start: 1301, End: 1500 }
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 931, Text: '9:30' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1301, Text: '13:00' },
                    { Value: 1330, Text: '13:30' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1430, Text: '14:30' },
                    { Value: 1500, Text: '15:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 931, Text: '9:30' },
                    { Value: 1030, Text: '10:30' },
                    { Value: 1301, Text: '13:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1500, Text: '15:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 931, Text: '9:30' },
                    { Value: 1301, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                ]
            }
        },
    ];

    this.MAP_TWOWORDS=new Map([
        //大连商品交易所
        [MARKET_SUFFIX_NAME.DCE + '-JD', {Time:0,Decimal:0,Name:"鸡蛋"}],
        [MARKET_SUFFIX_NAME.DCE + '-FB', {Time:0,Decimal:2,Name:"纤板"}],
        [MARKET_SUFFIX_NAME.DCE + '-BB', {Time:0,Decimal:2,Name:"胶板"}],
        [MARKET_SUFFIX_NAME.DCE + '-PP', {Time:6,Decimal:0,Name:"丙烯"}],
        [MARKET_SUFFIX_NAME.DCE + '-JM', {Time:6,Decimal:1,Name:'焦煤'}],
        [MARKET_SUFFIX_NAME.DCE + '-EG', {Time:6,Decimal:0,Name:'乙二醇'}],
        [MARKET_SUFFIX_NAME.DCE + '-EB', {Time:6,Decimal:0,Name:'苯乙烯'}],
        [MARKET_SUFFIX_NAME.DCE + '-CS', {Time:6,Decimal:0,Name:'淀粉'}],
        [MARKET_SUFFIX_NAME.DCE + '-PG', {Time:6,Decimal:0,Name:'液化气'}],
        [MARKET_SUFFIX_NAME.DCE + '-RR', {Time:6,Decimal:0,Name:'梗米'}],
        [MARKET_SUFFIX_NAME.DCE + '-LH', {Time:0,Decimal:0,Name:'生猪'}],

        //上期所
        [MARKET_SUFFIX_NAME.SHFE + '-CU', {Time:4,Decimal:0,Name:"铜"}],
        [MARKET_SUFFIX_NAME.SHFE + '-AL', {Time:4,Decimal:0,Name:"铝"}],
        [MARKET_SUFFIX_NAME.SHFE + '-NI', {Time:4,Decimal:0,Name:"镍"}],
        [MARKET_SUFFIX_NAME.SHFE + '-SN', {Time:4,Decimal:0,Name:'沪锡'}],
        [MARKET_SUFFIX_NAME.SHFE + '-ZN', {Time:4,Decimal:0,Name:"沪锌"}],
        [MARKET_SUFFIX_NAME.SHFE + '-PB', {Time:4,Decimal:0,Name:'沪铅'}],
        [MARKET_SUFFIX_NAME.SHFE + '-RU', {Time:6,Decimal:0,Name:"天然橡胶"}],
        [MARKET_SUFFIX_NAME.SHFE + '-FU', {Time:6,Decimal:0,Name:"燃料油"}],
        [MARKET_SUFFIX_NAME.SHFE + '-RB', {Time:6,Decimal:0,Name:"螺纹钢"}],
        [MARKET_SUFFIX_NAME.SHFE + '-BU', {Time:6,Decimal:0,Name:'石油沥青'}],
        [MARKET_SUFFIX_NAME.SHFE + '-HC', {Time:6,Decimal:0,Name:"热轧卷板"}],
        [MARKET_SUFFIX_NAME.SHFE + '-SP', {Time:6,Decimal:0,Name:"纸浆"}],
        [MARKET_SUFFIX_NAME.SHFE + '-WR', {Time:0,Decimal:0,Name:"线材"}],
        [MARKET_SUFFIX_NAME.SHFE + '-AG', {Time:5,Decimal:0,Name:"白银"}],
        [MARKET_SUFFIX_NAME.SHFE + '-AU', {Time:5,Decimal:2,Name:"黄金"}],
        [MARKET_SUFFIX_NAME.SHFE + '-SS', {Time:4,Decimal:0,Name:'不锈钢'}],
        [MARKET_SUFFIX_NAME.SHFE + '-AO', {Time:4,Decimal:0,Name:'氧化铝'}],
        [MARKET_SUFFIX_NAME.SHFE + '-BR', {Time:6,Decimal:0,Name:'合成橡胶'}],

        //上期所-能源
        [MARKET_SUFFIX_NAME.SHFE + '-NR', {Time:6,Decimal:1,Name:'20号胶'}],
        [MARKET_SUFFIX_NAME.SHFE + '-SC', {Time:5,Decimal:1,Name:'原油'}],
        [MARKET_SUFFIX_NAME.SHFE + '-LU', {Time:6,Decimal:0,Name:'低硫燃油'}],
        [MARKET_SUFFIX_NAME.SHFE + '-BC', {Time:4,Decimal:0,Name:'国际铜'}],
        [MARKET_SUFFIX_NAME.SHFE + '-EC', {Time:0,Decimal:0,Name:'集运指数'}],
       
        //郑州期货交易所
        [MARKET_SUFFIX_NAME.CZCE + '-CF', {Time:6,Decimal:0,Name:"棉花"}],
        [MARKET_SUFFIX_NAME.CZCE + '-SR', {Time:6,Decimal:0,Name:"白糖"}],
        [MARKET_SUFFIX_NAME.CZCE + '-MA', {Time:6,Decimal:0,Name:"甲醇"}],
        [MARKET_SUFFIX_NAME.CZCE + '-ZC', {Time:6,Decimal:1,Name:'动力煤'}],
        [MARKET_SUFFIX_NAME.CZCE + '-TA', {Time:6,Decimal:0,Name:"精对苯二甲酸(PTA)"}],
        [MARKET_SUFFIX_NAME.CZCE + '-RM', {Time:6,Decimal:0,Name:'菜籽粕'}],
        [MARKET_SUFFIX_NAME.CZCE + '-OI', {Time:6,Decimal:0,Name:"菜籽油"}],
        [MARKET_SUFFIX_NAME.CZCE + '-ME', {Time:3,Decimal:0,Name:"甲醇(老)"}],
        [MARKET_SUFFIX_NAME.CZCE + '-FG', {Time:6,Decimal:0,Name:'平板玻璃'}],
        [MARKET_SUFFIX_NAME.CZCE + '-WS', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-WT', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-GN', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-RO', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-RS', {Time:0,Decimal:0,Name:"菜籽"}],
        [MARKET_SUFFIX_NAME.CZCE + '-ER', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-RI', {Time:0,Decimal:0,Name:"早籼稻"}],
        [MARKET_SUFFIX_NAME.CZCE + '-WH', {Time:0,Decimal:0,Name:"强麦"}],
        [MARKET_SUFFIX_NAME.CZCE + '-AP', {Time:0,Decimal:0,Name:"苹果"}],
        [MARKET_SUFFIX_NAME.CZCE + '-PM', {Time:0,Decimal:0,Name:"普麦"}],
        [MARKET_SUFFIX_NAME.CZCE + '-QM', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-TC', {Time:0,Decimal:0}],
        [MARKET_SUFFIX_NAME.CZCE + '-JR', {Time:0,Decimal:0,Name:"粳稻"}],
        [MARKET_SUFFIX_NAME.CZCE + '-LR', {Time:0,Decimal:0,Name:"晚籼稻"}],
        [MARKET_SUFFIX_NAME.CZCE + '-SF', {Time:0,Decimal:0,Name:"硅铁"}],
        [MARKET_SUFFIX_NAME.CZCE + '-SM', {Time:0,Decimal:0,Name:"锰硅"}],
        [MARKET_SUFFIX_NAME.CZCE + '-CJ', {Time:0,Decimal:2, Name:"红枣"}],
        [MARKET_SUFFIX_NAME.CZCE + '-CY', {Time:6,Decimal:0, Name:"棉纱"}],
        [MARKET_SUFFIX_NAME.CZCE + '-UR', {Time:0,Decimal:0, Name:"尿素"}],
        [MARKET_SUFFIX_NAME.CZCE + '-SA', {Time:6,Decimal:0, Name:"纯碱"}],
        [MARKET_SUFFIX_NAME.CZCE + '-PF', {Time:6,Decimal:0, Name:"短纤"}],
        [MARKET_SUFFIX_NAME.CZCE + '-PK', {Time:0,Decimal:0, Name:"花生"}],


        //中期所 
        [MARKET_SUFFIX_NAME.CFFEX + '-TF', {Time:1,Decimal:3,Name:"二债"}],
        [MARKET_SUFFIX_NAME.CFFEX + '-TS', {Time:1,Decimal:3,Name:"五债"}],
        [MARKET_SUFFIX_NAME.CFFEX + '-IH', {Time:2,Decimal:1,Name:'上证股指期货'}],
        [MARKET_SUFFIX_NAME.CFFEX + '-IC', {Time:2,Decimal:1,Name:'中证股指期货'}],
        [MARKET_SUFFIX_NAME.CFFEX + '-IF', {Time:2,Decimal:1,Name:'沪深股指期货'}],
        [MARKET_SUFFIX_NAME.CFFEX + '-IM', {Time:2,Decimal:1,Name:'中证1000股指期货'}],
        [MARKET_SUFFIX_NAME.CFFEX + '-IO', {Time:2,Decimal:1,Name:'沪深300股指期权'}],
        [MARKET_SUFFIX_NAME.CFFEX + '-MO', {Time:2,Decimal:1,Name:'中证1000股指期权'}],
        [MARKET_SUFFIX_NAME.CFFEX + '-HO', {Time:2,Decimal:1,Name:'上证50股指期权'}],

        //广州期货交易所
        [MARKET_SUFFIX_NAME.GZFE+'-SI', {Time:0,Decimal:2,Name:"工业硅"}],
        [MARKET_SUFFIX_NAME.GZFE+'-LC', {Time:0,Decimal:2,Name:"碳酸锂"}]
    ]);

    this.MAP_ONEWORD=new Map([
        //大连商品交易所
        [MARKET_SUFFIX_NAME.DCE + '-C', {Time:6,Decimal:0,Name:"玉米"}],
        [MARKET_SUFFIX_NAME.DCE + '-L', {Time:6,Decimal:0,Name:"乙烯"}],
        [MARKET_SUFFIX_NAME.DCE + '-V', {Time:6,Decimal:0,Name:"PVC"}],
        [MARKET_SUFFIX_NAME.DCE + '-A', {Time:6,Decimal:0,Name:"豆一"}],
        [MARKET_SUFFIX_NAME.DCE + '-B', {Time:6,Decimal:0,Name:"豆二"}],
        [MARKET_SUFFIX_NAME.DCE + '-M', {Time:6,Decimal:0,Name:"豆粕"}],
        [MARKET_SUFFIX_NAME.DCE + '-Y', {Time:6,Decimal:0,Name:"豆油"}],
        [MARKET_SUFFIX_NAME.DCE + '-P', {Time:6,Decimal:0,Name:"棕榈"}],
        [MARKET_SUFFIX_NAME.DCE + '-J', {Time:6,Decimal:1,Name:'焦炭'}],
        [MARKET_SUFFIX_NAME.DCE + '-I', {Time:6,Decimal:1,Name:"铁矿"}],
        //中期所 
        [MARKET_SUFFIX_NAME.CFFEX + '-T', {Time:1,Decimal:3,Name:"十债"}],
    ]);

    //添加新品种
    this.AddNewFutures=function(obj)    //{ Suffix:后缀, Symbol:品种代码, Time:交易时间段, Decimal:小数位数, Name:名字 }
    {
        if (!obj) return;

        var key=obj.Suffix+'-'+obj.Symbol;
        var item={ Time:obj.Time, Decimal:obj.Decimal, Name:obj.Name };
        if (obj.Symbol.length==1)
        {
            this.MAP_ONEWORD.set(key, item);
        }
        else if (obj.Symbol.length==2)
        {
            this.MAP_TWOWORDS.set(key, item);
        }
    }

    this.GetData=function(upperSymbol)
    {
        var oneWord = upperSymbol.charAt(0);
        var twoWords = upperSymbol.substr(0,2);
        var oneWordName = null, twoWordsName=null;

        if (MARKET_SUFFIX_NAME.IsDCE(upperSymbol))  //大连商品交易所
        {
            oneWordName = MARKET_SUFFIX_NAME.DCE+'-'+oneWord;
            twoWordsName = MARKET_SUFFIX_NAME.DCE + '-' + twoWords;
        }
        else if (MARKET_SUFFIX_NAME.IsSHFE(upperSymbol))  //上期所
        {
            oneWordName = MARKET_SUFFIX_NAME.SHFE + '-' + oneWord;
            twoWordsName = MARKET_SUFFIX_NAME.SHFE + '-' + twoWords;
        }
        else if (MARKET_SUFFIX_NAME.IsCFFEX(upperSymbol))  //中期所 
        {
            oneWordName = MARKET_SUFFIX_NAME.CFFEX + '-' + oneWord;
            twoWordsName = MARKET_SUFFIX_NAME.CFFEX + '-' + twoWords;
        }
        else if (MARKET_SUFFIX_NAME.IsCZCE(upperSymbol))  //郑州期货交易所
        {
            oneWordName = MARKET_SUFFIX_NAME.CZCE + '-' + oneWord;
            twoWordsName = MARKET_SUFFIX_NAME.CZCE + '-' + twoWords;
        }
        else if (MARKET_SUFFIX_NAME.IsGZFE(upperSymbol))    //广州期货交易所
        {
            oneWordName = MARKET_SUFFIX_NAME.GZFE + '-' + oneWord;
            twoWordsName = MARKET_SUFFIX_NAME.GZFE + '-' + twoWords;
        }

        if (this.MAP_TWOWORDS.has(twoWordsName))
        {
            return this.MAP_TWOWORDS.get(twoWordsName);
        }

        if (this.MAP_ONEWORD.has(oneWordName))
        {
            return this.MAP_ONEWORD.get(oneWordName);
        }

        return null;
    }

    this.GetSplitData = function (upperSymbol)
    {
        var data=this.GetData(upperSymbol);
        if (!data) return null;

        return this.TIME_SPLIT[data.Time];
    }

    this.GetDecimal=function(upperSymbol)
    {
        var data=this.GetData(upperSymbol);
        if (!data) return 2;

        return data.Decimal;
    }
}


//纽约商业交易所 交易时间数据 
function NYMEXTimeData()
{
    //美国标准时间
    this.TIME_SPLIT=
    [
        {
            Name:'6:00-5:00',
            Data:
            [
                //6:00 - 5:00
                { Start: 600, End: 2359 },
                { Start: 0, End: 500 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 600, Text: '6:00' },
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' },
                    { Value: 400, Text: '4:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 600, Text: '6:00' },
                    //{ Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    //{ Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    //{ Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    //{ Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    //{ Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                    //{ Value: 400, Text: '4:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 600, Text: '6:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 500, Text: '5:00' }
                ]
            }
        }
    ]

    //美国夏时令
    this.TIME_SPLIT2=
    [
        {
            Name:'7:00-6:00',
            Data:
            [
                //6:00 - 5:00
                { Start: 700, End: 2359 },
                { Start: 0, End: 600 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 700, Text: '7:00' },
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' },
                    { Value: 500, Text: '5:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 700, Text: '7:00' },
                    //{ Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    //{ Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    //{ Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    //{ Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    //{ Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                    //{ Value: 500, Text: '5:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 700, Text: '7:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 500, Text: '5:00' }
                ]
            }
        }
    ]

    this.FUTURES_LIST=
    [
        { Symbol:"CL", Decimal:2, Time:0, Name:"原油"}, //原油
        { Symbol:"NG", Decimal:3, Time:0, Name:"天然气" }, //天然气
        { Symbol:"RB", Decimal:4, Time:0, Name:"汽油" }, //汽油
        { Symbol:"PL", Decimal:1, Time:0, Name:"铂金" }, //铂金
        { Symbol:"PA", Decimal:2, Time:0, Name:"钯金" }, //钯金
        { Symbol:"HR", Decimal:0, Time:0, Name:"热轧钢卷" }, //热轧钢卷
        { Symbol:"QM", Decimal:3, Time:0, Name:"迷你原油" }, //迷你原油
        { Symbol:"HO", Decimal:4, Time:0, Name:"燃油"}, //燃油
    ]

    this.MarketSuffix=".NYMEX";
    this.TimeType=0; // 0=标准时间 1=夏令时间 2=美国时间

    this.GetFuturesInfo=function(upperSymbol)
    {
        if (upperSymbol.indexOf(this.MarketSuffix)<=0) return null;

        for(var i in this.FUTURES_LIST)
        {
            var item=this.FUTURES_LIST[i];
            if (upperSymbol.indexOf(item.Symbol)==0)
            {
                return item;
            }
        }

        return null;
    }

    this.GetSplitData=function(upperSymbol)
    {
        //夏令和标准时间切换
        var timeSplit=this.TimeType==0 ? this.TIME_SPLIT : this.TIME_SPLIT2;
        var find=this.GetFuturesInfo(upperSymbol);
        if (find) return timeSplit[find.Time];

        return timeSplit[0];
    }

    this.GetDecimal=function(upperSymbol)
    {
        var find=this.GetFuturesInfo(upperSymbol);
        if (find) return find.Decimal;

        return 3;
    }

    this.GetMarketStatus=function(upperSymbol) // 0=闭市 1=盘前 2=盘中 3=盘后
    {
        var usaDate=GetLocalTime(-4);   //需要转成美国时间的 周6 周日
        var nowDate= new Date();
        var day = usaDate.getDay();
        var time = nowDate.getHours() * 100 + nowDate.getMinutes();
        if(day == 6 || day== 0) return 0;   //周末
        if(time>430 && time<730) return 1;

        return 2;   
    }

    this.AddNewFutures=function(obj) //{ Symbol:品种代码, Time:时间id, Decimal:小数位数, Name:名字 }
    {
        if (!obj) return;

        var newItem={ Symbol:obj.Symbol, Time:obj.Time, Decimal:obj.Decimal, Name:obj.Name };
        for(var i=0;i<this.FUTURES_LIST.length;++i)
        {
            var item=this.FUTURES_LIST[i];
            if (item.Symbol==newItem.Symbol) 
            {
                this.FUTURES_LIST[i]=newItem;
                return;
            }
        }
        
        this.FUTURES_LIST.push(newItem);
    }
}

//纽约金属交易所（COMEX）
function COMEXTimeData()
{
    this.newMethod=NYMEXTimeData;   //派生
    this.newMethod();
    delete this.newMethod;

    this.FUTURES_LIST=
    [
        { Symbol:"GC", Decimal:1, Time:0, Name:"COMEX黄金"}, //COMEX黄金
        { Symbol:"QO", Decimal:2, Time:0, Name:"迷你黄金" }, //迷你黄金
        { Symbol:"MG", Decimal:1, Time:0, Name:"微型黄金" }, //微型黄金
        { Symbol:"QI", Decimal:4, Time:0, Name:"迷你白银" }, //迷你白银
        { Symbol:"SI", Decimal:3, Time:0, Name:"COMEX白银" }, //COMEX白银
        { Symbol:"HG", Decimal:4, Time:0, Name:"COMEX铜" }  //COMEX铜
    ]

    this.MarketSuffix=".COMEX";
}

//纽约期货交易所（ICEUS-NYBOT）
function NYBOTTimeData()
{
    this.newMethod=NYMEXTimeData;   //派生
    this.newMethod();
    delete this.newMethod;

    //美国标准时间
    this.TIME_SPLIT=
    [
        {
            Name:'9:00-2:20',
            Data:
            [
                //9:00-2:20
                { Start: 900, End: 2359 },
                { Start: 0, End: 220 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    //{ Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    //{ Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 100, Text: '1:00' }
                ]
            }
        },
        {
            Name:'15:30-1:00',
            Data:
            [
                //9:00-2:20
                { Start: 1530, End: 2359 },
                { Start: 0, End: 100 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 1600, Text: '16:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 100, Text: '1:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 1600, Text: '16:00' },
                    //{ Value: 1600, Text: '17:00' },
                    { Value: 1800, Text: '18:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2000, Text: '20:00' },
                    //{ Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 0, Text: '0:00' },
                    //{ Value: 100, Text: '1:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 1600, Text: '16:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 100, Text: '1:00' }
                ]
            }
        }
    ]

    //美国夏时令
    this.TIME_SPLIT2=
    [
        {
            Name:'10:00-3:20',
            Data:
            [
                //9:00-2:20
                { Start: 1000, End: 2359 },
                { Start: 0, End: 320 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 1000, Text: '10:00' },
                    //{ Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    //{ Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    //{ Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    //{ Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 1000, Text: '10:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        },
        {
            Name:'16:30-2:00',
            Data:
            [
                { Start: 1630, End: 2359 },
                { Start: 0, End: 200 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 1700, Text: '17:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 100, Text: '1:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1800, Text: '18:00' },
                    { Value: 1900, Text: '19:00' },
                    //{ Value: 2000, Text: '20:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2200, Text: '22:00' },
                    { Value: 2300, Text: '23:00' },
                    //{ Value: 0, Text: '0:00' },
                    { Value: 100, Text: '1:00' }
                    //{ Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 1700, Text: '17:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        }
    ]

    this.FUTURES_LIST=
    [
        { Symbol:"SB", Decimal:2, Time:1 }, //11号白糖
        { Symbol:"CT", Decimal:2, Time:0 }, //棉花
        //{ Symbol:"KC", Decimal:2, Time:0 }, //咖啡
        //{ Symbol:"DX", Decimal:2, Time:0 }, //美元指数
        //{ Symbol:"CC", Decimal:2, Time:0 }  //可可
    ]

    this.MarketSuffix=".NYBOT";

    this.GetMarketStatus=function(upperSymbol) // 0=闭市 1=盘前 2=盘中 3=盘后
    {
        var usaDate=GetLocalTime(-4);   //需要转成美国时间的 周6 周日
        var day = usaDate.getDay();
        var time = usaDate.getHours() * 100 + usaDate.getMinutes();
        if(day == 6 || day== 0) return 0;   //周末

        var find=this.GetFuturesInfo(upperSymbol);
        if (!find) return 2;
        
        if (find.Symbol=="SB")  //Sugar No. 11 Futures 03:30 - 13:00
        {
            if (time>300 && time<1400) return 2;
        }
        else if (find.Symbol=="CT") //美棉 21:00-14:20 
        {
            if( (time>=0 && time<=1500 ) || (time>=2000 && time<=2359) ) return 2;
            return 1;
        }

        return 0;   
    }
}

//芝加哥期货交易所
function CBOTTimeData()
{
    this.newMethod=NYMEXTimeData;   //派生
    this.newMethod();
    delete this.newMethod;

    //标准时间
    this.TIME_SPLIT=
    [
        //ID=0 8:00-2:20
        {
            Name:'8:00-2:20',
            Data:
            [
                //6:00 - 5:00
                { Start: 800, End: 2359 },
                { Start: 0, End: 220 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 800, Text: '8:00' },
                    //{ Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    //{ Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    //{ Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    //{ Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' }
                    //{ Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        },
        //ID=1 8:00-2:45
        {
            Name:'8:00-2:45',
            Data:
            [
                //6:00 - 5:00
                { Start: 800, End: 2359 },
                { Start: 0, End: 245 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 800, Text: '8:00' },
                    //{ Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    //{ Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    //{ Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    //{ Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' }
                    //{ Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        },
        //ID=2 6:00-5:00
        {
            Name:'6:00-5:00',
            Data:
            [
                //6:00 - 5:00
                { Start: 600, End: 2359 },
                { Start: 0, End: 500 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 600, Text: '6:00' },
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' },
                    { Value: 400, Text: '4:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 600, Text: '6:00' },
                    //{ Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    //{ Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    //{ Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    //{ Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    //{ Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                    //{ Value: 400, Text: '4:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 600, Text: '6:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 500, Text: '5:00' }
                ]
            }
        },

        //ID=3 08:00-20:45 21:31-02:20
        {
            Name:'08:00-20:45 21:31-02:20',
            Data:
            [
                { Start: 800, End: 2045 },
                { Start: 2131, End: 2359 },
                { Start: 0, End: 220 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 800, Text: '8:00' },
                    //{ Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    //{ Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    //{ Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    //{ Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' }
                    //{ Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        },

        //ID=4 8:00-20:45 21:31-2:45
        {
            Name:'8:00-2:45',
            Data:
            [
                { Start: 800, End: 2045 },
                { Start: 2131, End: 2359 },
                { Start: 0, End: 245 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 800, Text: '8:00' },
                    //{ Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    //{ Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    //{ Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    //{ Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' }
                    //{ Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        },

        //ID=5 06:00-04:15 04:31-05:00
        {
            Name:'06:00-04:15 04:31-05:00',
            Data:
            [
                { Start: 600, End: 2359 },
                { Start: 0, End: 415 },
                { Start: 431, End: 500 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 600, Text: '6:00' },
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' },
                    { Value: 400, Text: '4:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 600, Text: '6:00' },
                    //{ Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    //{ Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    //{ Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    //{ Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    //{ Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                    //{ Value: 400, Text: '4:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 600, Text: '6:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 500, Text: '5:00' }
                ]
            }
        }
    ]

    //夏令时间
    this.TIME_SPLIT2=
    [
        //ID=0 9:00-3:20
        {
            Name:'9:00-3:20',
            Data:
            [
                { Start: 900, End: 2359 },
                { Start: 0, End: 320 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    //{ Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    //{ Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' }
                    //{ Value: 300, Text: '3:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 300, Text: '3:00' }
                ]
            }
        },
        //ID=1 9:00-3:45
        {
            Name:'9:00-3:45',
            Data:
            [
                { Start: 900, End: 2359 },
                { Start: 0, End: 345 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    //{ Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    //{ Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' }
                    //{ Value: 300, Text: '3:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 300, Text: '3:00' }
                ]
            }
        },
        //ID=2 7:00-6:00
        {
            Name:'7:00-6:00',
            Data:
            [
                { Start: 700, End: 2359 },
                { Start: 0, End: 600 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 700, Text: '7:00' },
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' },
                    { Value: 500, Text: '5:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 700, Text: '7:00' },
                    //{ Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    //{ Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    //{ Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    //{ Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    //{ Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                    //{ Value: 500, Text: '5:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 700, Text: '7:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 500, Text: '5:00' }
                ]
            }
        },

        //ID=3 09:00-21:45 22:31-03:20
        {
            Name:'09:00-21:45 22:31-03:20',
            Data:
            [
                { Start: 900, End: 2145 },
                { Start: 2231, End: 2359 },
                { Start: 0, End: 320 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    //{ Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    //{ Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' }
                    //{ Value: 300, Text: '3:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 300, Text: '3:00' }
                ]
            }
        },

        //ID=4 09:00-21:45 22:31-03:45
        {
            Name:'09:00-21:45 22:31-03:45',
            Data:
            [
                { Start: 900, End: 2145 },
                { Start: 2231, End: 2359 },
                { Start: 0, End: 345 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    //{ Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    //{ Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' }
                    //{ Value: 300, Text: '3:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 300, Text: '3:00' }
                ]
            }
        },

        //ID=5 07:00-05:15 05:31-06:00
        {
            Name:'07:00-05:15 05:31-06:00',
            Data:
            [
                { Start: 700, End: 2359 },
                { Start: 0, End: 515 },
                { Start: 531, End: 600 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 700, Text: '7:00' },
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' },
                    { Value: 500, Text: '5:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 700, Text: '7:00' },
                    //{ Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    //{ Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    //{ Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    //{ Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    //{ Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                    //{ Value: 500, Text: '5:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 700, Text: '7:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 500, Text: '5:00' }
                ]
            }
        }
    ]

    this.FUTURES_LIST=
    [
        { Symbol:"ZC", Decimal:2, Time:0, Name:"玉米" }, //玉米
        { Symbol:"XC", Decimal:2, Time:1, Name:"迷你玉米" }, //迷你玉米
        { Symbol:"ZS", Decimal:2, Time:0, Name:'大豆' }, //大豆
        { Symbol:"XK", Decimal:2, Time:1, Name:"迷你大豆" }, //迷你大豆
        { Symbol:"ZL", Decimal:2, Time:0, Name:"豆油"}, //豆油
        { Symbol:"ZR", Decimal:2, Time:0, Name:"稻谷" }, //稻谷
        { Symbol:"ZO", Decimal:2, Time:0, Name:"燕麦" }, //燕麦
        { Symbol:"ZW", Decimal:2, Time:0, Name:'小麦'}, //小麦
        { Symbol:"XW", Decimal:2, Time:1, Name:"迷你小麦" }, //迷你小麦
        { Symbol:"ZM", Decimal:1, Time:0, Name:"豆粕" }, //豆粕

        { Symbol:"EH", Decimal:3, Time:2 }, //乙醇

        { Symbol:"YM", Decimal:0, Time:2, Name:"小型道指"}, //小型道指
        { Symbol:"ES", Decimal:2, Time:2, Name:"小型标普" }, //小型标普
        { Symbol:"NQ", Decimal:2, Time:2, Name:"小型纳指" }, //小型纳指

        { Symbol:"TY", Decimal:4, Time:2, Name:"10年美国债" }, //10年美国债
        { Symbol:"TU", Decimal:4, Time:2, Name:"2年美国债" }, //2年美国债
        { Symbol:"FV", Decimal:4, Time:2, Name:"5年美国债" }, //5年美国债
        { Symbol:"US", Decimal:4, Time:2, Name:"30年美国债" }, //30年美国债
        { Symbol:"UL", Decimal:4, Time:2, Name:"超国债" }, //超国债
    ]

    this.MarketSuffix=".CBOT";
}

//伦敦金属交易所 LME
function LMETimeData()
{
    this.newMethod=NYMEXTimeData;   //派生
    this.newMethod();
    delete this.newMethod;

    //标准时间
    this.TIME_SPLIT=
    [
        {
            Name:'LME 9:00-3:00',
            Data:
            [
                { Start: 900, End: 2359 },
                { Start: 0, End: 300 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' },
                    { Value: 300, Text: '3:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    //{ Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    //{ Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    //{ Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    //{ Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' }
                   // { Value: 300, Text: '3:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 300, Text: '3:00' }
                ]
            }
        }
    ]

    //夏令
    this.TIME_SPLIT=
    [
        {
            Name:'LME 8:00-2:00',
            Data:
            [
                { Start: 800, End: 2359 },
                { Start: 0, End: 200 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 800, Text: '8:00' },
                    //{ Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    //{ Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    //{ Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    //{ Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' }
                    //{ Value: 200, Text: '2:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 200, Text: '2:00' }
                ]
            }
        }
    ]

    this.FUTURES_LIST=
    [
        { Symbol:"SN", Decimal:0, Time:0, Name:"LME锡" }, //综合锡03
        { Symbol:"AH", Decimal:2, Time:0, Name:"LME铝" }, //综合铝03
        { Symbol:"PB", Decimal:2, Time:0, Name:"LME铅" }, //综合铅03
        { Symbol:"ZS", Decimal:2, Time:0, Name:"LME锌" }, //综合锌03
        { Symbol:"CA", Decimal:2, Time:0, Name:"LME铜" }, //综合铜03
        { Symbol:"NI", Decimal:0, Time:0, Name:"LME镍" }, //综合镍03
    ]

    this.MarketSuffix=".LME";
}

//东京商品交易所（TOCOM）
function TOCOMTimeData()
{
    this.newMethod=NYMEXTimeData;   //派生
    this.newMethod();
    delete this.newMethod;

    this.TimeType=0;

    this.TIME_SPLIT=
    [
        //ID=0 15:30-04:30 07:46-14:15
        {
            Name:'15:30-04:30 07:46-14:15',
            Data:
            [
                { Start: 1530,  End: 2359},
                { Start: 0,     End: 430 },
                { Start: 746,   End: 1415 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 1530, Text: '15:30' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' },
                    { Value: 300, Text: '3:00' },
                    { Value: 430, Text: '4:30' },
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1415, Text: '14:15' }
                ],
                Simple: //简洁模式
                [
                    { Value: 1530, Text: '15:30' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 100, Text: '1:00' },
                    { Value: 430, Text: '4:30' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1415, Text: '14:15' }
                ],
                Min:   //最小模式  
                [
                    { Value: 1530, Text: '15:30' },
                    { Value: 100, Text: '1:00' },
                    { Value: 1415, Text: '14:15' }
                ]
            }
        }
    ];

    this.FUTURES_LIST=
    [
        { Symbol:"JRV", Decimal:0, Time:0, Name:"东京TSR20橡胶" }, 
        { Symbol:"JPL", Decimal:0, Time:0, Name:"东京铂金" }, 
        { Symbol:"JAU", Decimal:0, Time:0, Name:"东京黄金" }, 
        { Symbol:"JCO", Decimal:0, Time:0, Name:"中东原油" }, 
        { Symbol:"JRU", Decimal:1, Time:0, Name:"东京RSS3橡胶橡胶" }, 
        { Symbol:"JAG", Decimal:1, Time:0, Name:"日白银" } ,
        { Symbol:"JPA", Decimal:1, Time:0, Name:"日钯金" } 
    ]

    this.MarketSuffix=".TOCOM";
}

//美国洲际交易所（ICE EUROPE）
function IPETimeData()
{
    this.newMethod=NYMEXTimeData;   //派生
    this.newMethod();
    delete this.newMethod;

    this.MarketSuffix=".IPE";

     //美国标准时间
    this.TIME_SPLIT=
    [
        //ID=0 8:00-6:00
        {
            Name:'8:00-6:00',
            Data:
            [
                { Start: 800, End: 2359 },
                { Start: 0, End: 600 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1000, Text: '10:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1400, Text: '14:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 1800, Text: '18:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 2200, Text: '22:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 200, Text: '2:00' },
                    { Value: 400, Text: '4:00' },
                    { Value: 600, Text: '6:00' },
                ],
                Simple: //简洁模式
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 1200, Text: '12:00' },
                    { Value: 1600, Text: '16:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 0, Text: '0:00' },
                    { Value: 400, Text: '4:00' },
                    { Value: 600, Text: '6:00' },
                ],
                Min:   //最小模式  
                [
                    { Value: 800, Text: '8:00' },
                    { Value: 2000, Text: '20:00' },
                    { Value: 600, Text: '6:00' }
                ]
            }
        }
    ]
 
    //美国夏时令
    this.TIME_SPLIT2=
    [
        //ID=0 09:00-07:00
        {
            Name:'09:00-07:00',
            Data:
            [
                { Start: 900, End: 2359 },
                { Start: 0, End: 700 },
            ],
            Coordinate:
            {
                Full://完整模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1100, Text: '11:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1500, Text: '15:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 1900, Text: '19:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 2300, Text: '23:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 300, Text: '3:00' },
                    { Value: 500, Text: '5:00' },
                    { Value: 700, Text: '7:00' }
                ],
                Simple: //简洁模式
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 1300, Text: '13:00' },
                    { Value: 1700, Text: '17:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 1, Text: '1:00' },
                    { Value: 500, Text: '5:00' },
                    { Value: 700, Text: '7:00' }
                ],
                Min:   //最小模式  
                [
                    { Value: 900, Text: '9:00' },
                    { Value: 2100, Text: '21:00' },
                    { Value: 700, Text: '7:00' }
                ]
            }
        }
    ]

    this.FUTURES_LIST=
    [
        { Symbol:"RC", Decimal:2, Time:0, Name:"罗布斯塔咖啡" }, 
        { Symbol:"W", Decimal:2, Time:0, Name:"白糖" }, 
        { Symbol:"C", Decimal:2, Time:0, Name:"伦敦可可" }, 
        { Symbol:"R", Decimal:2, Time:0, Name:"长期英国国债" }, 
        { Symbol:"L", Decimal:2, Time:0, Name:"3个月英镑利率" },
        { Symbol:"T", Decimal:2, Time:0, Name:"WTI原油" },
        { Symbol:"G", Decimal:2, Time:0, Name:"低硫柴油" },
        { Symbol:"B", Decimal:2, Time:0, Name:"布伦特原油" }  
    ]
}

var g_MinuteTimeStringData = new MinuteTimeStringData();
var g_MinuteCoordinateData = new MinuteCoordinateData();
var g_FuturesTimeData = new FuturesTimeData();
var g_NYMEXTimeData=new NYMEXTimeData();
var g_COMEXTimeData=new COMEXTimeData();
var g_NYBOTTimeData=new NYBOTTimeData();
var g_CBOTTimeData=new CBOTTimeData();
var g_LMETimeData=new LMETimeData();
var g_TOCOMTimeData=new TOCOMTimeData();
var g_IPETimeData=new IPETimeData();


function GetfloatPrecision(symbol)  //获取小数位数
{
    var defaultfloatPrecision=2;    //默认2位
    if (!symbol) return defaultfloatPrecision;
    var upperSymbol=symbol.toUpperCase();

    //全部由外部控制
    if (typeof(MARKET_SUFFIX_NAME.GetCustomDecimal)=='function') return MARKET_SUFFIX_NAME.GetCustomDecimal(upperSymbol);

    if (MARKET_SUFFIX_NAME.IsSHSZFund(upperSymbol)) defaultfloatPrecision=3;    //基金3位小数
    else if (MARKET_SUFFIX_NAME.IsSHO(upperSymbol) || MARKET_SUFFIX_NAME.IsSZO(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetSHODecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsChinaFutures(upperSymbol)) defaultfloatPrecision=g_FuturesTimeData.GetDecimal(upperSymbol);  //期货小数位数读配置
    else if (MARKET_SUFFIX_NAME.IsFHK(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetFHKDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsFTSE(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetFTSEDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsBIT(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetBITDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsET(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetETDecimal(upperSymbol); 
    else if (MARKET_SUFFIX_NAME.IsForeignExchange(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetForeignExchangeDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsNYMEX(upperSymbol)) defaultfloatPrecision=g_NYMEXTimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsCOMEX(upperSymbol)) defaultfloatPrecision=g_COMEXTimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsNYBOT(upperSymbol)) defaultfloatPrecision=g_NYBOTTimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsCBOT(upperSymbol)) defaultfloatPrecision=g_CBOTTimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsLME(upperSymbol)) defaultfloatPrecision=g_LMETimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsTOCOM(upperSymbol)) defaultfloatPrecision=g_TOCOMTimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsIPE(upperSymbol)) defaultfloatPrecision=g_IPETimeData.GetDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsHK(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetHKDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsTW(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetTWDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsJP(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetJPDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsHSX(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetHSXDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsHNX(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetHNXDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsUPCOM(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetUPCOMDecimal(upperSymbol);

    else if (MARKET_SUFFIX_NAME.IsSZ(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetSZDecimal(upperSymbol);
    else if (MARKET_SUFFIX_NAME.IsSH(upperSymbol)) defaultfloatPrecision=MARKET_SUFFIX_NAME.GetSHDecimal(upperSymbol);
    
    else defaultfloatPrecision=MARKET_SUFFIX_NAME.GetDefaultDecimal(upperSymbol);

    return defaultfloatPrecision;
}

//把不连续的分时数据转成连续的分时数据
function GenerateMinuteStockJsonData(data)
{
    var stock =
    { 
        symbol:data.symbol, name:data.name,time:data.time, date:data.date,
        price:data.price, open:data.open, yclose:data.yclose, high:data.high, low:data.low, vol:data.vol,amount:data.amount,
        minute:[]
    };

    var mapMinute=new Map();
    for(var i in data.minute)
    {
        var item=data.minute[i];
        mapMinute.set(item.time,item);
    }

    var timeData=g_MinuteTimeStringData.GetTimeData(stock.symbol);
    for(var i in timeData)  //根据交易时间产生数据
    {
        var time=timeData[i];
        var minuteItem={ time:time, vaild:false };
        if (mapMinute.has(time))
        {
            var find=mapMinute.get(time);
            minuteItem.vaild=true;
            minuteItem.price=find.price;
            minuteItem.open=find.open;
            minuteItem.high=find.high;
            minuteItem.low=find.low;
            minuteItem.avprice=find.avprice;
            minuteItem.vol=find.vol;
            minuteItem.amount=find.amount;
            if (IFrameSplitOperator.IsNumber(find.increase)) minuteItem.increase=find.increase;
            if (IFrameSplitOperator.IsNumber(find.risefall)) minuteItem.risefall=find.risefall;
            if (IFrameSplitOperator.IsNumber(find.position)) minuteItem.position=find.position;
        }
        stock.minute.push(minuteItem);
    }

    var vaildCount=0;
    for(var i=stock.minute.length-1;i>=0;--i)
    {
        vaildCount=i+1;
        var item=stock.minute[i];
        if (item.vaild==true) break;
    }

    stock.minute=stock.minute.slice(0,vaildCount);  //去掉最后无用的数据

    return stock;
}

function GetLocalTime(i)    //得到标准时区的时间的函数
{
    if (typeof i !== 'number') return;
    var d = new Date();
    //得到1970年一月一日到现在的秒数
    var len = d.getTime();
    //本地时间与GMT时间的时间偏移差
    var offset = d.getTimezoneOffset() * 60000;
    //得到现在的格林尼治时间
    var utcTime = len + offset;
    return new Date(utcTime + 3600000 * i);
}






